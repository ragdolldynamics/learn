{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn RAGDOLL Real-time physics for Autodesk\u00ae Maya 2020 Ragdoll provides animators with real-time physics for fast, automatic overlapping motion. Learn more Download Releases","title":"Home"},{"location":"api/","text":"Ragdoll consists of custom (locator) nodes written in C++, but everything involved in connecting these up and generating the dependency network happens in Python. This API is exposed to you for integration with auto-rigging, tools development and generally just extend the capabilities of the system. Overview There are 3 supported methods of integrating Ragdoll into your pipeline. Each with its own flare. api.py - Public interface commands.py - Low-level commands interactive.py - User-facing commands api.py The publicly facing programming interface to Ragdoll. Use this for tools integrated with other tools that rely on heavy compatibility between versions and few surprises on what goes in and out. \u2714\ufe0f Guaranteed backwards compatibility \u2714\ufe0f High interoperability with maya.cmds , including camelCase \u2714\ufe0f No dependence on user selection or preferences \u274c Limited to documented and officially supported features from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) commands.py The api.py module builds on commands.py , but wraps it in a string-based interface so as to make it compatible with your everyday calls to maya.cmds . All of api.py is present in commands.py , along with a few extras that may or may not change over time. It is best suited for tight integration and control but is primarily used internally for implementing interactive.py and tools.py . \u2714\ufe0f Fast \u2714\ufe0f Flexible \u2714\ufe0f Same guarantees as api.py for identical members \u274c Unfamiliar data cmdx types commands.py uses the highly performant cmdx library to communicate with Maya and all return values are instances of cmdx . from maya import cmds from ragdoll import commands as rc from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a scene scene = rc . create_scene () assert isinstance ( scene , cmdx . DagNode ) assert scene . type () == \"rdScene\" # Every scene needs one or more rigid bodies rigid = rc . create_rigid ( cube , scene ) assert isinstance ( rigid , cmdx . DagNode ) assert rigid . type () == \"rdRigid\" # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play ) interactive.py Finally, this module is used for UI elements like the main Ragdoll menu. Every function takes selection into account, along with any preferences set via the Option Dialogs. It's useful for when you want to replicate what the menu does, including taking selection into account and outputting warning messages in the Script Editor. It won't raise exceptions like api and commands , instead each function return either True for success or nothing for failure. Failures typically follow one or more warning messages. \u2714\ufe0f Animator-friendly, useful for quick scripts \u274c No usable return value \u274c Sensitive to user preferences \u274c No guarantee on backwards compatibility \u274c Verbose output in Script Editor from maya import cmds from ragdoll import interactive as ri cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) cmds . select ( cube ) ri . create_rigid () cmds . evalDeferred ( cmds . play ) Members Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createScene () api . createRigid ( node , scene , passive = False , compute_mass = True ) # Constraints api . pointConstraint ( parent , child , scene ) api . orientConstraint ( parent , child , scene ) api . hingeConstraint ( parent , child , scene ) api . socketConstraint ( parent , child , scene ) api . parentConstraint ( parent , child , scene ) api . convertToPoint ( con ) api . convertToOrient ( con ) api . convertToHinge ( con , secondary_axis = \"y\" ) api . convertToSocket ( con ) api . convertToParent ( con ) # Controls api . createAbsoluteControl ( rigid ) api . createRelativeControl ( rigid ) api . createActiveControl ( reference , rigid ) api . createKinematicControl ( rigid ) # Forces api . createForce ( type , rigid , scene ) api . createSlice ( scene ) api . assignForce ( rigid , force ) # Utilities api . transferAttributes ( a , b , mirror = True ) api . transferRigid ( ra , rb ) api . transferConstraint ( ca , cb , mirror = True ) api . editConstraintFrames ( con ) api . duplicate ( rigid ) Environment Variables Gain more control over the integration of Ragdoll into your pipeline with these optional environment variables. For example, to manually load the Ragdoll plug-in and Maya menu, set RAGDOLL_NO_AUTOLOAD=1 and then call: import ragdoll.interactive ragdoll . interactive . install () Added Ragdoll 2021.01.14 Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset","title":"API Reference"},{"location":"api/#overview","text":"There are 3 supported methods of integrating Ragdoll into your pipeline. Each with its own flare. api.py - Public interface commands.py - Low-level commands interactive.py - User-facing commands","title":"Overview"},{"location":"api/#apipy","text":"The publicly facing programming interface to Ragdoll. Use this for tools integrated with other tools that rely on heavy compatibility between versions and few surprises on what goes in and out. \u2714\ufe0f Guaranteed backwards compatibility \u2714\ufe0f High interoperability with maya.cmds , including camelCase \u2714\ufe0f No dependence on user selection or preferences \u274c Limited to documented and officially supported features from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play )","title":"api.py"},{"location":"api/#commandspy","text":"The api.py module builds on commands.py , but wraps it in a string-based interface so as to make it compatible with your everyday calls to maya.cmds . All of api.py is present in commands.py , along with a few extras that may or may not change over time. It is best suited for tight integration and control but is primarily used internally for implementing interactive.py and tools.py . \u2714\ufe0f Fast \u2714\ufe0f Flexible \u2714\ufe0f Same guarantees as api.py for identical members \u274c Unfamiliar data cmdx types commands.py uses the highly performant cmdx library to communicate with Maya and all return values are instances of cmdx . from maya import cmds from ragdoll import commands as rc from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a scene scene = rc . create_scene () assert isinstance ( scene , cmdx . DagNode ) assert scene . type () == \"rdScene\" # Every scene needs one or more rigid bodies rigid = rc . create_rigid ( cube , scene ) assert isinstance ( rigid , cmdx . DagNode ) assert rigid . type () == \"rdRigid\" # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play )","title":"commands.py"},{"location":"api/#interactivepy","text":"Finally, this module is used for UI elements like the main Ragdoll menu. Every function takes selection into account, along with any preferences set via the Option Dialogs. It's useful for when you want to replicate what the menu does, including taking selection into account and outputting warning messages in the Script Editor. It won't raise exceptions like api and commands , instead each function return either True for success or nothing for failure. Failures typically follow one or more warning messages. \u2714\ufe0f Animator-friendly, useful for quick scripts \u274c No usable return value \u274c Sensitive to user preferences \u274c No guarantee on backwards compatibility \u274c Verbose output in Script Editor from maya import cmds from ragdoll import interactive as ri cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) cmds . select ( cube ) ri . create_rigid () cmds . evalDeferred ( cmds . play )","title":"interactive.py"},{"location":"api/#members","text":"Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createScene () api . createRigid ( node , scene , passive = False , compute_mass = True ) # Constraints api . pointConstraint ( parent , child , scene ) api . orientConstraint ( parent , child , scene ) api . hingeConstraint ( parent , child , scene ) api . socketConstraint ( parent , child , scene ) api . parentConstraint ( parent , child , scene ) api . convertToPoint ( con ) api . convertToOrient ( con ) api . convertToHinge ( con , secondary_axis = \"y\" ) api . convertToSocket ( con ) api . convertToParent ( con ) # Controls api . createAbsoluteControl ( rigid ) api . createRelativeControl ( rigid ) api . createActiveControl ( reference , rigid ) api . createKinematicControl ( rigid ) # Forces api . createForce ( type , rigid , scene ) api . createSlice ( scene ) api . assignForce ( rigid , force ) # Utilities api . transferAttributes ( a , b , mirror = True ) api . transferRigid ( ra , rb ) api . transferConstraint ( ca , cb , mirror = True ) api . editConstraintFrames ( con ) api . duplicate ( rigid )","title":"Members"},{"location":"api/#environment-variables","text":"Gain more control over the integration of Ragdoll into your pipeline with these optional environment variables. For example, to manually load the Ragdoll plug-in and Maya menu, set RAGDOLL_NO_AUTOLOAD=1 and then call: import ragdoll.interactive ragdoll . interactive . install () Added Ragdoll 2021.01.14 Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset","title":"Environment Variables"},{"location":"download/","text":"At the time of this writing, Ragdoll is still in early access. Reach out for access. Download Ragdoll 2021.03.01 awaits. Click here to get started. Previous versions Install Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. However you can also do what Linux users do, and unzip the plug-in straight into your home directory. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS Sorry, MacOS is currently not supported . Let us know this is important to you, and priorities can be shifted. contact@ragdolldynamics.com You should now see a new Ragdoll menu. See Release History Everything ok? No menu You've booted up Maya, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' Fair enough, let's go deeper. from os.path import join modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = join ( modules_path , \"Ragdoll-Maya-2021_06_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here . FAQ What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2021 What are my licensing options? Trial - 30 days of non-commercial use, no strings attached NodeLocked - Any number of users, one machine per licence Floating - Any number of machines, one user per licence Headless - A cost-effective alternative for distributed simulations What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? Best not to, you'll see this warning message in your Script Editor. Warning: Ragdoll evaluation skipped, frame change too large Letting you know to rewind and not trust the results until you do. How do I disable the ground? A static collider is automatically added on the Maya grid per default, it can be disabled on the rdScene node via the .useGround attribute. Why not use nHair for overlapping animation? Yes, and while your at it, why not stick razor blades in your eyes? Seriously though, Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance. Limitations As of Ragdoll 2021.03.01 these are the current known limitations of Ragdoll. Must visit start frame on scene open Poor support for any rotateAxis other than XYZ Attributes jointOrient , rotatePivot and rotatePivotTranslate will be zeroed out When weight painting rigid joints, cannot right-click \"Select influence\" (see workaround )","title":"Download"},{"location":"download/#install","text":"Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. However you can also do what Linux users do, and unzip the plug-in straight into your home directory. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS Sorry, MacOS is currently not supported . Let us know this is important to you, and priorities can be shifted. contact@ragdolldynamics.com You should now see a new Ragdoll menu. See Release History Everything ok? No menu You've booted up Maya, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' Fair enough, let's go deeper. from os.path import join modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = join ( modules_path , \"Ragdoll-Maya-2021_06_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here .","title":"Install"},{"location":"download/#faq","text":"What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2021 What are my licensing options? Trial - 30 days of non-commercial use, no strings attached NodeLocked - Any number of users, one machine per licence Floating - Any number of machines, one user per licence Headless - A cost-effective alternative for distributed simulations What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? Best not to, you'll see this warning message in your Script Editor. Warning: Ragdoll evaluation skipped, frame change too large Letting you know to rewind and not trust the results until you do. How do I disable the ground? A static collider is automatically added on the Maya grid per default, it can be disabled on the rdScene node via the .useGround attribute. Why not use nHair for overlapping animation? Yes, and while your at it, why not stick razor blades in your eyes? Seriously though, Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance.","title":"FAQ"},{"location":"download/#limitations","text":"As of Ragdoll 2021.03.01 these are the current known limitations of Ragdoll. Must visit start frame on scene open Poor support for any rotateAxis other than XYZ Attributes jointOrient , rotatePivot and rotatePivotTranslate will be zeroed out When weight painting rigid joints, cannot right-click \"Select influence\" (see workaround )","title":"Limitations"},{"location":"examples/","text":"Examples Download and have a go! 6.78 mb Example 1 | Just a Girl An example of hair simulation with Ragdoll. Download 2.93 mb Example 2 | mGirl An example of cloth simulation with Ragdoll. Download 2.77 mb Example 3 | Muscle An example of muscle simulation with Ragdoll. Download 1.18 mb Example 4 | Overview Some basic object types to fool around with. Download 0.16 mb Example 5 | Parkour An animated Ragdoll \"parkour\" character. Download 4.15 mb Example 6 | mHair Basic character setup with basic hair controls. Download 0.44 mb Example 7 | Mechanical An accurate mechanical contraption. Download 0.40 mb Example 8 | Driving A late night drive on a busy country road. Download 0.05 mb Example 9 | Dynamic Control A regular animation control. With dynamics! Download 2.91 mb Example 10 | Dance, Baby Fool around with guide strength to affect this dance performance! Download 0.24 mb Example 11 | Slowmo Manipulate time with the timeMultiplier attribute. Download","title":"Examples"},{"location":"examples/#examples","text":"Download and have a go! 6.78 mb","title":"Examples"},{"location":"licencing/","text":"Ragdoll requires a licence per seat in order to run. Activation requires a Product Key which you get by either purchasing a licence or by being really awesome. FAQ Let's dive into specifics. How does it work? On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Enter your product key Click Activate Or if you prefer: from ragdoll import licence licence . activate ( key ) What happens when my trial expires? Any rdScene.enabled attribute will be set to False . Scenes will still load just fine and nothing else in your scene is affected. Once activated, the .enabled attribute will return to normal. Can I renew my trial licence? Possibly. Reach out to us if this is relevant to you. We're contemplating a permanently active \"Personal Learning Edition\" with limitations on what you can do commercially, similar to SideFX Houdini. Can I use it on more than one machine? Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence. Can I move a licence between two machines? Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released. Do I need an internet connection to use Ragdoll? No. What if someone steals my licence key? That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one. Can I have a floating licence? Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All we need is you. Can I activate offline? Not yet. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch. When exactly is internet required? A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain. Can I manage my licence via Python? Sure can, see below. Licence API As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" : \"Your-Key\" , # Is the current licence activated? \"isActivated\" : True , # Is the current licence a trial licence? \"isTrial\" : False , # Has the licence not been tampered with? \"isGenuine\" : True , # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" : True , # How many days until this trial expires? \"trialDays\" : 23 }","title":"Licencing"},{"location":"licencing/#faq","text":"Let's dive into specifics.","title":"FAQ"},{"location":"licencing/#how-does-it-work","text":"On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Enter your product key Click Activate Or if you prefer: from ragdoll import licence licence . activate ( key )","title":"How does it work?"},{"location":"licencing/#what-happens-when-my-trial-expires","text":"Any rdScene.enabled attribute will be set to False . Scenes will still load just fine and nothing else in your scene is affected. Once activated, the .enabled attribute will return to normal.","title":"What happens when my trial expires?"},{"location":"licencing/#can-i-renew-my-trial-licence","text":"Possibly. Reach out to us if this is relevant to you. We're contemplating a permanently active \"Personal Learning Edition\" with limitations on what you can do commercially, similar to SideFX Houdini.","title":"Can I renew my trial licence?"},{"location":"licencing/#can-i-use-it-on-more-than-one-machine","text":"Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence.","title":"Can I use it on more than one machine?"},{"location":"licencing/#can-i-move-a-licence-between-two-machines","text":"Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released.","title":"Can I move a licence between two machines?"},{"location":"licencing/#do-i-need-an-internet-connection-to-use-ragdoll","text":"No.","title":"Do I need an internet connection to use Ragdoll?"},{"location":"licencing/#what-if-someone-steals-my-licence-key","text":"That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one.","title":"What if someone steals my licence key?"},{"location":"licencing/#can-i-have-a-floating-licence","text":"Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All we need is you.","title":"Can I have a floating licence?"},{"location":"licencing/#can-i-activate-offline","text":"Not yet. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch.","title":"Can I activate offline?"},{"location":"licencing/#when-exactly-is-internet-required","text":"A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain.","title":"When exactly is internet required?"},{"location":"licencing/#can-i-manage-my-licence-via-python","text":"Sure can, see below.","title":"Can I manage my licence via Python?"},{"location":"licencing/#licence-api","text":"As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" : \"Your-Key\" , # Is the current licence activated? \"isActivated\" : True , # Is the current licence a trial licence? \"isTrial\" : False , # Has the licence not been tampered with? \"isGenuine\" : True , # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" : True , # How many days until this trial expires? \"trialDays\" : 23 }","title":"Licence API"},{"location":"menu/","text":"All items found in the Ragdoll menu at the top of Maya's main window. Add menu items to your shelf with Ctrl + Shift + Click Overview Item Description Show Messages Display warnings and errors in the Message Board Active Rigid Customise the creation of a new rigid body. Passive Rigid Customise the creation of a new passive rigid body. Muscle Make a muscle from the selected anchor points. Constraint Constrain one rigid to another. Point Constraint the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. Parent Constrain both the position and orientation of two rigid bodies. Hinge A special kind of Socket Constraint Socket Constraint the position and limit the orientation between two rigid bodies. Passive Animate a passive rigid body with an external transform. Guide Animate an active rigid body with an external transform. Push Push rigids away from a point in space. Pull Pull rigids towards a point in space. Directional Like gravity, except in any arbitrary direction. Wind Create a force similar to wind, with editable turbulence. Visualiser Visualise 3D forces with a 2D slice, much like an MRI. Assign to Selected Assign force to the selected rigids. Character Generate a character from the selected joint hierarchy. Create Dynamic Control Create a new dynamic control from the currently selected regular control(s). Multiply Selected Rigids Multiply keyable attributes on multiple rigid at once. Multiply Selected Constraints Multiply keyable attributes on multiple constraints at once. Edit Constraint Frames Edit the parent and child frames using a native Maya transform. Duplicate Selected Create a new rigid, using the selected rigid as a template for position, orientation and shape. Transfer Attributes Copy attributes from one rigid body to another. Convert to Polygons Convert selected rigids and controls into polygons. Normalise Shapes Resize shapes within a hierarchy to avoid some being too different. Set Initial State Re-establish the starting position and orientation of selected rigids. Delete All Physics Clear the Maya scene of anything related to Ragdoll. Ragdoll Preferences Edit global Ragdoll preferences, like the scale at which Ragdoll draws things. Save Preferences Save Ragdoll preferences to disk. Reset Preferences Restore Ragdoll preferences to their default values. Select Rigids Select all rigids, or filter rigids from selection. Select Constraints Select all constraints, or filter constraints from selection. Select Scenes Select all scenes, or filter scenes from selection. Select Controls Select all controls, or filter controls from selection. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though. Create The top part of the menu contain commands to create new rigids. Active Rigid The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box. Rigids either output or input a transform. The active rigid outputs a transform, passing information from solver into your Maya scene. Basics Basics Turn any native Maya polygon or NURBS object into a rigid by selecting it and clicking 'Active Rigid'. Multiple Selection Multiple Selection When two or more objects are selected - whether it be polygons, NURBS or joints - they'll all be turned into rigids. Blend Existing Animation Blend Existing Animation If the selected node(s) are animated, the animation can be used as a target for the subsequent simulation using the 'Blend' option. Blend and Edit Blend and Edit Once turned into rigids, your original animation remains intact and can be edited just like before. You can also blend between the original input and final simulation via the blendSimulation node. Passive Rigid The passive rigid body feeds data from your animation control to Ragdoll, rather than the other way around like the Active Rigid. It's used to pass animation straight into the solver, without modifying it with forces or contacts. That also means passive rigids can travel straight through other rigids if not careful. You can think of a Passive Rigid as a physical object of infinite mass; nothing gets in its way. Basics Basics Turn any polygonal, NURBS surface or joint into a rigid which can be animated but isn't affected by the simulation. Muscle The muscle is a regular Active Rigid with two additional Point Constraints added to either end. The benefit is simply less clicks required. Option Description Default Aim Axis Which axis to treat as aim for the resulting muscle. X Up Axis Which axis to treat as the up-axis for the resulting muscle. Y Flex How much to allow the muscle to contract, from not-at-all to all-the-way. 0.75 Radius Capsule radius, how thick of a muscle to make. 1.0 Constraint Like normal Maya constraints, these limit the motion of one rigid relative another. For example, the Parent Constraint will make one rigid move as though it was a child of the other, whereas the Point Constraint will only limit position whilst letting orientation roam free. Option Description Default Constraint Type The type of constraint created. Point Maintain Offset Keep rigids where they are, or snap them together. Offsets can be manipulated with the Edit Constraint Frames menu item. True Auto Orient Orient constraint automatically by aiming towards the immediate child. Otherwise use the local orientation of the node. True Standalone Give constraints their own transform at the root of the outliner. Guide Strength Include some guide strength with this constraint. 1.0 Point Constraint the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship. Parent Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid. Socket Constraint the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints. Hinge A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well suited for hinge-like appendages, like elbows and knees. Control High-level control, either direct (kinematic, passive) or indirect (driven, guided). Kinematic Control Create a new Maya transform and use the world matrix as input for 'kinematic' a.k.a. 'passive' animation. This is the same as creating or converting to a Passive Rigid, except it allows for the rdRigid.kinematic attribute to be animated . This can be used to transition from animation into simulation and vice versa. Option Description Default No Options Guide Control Create a new Maya transform and use the world matrix as input to 'drive' a.k.a. 'guide' a rigid dynamically. This is the same as what a Dynamic Control and a blended Active Rigid uses, except as a separate transform. There can be multiple guides to a single rigid, where each can fight for control over the final position, or where you the animator can blend between them. Option Description Default No Options Forces Apply an external force to rigids. Kind of like constraints, except rigids are effected independently instead of relative another rigid. Push Force This forces applies a force facing away from a point in space. It can be used for things like explosions. Option Description Default No Options Pull Force This is technically the same as 'Push', except the opposite. Instead of pushing rigids away from a point in space, rigids are pull towards it. This can be used for effects like black holes, or to simply nudge a rigid in some specific direction. Option Description Default No Options Directional Force Gravity is computed deep within the solver and isn't technically applied as an external force, but apart form that this force replicates gravity in addition to letting you control the direction. Option Description Default No Options Wind Force Wind is a complex phenomena. This force applies an iterative, 3D Perlin noise field to rigid bodies and is a great representation of how wind looks and acts in the real world. Use 'Visualiser' to get a sense of how it looks. Option Description Default No Options Visualiser This creates a 2-dimensonal representation of either all or selected 3-dimensional forces. The slice can be moved and scaled just like any normal Maya transform, and the amount and length of samples can be manipulated (and even animated) interactively to get a fine-grained understanding of what your forces do to each rigid. Hint: Create multiple slices at various strategic locations in your scene to get an even greater understanding at specific areas. Option Description Default No Options Assign To Selected Forces are typically assigned to all existing rigids when created, or to the currently selected rigids. This command lets you add forces to rigids manually. Forces can be removed by breaking their connection to each other. Option Description Default No Options Utilities High-level tools for animators and riggers that build upon the lower-level concepts above. Everything here can be created manually using a combination of the above commands or by making the connections yourself. Character An auto-rigger, designed to produce an animatable character from a skeleton hierarchy. Option Description Default Copy Turn a copy of the selected hierarchy into a character, rather than the hierarchy itself. True Control Create an additional control hierarchy from generated character. True Normalise Shapes Make sure shapes are relatively evenly sized. This can help prevent 'stick-figures' which are tougher to control. Stop Behaviour Whether to include the joint with a 'Stop' label in the generated character or not. Inclusive Dynamic Control Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between. Basics Basics Turn any FK hierarchy into a dynamic chain. Every other control Every other control Skip some FK controls, for a simplified dynamic hierarchy. Global Preferences Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend. Option Description Default Gizmo Scale Scale at which to draw viewport widgets, like constraints. 1.0 Cache Media Cache clips in the timeline, for immediate feedback when scroll. - Off Fast, interactive but no scrubbing. - On Slow scrubbing support. - All Interactive scrubbing at the expense of RAM.< Off Auto Hide Shape Attributes (Requires scene reopen) Rid the Channel Box of attributes unrelated to the currently selected shape type. True Auto Initial State (Requires scene reopen) Whether or not to use the pose of a rigid at the start time as the active initial state. This feature records the pose from frame 1 at frame 2, by inserting itself in between finished evaluation of frame 1 and yet-to-begin evaluation of frame 2. True DG Viewport Fix Improve viewport robustness when simulating in DG Evaluation mode, by calling ogs -reset on the start frame. Bear in mind this action is global to Maya and may negatively (or positively) affect other nodes in your scene. Validate Evaluation Mode Check whether Maya is evaluating in Parallel or Serial whenever creating a new scene, as DG is slow and error-prone. True Validate Rotate Pivot Check whether the selected transform has a non-zero rotatePivot; they are unsupported and will be zeroed out. True Validate Rotate Axis Let the user know of a Ragdoll limitation, that a custom rotate axis are unsupported. True Validate Scale Let the user know of a Ragdoll limitation, that scale is unsupported. Validate Playback Speed Make sure Maya's playback speed is set to 'Play every frame'. True Help The Ragdoll user interfaces double as a place for help. The information is generated from the same source as this website, so as to be available wherever you are; without breaking your flow . Help Page The page can also be accessed by clicking on the top description. You can find hints about each option by hovering over it. Timeline Available videos regarding any menu item is visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about.","title":"Menu Reference"},{"location":"menu/#overview","text":"Item Description Show Messages Display warnings and errors in the Message Board Active Rigid Customise the creation of a new rigid body. Passive Rigid Customise the creation of a new passive rigid body. Muscle Make a muscle from the selected anchor points. Constraint Constrain one rigid to another. Point Constraint the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. Parent Constrain both the position and orientation of two rigid bodies. Hinge A special kind of Socket Constraint Socket Constraint the position and limit the orientation between two rigid bodies. Passive Animate a passive rigid body with an external transform. Guide Animate an active rigid body with an external transform. Push Push rigids away from a point in space. Pull Pull rigids towards a point in space. Directional Like gravity, except in any arbitrary direction. Wind Create a force similar to wind, with editable turbulence. Visualiser Visualise 3D forces with a 2D slice, much like an MRI. Assign to Selected Assign force to the selected rigids. Character Generate a character from the selected joint hierarchy. Create Dynamic Control Create a new dynamic control from the currently selected regular control(s). Multiply Selected Rigids Multiply keyable attributes on multiple rigid at once. Multiply Selected Constraints Multiply keyable attributes on multiple constraints at once. Edit Constraint Frames Edit the parent and child frames using a native Maya transform. Duplicate Selected Create a new rigid, using the selected rigid as a template for position, orientation and shape. Transfer Attributes Copy attributes from one rigid body to another. Convert to Polygons Convert selected rigids and controls into polygons. Normalise Shapes Resize shapes within a hierarchy to avoid some being too different. Set Initial State Re-establish the starting position and orientation of selected rigids. Delete All Physics Clear the Maya scene of anything related to Ragdoll. Ragdoll Preferences Edit global Ragdoll preferences, like the scale at which Ragdoll draws things. Save Preferences Save Ragdoll preferences to disk. Reset Preferences Restore Ragdoll preferences to their default values. Select Rigids Select all rigids, or filter rigids from selection. Select Constraints Select all constraints, or filter constraints from selection. Select Scenes Select all scenes, or filter scenes from selection. Select Controls Select all controls, or filter controls from selection. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though.","title":"Overview"},{"location":"menu/#create","text":"The top part of the menu contain commands to create new rigids.","title":"Create"},{"location":"menu/#active-rigid","text":"The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box. Rigids either output or input a transform. The active rigid outputs a transform, passing information from solver into your Maya scene. Basics","title":"Active Rigid"},{"location":"menu/#passive-rigid","text":"The passive rigid body feeds data from your animation control to Ragdoll, rather than the other way around like the Active Rigid. It's used to pass animation straight into the solver, without modifying it with forces or contacts. That also means passive rigids can travel straight through other rigids if not careful. You can think of a Passive Rigid as a physical object of infinite mass; nothing gets in its way. Basics","title":"Passive Rigid"},{"location":"menu/#muscle","text":"The muscle is a regular Active Rigid with two additional Point Constraints added to either end. The benefit is simply less clicks required. Option Description Default Aim Axis Which axis to treat as aim for the resulting muscle. X Up Axis Which axis to treat as the up-axis for the resulting muscle. Y Flex How much to allow the muscle to contract, from not-at-all to all-the-way. 0.75 Radius Capsule radius, how thick of a muscle to make. 1.0","title":"Muscle"},{"location":"menu/#constraint","text":"Like normal Maya constraints, these limit the motion of one rigid relative another. For example, the Parent Constraint will make one rigid move as though it was a child of the other, whereas the Point Constraint will only limit position whilst letting orientation roam free. Option Description Default Constraint Type The type of constraint created. Point Maintain Offset Keep rigids where they are, or snap them together. Offsets can be manipulated with the Edit Constraint Frames menu item. True Auto Orient Orient constraint automatically by aiming towards the immediate child. Otherwise use the local orientation of the node. True Standalone Give constraints their own transform at the root of the outliner. Guide Strength Include some guide strength with this constraint. 1.0","title":"Constraint"},{"location":"menu/#point","text":"Constraint the position of two rigid bodies.","title":"Point"},{"location":"menu/#orient","text":"Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship.","title":"Orient"},{"location":"menu/#parent","text":"Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid.","title":"Parent"},{"location":"menu/#socket","text":"Constraint the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints.","title":"Socket"},{"location":"menu/#hinge","text":"A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well suited for hinge-like appendages, like elbows and knees.","title":"Hinge"},{"location":"menu/#control","text":"High-level control, either direct (kinematic, passive) or indirect (driven, guided).","title":"Control"},{"location":"menu/#kinematic-control","text":"Create a new Maya transform and use the world matrix as input for 'kinematic' a.k.a. 'passive' animation. This is the same as creating or converting to a Passive Rigid, except it allows for the rdRigid.kinematic attribute to be animated . This can be used to transition from animation into simulation and vice versa. Option Description Default No Options","title":"Kinematic Control"},{"location":"menu/#guide-control","text":"Create a new Maya transform and use the world matrix as input to 'drive' a.k.a. 'guide' a rigid dynamically. This is the same as what a Dynamic Control and a blended Active Rigid uses, except as a separate transform. There can be multiple guides to a single rigid, where each can fight for control over the final position, or where you the animator can blend between them. Option Description Default No Options","title":"Guide Control"},{"location":"menu/#forces","text":"Apply an external force to rigids. Kind of like constraints, except rigids are effected independently instead of relative another rigid.","title":"Forces"},{"location":"menu/#push-force","text":"This forces applies a force facing away from a point in space. It can be used for things like explosions. Option Description Default No Options","title":"Push Force"},{"location":"menu/#pull-force","text":"This is technically the same as 'Push', except the opposite. Instead of pushing rigids away from a point in space, rigids are pull towards it. This can be used for effects like black holes, or to simply nudge a rigid in some specific direction. Option Description Default No Options","title":"Pull Force"},{"location":"menu/#directional-force","text":"Gravity is computed deep within the solver and isn't technically applied as an external force, but apart form that this force replicates gravity in addition to letting you control the direction. Option Description Default No Options","title":"Directional Force"},{"location":"menu/#wind-force","text":"Wind is a complex phenomena. This force applies an iterative, 3D Perlin noise field to rigid bodies and is a great representation of how wind looks and acts in the real world. Use 'Visualiser' to get a sense of how it looks. Option Description Default No Options","title":"Wind Force"},{"location":"menu/#visualiser","text":"This creates a 2-dimensonal representation of either all or selected 3-dimensional forces. The slice can be moved and scaled just like any normal Maya transform, and the amount and length of samples can be manipulated (and even animated) interactively to get a fine-grained understanding of what your forces do to each rigid. Hint: Create multiple slices at various strategic locations in your scene to get an even greater understanding at specific areas. Option Description Default No Options","title":"Visualiser"},{"location":"menu/#assign-to-selected","text":"Forces are typically assigned to all existing rigids when created, or to the currently selected rigids. This command lets you add forces to rigids manually. Forces can be removed by breaking their connection to each other. Option Description Default No Options","title":"Assign To Selected"},{"location":"menu/#utilities","text":"High-level tools for animators and riggers that build upon the lower-level concepts above. Everything here can be created manually using a combination of the above commands or by making the connections yourself.","title":"Utilities"},{"location":"menu/#character","text":"An auto-rigger, designed to produce an animatable character from a skeleton hierarchy. Option Description Default Copy Turn a copy of the selected hierarchy into a character, rather than the hierarchy itself. True Control Create an additional control hierarchy from generated character. True Normalise Shapes Make sure shapes are relatively evenly sized. This can help prevent 'stick-figures' which are tougher to control. Stop Behaviour Whether to include the joint with a 'Stop' label in the generated character or not. Inclusive","title":"Character"},{"location":"menu/#dynamic-control","text":"Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between. Basics","title":"Dynamic Control"},{"location":"menu/#global-preferences","text":"Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend. Option Description Default Gizmo Scale Scale at which to draw viewport widgets, like constraints. 1.0 Cache Media Cache clips in the timeline, for immediate feedback when scroll. - Off Fast, interactive but no scrubbing. - On Slow scrubbing support. - All Interactive scrubbing at the expense of RAM.< Off Auto Hide Shape Attributes (Requires scene reopen) Rid the Channel Box of attributes unrelated to the currently selected shape type. True Auto Initial State (Requires scene reopen) Whether or not to use the pose of a rigid at the start time as the active initial state. This feature records the pose from frame 1 at frame 2, by inserting itself in between finished evaluation of frame 1 and yet-to-begin evaluation of frame 2. True DG Viewport Fix Improve viewport robustness when simulating in DG Evaluation mode, by calling ogs -reset on the start frame. Bear in mind this action is global to Maya and may negatively (or positively) affect other nodes in your scene. Validate Evaluation Mode Check whether Maya is evaluating in Parallel or Serial whenever creating a new scene, as DG is slow and error-prone. True Validate Rotate Pivot Check whether the selected transform has a non-zero rotatePivot; they are unsupported and will be zeroed out. True Validate Rotate Axis Let the user know of a Ragdoll limitation, that a custom rotate axis are unsupported. True Validate Scale Let the user know of a Ragdoll limitation, that scale is unsupported. Validate Playback Speed Make sure Maya's playback speed is set to 'Play every frame'. True","title":"Global Preferences"},{"location":"menu/#help","text":"The Ragdoll user interfaces double as a place for help. The information is generated from the same source as this website, so as to be available wherever you are; without breaking your flow .","title":"Help"},{"location":"menu/#help-page","text":"The page can also be accessed by clicking on the top description. You can find hints about each option by hovering over it.","title":"Help Page"},{"location":"menu/#timeline","text":"Available videos regarding any menu item is visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about.","title":"Timeline"},{"location":"no-javascript/","text":"Got'cha! You've just been redirected from a JavaScript-heavy landing page, but your browser won't permit JavaScript. Continue Try again","title":"No javascript"},{"location":"nodes/","text":"Detailed information about all of Ragdoll's custom nodes along with the most commonly used attributes. For full attribute reference, see the link at the bottom of each node type, such as rdRigid . Each Ragdoll node starts with rd , e.g. rdRigid Scene Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Parallelism Ragdoll scenes support both scene-level parallelism and node-level parallelism. Scene-level parallelism happens when there are more than one Ragdoll scene present, each scene is then run in parallel for improved performance. For that reason, prefer using as many scenes as possible, especially if they are unlikely to interact. Node-level Parallelism happens internally, whereby a single simulation is distributed over multiple threads. The behavior can be tuned via the rdScene.threadCount attribute. Keep this at 0 when your scenes are small, i.e. < 100 rigids. The overhead of splitting up a simulation outweighs the benefit unless there is a lot to split. You should notice a performance difference in either direction as you manipulate this attribute. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .groundRestitution Bounciness of the ground plane. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference Rigid A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Passive Rigid pass data from Maya to Ragdoll Active Rigid pass data from Ragdoll to Maya Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference Constraint A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference Control A placeholder for drawing a rigid under a different transform. This node is cosmetic only. It helps you spot the rigid and rigid orientation in the viewport for a standalone controller, like a Guide . It also draws the node with a special icon in the outliner. But that's about it! Full Reference Constraint Multiplier Multiply one or more attributes of one or more constraints . This node enables you to animate one attribute that affect many attributes, like Translate Guide Stiffness across an entire character or limb. Attribute Description Type .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping float .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness float .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping float .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness float .driveStrength Multiplier for rdConstraint.driveStrength float .limitStrength Multiplier for rdConstraint.limitStrength float .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping float .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness float .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping float .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness float Full Reference Rigid Multiplier Multiply one or more attributes of one or more rigids . This node enables you to animate one attribute that affect many attributes, like Air Density across an entire character or limb. Attribute Description Type .airDensity Multiplier for rdRigid.airDensity float .angularDamping Multiplier for rdRigid.angularDamping float .linearDamping Multiplier for rdRigid.linearDamping float Full Reference","title":"Node Reference"},{"location":"nodes/#scene","text":"Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Parallelism Ragdoll scenes support both scene-level parallelism and node-level parallelism. Scene-level parallelism happens when there are more than one Ragdoll scene present, each scene is then run in parallel for improved performance. For that reason, prefer using as many scenes as possible, especially if they are unlikely to interact. Node-level Parallelism happens internally, whereby a single simulation is distributed over multiple threads. The behavior can be tuned via the rdScene.threadCount attribute. Keep this at 0 when your scenes are small, i.e. < 100 rigids. The overhead of splitting up a simulation outweighs the benefit unless there is a lot to split. You should notice a performance difference in either direction as you manipulate this attribute. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .groundRestitution Bounciness of the ground plane. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference","title":"Scene"},{"location":"nodes/#rigid","text":"A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Passive Rigid pass data from Maya to Ragdoll Active Rigid pass data from Ragdoll to Maya Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference","title":"Rigid"},{"location":"nodes/#constraint","text":"A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference","title":"Constraint"},{"location":"nodes/#control","text":"A placeholder for drawing a rigid under a different transform. This node is cosmetic only. It helps you spot the rigid and rigid orientation in the viewport for a standalone controller, like a Guide . It also draws the node with a special icon in the outliner. But that's about it! Full Reference","title":"Control"},{"location":"nodes/#constraint-multiplier","text":"Multiply one or more attributes of one or more constraints . This node enables you to animate one attribute that affect many attributes, like Translate Guide Stiffness across an entire character or limb. Attribute Description Type .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping float .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness float .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping float .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness float .driveStrength Multiplier for rdConstraint.driveStrength float .limitStrength Multiplier for rdConstraint.limitStrength float .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping float .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness float .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping float .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness float Full Reference","title":"Constraint Multiplier"},{"location":"nodes/#rigid-multiplier","text":"Multiply one or more attributes of one or more rigids . This node enables you to animate one attribute that affect many attributes, like Air Density across an entire character or limb. Attribute Description Type .airDensity Multiplier for rdRigid.airDensity float .angularDamping Multiplier for rdRigid.angularDamping float .linearDamping Multiplier for rdRigid.linearDamping float Full Reference","title":"Rigid Multiplier"},{"location":"overview/","text":"Ragdoll is a real-time physics solver for Maya, similar the native nCloth and nHair solvers except it works on transforms rather than points. That makes it better equipt to integrate with your existing animation controls and doesn't require translating from points like people did in the 90's. This domain contains Ragdoll learning resources, for a more general overview see the Product Page . Where to Find Help? Depending on where you are and what you are looking for, one of these should fit the bill. Source Description Release Notes Every new release comes with examples of every new feature and squashed bug. Search Top-right on this website there's a field to search for any word or phrase on this domain, including node attribute reference. UI Help Find help without leaving Maya YouTube Videos Long-form walkthroughs and examples. Tutorials (Coming soon) Long-form, written tutorials are about to appear on this website, watch this space. Examples Download and play around with some example scenes. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . Community Inspire and be inspired via the Ragdoll forums Support Get us involved and we'll make some waves What's Next? Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch Me I've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"Overview"},{"location":"overview/#where-to-find-help","text":"Depending on where you are and what you are looking for, one of these should fit the bill. Source Description Release Notes Every new release comes with examples of every new feature and squashed bug. Search Top-right on this website there's a field to search for any word or phrase on this domain, including node attribute reference. UI Help Find help without leaving Maya YouTube Videos Long-form walkthroughs and examples. Tutorials (Coming soon) Long-form, written tutorials are about to appear on this website, watch this space. Examples Download and play around with some example scenes. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . Community Inspire and be inspired via the Ragdoll forums Support Get us involved and we'll make some waves","title":"Where to Find Help?"},{"location":"overview/#whats-next","text":"Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch Me I've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"What's Next?"},{"location":"quick-tail-setup/","text":"In this tutorial you'll learn how to setup a tail with physics and how to steer the look and feel of the simulation using normal keyframing techniques. We'll use one of the excellent rigs by Truong CG Artist . Optional example files falloff_example.zip Walkcycle Let's start with a walkcycle, and move towards interacting with the environment. Apply Simulation Select the hip followed by each tail control along the tail in order, and click Create Dynamic Control . Reduce Gravity This particular rig is very small, about 1.6 cm tall, so we need to reduce the default Gravity to reflect this. Global Strength The first selected Dynamic Control contains a Guide Multiplier to influence the strength on all of the tail controls at the same time. Local Strength You can also adjust the strength values individually for each joints, to taper their stiffness along the length of the tail. Strength Falloff Let's taper the strength along the length of the tail. Result Let's see how it looks. Sitting Down Now let's see how to steer our simulation with regular keyframes. Switch to Animation The simulation will try to follow your keyframe animation. Just switch off the Blend Simulation attribute on the root control while you're animating, then switch it back on to see how it looks. Animation vs Simulation You can see the animation input on the left and the resulting simulation on the right. With just 3 keyframed poses we end up with this result. Note that I had to overcompensate my animation poses to fight gravity when the tail swings around. Advanced Control Gain even more fine-grained control with these advanced topics. Flex and Relax Muscles By keyframing the root strength multiplier you can flex or relax the muscles in the tail. The higher the value the stiffer it gets and the lower the value the more relaxed it becomes, allowing gravity to drop it to the ground. Damping Damping controls how fleshy and sluggish your simulation behaves. Low or zero damping preserves more energy in the system, making a simulation more elastic or rubbery. Creatures and humans tend to look best with moderate to high damping values.","title":"Quick Tail Setup"},{"location":"quick-tail-setup/#walkcycle","text":"Let's start with a walkcycle, and move towards interacting with the environment.","title":"Walkcycle"},{"location":"quick-tail-setup/#apply-simulation","text":"Select the hip followed by each tail control along the tail in order, and click Create Dynamic Control .","title":"Apply Simulation"},{"location":"quick-tail-setup/#reduce-gravity","text":"This particular rig is very small, about 1.6 cm tall, so we need to reduce the default Gravity to reflect this.","title":"Reduce Gravity"},{"location":"quick-tail-setup/#global-strength","text":"The first selected Dynamic Control contains a Guide Multiplier to influence the strength on all of the tail controls at the same time.","title":"Global Strength"},{"location":"quick-tail-setup/#local-strength","text":"You can also adjust the strength values individually for each joints, to taper their stiffness along the length of the tail.","title":"Local Strength"},{"location":"quick-tail-setup/#strength-falloff","text":"Let's taper the strength along the length of the tail.","title":"Strength Falloff"},{"location":"quick-tail-setup/#result","text":"Let's see how it looks.","title":"Result"},{"location":"quick-tail-setup/#sitting-down","text":"Now let's see how to steer our simulation with regular keyframes.","title":"Sitting Down"},{"location":"quick-tail-setup/#switch-to-animation","text":"The simulation will try to follow your keyframe animation. Just switch off the Blend Simulation attribute on the root control while you're animating, then switch it back on to see how it looks.","title":"Switch to Animation"},{"location":"quick-tail-setup/#animation-vs-simulation","text":"You can see the animation input on the left and the resulting simulation on the right. With just 3 keyframed poses we end up with this result. Note that I had to overcompensate my animation poses to fight gravity when the tail swings around.","title":"Animation vs Simulation"},{"location":"quick-tail-setup/#advanced-control","text":"Gain even more fine-grained control with these advanced topics.","title":"Advanced Control"},{"location":"quick-tail-setup/#flex-and-relax-muscles","text":"By keyframing the root strength multiplier you can flex or relax the muscles in the tail. The higher the value the stiffer it gets and the lower the value the more relaxed it becomes, allowing gravity to drop it to the ground.","title":"Flex and Relax Muscles"},{"location":"quick-tail-setup/#damping","text":"Damping controls how fleshy and sluggish your simulation behaves. Low or zero damping preserves more energy in the system, making a simulation more elastic or rubbery. Creatures and humans tend to look best with moderate to high damping values.","title":"Damping"},{"location":"releases/","text":"Stay up to date with the latest improvements and fixes to Ragdoll. 2021.03.01 - Auto Initial State 2021.02.07 - Scale 2021.01.27 - Message Board 2021.01.17 - Hotfix 2021.01.15 - Dynamic Control 3.0 2021.01.14 - Multiplier Nodes 2021.01.04 - Licencing 2020.12.18 - Documentation 2020.12.07 - Dynamic Control Improvements 2020.12.01 - Character 2.0 2020.11.24 - Hotfix 2020.11.23 - Dynamic Control 2.0 2020.11.22 - Bugfixes 2020.11.17 - Splash Screen 2020.11.16 - Cached Playback 2020.11.10 - Multi-threading","title":"Releases"},{"location":"blog/20201215_cmdx/","text":"Talk about cmdx and why it's necessary.","title":"20201215 cmdx"},{"location":"blog/20201216_high_dpi_and_px/","text":"UI and Resolution Scaling Read about how Ragdoll implements resolution scaling, to support scalable UIs on modern high-resolution displays. TL;DR Here's a standalone version of the function I'll be walking you through, requires Maya 2017 (Qt 5) and above (due to QScreen ). def px ( value ): if not hasattr ( px , \"dpi\" ): any_widget = QtWidgets . QWidget () any_widget . setWindowFlags ( QtCore . Qt . ToolTip ) any_widget . show () window = any_widget . windowHandle () scale = window . screen () . logicalDotsPerInch () / 96.0 px . dpi = scale return value * px . dpi What is Resolution Scaling? Most displays have resolutions beyond the traditional 1080p, which makes text and graphics overly small. To account for this, operating systems have implemented \"resolution scaling\"; which is some factor to scale text and graphics by when drawing it on screen. Maya added (early and crude) support for resolution scaling in Maya 2016 with a usable and mostly transparent version landing in 2018 and beyond. Building UIs with Maya's native MEL-based UI tools account for scaling automatically, so you generally don't have to think about it. Unfortunately, for any non-trivial Qt project however you'll need to actively implement and maintain support for it. Ragdoll does this, and here's how. Implementation In short, any mention pixels run through a conversion function like this. # setFixedWidth(50) # Before setFixedWidth ( px ( 50 )) # After Where px() looks something like this. def px ( value ): return value * 1.5 That goes for stylesheets as well. style = \"\"\" QPushButton { width: 50px; } \"\"\" style = convert_px ( style ) setStyleSheet ( style ) Where convert_px() looks something like.. def convert_px ( style ): lines = [] for line in style . splitlines (); if \"px\" in line : # Find them and destroy them return \" \\n \" . join ( lines ) But where does this magical 1.5 value come from? The value depends on your display scale factor, or more precisely whichever scale factor Maya is currently working with. On Windows, the scale factor is set under your Display settings and Linux's various display managers have something like it. You can read this straight from the operating system, but the more cross-platform method would be to lean on Qt. Unfortunately, the Qt documentation for resolution scaling is a good representation of how confusing resolution scaling is amongst UI developers at large. https://doc.qt.io/qt-5/highdpi.html Because you have (1) an application scale, (2) an operating system scale and (3) a physical monitor scale; each of which combine in non-obvious ways to produce the final pixel coordinate on screen. What is the difference between \"Physical DPI\" and \"Logical DPI\"? Where does \"Device Pixel Ratio\" come into the picture? Here's what you need to know. scale = logicalDpi / 96.0 The value you'll end up with is 1.0 for a non-scaled display, such as your everyday 1080p monitor, and 1.5 or 2.0 for greater resolutions. If your OS allows, you could get values inbetween or greater, and although text scales somewhat well to any value, graphics shipped with Ragdoll is scaled at 2.0 which means it'll look best at 1.0 , 1.5 and 2.0 . Anything else will likely introduce blur. But wait, where does logicalDpi come from, and what's this magical 96.0 ? Qt can provide that for you, but not without a fight. window .","title":"20201216 high dpi and px"},{"location":"blog/20201216_high_dpi_and_px/#ui-and-resolution-scaling","text":"Read about how Ragdoll implements resolution scaling, to support scalable UIs on modern high-resolution displays.","title":"UI and Resolution Scaling"},{"location":"blog/20201216_high_dpi_and_px/#tldr","text":"Here's a standalone version of the function I'll be walking you through, requires Maya 2017 (Qt 5) and above (due to QScreen ). def px ( value ): if not hasattr ( px , \"dpi\" ): any_widget = QtWidgets . QWidget () any_widget . setWindowFlags ( QtCore . Qt . ToolTip ) any_widget . show () window = any_widget . windowHandle () scale = window . screen () . logicalDotsPerInch () / 96.0 px . dpi = scale return value * px . dpi","title":"TL;DR"},{"location":"blog/20201216_high_dpi_and_px/#what-is-resolution-scaling","text":"Most displays have resolutions beyond the traditional 1080p, which makes text and graphics overly small. To account for this, operating systems have implemented \"resolution scaling\"; which is some factor to scale text and graphics by when drawing it on screen. Maya added (early and crude) support for resolution scaling in Maya 2016 with a usable and mostly transparent version landing in 2018 and beyond. Building UIs with Maya's native MEL-based UI tools account for scaling automatically, so you generally don't have to think about it. Unfortunately, for any non-trivial Qt project however you'll need to actively implement and maintain support for it. Ragdoll does this, and here's how.","title":"What is Resolution Scaling?"},{"location":"blog/20201216_high_dpi_and_px/#implementation","text":"In short, any mention pixels run through a conversion function like this. # setFixedWidth(50) # Before setFixedWidth ( px ( 50 )) # After Where px() looks something like this. def px ( value ): return value * 1.5 That goes for stylesheets as well. style = \"\"\" QPushButton { width: 50px; } \"\"\" style = convert_px ( style ) setStyleSheet ( style ) Where convert_px() looks something like.. def convert_px ( style ): lines = [] for line in style . splitlines (); if \"px\" in line : # Find them and destroy them return \" \\n \" . join ( lines ) But where does this magical 1.5 value come from? The value depends on your display scale factor, or more precisely whichever scale factor Maya is currently working with. On Windows, the scale factor is set under your Display settings and Linux's various display managers have something like it. You can read this straight from the operating system, but the more cross-platform method would be to lean on Qt. Unfortunately, the Qt documentation for resolution scaling is a good representation of how confusing resolution scaling is amongst UI developers at large. https://doc.qt.io/qt-5/highdpi.html Because you have (1) an application scale, (2) an operating system scale and (3) a physical monitor scale; each of which combine in non-obvious ways to produce the final pixel coordinate on screen. What is the difference between \"Physical DPI\" and \"Logical DPI\"? Where does \"Device Pixel Ratio\" come into the picture? Here's what you need to know. scale = logicalDpi / 96.0 The value you'll end up with is 1.0 for a non-scaled display, such as your everyday 1080p monitor, and 1.5 or 2.0 for greater resolutions. If your OS allows, you could get values inbetween or greater, and although text scales somewhat well to any value, graphics shipped with Ragdoll is scaled at 2.0 which means it'll look best at 1.0 , 1.5 and 2.0 . Anything else will likely introduce blur. But wait, where does logicalDpi come from, and what's this magical 96.0 ? Qt can provide that for you, but not without a fight. window .","title":"Implementation"},{"location":"blog/20201217_option_dialogs/","text":"Talk about qargparse and why it's necessary.","title":"20201217 option dialogs"},{"location":"blog/20201218_optionvar/","text":"Maya's native persistent preferences, with support for access from C++.","title":"20201218 optionvar"},{"location":"blog/20201219_pythonreload/","text":"Talk about how you iterate in Maya, reloading all modules by namespace and what to look out for. Especially undo. And always having an uninstall.","title":"20201219 pythonreload"},{"location":"nodes/rdConstraint/","text":"Reference sheet for the rdConstraint node type. from maya import cmds cmds . createNode ( \"rdConstraint\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdConstraint"},{"location":"nodes/rdConstraint/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdConstraintMultiplier/","text":"Reference sheet for the rdConstraintMultiplier node type. from maya import cmds cmds . createNode ( \"rdConstraintMultiplier\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping \u2714\ufe0f float 1.0 .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness \u2714\ufe0f float 1.0 .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping \u2714\ufe0f float 1.0 .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness \u2714\ufe0f float 1.0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .driveStrength Multiplier for rdConstraint.driveStrength \u2714\ufe0f float 1.0 .limitStrength Multiplier for rdConstraint.limitStrength \u2714\ufe0f float 1.0 .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping \u2714\ufe0f float 1.0 .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness \u2714\ufe0f float 1.0 .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping \u2714\ufe0f float 1.0 .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdConstraintMultiplier"},{"location":"nodes/rdConstraintMultiplier/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping \u2714\ufe0f float 1.0 .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness \u2714\ufe0f float 1.0 .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping \u2714\ufe0f float 1.0 .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness \u2714\ufe0f float 1.0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .driveStrength Multiplier for rdConstraint.driveStrength \u2714\ufe0f float 1.0 .limitStrength Multiplier for rdConstraint.limitStrength \u2714\ufe0f float 1.0 .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping \u2714\ufe0f float 1.0 .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness \u2714\ufe0f float 1.0 .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping \u2714\ufe0f float 1.0 .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdControl/","text":"Reference sheet for the rdControl node type. from maya import cmds cmds . createNode ( \"rdControl\" ) Attributes Attribute Description Keyable Type Default .color Color of the surface and wireframe. float3 0.443 0.705 0.952 .drawShaded Whether or not to draw wireframe or shaded. bool False .outputMesh Polygonal output, for rendering, shadows and export. mesh .rigid Reference to rigid this control represents. int -1 .version Version of Ragdoll used to create this node. int 0","title":"rdControl"},{"location":"nodes/rdControl/#attributes","text":"Attribute Description Keyable Type Default .color Color of the surface and wireframe. float3 0.443 0.705 0.952 .drawShaded Whether or not to draw wireframe or shaded. bool False .outputMesh Polygonal output, for rendering, shadows and export. mesh .rigid Reference to rigid this control represents. int -1 .version Version of Ragdoll used to create this node. int 0","title":"Attributes"},{"location":"nodes/rdRigid/","text":"Reference sheet for the rdRigid node type. from maya import cmds cmds . createNode ( \"rdRigid\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float 1.0 .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced. Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .inputSurface NURBS input to the Mesh shape type. nurbsSurface .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float 0.5 .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum 1 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdRigid"},{"location":"nodes/rdRigid/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float 1.0 .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced. Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .inputSurface NURBS input to the Mesh shape type. nurbsSurface .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float 0.5 .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum 1 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdRigidMultiplier/","text":"Reference sheet for the rdRigidMultiplier node type. from maya import cmds cmds . createNode ( \"rdRigidMultiplier\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier for rdRigid.airDensity \u2714\ufe0f float 1.0 .angularDamping Multiplier for rdRigid.angularDamping \u2714\ufe0f float 1.0 .linearDamping Multiplier for rdRigid.linearDamping \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdRigidMultiplier"},{"location":"nodes/rdRigidMultiplier/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier for rdRigid.airDensity \u2714\ufe0f float 1.0 .angularDamping Multiplier for rdRigid.angularDamping \u2714\ufe0f float 1.0 .linearDamping Multiplier for rdRigid.linearDamping \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdScene/","text":"Reference sheet for the rdScene node type. from maya import cmds cmds . createNode ( \"rdScene\" ) Attributes Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdScene"},{"location":"nodes/rdScene/#attributes","text":"Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"releases/2020.11.10/","text":"Performance! NEW Multi-threading Ragdoll now supports multiple solvers in the same Maya scene, each of which run in parallel offering a 2-3x increase in FPS NEW UI Menu items now have additional customisation with a new UI interface. NEW Animation Influence Dynamic Controls can now respond to animation input, either kinematically or as a guided influence to your simulation. This means you can turn your controllers dynamic, and add additional animation to steer the simulation! NEW Exploratory Menu The menu is now fully unlocked, with user-friendly messages letting you know how to use it if you are unfamiliar. The goal is facilitating exploration and curiosity in a safe environment with reliable undo. FIXED Hinge Constraint A constraint being converted to/from a hinge constraint no longer breaks the constraint. FIXED Set Initial State Modify the position and orientation of your rigid bodies after creation with this feature. Multi-Threading Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead. Option Dialogs Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches. Animation Influence The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"2020.11.10"},{"location":"releases/2020.11.10/#multi-threading","text":"Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead.","title":"Multi-Threading"},{"location":"releases/2020.11.10/#option-dialogs","text":"Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches.","title":"Option Dialogs"},{"location":"releases/2020.11.10/#animation-influence","text":"The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"Animation Influence"},{"location":"releases/2020.11.16/","text":"The highlight for this release is Cached Playback! NEW Cached Playback You can now leverage Maya 2020's native cached playback for your simulations, speeding up playback performance and lowering iteration times. NEW Help Videos Ragdoll commands now come with how-to videos built directly into the UI. NEW Shape orientation and joints Shapes relied on the jointOrient being proper for joints, gone are the days. FIXED Wireframe Bug The wireframe for the Box shape does now draw correctly with a custom rdRigid.shapeRotation FIXED Outliner Icon Support on Linux Linux now benefits from the same pretty icons as Windows FIXED Logging Warnings These now emit a yellow color in your Command Line FIXED Boxes and Joints Joints converted to Rigids can now be set to Box shape with proper orientation Cached Playback Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor Known Limitations with Cached Playback There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! rdRigid.ouputGeometry Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why. Help Videos Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll. Shape Orientation Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"2020.11.16"},{"location":"releases/2020.11.16/#cached-playback","text":"Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor","title":"Cached Playback"},{"location":"releases/2020.11.16/#known-limitations-with-cached-playback","text":"There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! rdRigid.ouputGeometry Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why.","title":"Known Limitations with Cached Playback"},{"location":"releases/2020.11.16/#help-videos","text":"Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll.","title":"Help Videos"},{"location":"releases/2020.11.16/#shape-orientation","text":"Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"Shape Orientation"},{"location":"releases/2020.11.17/","text":"Minor release. NEW Installation confirmation Ragdoll now lets you know whether the install went successful or not. This appears on first launch, and can be revisited via the Ragdoll menu. This is also where updates will be found, along with future new-user material like links to docs and tutorials. FIXED The Ragdoll | Character menu item has been fixed and is operating at 100% Install Confirmation It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"2020.11.17"},{"location":"releases/2020.11.17/#install-confirmation","text":"It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"Install Confirmation"},{"location":"releases/2020.11.22/","text":"Minor release, no breaking changes. FIXED Capsule orientation used to face the wrong direction with some joints FIXED Creating a new collider is now undoable like you would expect FIXED Message printed when converting a rigid is now accurate FIXED Kinematic/Dynamic option from Convert Options does no longer bleeds into the Create Rigid Options ADDED Auto option to Convert Rigid , to toggle a rigid between dynamic and kinematic CHANGED The rdRigid.kinematic attribute is now up-top, better indicating its importance CHANGED The Ragdoll | Convert menu item is now split into Convert Rigid and Convert Constraint CHANGED Renamed Convex Hull -> Mesh , should make more sense now Capsule Orientation Fixed a bug where the capsule of a joint would face the wrong way. What is Rigid Body Dynamics? Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body Performance Tips Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"2020.11.22"},{"location":"releases/2020.11.22/#capsule-orientation","text":"Fixed a bug where the capsule of a joint would face the wrong way.","title":"Capsule Orientation"},{"location":"releases/2020.11.22/#what-is-rigid-body-dynamics","text":"Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body","title":"What is Rigid Body Dynamics?"},{"location":"releases/2020.11.22/#performance-tips","text":"Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"Performance Tips"},{"location":"releases/2020.11.23/","text":"The headline of this release is Dynamic Control 2.0 CHANGED Dynamic Control Removed fuss and simplified the interface. CHANGED \"Delete All Physics\" Now deletes all physics, regardless of the current selection CHANGED Rigid versus Collider Learn about what these mean and how to convert between the two. ADDED Center of mass (Advanced) Now you can change the point at which a rigid body is balanced ADDED Angular mass (Advanced) Typically computed automatically from the shape and size of your rigid, now you can manually define this. ADDED Auto Connect More clarity, and also usable with things other than joints Dynamic Control 2.0 Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos Limitations Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment. Center of Mass If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it Angular Mass In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\" or \"moment of inertia\". It's like mass, but in terms of rotation rather than position. The broom has a low angular mass around its length axis, and a high angular mass in the other two axes. That makes it \"heavier\" around some axes but not others. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, then the angular mass will also be lighter around its length then its width. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it Auto Connect The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"2020.11.23"},{"location":"releases/2020.11.23/#dynamic-control-20","text":"Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos","title":"Dynamic Control 2.0"},{"location":"releases/2020.11.23/#limitations","text":"Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment.","title":"Limitations"},{"location":"releases/2020.11.23/#center-of-mass","text":"If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it","title":"Center of Mass"},{"location":"releases/2020.11.23/#angular-mass","text":"In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\" or \"moment of inertia\". It's like mass, but in terms of rotation rather than position. The broom has a low angular mass around its length axis, and a high angular mass in the other two axes. That makes it \"heavier\" around some axes but not others. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, then the angular mass will also be lighter around its length then its width. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it","title":"Angular Mass"},{"location":"releases/2020.11.23/#auto-connect","text":"The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"Auto Connect"},{"location":"releases/2020.11.24/","text":"Hotfix, the last release broke a few things. FIXED You can now save the Maya scene. Imagine that! FIXED You can now enable the Ragdoll solver after having disabled it That's all, have mercy.","title":"2020.11.24"},{"location":"releases/2020.12.01/","text":"Lots of good stuff! CHANGED Active & Passive Rigid More intuitive jargon for these suckers CHANGED Character 2.0 New and improved, now with cup-holders! ADDED Dynamic Control Capsules For those flat controls ADDED Time Multiplier Speed up or slow down your simulation, can be animated! ADDED Normalise Shapes Evenly distribute shapes across a hierarchy ADDED Auto Orient Don't bother orienting your joints with this nifty automation, now the X-axis always means \"length\" CHANGED Delete all Physics now also deletes Ragdoll's attributes on your animation controls, for that squeaky clean feeling ADDED Support for custom Rotate Order means more character controls now work out-of-the-box. FIXED Undo bug and rdRigid The rigids should now clean up after themselves better FIXED Simulation start time now uses the start range rather than start time, which is what you would expect NOTES Stick figures Learn about how thickness affects your simulation NOTES Animation in 1995 Witness how little our industry has changed since then, let's fix that! Active & Passive Rigid Body The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\"). Character 2.0 - \"Auto-Ragger\" This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page Dynamic Control Capsules Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page Normalise Shapes An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up Time Multiplier Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene Rotate Order Now rigids plya well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one! Auto Orient Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons. Undo Bug There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed! Stick Figures In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head? Animation in 1995 Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"2020.12.01"},{"location":"releases/2020.12.01/#active-passive-rigid-body","text":"The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\").","title":"Active &amp; Passive Rigid Body"},{"location":"releases/2020.12.01/#character-20-auto-ragger","text":"This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page","title":"Character 2.0 - \"Auto-Ragger\""},{"location":"releases/2020.12.01/#dynamic-control-capsules","text":"Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.01/#normalise-shapes","text":"An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up","title":"Normalise Shapes"},{"location":"releases/2020.12.01/#time-multiplier","text":"Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene","title":"Time Multiplier"},{"location":"releases/2020.12.01/#rotate-order","text":"Now rigids plya well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one!","title":"Rotate Order"},{"location":"releases/2020.12.01/#auto-orient","text":"Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons.","title":"Auto Orient"},{"location":"releases/2020.12.01/#undo-bug","text":"There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed!","title":"Undo Bug"},{"location":"releases/2020.12.01/#stick-figures","text":"In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head?","title":"Stick Figures"},{"location":"releases/2020.12.01/#animation-in-1995","text":"Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"Animation in 1995"},{"location":"releases/2020.12.07/","text":"Small release with important changes if you use Dynamic Controls on complex rigs with pre-existing animation. ADDED Blend Rigid Now rigids can do some of what Dynamic Controls can do. :) FIXED Dynamic Control switch Shape You can now switch to capsules after having created them as meshes. FIXED Dynamic Control and Undo If your controls have pre-existing animation, undo will now work properly FIXED Dynamic Control and Auto Orient If you controls have intermediate groups between themselves, auto axis will now work properly Blend Rigid Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box. Dynamic Control Capsules Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around. Dynamic Control and Undo You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo. Dynamic Control and Orient Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"2020.12.07"},{"location":"releases/2020.12.07/#blend-rigid","text":"Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box.","title":"Blend Rigid"},{"location":"releases/2020.12.07/#dynamic-control-capsules","text":"Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around.","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.07/#dynamic-control-and-undo","text":"You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo.","title":"Dynamic Control and Undo"},{"location":"releases/2020.12.07/#dynamic-control-and-orient","text":"Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"Dynamic Control and Orient"},{"location":"releases/2020.12.18/","text":"Documentation documentation documentation! ADDED Documentation You heard it here first! ADDED Help Page All menu items now offer a dedicated help page for details about how it works. ADDED Timeline More videos more easily accessible via the new Timeline feature of UIs CHANGED API \ud83d\udc96 cmds The API now integrates with maya.cmds ADDED Shelf Support Menu items can now be added to your own custom shelf with Ctrl + Shift + Click ADDED Helper warnings Ragdoll now warns when doing something unsupported This version expires January 10 2021 Documentation Since the last release I've added a boatload of documentation to Ragdoll, including the very website you are visiting now! https://learn.ragdolldynamics.com This is where I'll aggregate anything there is to know about Ragdoll, including links to the upcoming forums and chat rooms, YouTube series and more. More more more! Documentation is generated dynamically from the same source used to generate the in-Maya menu and graphical dialogs, so whenever you want quick help from within Maya without breaking your flow, you can! And when you're on the train without access to Maya wanting to know more about a particular button or feature, you can! Overview Help Page Every menu item now comes with the Help sub-menu active. The page can also be accessed by clicking on the top description. I also added hints to the labels of attributes, rather than just the widgets themselves. All of the information is generated from the same source as the website, so they'll tell you the same thing except closer to where you are. For example, the Active Rigid menu item: https://learn.ragdolldynamics.com/menu/#active-rigid Timeline Multiple videos are now visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about. Real-time scrubbing I've added real-time scrubbing too! The caveat however is that it consumes a lot of RAM, this dialog of about 1,000 frames takes 1.5 GB of RAM, and a hefty delay to showing the option dialog. API and cmds The API used to take and return instances of cmdx , the high-performance alternative to PyMEL. The API now integrates seamlessly with maya.cmds , both taking and returning node paths (i.e. strings) rather than instances, which means you can now do this! from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) The performance advantage of cmdx is still intact, and can be accessed via commands.py which contains identical members and argument signatures, except returning instanced of cmdx instead. This is what's used internally for both performance and readability. In addition, there is now support for interactive.py for quick-and-dirty one-off scripts. This module contains all of what is provided by the Ragdoll menu and work similarly to api.py except they take (1) user selection and (2) user preferences into account. API Reference Add to Shelf Menu items can now be added to the shelf by holding Ctrl + Shift + Click. Menu items also reveal the equivalent Python command to use for your scripts! Helper Warnings If nodes have custom pivots or if your Maya scene is set to DG evaluation mode, Ragdoll will tell you about why that's a bad idea.","title":"2020.12.18"},{"location":"releases/2020.12.18/#documentation","text":"Since the last release I've added a boatload of documentation to Ragdoll, including the very website you are visiting now! https://learn.ragdolldynamics.com This is where I'll aggregate anything there is to know about Ragdoll, including links to the upcoming forums and chat rooms, YouTube series and more. More more more! Documentation is generated dynamically from the same source used to generate the in-Maya menu and graphical dialogs, so whenever you want quick help from within Maya without breaking your flow, you can! And when you're on the train without access to Maya wanting to know more about a particular button or feature, you can! Overview","title":"Documentation"},{"location":"releases/2020.12.18/#help-page","text":"Every menu item now comes with the Help sub-menu active. The page can also be accessed by clicking on the top description. I also added hints to the labels of attributes, rather than just the widgets themselves. All of the information is generated from the same source as the website, so they'll tell you the same thing except closer to where you are. For example, the Active Rigid menu item: https://learn.ragdolldynamics.com/menu/#active-rigid","title":"Help Page"},{"location":"releases/2020.12.18/#timeline","text":"Multiple videos are now visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about. Real-time scrubbing I've added real-time scrubbing too! The caveat however is that it consumes a lot of RAM, this dialog of about 1,000 frames takes 1.5 GB of RAM, and a hefty delay to showing the option dialog.","title":"Timeline"},{"location":"releases/2020.12.18/#api-and-cmds","text":"The API used to take and return instances of cmdx , the high-performance alternative to PyMEL. The API now integrates seamlessly with maya.cmds , both taking and returning node paths (i.e. strings) rather than instances, which means you can now do this! from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) The performance advantage of cmdx is still intact, and can be accessed via commands.py which contains identical members and argument signatures, except returning instanced of cmdx instead. This is what's used internally for both performance and readability. In addition, there is now support for interactive.py for quick-and-dirty one-off scripts. This module contains all of what is provided by the Ragdoll menu and work similarly to api.py except they take (1) user selection and (2) user preferences into account. API Reference","title":"API and cmds"},{"location":"releases/2020.12.18/#add-to-shelf","text":"Menu items can now be added to the shelf by holding Ctrl + Shift + Click. Menu items also reveal the equivalent Python command to use for your scripts!","title":"Add to Shelf"},{"location":"releases/2020.12.18/#helper-warnings","text":"If nodes have custom pivots or if your Maya scene is set to DG evaluation mode, Ragdoll will tell you about why that's a bad idea.","title":"Helper Warnings"},{"location":"releases/2021.01.04/","text":"This release introduces proper licencing to Ragdoll. ADDED Official Website Tell your friends! ADDED Licencing Read all about it! FIXED Locked rotatePivot Minor bug patched up and ready to go FIXED Centered Option Window - On Linux, the option window would sometimes appear in the top-left corner of the screen. No more! Website Happy New Year, the year of Ragdoll. :) I've launched the next generation of Ragdoll's website. Something a little more flashy and intended to wet people's appetite for what lies ahead. Feel free to tell people about it, I've added a note about when it'll become a reality. https://ragdolldynamics.com Also see this news coverage happening in Japan! :D https://3dnchu.com/archives/ragdoll-dynamics-maya/ The old website can still be accessed, although it is a little crippled. https://alanjfs.github.io/ragdoll-web/ If any link fails, just make sure it's prefixed with ragdoll-web/ as the landing page, e.g. https://alanjfs.github.io/ragdoll-web/howto Licencing Ragdoll is growing up and now understands the \"product key\" which means users can now purchase a copy and register it to themselves. Here's the short version, with a longer version below. Can I use it on more than one machine? Yes Can I move a licence between two machines? Yes Do I need an internet connection to use Ragdoll? Yes and no What if someone steals my licence key? Bummer Can I have a floating licence? Soon Can I activate offline? Soon When exactly is internet required? See long answer Can I manage my licence via Python? Yes Now let's cover the nitty gritty details, at the time of this writing. See licencing for current up-to-date information if you are reading this from the future. What's changed? You won't notice a change, other than a new UI. Rather than Ragdoll expiring on a fixed date, it'll now expire 30 days after first launch, unless you activate. Activation requires a product key which you get by either purchasing a licence or being really awesome. How does it work? On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Click Activate Enter your product key Or if you prefer: from ragdoll import licence licence . activate ( key ) Can I use it on more than one machine? Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence. Can I move a licence between two machines? Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released. Do I need an internet connection to use Ragdoll? Yes and no. Yes: To activate either the trial of purchased version of Ragdoll, the machine needs a connection to the internet. No: Once activated, you won't need internet for 90 days No: For special cases, get in touch. What if someone steals my licence key? That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one. Can I have a floating licence? Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All I need is you. Can I activate offline? Yes. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch. When exactly is internet required? A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain. Can I manage my licence via Python? Sure can, see below. Licence API As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" # Is the current licence activated? \"isActivated\" # Is the current licence a trial licence? \"isTrial\" # Has the licence not been tampered with? \"isGenuine\" # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" # How many days until this trial expires? \"trialDays\" } Locked Rotate Pivot Ragdoll doesn't support a custom rotatePivot attribute and would zero this out whenever a transform is turned dynamic. It'll provide a warning to the end user that this would happen. But, it wasn't taking into account the rotatePivot being connected or locked. If that happened, Ragdoll would flat out refuse and print something cryptic in the Script Editor. This has now been fixed. If the attribute is zero, nothing changes If the attribute is modified, it'll be zeroed out If the attribute is locked or connected, a warning is printed, but nothing changes. Ragdoll still doesn't actually support a custom rotate pivot. So this fixes only the situation where.. The rotatePivot is zero (default), and.. The rotatePivot is locked","title":"2021.01.04"},{"location":"releases/2021.01.04/#website","text":"Happy New Year, the year of Ragdoll. :) I've launched the next generation of Ragdoll's website. Something a little more flashy and intended to wet people's appetite for what lies ahead. Feel free to tell people about it, I've added a note about when it'll become a reality. https://ragdolldynamics.com Also see this news coverage happening in Japan! :D https://3dnchu.com/archives/ragdoll-dynamics-maya/ The old website can still be accessed, although it is a little crippled. https://alanjfs.github.io/ragdoll-web/ If any link fails, just make sure it's prefixed with ragdoll-web/ as the landing page, e.g. https://alanjfs.github.io/ragdoll-web/howto","title":"Website"},{"location":"releases/2021.01.04/#licencing","text":"Ragdoll is growing up and now understands the \"product key\" which means users can now purchase a copy and register it to themselves. Here's the short version, with a longer version below. Can I use it on more than one machine? Yes Can I move a licence between two machines? Yes Do I need an internet connection to use Ragdoll? Yes and no What if someone steals my licence key? Bummer Can I have a floating licence? Soon Can I activate offline? Soon When exactly is internet required? See long answer Can I manage my licence via Python? Yes Now let's cover the nitty gritty details, at the time of this writing. See licencing for current up-to-date information if you are reading this from the future.","title":"Licencing"},{"location":"releases/2021.01.04/#whats-changed","text":"You won't notice a change, other than a new UI. Rather than Ragdoll expiring on a fixed date, it'll now expire 30 days after first launch, unless you activate. Activation requires a product key which you get by either purchasing a licence or being really awesome.","title":"What's changed?"},{"location":"releases/2021.01.04/#how-does-it-work","text":"On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Click Activate Enter your product key Or if you prefer: from ragdoll import licence licence . activate ( key )","title":"How does it work?"},{"location":"releases/2021.01.04/#can-i-use-it-on-more-than-one-machine","text":"Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence.","title":"Can I use it on more than one machine?"},{"location":"releases/2021.01.04/#can-i-move-a-licence-between-two-machines","text":"Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released.","title":"Can I move a licence between two machines?"},{"location":"releases/2021.01.04/#do-i-need-an-internet-connection-to-use-ragdoll","text":"Yes and no. Yes: To activate either the trial of purchased version of Ragdoll, the machine needs a connection to the internet. No: Once activated, you won't need internet for 90 days No: For special cases, get in touch.","title":"Do I need an internet connection to use Ragdoll?"},{"location":"releases/2021.01.04/#what-if-someone-steals-my-licence-key","text":"That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one.","title":"What if someone steals my licence key?"},{"location":"releases/2021.01.04/#can-i-have-a-floating-licence","text":"Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All I need is you.","title":"Can I have a floating licence?"},{"location":"releases/2021.01.04/#can-i-activate-offline","text":"Yes. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch.","title":"Can I activate offline?"},{"location":"releases/2021.01.04/#when-exactly-is-internet-required","text":"A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain.","title":"When exactly is internet required?"},{"location":"releases/2021.01.04/#can-i-manage-my-licence-via-python","text":"Sure can, see below.","title":"Can I manage my licence via Python?"},{"location":"releases/2021.01.04/#licence-api","text":"As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" # Is the current licence activated? \"isActivated\" # Is the current licence a trial licence? \"isTrial\" # Has the licence not been tampered with? \"isGenuine\" # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" # How many days until this trial expires? \"trialDays\" }","title":"Licence API"},{"location":"releases/2021.01.04/#locked-rotate-pivot","text":"Ragdoll doesn't support a custom rotatePivot attribute and would zero this out whenever a transform is turned dynamic. It'll provide a warning to the end user that this would happen. But, it wasn't taking into account the rotatePivot being connected or locked. If that happened, Ragdoll would flat out refuse and print something cryptic in the Script Editor. This has now been fixed. If the attribute is zero, nothing changes If the attribute is modified, it'll be zeroed out If the attribute is locked or connected, a warning is printed, but nothing changes. Ragdoll still doesn't actually support a custom rotate pivot. So this fixes only the situation where.. The rotatePivot is zero (default), and.. The rotatePivot is locked","title":"Locked Rotate Pivot"},{"location":"releases/2021.01.14/","text":"Highlight for this release are the new Multiplier Nodes ! ADDED Multiplier Nodes Animate in bulk with this nifty utility node! ADDED Environment variables Gain more control over the integration of Ragdoll into your pipeline ADDED Dynamic Shape Type Attributes Cleaner channel box means happier animators FIXED NaN and Dynamic Control Got bogus values on the Rotate Limit of Dynamic Controls? No longer! FIXED Cycle warnings on create In rare occasions, Maya would complain that there's a cycle just as you turn a control dynamic. No more. FIXED Zero limit strength Used to be interpreted as \"inifinitely strong\", but now is \"off\" as one would expect. PUBLICITY EnTT We got mentioned in this great project :) OPTIMISATION Bounding Box Minor performance and stability improvements with native bounding box support Multiplier Nodes Work procedurally, with this centralised place to edit any number of rigids or constraints simultaneously. The idea is to facilitate a top-level node which govern the overall look of your simulation; withouth having to find and select each control individually. Workflow Select any number of rigids or constraints Click Multiply Selected Constraints (or Rigids ) The order in which you select matters, the first selection gets the node. The recommended workflow is to start with the root and work your way out. But your selection can span multiple hierarchies or even the whole character. A quick \"Select Hierarchy\" across an entire character is possible also. A constraint and rigid can only have 1 multiplier connected at any one time. Demo The most common attributes are made available currently, let me know if you find something missing! YouTube Wolf Rig Example Multiply Constraint Attributes Multiply Rigid Attributes Environment Variables Added these suckers for you to play around with. Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset For up to date information, see here. https://learn.ragdolldynamics.com/api/#environment-variables EnTT Getting some more recognition on the interwebs from EnTT, the library used to keep Ragdoll fast and clean! https://github.com/skypjack/entt Dynamic Shape Type Attributes Now only relevant attributes are visible in the Channel Box, dynamically based on the current type. I've added an option to disable this in the Global Preferences. Bounding Box Maya uses bounding box information to avoid drawing things that aren't visible in camera. The previous version of Ragdoll didn't provide Maya with any bounding box, which left Maya with no choice but to draw these always; even when behind the camera. Now this isn't so. You shouldn't notice much for smaller scenes, but drawing typically consumes 20-30% of the total CPU impact Ragdoll has on your character rigs. So for larger scenes this should reap a significant performance boost. Pro tip: You can also disable drawing of all Ragdoll primitives by disabling Locators in your viewport; that's how Maya classifies any and all Ragdoll nodes. Cycle Warnings TLDR; you should now experience fewer cycle warnings. https://forums.ragdolldynamics.com/t/how-to-cause-a-cycle-warning/33 Whenever you create a rigid from any Maya node, like an animation control, Ragdoll makes a note of the position and orientation of that control. It takes into account that you may not be on the start frame when you create the control, which is what you most likely intended to do. When that happens, Maya will silently roll back time in the background to query an attribute at the start frame. This silent roll-back has a tendency to trigger evaluation of unrelated nodes, like IK handles, which in turn trigger other nodes, ultimately leading back to where it came from, and thus cause a cycle. These were somewhat harmless, but could mask a real cycle from happening. In this release, this silent roll back only happens when you actually aren't on the start frame. So you should see less of it. There's still room for improvement however, so if you still find warnings or any odd behaviors being due to cycles, do reach out! NaN If you've ever gotten these, you can now rest easy. They are gone. They could happen on occasion, especially after repeated undo. It had to do with memory access violation by Maya being naughty, something it really shouldn't be able to do in the first place. We now guard against this , so all is well.","title":"2021.01.14"},{"location":"releases/2021.01.14/#multiplier-nodes","text":"Work procedurally, with this centralised place to edit any number of rigids or constraints simultaneously. The idea is to facilitate a top-level node which govern the overall look of your simulation; withouth having to find and select each control individually. Workflow Select any number of rigids or constraints Click Multiply Selected Constraints (or Rigids ) The order in which you select matters, the first selection gets the node. The recommended workflow is to start with the root and work your way out. But your selection can span multiple hierarchies or even the whole character. A quick \"Select Hierarchy\" across an entire character is possible also. A constraint and rigid can only have 1 multiplier connected at any one time. Demo The most common attributes are made available currently, let me know if you find something missing! YouTube Wolf Rig Example Multiply Constraint Attributes Multiply Rigid Attributes","title":"Multiplier Nodes"},{"location":"releases/2021.01.14/#environment-variables","text":"Added these suckers for you to play around with. Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset For up to date information, see here. https://learn.ragdolldynamics.com/api/#environment-variables","title":"Environment Variables"},{"location":"releases/2021.01.14/#entt","text":"Getting some more recognition on the interwebs from EnTT, the library used to keep Ragdoll fast and clean! https://github.com/skypjack/entt","title":"EnTT"},{"location":"releases/2021.01.14/#dynamic-shape-type-attributes","text":"Now only relevant attributes are visible in the Channel Box, dynamically based on the current type. I've added an option to disable this in the Global Preferences.","title":"Dynamic Shape Type Attributes"},{"location":"releases/2021.01.14/#bounding-box","text":"Maya uses bounding box information to avoid drawing things that aren't visible in camera. The previous version of Ragdoll didn't provide Maya with any bounding box, which left Maya with no choice but to draw these always; even when behind the camera. Now this isn't so. You shouldn't notice much for smaller scenes, but drawing typically consumes 20-30% of the total CPU impact Ragdoll has on your character rigs. So for larger scenes this should reap a significant performance boost. Pro tip: You can also disable drawing of all Ragdoll primitives by disabling Locators in your viewport; that's how Maya classifies any and all Ragdoll nodes.","title":"Bounding Box"},{"location":"releases/2021.01.14/#cycle-warnings","text":"TLDR; you should now experience fewer cycle warnings. https://forums.ragdolldynamics.com/t/how-to-cause-a-cycle-warning/33 Whenever you create a rigid from any Maya node, like an animation control, Ragdoll makes a note of the position and orientation of that control. It takes into account that you may not be on the start frame when you create the control, which is what you most likely intended to do. When that happens, Maya will silently roll back time in the background to query an attribute at the start frame. This silent roll-back has a tendency to trigger evaluation of unrelated nodes, like IK handles, which in turn trigger other nodes, ultimately leading back to where it came from, and thus cause a cycle. These were somewhat harmless, but could mask a real cycle from happening. In this release, this silent roll back only happens when you actually aren't on the start frame. So you should see less of it. There's still room for improvement however, so if you still find warnings or any odd behaviors being due to cycles, do reach out!","title":"Cycle Warnings"},{"location":"releases/2021.01.14/#nan","text":"If you've ever gotten these, you can now rest easy. They are gone. They could happen on occasion, especially after repeated undo. It had to do with memory access violation by Maya being naughty, something it really shouldn't be able to do in the first place. We now guard against this , so all is well.","title":"NaN"},{"location":"releases/2021.01.15/","text":"The gift that keeps on giving, the highlight for this release is Dynamic Control 3.0 ! UX Dynamic Control 3.0 More intuitive, more smart UX Convert & Restore Slimmer and more intuitive UI Passive Grayscale Passive rigids are now distinguished by grayscale colors ADDED Select All Quickly select all rigids and constraints with this handy menu or shelf item. Dynamic Control 3.0 Another step forward for Dynamic Controls. Default Capsule Ragdoll now defaults to the newer Capsule shape type for dynamic controls. It's faster and applies more generally to most rigs; even those that do have NURBS curves wrapping around the underlying character geometry. Before After Automatic Multiplier The previous release introduced Multiplier Nodes . This release add a multiplier to each new dynamic control chain per default, on the root control, which means you can now do stuff like this! Centralised Blend Simulation Previously, to blend between animation and simulation you needed to select the controls to blend and edit each individually. But it's rather uncommon (and probably not very useful) to want independent control over each blend. In this release, there is 1 central Blend Simulation attribute on the root dynamic control. This can be changed in the Options, but will probably disappear unless someone says they like it and wants to keep it! Smart Tip Length Previously, Ragdoll wasn't able to figure out how long to make the last control. Now it borrows length, radius and orientation from the parent capsule, which should be what you expect for the majority of cases. Meaning you can now expect this. Before After You can change the shape type after creation, and modify the default value in the options dialog. Transparent Root The first selection of a dynamic control chain is passive, and it used to also collide with the first child. But, most of the time, that root isn't useful as a collider. It would be a global hip control or some particular shoulder/clavicle gizmo. So the root is now set to Collide = False , meaning this is now ok. You can still enable it afterwards if you'd like. Convert and Restore I've merge the Convert Rigid and Convert Constraint buttons into the rigid and constraint creation buttons. Convert Rigid Turn a passive into an active rigid, or vice versa. Select active rigid in viewport Click Passive to convert it into a passive rigid If it's already passive, nothing happens. If you wanted to make a passive rigid active, you know what to do. Convert Constraint Turn a Socket Constraint into a Hinge Constraint, or any other type, on-the-fly. Select any constraint Click Socket to turn it into a socket constraint, regardless of what it was Restore Constraint Sometimes you just want to start from scratch. And using the same convert feature you can also restore a constraint to its original settings. Select any constraint Click any constraint type Passive Grayscale Spot passive rigids by their colors, now all passive rigids are gray. That means.. Active rigids are multi-colored Passive rigids are gray Controls are blue Select All Sometimes you want to make bulk changes to all rigids or all constraints at once. You could select each of them, or you could turn to Python and say.. cmds . select ( cmds . ls ( type = \"rdRigid\" )) Now there's a menu item for it too! With nothing selected, it'll select all rigids or constraints With something selected, it'll filter that selection for just rigids or constraints That means you can either find everything all at once and make great big changes, or you can zone in on a particular hierarchy or character and affect all rigids or constraints in just that hierarchy! Fire Wolf rig courtesy of Truong CG Artist","title":"2021.01.15"},{"location":"releases/2021.01.15/#dynamic-control-30","text":"Another step forward for Dynamic Controls.","title":"Dynamic Control 3.0"},{"location":"releases/2021.01.15/#default-capsule","text":"Ragdoll now defaults to the newer Capsule shape type for dynamic controls. It's faster and applies more generally to most rigs; even those that do have NURBS curves wrapping around the underlying character geometry. Before After","title":"Default Capsule"},{"location":"releases/2021.01.15/#automatic-multiplier","text":"The previous release introduced Multiplier Nodes . This release add a multiplier to each new dynamic control chain per default, on the root control, which means you can now do stuff like this!","title":"Automatic Multiplier"},{"location":"releases/2021.01.15/#centralised-blend-simulation","text":"Previously, to blend between animation and simulation you needed to select the controls to blend and edit each individually. But it's rather uncommon (and probably not very useful) to want independent control over each blend. In this release, there is 1 central Blend Simulation attribute on the root dynamic control. This can be changed in the Options, but will probably disappear unless someone says they like it and wants to keep it!","title":"Centralised Blend Simulation"},{"location":"releases/2021.01.15/#smart-tip-length","text":"Previously, Ragdoll wasn't able to figure out how long to make the last control. Now it borrows length, radius and orientation from the parent capsule, which should be what you expect for the majority of cases. Meaning you can now expect this. Before After You can change the shape type after creation, and modify the default value in the options dialog.","title":"Smart Tip Length"},{"location":"releases/2021.01.15/#transparent-root","text":"The first selection of a dynamic control chain is passive, and it used to also collide with the first child. But, most of the time, that root isn't useful as a collider. It would be a global hip control or some particular shoulder/clavicle gizmo. So the root is now set to Collide = False , meaning this is now ok. You can still enable it afterwards if you'd like.","title":"Transparent Root"},{"location":"releases/2021.01.15/#convert-and-restore","text":"I've merge the Convert Rigid and Convert Constraint buttons into the rigid and constraint creation buttons.","title":"Convert and Restore"},{"location":"releases/2021.01.15/#convert-rigid","text":"Turn a passive into an active rigid, or vice versa. Select active rigid in viewport Click Passive to convert it into a passive rigid If it's already passive, nothing happens. If you wanted to make a passive rigid active, you know what to do.","title":"Convert Rigid"},{"location":"releases/2021.01.15/#convert-constraint","text":"Turn a Socket Constraint into a Hinge Constraint, or any other type, on-the-fly. Select any constraint Click Socket to turn it into a socket constraint, regardless of what it was","title":"Convert Constraint"},{"location":"releases/2021.01.15/#restore-constraint","text":"Sometimes you just want to start from scratch. And using the same convert feature you can also restore a constraint to its original settings. Select any constraint Click any constraint type","title":"Restore Constraint"},{"location":"releases/2021.01.15/#passive-grayscale","text":"Spot passive rigids by their colors, now all passive rigids are gray. That means.. Active rigids are multi-colored Passive rigids are gray Controls are blue","title":"Passive Grayscale"},{"location":"releases/2021.01.15/#select-all","text":"Sometimes you want to make bulk changes to all rigids or all constraints at once. You could select each of them, or you could turn to Python and say.. cmds . select ( cmds . ls ( type = \"rdRigid\" )) Now there's a menu item for it too! With nothing selected, it'll select all rigids or constraints With something selected, it'll filter that selection for just rigids or constraints That means you can either find everything all at once and make great big changes, or you can zone in on a particular hierarchy or character and affect all rigids or constraints in just that hierarchy! Fire Wolf rig courtesy of Truong CG Artist","title":"Select All"},{"location":"releases/2021.01.17/","text":"Minor maintenance release. FIXED userSetup.py More robust integration with some pipelines FIXED Two-chain Dynamic Control More able to deal with edge-cases userSetup The startup code for Ragdoll since 2021.01.14 didn't play well with other userSetup.py files, like the ones you might have in a major production pipeline. If you were having any issues with the os module, then this is the fix for you. Two-chain Dynamic Control The previous release made it possible for the last selected Dynamic Control to inherit its size and orientation from the previously selected control. This only worked if you have 3 controls selected. This release makes it work on just 2 controls!","title":"2021.01.17"},{"location":"releases/2021.01.17/#usersetup","text":"The startup code for Ragdoll since 2021.01.14 didn't play well with other userSetup.py files, like the ones you might have in a major production pipeline. If you were having any issues with the os module, then this is the fix for you.","title":"userSetup"},{"location":"releases/2021.01.17/#two-chain-dynamic-control","text":"The previous release made it possible for the last selected Dynamic Control to inherit its size and orientation from the previously selected control. This only worked if you have 3 controls selected. This release makes it work on just 2 controls!","title":"Two-chain Dynamic Control"},{"location":"releases/2021.01.27/","text":"Focus of this release is Solver Iterations , and some UI additions too! ADDED Message Board Greater visibility of warnings and errors ADDED Solver Iterations Trade performance for precision ADDED Help Line The Help Line now displays a summary of what menu items do ADDED Delete from Selection Trim your setup more accurately with this new addition FIXED Locked Channels Now able to simulate even the most locked channel! FIXED Multiple cmdx You're now able to have Ragdoll running in conjunction with cmdx and vendors of cmdx. ADDED Animated Initial State A more adaptive initial state ADDED Worldspace Dynamic Control Dynamic Controls.. now in wordspace! Message Board Ever opened the Script Editor to find Ragdoll screaming for help? I've added a new Message Board to help Ragdoll stand out from the overall messy or hidden messages from rigs and Maya and all else. Your goal then is to never have any messages appear in the Message Board. A silent Message Board means a happy simulation. :) Solver Iterations Anything called strength in Ragdoll is a multipler for stiffness and damping . And currently there's a ceiling to how high stiffness and damping values can go, after which point they just stop having an effect. The values are limited by how many \"iterations\" you let the solver perform. Per default, they are set to 8 and can be found at rdRigid.positionIterations . This release sheds some more light on this somewhat obscure attribute by exposing it directly on the solver, right next to Substeps . This value multiplies each rdRigid.positionIterations attribute, meaning a value of 2 yields a total iteration count for every rigid in the solver of 16 (i.e. 2 * 8 ). Which means you can now do this! You can further customise iteration counts per rigid, under the Advanced tab. There's no limit to how many iterations you can allow; more iterations means greater accuracy. However, I have found that values beyond 128 tend to get funky. Iteration Count Strength Range Description 8 (default) 0-5 Default, sensible for most uses 16 0-10 High 32 0-500 Really, really high 64 0-1000 Ultra Nightmare For completeness, here's how Iterations differ from Substeps . Substep Divide each frame into smaller time steps Iterations Number of times a constraint is \"resolved\" They both provide accuracy in slightly different ways. With a greater amount of substeps, the solver is effectively working in slow-motion. Everything is easier in slow-motion. Resolving constraints is independent of time and a little more technical to describe, so you can instead kind of think of it a little bit like rubbing dirt of a silver platter. The first rub, you'll get most of it off. But the more you rub, the shinier it gets. There's no limit to how much you can rub, but eventually rubbing will stop having a visible effect. Help Line Hovering over any menu item now reveals a short description of what it does in the native Maya Help Line (typically at the bottom of the Maya window). This is the same information as can be found in the Menu Reference . Delete From Selection The Delete All Physics menu-item has gotten an option box, now it can be used to limit deletion to currently selected nodes! Locked Channels The previous release would bark at you whenever trying to turn any transform dynamic if it had any of its translate or rotate channels locked. This was a problem when you didn't necessarily care for some of them. For example, with a dynamic control, you really only cared for the rotate channels but would be prevented from simulating them if the sibling translate channels were locked. No longer! That said, the simulation does still produce both translate and rotate values. There's no way around it. And locked channels cannot be connected or edited. Even though you might want to. If the transform is referenced, then there's nothing you can do. Warnings will be emitted (and made visible in the new Message Board!) if this happens, so it's still true that if your Message Board is silent, all is well. Multiple cmdx This should only really affect users of WeightShift, which also uses cmdx . The previous release was adamant on being the one and only physics solver for Maya. But it has now become more lenient and accepting of other lifestyle choices. :D Animated Initial State Heads up! This got removed. Stay tuned for a re-appearance in a later release In the previous release, you could animate your dynamic controls, but you couldn't change the initial pose unless you explicitly called Set Initial Pose from the Ragdoll | Rigging menu. With this release, you can! Limitations This currently only works reliably with strict FK control hierarchies. The animation is translated into an initial state, but in doing so we are effectively recreating the parent/child relationship between controls. And sometimes - perhaps a lot of times - this isn't a direct FK hierarchy. Here you can see how the physics and animation controls disagree on what the pose should be. The animation controls aren't in a hierarchy, they are constrained in a complex manner. It isn't accurately reproduced in the initial state. So if you notice your the simulated initial state to differ from the first pose of your animation, it's the best you can get at the moment. Worldspace Dynamic Control Heads up! This got removed. Stay tuned for a re-appearance in a later release Guide forces in dynamic controls are all local . Which means it'll maintain a pose, even if that pose is upside down or sideways. And since many versions ago, you've been able to append these \"Guide\" controls, that are in worldspace (per default). These look at the worldspace position and rotation of the control, and use that to line up the simulation. Much like IK! Now these are built-in to each Dynamic Control (toggle in the option dialog). These can help keep a character closer to an animated pose. But they are \"cheats\". Forces that appear out of nowhere, as opposed to the local forces which behave like muscles. Muscles can tense and relax whilst still appearing natural, but these are not natural. You can however use them to fake natural. One more thing; world spaces have strength in either translation or rotation, or both. A worldspace rotation could for example keep a head facing a certain direction, not unlike how IK works. Except physical! Limitations This feature uses the same \"virtual hierarchy\" as the animated initial state and suffers from the same limitations.","title":"2021.01.27"},{"location":"releases/2021.01.27/#message-board","text":"Ever opened the Script Editor to find Ragdoll screaming for help? I've added a new Message Board to help Ragdoll stand out from the overall messy or hidden messages from rigs and Maya and all else. Your goal then is to never have any messages appear in the Message Board. A silent Message Board means a happy simulation. :)","title":"Message Board"},{"location":"releases/2021.01.27/#solver-iterations","text":"Anything called strength in Ragdoll is a multipler for stiffness and damping . And currently there's a ceiling to how high stiffness and damping values can go, after which point they just stop having an effect. The values are limited by how many \"iterations\" you let the solver perform. Per default, they are set to 8 and can be found at rdRigid.positionIterations . This release sheds some more light on this somewhat obscure attribute by exposing it directly on the solver, right next to Substeps . This value multiplies each rdRigid.positionIterations attribute, meaning a value of 2 yields a total iteration count for every rigid in the solver of 16 (i.e. 2 * 8 ). Which means you can now do this! You can further customise iteration counts per rigid, under the Advanced tab. There's no limit to how many iterations you can allow; more iterations means greater accuracy. However, I have found that values beyond 128 tend to get funky. Iteration Count Strength Range Description 8 (default) 0-5 Default, sensible for most uses 16 0-10 High 32 0-500 Really, really high 64 0-1000 Ultra Nightmare For completeness, here's how Iterations differ from Substeps . Substep Divide each frame into smaller time steps Iterations Number of times a constraint is \"resolved\" They both provide accuracy in slightly different ways. With a greater amount of substeps, the solver is effectively working in slow-motion. Everything is easier in slow-motion. Resolving constraints is independent of time and a little more technical to describe, so you can instead kind of think of it a little bit like rubbing dirt of a silver platter. The first rub, you'll get most of it off. But the more you rub, the shinier it gets. There's no limit to how much you can rub, but eventually rubbing will stop having a visible effect.","title":"Solver Iterations"},{"location":"releases/2021.01.27/#help-line","text":"Hovering over any menu item now reveals a short description of what it does in the native Maya Help Line (typically at the bottom of the Maya window). This is the same information as can be found in the Menu Reference .","title":"Help Line"},{"location":"releases/2021.01.27/#delete-from-selection","text":"The Delete All Physics menu-item has gotten an option box, now it can be used to limit deletion to currently selected nodes!","title":"Delete From Selection"},{"location":"releases/2021.01.27/#locked-channels","text":"The previous release would bark at you whenever trying to turn any transform dynamic if it had any of its translate or rotate channels locked. This was a problem when you didn't necessarily care for some of them. For example, with a dynamic control, you really only cared for the rotate channels but would be prevented from simulating them if the sibling translate channels were locked. No longer! That said, the simulation does still produce both translate and rotate values. There's no way around it. And locked channels cannot be connected or edited. Even though you might want to. If the transform is referenced, then there's nothing you can do. Warnings will be emitted (and made visible in the new Message Board!) if this happens, so it's still true that if your Message Board is silent, all is well.","title":"Locked Channels"},{"location":"releases/2021.01.27/#multiple-cmdx","text":"This should only really affect users of WeightShift, which also uses cmdx . The previous release was adamant on being the one and only physics solver for Maya. But it has now become more lenient and accepting of other lifestyle choices. :D","title":"Multiple cmdx"},{"location":"releases/2021.01.27/#animated-initial-state","text":"Heads up! This got removed. Stay tuned for a re-appearance in a later release In the previous release, you could animate your dynamic controls, but you couldn't change the initial pose unless you explicitly called Set Initial Pose from the Ragdoll | Rigging menu. With this release, you can! Limitations This currently only works reliably with strict FK control hierarchies. The animation is translated into an initial state, but in doing so we are effectively recreating the parent/child relationship between controls. And sometimes - perhaps a lot of times - this isn't a direct FK hierarchy. Here you can see how the physics and animation controls disagree on what the pose should be. The animation controls aren't in a hierarchy, they are constrained in a complex manner. It isn't accurately reproduced in the initial state. So if you notice your the simulated initial state to differ from the first pose of your animation, it's the best you can get at the moment.","title":"Animated Initial State"},{"location":"releases/2021.01.27/#worldspace-dynamic-control","text":"Heads up! This got removed. Stay tuned for a re-appearance in a later release Guide forces in dynamic controls are all local . Which means it'll maintain a pose, even if that pose is upside down or sideways. And since many versions ago, you've been able to append these \"Guide\" controls, that are in worldspace (per default). These look at the worldspace position and rotation of the control, and use that to line up the simulation. Much like IK! Now these are built-in to each Dynamic Control (toggle in the option dialog). These can help keep a character closer to an animated pose. But they are \"cheats\". Forces that appear out of nowhere, as opposed to the local forces which behave like muscles. Muscles can tense and relax whilst still appearing natural, but these are not natural. You can however use them to fake natural. One more thing; world spaces have strength in either translation or rotation, or both. A worldspace rotation could for example keep a head facing a certain direction, not unlike how IK works. Except physical! Limitations This feature uses the same \"virtual hierarchy\" as the animated initial state and suffers from the same limitations.","title":"Worldspace Dynamic Control"},{"location":"releases/2021.02.07/","text":"Highlight of this release is Support for Scale ! ADDED Support for Scale Ragdoll now works on scaled geometry and controls ADDED Support for NURBS Surfaces This hip new thing popularised in the 90s is now yours to reap! ADDED Visualise Output Attributes Gain insight into what comes out of the solver FIXED Zombie Attributes Delete All Physics didn't quite catch'em all Scale This has been an epic challenge , but it finally happened! Up till now, any scale other than (1, 1, 1) at any level of a hierarchy would have either broken a simulation or refused to work outright. Not anymore! Now you can simulate scaled transforms , including scaled rigs and all of what it entails. Here's a brief on what works and what doesn't. Feature Example \u2714\ufe0f Uniform Scale 1.5, 1.5, 1.5 \u2714\ufe0f Non-uniform Scale 0.5, 0.6, 0.12 \u2714\ufe0f Scaled parent(s) Scaled root control \u2714\ufe0f Mixed Scale & Constraints Scaled box to differently-scaled capsule \u2796 Zero Scale 0.0, 0.0, 0.0 \u2796 Mixed Zero Scale 1.0, 0.0, 1.0 \u2796 Negative Scale -1.5, -1.5, -1.5 \u2796 Mixed Positive/Negative Scale 0.9, -1.5, -1.1 \u2796 Non-uniform Negative Scale -1.0, 1.0, -2.0 \u274c Non Object-Space Scale Scale in World mode There are a few caveats. Avoid negative scale if possible, it works but can surprise you Negative non-uniform scale is more common, e.g. to mirror something across the X-axis, and may work but may surprise you Non object-space scale flat-out doesn't work, not even Maya can do that; it's here for completeness. Scale cannot be animated Scale is set on the start frame, and is part of the Initial State. It is also updated alongside the translate/rotate initial state. Negative Scale Commonly found in parent hierarchies that attempt to mirror the behavior of a control or hierarchy of controls. I'd like to better support this, but it is currently limited by math. More specifically, in that a transformation matrix simply cannot distinguish between negative and positive scale. So this one is semi-supported . The problem is for Ragdoll to distinguish between scale and rotation. It's a bit mathy, but you know how you can achieve the same pose by either scaling something negatively or rotate it 180 degrees along one or more axes? Ragdoll currently cannot know which of the possible outcomes you wanted. Here's a visual to help illustrate this point. ( Reference ) Here's what can happen in practice. Notice how both the scale and rotation values changed, even though the object in the viewport remains in the same orientation. That's because these values are both correct scale and orientation for this particular transform. You might think.. Well, whatever. So long as it's oriented right, why should I care? Well, what if you had animated a realistically looking horse locomotion, rotating around the X-axis ? Did you spot it? Both X and Z got their scale neutralised and X got 180 degrees steeper, compensating for the neutralised scale values. Also Z got flipped too! You can work around it, by accepting the new Z and offsetting your animation by 180 degrees. There's also the issue with it flying off for the first few frames. It's unclear why this happens, this may be a bug in the solver itself, trying to reconcile an orientation that is 180 degrees wrong. So, negative scale works, but it's painful. Avoid if possible. Zero Scale This is \"supported\" in that it doesn't fatal crash your Maya session. Ragdoll is a 3D solver, it cannot operate on anything without volume and mass. Here's an example of what to expect should you find the need for zero scale. Scaled Rotation TLDR; if you animate something from 0-45 degrees, it will rotate 45 degrees, regardless of scale. This should be what you expect and won't need remembering, but for completeness here's what happening under the hood. Ragdoll strips scale from most internal computations. It's kept mostly so that it can be outputted again, as well as for rendering. See, custom Maya nodes render in the space of the transform. So rendering a point at coordinate (0, 0, 0) ends up in the middle of the transform node. Even as you move that transform around with the translate tool. That's problematic if you need to draw something uniformly, like the limits and drive visualisations. Even more so when you attempt to draw a line from one transform to another.. at different scales! But stripping it early is beneficial for both readability of code, but also usability for you. Uniform scale normally doesn't affect rotation, but non-uniform scale could. Consider this. Here, we've got a single angle of 45 degrees. If you were to scale this horizontally, you can see how the angle now changes! At a scale of 0, the angle has gone from 45 degrees to 90 degrees. This complicates things a lot, and Ragdoll saves you from that by not taking non-uniform scale into consideration for its rotations. A 45 degree angle will remain 45 degree regardless of scale; with the exception of negative scales which still flip the angle as you'd expect. Non Object-Space Scale You probably don't do this, but for completeness here's what doesn't work. NURBS Surfaces Ragdoll could translate polygon meshes and NURBS curves into collision meshes, and today I'm happy to announce that it now also supports the latest trend in computer graphics, heavily used in the 90s at Dreamworks for critically acclaimed feature animation films Antz and Shark Tale. Join the future! Output Attributes The Attribute Editor now displays the output translate, rotate and scale attributes from each rigid body. In both local and world space coordinates. These are the values that feed into your animation control, or any transform you're simulating. Zombie Attributes Minor bug fix. The Delete All Physics menu item didn't catch the last remaining Local Strength attribute created by Create Dynamic Control . This is all patched up!","title":"2021.02.07"},{"location":"releases/2021.02.07/#scale","text":"This has been an epic challenge , but it finally happened! Up till now, any scale other than (1, 1, 1) at any level of a hierarchy would have either broken a simulation or refused to work outright. Not anymore! Now you can simulate scaled transforms , including scaled rigs and all of what it entails. Here's a brief on what works and what doesn't. Feature Example \u2714\ufe0f Uniform Scale 1.5, 1.5, 1.5 \u2714\ufe0f Non-uniform Scale 0.5, 0.6, 0.12 \u2714\ufe0f Scaled parent(s) Scaled root control \u2714\ufe0f Mixed Scale & Constraints Scaled box to differently-scaled capsule \u2796 Zero Scale 0.0, 0.0, 0.0 \u2796 Mixed Zero Scale 1.0, 0.0, 1.0 \u2796 Negative Scale -1.5, -1.5, -1.5 \u2796 Mixed Positive/Negative Scale 0.9, -1.5, -1.1 \u2796 Non-uniform Negative Scale -1.0, 1.0, -2.0 \u274c Non Object-Space Scale Scale in World mode There are a few caveats. Avoid negative scale if possible, it works but can surprise you Negative non-uniform scale is more common, e.g. to mirror something across the X-axis, and may work but may surprise you Non object-space scale flat-out doesn't work, not even Maya can do that; it's here for completeness. Scale cannot be animated Scale is set on the start frame, and is part of the Initial State. It is also updated alongside the translate/rotate initial state.","title":"Scale"},{"location":"releases/2021.02.07/#negative-scale","text":"Commonly found in parent hierarchies that attempt to mirror the behavior of a control or hierarchy of controls. I'd like to better support this, but it is currently limited by math. More specifically, in that a transformation matrix simply cannot distinguish between negative and positive scale. So this one is semi-supported . The problem is for Ragdoll to distinguish between scale and rotation. It's a bit mathy, but you know how you can achieve the same pose by either scaling something negatively or rotate it 180 degrees along one or more axes? Ragdoll currently cannot know which of the possible outcomes you wanted. Here's a visual to help illustrate this point. ( Reference ) Here's what can happen in practice. Notice how both the scale and rotation values changed, even though the object in the viewport remains in the same orientation. That's because these values are both correct scale and orientation for this particular transform. You might think.. Well, whatever. So long as it's oriented right, why should I care? Well, what if you had animated a realistically looking horse locomotion, rotating around the X-axis ? Did you spot it? Both X and Z got their scale neutralised and X got 180 degrees steeper, compensating for the neutralised scale values. Also Z got flipped too! You can work around it, by accepting the new Z and offsetting your animation by 180 degrees. There's also the issue with it flying off for the first few frames. It's unclear why this happens, this may be a bug in the solver itself, trying to reconcile an orientation that is 180 degrees wrong. So, negative scale works, but it's painful. Avoid if possible.","title":"Negative Scale"},{"location":"releases/2021.02.07/#zero-scale","text":"This is \"supported\" in that it doesn't fatal crash your Maya session. Ragdoll is a 3D solver, it cannot operate on anything without volume and mass. Here's an example of what to expect should you find the need for zero scale.","title":"Zero Scale"},{"location":"releases/2021.02.07/#scaled-rotation","text":"TLDR; if you animate something from 0-45 degrees, it will rotate 45 degrees, regardless of scale. This should be what you expect and won't need remembering, but for completeness here's what happening under the hood. Ragdoll strips scale from most internal computations. It's kept mostly so that it can be outputted again, as well as for rendering. See, custom Maya nodes render in the space of the transform. So rendering a point at coordinate (0, 0, 0) ends up in the middle of the transform node. Even as you move that transform around with the translate tool. That's problematic if you need to draw something uniformly, like the limits and drive visualisations. Even more so when you attempt to draw a line from one transform to another.. at different scales! But stripping it early is beneficial for both readability of code, but also usability for you. Uniform scale normally doesn't affect rotation, but non-uniform scale could. Consider this. Here, we've got a single angle of 45 degrees. If you were to scale this horizontally, you can see how the angle now changes! At a scale of 0, the angle has gone from 45 degrees to 90 degrees. This complicates things a lot, and Ragdoll saves you from that by not taking non-uniform scale into consideration for its rotations. A 45 degree angle will remain 45 degree regardless of scale; with the exception of negative scales which still flip the angle as you'd expect.","title":"Scaled Rotation"},{"location":"releases/2021.02.07/#non-object-space-scale","text":"You probably don't do this, but for completeness here's what doesn't work.","title":"Non Object-Space Scale"},{"location":"releases/2021.02.07/#nurbs-surfaces","text":"Ragdoll could translate polygon meshes and NURBS curves into collision meshes, and today I'm happy to announce that it now also supports the latest trend in computer graphics, heavily used in the 90s at Dreamworks for critically acclaimed feature animation films Antz and Shark Tale. Join the future!","title":"NURBS Surfaces"},{"location":"releases/2021.02.07/#output-attributes","text":"The Attribute Editor now displays the output translate, rotate and scale attributes from each rigid body. In both local and world space coordinates. These are the values that feed into your animation control, or any transform you're simulating.","title":"Output Attributes"},{"location":"releases/2021.02.07/#zombie-attributes","text":"Minor bug fix. The Delete All Physics menu item didn't catch the last remaining Local Strength attribute created by Create Dynamic Control . This is all patched up!","title":"Zombie Attributes"},{"location":"releases/2021.03.01/","text":"It's been an epic month of problem-solving, but it finally happened. :D Highlight for this release is.. drumroll.. Automatic Initial State ! ADDED Auto Initial State Start simulating in whatever pose your character is in ADDED Hierarchy Preservation Moving parents around now correctly moves children ADDED Worldspace Constraints Animate in both local- and world-space FIXED DG Viewport Bug Fix for rare cases of viewport going out of sync FIXED Unload plug-in The Ragdoll plug-in can now be loaded and unloaded using the native Maya plug-in manager ADDED New Commands Developer candy, return a JSON of physics for export and import into another application, like Unreal, Motion Builder or Blender! Tiger Rig courtesy of www.cgspectrum.com Auto Initial State Have you ever used the Set Initial State button? It's useful, isn't it? It's what enables you to turn something dynamic but then change your mind about where it should start simulating. With this release, that process is automatic! It's more or less what you expected would happen anyway. I mean, obviously the box should drop from where you left it, rather than where it was originally turned dynamic? Disable Feature If you would rather have none of it, or if it gives you trouble, you can switch it off like this. NOTE: Changes take effect on next scene open and newly created rigids. Parallel Only That's right, automatic initial state will only work in Maya's Parallel Evaluation mode. It may end up getting support for DG later on, the trouble lies in the callback we use to read an edited initial state is not reliable in DG. It's possible we'll find another means of achieving the same goal in the future, although DG really is part of the past. Ragdoll works best under Parallel for other reasons too; primarily performance but also stability and robustness. Constraints Stay Behind Constraints currently show you the true position of rigid bodies. They stay behind because hierarchy preservation is \"artificial\". It's just for you and Maya. In a later release, I'll make rigids also stay behind, and only have your controls move with hierarchy, so that you get to visualise where rigid bodies really are (even when your controls have locked channels, like translate) whilst at the same time letting you move and see your controls and how they reflect that true position. Caveat There's one known \"gotcha\" with the automated initial state. Namely, the initial state is \"recorded\" whenever you transition from the start time to the next frame. Evaluation on the next frame will automatically read whatever was evaluated previously, and store that as the initial state. However! It is possible to trigger evaluation without actually changing time. Maya loves doing that. You can do it by either scrubbing the timeline, or holding K and dragging (effectively scrubbing) the viewport. As you scrub, even if time isn't actually changing, Maya will go ahead and re-evaluated the time. When that happens, it won't actually record a new initial state, but instead restore the original value. Something to be aware of. Journey For the technically inclined, here you can witness last month's struggle first hand and all the kinks uncovered in Maya's API and evaluation graph. Hierarchy Preservation Like in the real world, physics happens in worldspace. There are no \"children\" and no \"parents\". As a result, as soon as you turn any of your controls dynamic, they start acting that way. But we don't want that. With this release, you'll now get realism along with that familiar feeling of having children and being a parent! Before After Caveat There is one known case to be aware of when it comes to children. Passive Rigids Hierarchy is currently preserved only if a rigid is active . The reason being.. well, I'll just show you. In this case, the passive rigid bodies are driven by an external transform, those blue \"controls\". Hierarchy is coming from the blue rigids, so we wouldn't want the passive rigids to mess with that. But now when we move the rigids themselves (gray, in this example) we aren't getting our hierarchy preservation.. :( At the other extreme, if we do account for hierarchy then the problem pops up at the other end instead. I trust experience and feedback will light the way here for a more intuitive experience working with external controls. Worldspace Constraints If you thought automatic initial state was enough, think again! If your controls have animation already applied, Ragdoll will now translate it into physics in world- and local-space. Default Behavior Local animation, like a rotated arm, are imbued with a \"local constraint\" to preserve the relative angle between it and its parent. World animation, like in this case where there is no parent, get imbued with a \"world constraint\". World Only Here's what you get when constraining the child to its worldspace pose. Notice how it assumes the angle you give it regardless of whatever the parent is doing. Local Only Conversely, with just the local constraint, it'll assume the relative angle and respects its parent. World + Local Things get interesting when you combine the two! World + World + Local ..or combine the three! Here's the lower arm trying to adhere to both its worldspace and local orientation. Notice the constraint coming out of alignment at the root; the constraints are of equal strength per default so it'll end up averaging the desired poses. There's one more thing happening here that I'll touch on in an upcoming release, which is the concept of world space forces. Notice how the joint chain follows animation DG Viewport Bug If you've ever had the viewport \"remember\" old frames as you scrub the timeline, this fix is for you. Unload Plug-in In the previous release, licencing was implemented as a Python binding. The trouble with compiled Python bindings in Maya is that they cannot be unloaded. As a result, Ragdoll could not be unloaded. Licencing is now implemented as a native Maya command, accessible as ragdollLicence from MEL and cmds.ragdollLicence() from Python. See ragdollLicence below New Commands Three new commands was added in this release, they are primarily intended for TDs and technically minded folk. cmds.ragdollLicence() cmds.ragdollPeek() cmds.ragdollDump() cmds.ragdollLicence Synopsis : ragdollLicence [ flags ] Flags : - q - query - a - activate String - d - deactivate - h - help - i - init - ia - isActivated - ig - isGenuine - it - isTrial - iv - isVerified - md - magicDays - r - reverify - s - serial - td - trialDays You still typically interact with ragdoll.licence , as documented here . But under the hood, this is now the native Maya command being called. from maya import cmds cmds . ragdollLicence ( serial = True , query = True ) # Your-Serial-Number-Here cmds.ragdollPeek Synopsis : ragdollPeek [ flags ] Flags : - e - entity UnsignedInt - h - help - ps - physicsStatistics - ss - sceneStatistics Gain insight into what Maya sees in Ragdoll. cmds . ragdollPeek ( sceneStatistics = True ) # Ragdoll Peek Scene ____________ ___________________________ _______________ | Id | Scene | Name | |------------|---------------------------|---------------| | 71 | rSceneShape | rSceneShape | | 70 | rSceneShape | rRigid18 | | 69 | rSceneShape | rRigid17 | | 67 | rSceneShape | rRigid | | 65 | rSceneShape | rRigid7 | | 63 | rSceneShape | rRigid8 | | 61 | rSceneShape | rRigid14 | | 59 | rSceneShape | rRigid15 | | 57 | rSceneShape | rRigid16 | | 55 | rSceneShape | rRigid11 | | 53 | rSceneShape | rRigid12 | | 51 | rSceneShape | rRigid13 | | 49 | rSceneShape | rRigid9 | | 46 | rSceneShape | rRigid10 | | 44 | rSceneShape | rRigid4 | | 42 | rSceneShape | rRigid5 | | 40 | rSceneShape | rRigid6 | | 38 | rSceneShape | rRigid1 | | 36 | rSceneShape | rRigid2 | | 34 | rSceneShape | rRigid3 | | 15 | rSceneShape | rRigid27 | | 14 | rSceneShape | rRigid28 | | 13 | rSceneShape | rRigid29 | | 12 | rSceneShape | rRigid30 | | 11 | rSceneShape | rRigid31 | | 10 | rSceneShape | rRigid32 | | 9 | rSceneShape | rRigid33 | | 8 | rSceneShape | rRigid34 | | 7 | rSceneShape | rRigid19 | | 6 | rSceneShape | rRigid20 | | 5 | rSceneShape | rRigid21 | | 4 | rSceneShape | rRigid22 | | 3 | rSceneShape | rRigid23 | | 1048576 | rSceneShape | rRigid24 | | 1048578 | rSceneShape | rRigid25 | | 1048577 | rSceneShape | rRigid26 | | ____________ | ___________________________ | _______________ | cmds . ragdollPeek ( physicsStatistics = True ) # Ragdoll Peek Solver - Number of scenes : 1 - Number of shapes : 36 - Number of materials : 36 - Number of convex meshes : 0 - scene [ 71 ] - Number of dynamic actors : 35 - Number of static actors : 1 - Number of constraints : 18 # cmds.ragdollDump Synopsis : ragdollDump - h - help This is more of a teaser of what's to come, but let me tell you about it for completeness of these release notes. ragdollDumps is the start of an integration effort of Ragdoll into any and all external software, like Unreal and Blender. Anything able to parse JSON. Including web-applications. What if you could rig and/or animate in Maya, but then export the physics setup into e.g. Unreal? I'm not talking about baking your animation and playing it back somewhere else. But of exporting the internal physics objects from Ragdoll, translating them to whatever the third-party software uses for physics, and re-using it there! With that, you could bypass all of the horrible authoring tools of those applications and transfer a physics scene or setup across applications. Later, you'll be able to load these into a standalone Ragdoll desktop and web-based application. Useful for sharing your creations and animations with others, and for debugging too! import json from maya import cmds cmds . ragdollDump () # { # \"scenes\": { # \"0\": { # \"id\": 0, # \"name\": \"rSceneShape\", # \"entities\": { # \"0\": { # \"id\": 0, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rSceneShape\" # } # } # } # }, # \"1\": { # \"id\": 1, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rRigid\" # } # } # } # }, # \"2\": { # \"id\": 2, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rGuideConstraint\" # } # } # } # } # } # } # } # } Turn this string into json, with the native Python json module. import json from maya import cmds dump = cmds . ragdollDump () dump = json . loads ( dump ) # From string to dictionary # The format is internal and yet to be documented, stay tuned scene = dump [ \"scenes\" ][ \"0\" ] rigid = scene [ \"entities\" ][ \"1\" ] name = rigid [ \"components\" ][ \"NameComponent\" ][ \"members\" ][ \"value\" ] print ( name ) # rRigid Expect the output to grow throughout later releases as more internals get serialised to JSON.","title":"2021.03.01"},{"location":"releases/2021.03.01/#auto-initial-state","text":"Have you ever used the Set Initial State button? It's useful, isn't it? It's what enables you to turn something dynamic but then change your mind about where it should start simulating. With this release, that process is automatic! It's more or less what you expected would happen anyway. I mean, obviously the box should drop from where you left it, rather than where it was originally turned dynamic?","title":"Auto Initial State"},{"location":"releases/2021.03.01/#disable-feature","text":"If you would rather have none of it, or if it gives you trouble, you can switch it off like this. NOTE: Changes take effect on next scene open and newly created rigids.","title":"Disable Feature"},{"location":"releases/2021.03.01/#parallel-only","text":"That's right, automatic initial state will only work in Maya's Parallel Evaluation mode. It may end up getting support for DG later on, the trouble lies in the callback we use to read an edited initial state is not reliable in DG. It's possible we'll find another means of achieving the same goal in the future, although DG really is part of the past. Ragdoll works best under Parallel for other reasons too; primarily performance but also stability and robustness.","title":"Parallel Only"},{"location":"releases/2021.03.01/#constraints-stay-behind","text":"Constraints currently show you the true position of rigid bodies. They stay behind because hierarchy preservation is \"artificial\". It's just for you and Maya. In a later release, I'll make rigids also stay behind, and only have your controls move with hierarchy, so that you get to visualise where rigid bodies really are (even when your controls have locked channels, like translate) whilst at the same time letting you move and see your controls and how they reflect that true position.","title":"Constraints Stay Behind"},{"location":"releases/2021.03.01/#caveat","text":"There's one known \"gotcha\" with the automated initial state. Namely, the initial state is \"recorded\" whenever you transition from the start time to the next frame. Evaluation on the next frame will automatically read whatever was evaluated previously, and store that as the initial state. However! It is possible to trigger evaluation without actually changing time. Maya loves doing that. You can do it by either scrubbing the timeline, or holding K and dragging (effectively scrubbing) the viewport. As you scrub, even if time isn't actually changing, Maya will go ahead and re-evaluated the time. When that happens, it won't actually record a new initial state, but instead restore the original value. Something to be aware of.","title":"Caveat"},{"location":"releases/2021.03.01/#journey","text":"For the technically inclined, here you can witness last month's struggle first hand and all the kinks uncovered in Maya's API and evaluation graph.","title":"Journey"},{"location":"releases/2021.03.01/#hierarchy-preservation","text":"Like in the real world, physics happens in worldspace. There are no \"children\" and no \"parents\". As a result, as soon as you turn any of your controls dynamic, they start acting that way. But we don't want that. With this release, you'll now get realism along with that familiar feeling of having children and being a parent! Before After","title":"Hierarchy Preservation"},{"location":"releases/2021.03.01/#caveat_1","text":"There is one known case to be aware of when it comes to children. Passive Rigids Hierarchy is currently preserved only if a rigid is active . The reason being.. well, I'll just show you. In this case, the passive rigid bodies are driven by an external transform, those blue \"controls\". Hierarchy is coming from the blue rigids, so we wouldn't want the passive rigids to mess with that. But now when we move the rigids themselves (gray, in this example) we aren't getting our hierarchy preservation.. :( At the other extreme, if we do account for hierarchy then the problem pops up at the other end instead. I trust experience and feedback will light the way here for a more intuitive experience working with external controls.","title":"Caveat"},{"location":"releases/2021.03.01/#worldspace-constraints","text":"If you thought automatic initial state was enough, think again! If your controls have animation already applied, Ragdoll will now translate it into physics in world- and local-space.","title":"Worldspace Constraints"},{"location":"releases/2021.03.01/#default-behavior","text":"Local animation, like a rotated arm, are imbued with a \"local constraint\" to preserve the relative angle between it and its parent. World animation, like in this case where there is no parent, get imbued with a \"world constraint\".","title":"Default Behavior"},{"location":"releases/2021.03.01/#world-only","text":"Here's what you get when constraining the child to its worldspace pose. Notice how it assumes the angle you give it regardless of whatever the parent is doing.","title":"World Only"},{"location":"releases/2021.03.01/#local-only","text":"Conversely, with just the local constraint, it'll assume the relative angle and respects its parent.","title":"Local Only"},{"location":"releases/2021.03.01/#world-local","text":"Things get interesting when you combine the two!","title":"World + Local"},{"location":"releases/2021.03.01/#world-world-local","text":"..or combine the three! Here's the lower arm trying to adhere to both its worldspace and local orientation. Notice the constraint coming out of alignment at the root; the constraints are of equal strength per default so it'll end up averaging the desired poses. There's one more thing happening here that I'll touch on in an upcoming release, which is the concept of world space forces. Notice how the joint chain follows animation","title":"World + World + Local"},{"location":"releases/2021.03.01/#dg-viewport-bug","text":"If you've ever had the viewport \"remember\" old frames as you scrub the timeline, this fix is for you.","title":"DG Viewport Bug"},{"location":"releases/2021.03.01/#unload-plug-in","text":"In the previous release, licencing was implemented as a Python binding. The trouble with compiled Python bindings in Maya is that they cannot be unloaded. As a result, Ragdoll could not be unloaded. Licencing is now implemented as a native Maya command, accessible as ragdollLicence from MEL and cmds.ragdollLicence() from Python. See ragdollLicence below","title":"Unload Plug-in"},{"location":"releases/2021.03.01/#new-commands","text":"Three new commands was added in this release, they are primarily intended for TDs and technically minded folk. cmds.ragdollLicence() cmds.ragdollPeek() cmds.ragdollDump()","title":"New Commands"},{"location":"releases/2021.03.01/#cmdsragdolllicence","text":"Synopsis : ragdollLicence [ flags ] Flags : - q - query - a - activate String - d - deactivate - h - help - i - init - ia - isActivated - ig - isGenuine - it - isTrial - iv - isVerified - md - magicDays - r - reverify - s - serial - td - trialDays You still typically interact with ragdoll.licence , as documented here . But under the hood, this is now the native Maya command being called. from maya import cmds cmds . ragdollLicence ( serial = True , query = True ) # Your-Serial-Number-Here","title":"cmds.ragdollLicence"},{"location":"releases/2021.03.01/#cmdsragdollpeek","text":"Synopsis : ragdollPeek [ flags ] Flags : - e - entity UnsignedInt - h - help - ps - physicsStatistics - ss - sceneStatistics Gain insight into what Maya sees in Ragdoll. cmds . ragdollPeek ( sceneStatistics = True ) # Ragdoll Peek Scene ____________ ___________________________ _______________ | Id | Scene | Name | |------------|---------------------------|---------------| | 71 | rSceneShape | rSceneShape | | 70 | rSceneShape | rRigid18 | | 69 | rSceneShape | rRigid17 | | 67 | rSceneShape | rRigid | | 65 | rSceneShape | rRigid7 | | 63 | rSceneShape | rRigid8 | | 61 | rSceneShape | rRigid14 | | 59 | rSceneShape | rRigid15 | | 57 | rSceneShape | rRigid16 | | 55 | rSceneShape | rRigid11 | | 53 | rSceneShape | rRigid12 | | 51 | rSceneShape | rRigid13 | | 49 | rSceneShape | rRigid9 | | 46 | rSceneShape | rRigid10 | | 44 | rSceneShape | rRigid4 | | 42 | rSceneShape | rRigid5 | | 40 | rSceneShape | rRigid6 | | 38 | rSceneShape | rRigid1 | | 36 | rSceneShape | rRigid2 | | 34 | rSceneShape | rRigid3 | | 15 | rSceneShape | rRigid27 | | 14 | rSceneShape | rRigid28 | | 13 | rSceneShape | rRigid29 | | 12 | rSceneShape | rRigid30 | | 11 | rSceneShape | rRigid31 | | 10 | rSceneShape | rRigid32 | | 9 | rSceneShape | rRigid33 | | 8 | rSceneShape | rRigid34 | | 7 | rSceneShape | rRigid19 | | 6 | rSceneShape | rRigid20 | | 5 | rSceneShape | rRigid21 | | 4 | rSceneShape | rRigid22 | | 3 | rSceneShape | rRigid23 | | 1048576 | rSceneShape | rRigid24 | | 1048578 | rSceneShape | rRigid25 | | 1048577 | rSceneShape | rRigid26 | | ____________ | ___________________________ | _______________ | cmds . ragdollPeek ( physicsStatistics = True ) # Ragdoll Peek Solver - Number of scenes : 1 - Number of shapes : 36 - Number of materials : 36 - Number of convex meshes : 0 - scene [ 71 ] - Number of dynamic actors : 35 - Number of static actors : 1 - Number of constraints : 18 #","title":"cmds.ragdollPeek"},{"location":"releases/2021.03.01/#cmdsragdolldump","text":"Synopsis : ragdollDump - h - help This is more of a teaser of what's to come, but let me tell you about it for completeness of these release notes. ragdollDumps is the start of an integration effort of Ragdoll into any and all external software, like Unreal and Blender. Anything able to parse JSON. Including web-applications. What if you could rig and/or animate in Maya, but then export the physics setup into e.g. Unreal? I'm not talking about baking your animation and playing it back somewhere else. But of exporting the internal physics objects from Ragdoll, translating them to whatever the third-party software uses for physics, and re-using it there! With that, you could bypass all of the horrible authoring tools of those applications and transfer a physics scene or setup across applications. Later, you'll be able to load these into a standalone Ragdoll desktop and web-based application. Useful for sharing your creations and animations with others, and for debugging too! import json from maya import cmds cmds . ragdollDump () # { # \"scenes\": { # \"0\": { # \"id\": 0, # \"name\": \"rSceneShape\", # \"entities\": { # \"0\": { # \"id\": 0, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rSceneShape\" # } # } # } # }, # \"1\": { # \"id\": 1, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rRigid\" # } # } # } # }, # \"2\": { # \"id\": 2, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rGuideConstraint\" # } # } # } # } # } # } # } # } Turn this string into json, with the native Python json module. import json from maya import cmds dump = cmds . ragdollDump () dump = json . loads ( dump ) # From string to dictionary # The format is internal and yet to be documented, stay tuned scene = dump [ \"scenes\" ][ \"0\" ] rigid = scene [ \"entities\" ][ \"1\" ] name = rigid [ \"components\" ][ \"NameComponent\" ][ \"members\" ][ \"value\" ] print ( name ) # rRigid Expect the output to grow throughout later releases as more internals get serialised to JSON.","title":"cmds.ragdollDump"},{"location":"releases/next/","text":"Highlight for this release is Automatic Initial State ! ADDED Replay Animator-friendly automation of Ragdoll setuport going out of sync Replay Ever set-up a character with physics, only to have to do it all over again on some other shot or character? With Replay this can be a thing of the past! :) If you've ever worked with Photoshop and it's \"Actions\" panel, you'll know what to expect. It'll record the things you do, such that you can replay them later. For every recorded action, selection and preferences are stored. You can edit the names of selected nodes with wildcards to support alternative naming conventions, for example if a control has a different namespace than originally recorded at. Preferences can be manipulated post-recording as well, such as the initial shapes of things.","title":"Next"},{"location":"releases/next/#replay","text":"Ever set-up a character with physics, only to have to do it all over again on some other shot or character? With Replay this can be a thing of the past! :) If you've ever worked with Photoshop and it's \"Actions\" panel, you'll know what to expect. It'll record the things you do, such that you can replay them later. For every recorded action, selection and preferences are stored. You can edit the names of selected nodes with wildcards to support alternative naming conventions, for example if a control has a different namespace than originally recorded at. Preferences can be manipulated post-recording as well, such as the initial shapes of things.","title":"Replay"}]}