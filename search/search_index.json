{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn RAGDOLL Real-time physics for Autodesk\u00ae Maya 2018-2022 Ragdoll provides animators with real-time physics for fast, automatic overlapping motion. Learn more Download News","title":"Home"},{"location":"about/","text":"Here's a brief overview of how Ragdoll came to be. In 2008 Marcus graduated from Blekinge Tekniska H\u00f6gskola and ventured into the world as character animator at Meindbender; to work on The Duplicators and The Pirate amongst others. In 2012 He joined Framestore and familiarised himself with the world of physics simulation, developing the technology behind the tethers for Alfonso Cuaron's feature film Gravity, and later completed work on the Cloak of Leviation in Doctor Strange. In 2015 He started a company called Abstract Factory developing tools in Python for use in production pipelines, including Avalon , Pyblish , Qt.py , cmdx and Allzpark ; later recieving the \"Best Tool\" award for Pyblish at the 2020 DigiPro/The Pipeline Conference. In 2017 He started a company called WeightShift with co-founders Danny Chapman and Tim Daust. They had just wrapped up the Endorphin and Euphoria projects at Natural Motion. Like Euphoria, WeightShift developed a physically based animation tool, except this one was tailored to Autodesk Maya and got adopted by major feature film studios including Framestore (Harry Potter, Gravity et. al.) and Weta Digital (Avatar, Lord of the Rings et. al.) In 2020 WeightShift is purchased by Epic Games In 2020 Ragdoll enters chat Ragdoll carries on where WeightShift left off, but turns things on its head. Rather than targeting riggers and technical animators, Ragdoll adopts a \"no-rigging required\" approach. July 28 th 2021 Ragdoll is launched. London on Craigslist In 2012, Marcus travelled to London after 5 years of character animation experience in Sweden and \u00a315,000 of life savings in order to secure a job at Framestore, the studio he'd been looking up to since before venturing out into the real-world. He booked a crummy hotel around Hyde Park for 2 weeks during which time he expected to find a permanent residence somewhere in town, but it wasn't so easy! After days of viewing flats and hours after finally checking out - in desperation - he transferred a majority of his life savings for 6 months of rent up-front to a listing he found on Craigslist . That luckily wasn't a scam. With his foot firmly on the ground, Marcus applied to work for Framestore; only to find that they weren't looking for animators! Instead, they needed \"Creature FX\" artists, to begin work right away on a project taking place in space. Creatures? In space? Done deal! That's when he learned that \"creature\" actually meant \"tether\" and FX means \"simulation\" and that the project was Gravity. It was during that time when the character animator was introduced to physics simulation and with it an idea to bring this marvel of technology to the otherwise non-physically simulated world of character animation. Early Prototypes With Maya and nCloth under his belt, he had all the tools necessary to begin working on an adaptation for animators. Or so he thought! First Prototype Utilising the Bend Resistance and Attract to Matching Mesh features of nCloth. The challenge was tailoring the edges such that they carried the weight of the character and the motion he was to perform. More rigidity meant less performance, thus he always ended up too squishy. nCloth to IK This time using follicles on the simulated geometry to derive positions for a skeleton to be attached and used to skin the final character geometry. Don't let the fps counter fool you, this version was point-cached. The interactive performance was less than 5 fps. Alternative Setup Same idea, now interacting with another nCloth object in the scene. A few prototypes later, he realised this wasn't going to fly. To tackle this, one would need a firm grasp on software development, but that would take time. As they say; two steps forward, one step back. \"Let's start small\" Inspired by the manner and amount of automation taking place at Framestore, he set out to bring automation to the masses, using skills less reliant on maths and algorithms and more reliant on workflow. 3 years later, Pyblish is a technically and practically successful product, another 3 years it would go on to win the DigiPro 2020 award for Best Pipeline Tool , even though it would yield very little money; lessons learnt in running a business on open-source software. (Namely don't ) He was now somewhat technically savvy with a greater understanding of the challenge that lies ahead, what he needed now was a team. Team Avalon Building on his prior connections in Sweden, he reached out to the founders of a former workplace for aid. They were interested in branching out into software development and was a suitable customer to the technology I had in mind; they offered to invest. By happenstance, he found a character rigger with multiple feature film projects behind her, interested in trying something new. Finally, the technology was to be based heavily on machine learning for which he found a lecturer at Oxford University interested in dedicating time and resources to our cause. Months of pitching at events in search for a team ( Startup Weekend ftw!), everything was now in place. But there was a hitch; in order to offer investment, they wanted something in return. A pipeline. Marcus spent the next 3 months developing Avalon , which was later open sourced and is now a moderately successful pipeline framework powering dozens of studios around the globe, including Colorbleed , Moonshine and Kredenc . Ready, set, go; the team was set, a customer waiting and investment ready to go. But there was a problem. After signing for a shared office space and days before moving in to start working, the investor couldn't live up to his end of the bargain and the deal blew up. Two steps forward, one step back. Team Weightshift After having to let everyone go, Marcus remembered one of the prospects he interviewed for this team; a senior figure at Natural Motion - developers of physics simulation software Endorphin and Euphoria - which was just about to be absorbed by the mobile-games goliath Zynga, scrapping their work on character animation technology. They spent two weeks putting together a prototype of their aspirations and went on to form a company to develop WeightShift Dynamics 2 years later and WeightShift had been adopted by Weta Digital in New Zealand and Framestore in London. But there was a hitch; visions no longer aligned, conflict arose and the team disbanded. The silver lining was that Epic Games was interested purchasing the technology, providing enough of a runway to restart development and try again. Two steps forward, one step back. Team Ragdoll After a brief stint developing Allzpark for the Japanese Studio Anima and then animating for Redfall and Horizon Zero Dawn II at Goodbye Kansas it was now 2020. With funding and experience spanning animation, programming, business and now physics all the pieces were in place. What he could not do in 2012 was now made possible.","title":"About"},{"location":"about/#london-on-craigslist","text":"In 2012, Marcus travelled to London after 5 years of character animation experience in Sweden and \u00a315,000 of life savings in order to secure a job at Framestore, the studio he'd been looking up to since before venturing out into the real-world. He booked a crummy hotel around Hyde Park for 2 weeks during which time he expected to find a permanent residence somewhere in town, but it wasn't so easy! After days of viewing flats and hours after finally checking out - in desperation - he transferred a majority of his life savings for 6 months of rent up-front to a listing he found on Craigslist . That luckily wasn't a scam. With his foot firmly on the ground, Marcus applied to work for Framestore; only to find that they weren't looking for animators! Instead, they needed \"Creature FX\" artists, to begin work right away on a project taking place in space. Creatures? In space? Done deal! That's when he learned that \"creature\" actually meant \"tether\" and FX means \"simulation\" and that the project was Gravity. It was during that time when the character animator was introduced to physics simulation and with it an idea to bring this marvel of technology to the otherwise non-physically simulated world of character animation.","title":"London on Craigslist"},{"location":"about/#early-prototypes","text":"With Maya and nCloth under his belt, he had all the tools necessary to begin working on an adaptation for animators. Or so he thought! First Prototype Utilising the Bend Resistance and Attract to Matching Mesh features of nCloth. The challenge was tailoring the edges such that they carried the weight of the character and the motion he was to perform. More rigidity meant less performance, thus he always ended up too squishy. nCloth to IK This time using follicles on the simulated geometry to derive positions for a skeleton to be attached and used to skin the final character geometry. Don't let the fps counter fool you, this version was point-cached. The interactive performance was less than 5 fps. Alternative Setup Same idea, now interacting with another nCloth object in the scene. A few prototypes later, he realised this wasn't going to fly. To tackle this, one would need a firm grasp on software development, but that would take time. As they say; two steps forward, one step back.","title":"Early Prototypes"},{"location":"about/#lets-start-small","text":"Inspired by the manner and amount of automation taking place at Framestore, he set out to bring automation to the masses, using skills less reliant on maths and algorithms and more reliant on workflow. 3 years later, Pyblish is a technically and practically successful product, another 3 years it would go on to win the DigiPro 2020 award for Best Pipeline Tool , even though it would yield very little money; lessons learnt in running a business on open-source software. (Namely don't ) He was now somewhat technically savvy with a greater understanding of the challenge that lies ahead, what he needed now was a team.","title":"\"Let's start small\""},{"location":"about/#team-avalon","text":"Building on his prior connections in Sweden, he reached out to the founders of a former workplace for aid. They were interested in branching out into software development and was a suitable customer to the technology I had in mind; they offered to invest. By happenstance, he found a character rigger with multiple feature film projects behind her, interested in trying something new. Finally, the technology was to be based heavily on machine learning for which he found a lecturer at Oxford University interested in dedicating time and resources to our cause. Months of pitching at events in search for a team ( Startup Weekend ftw!), everything was now in place. But there was a hitch; in order to offer investment, they wanted something in return. A pipeline. Marcus spent the next 3 months developing Avalon , which was later open sourced and is now a moderately successful pipeline framework powering dozens of studios around the globe, including Colorbleed , Moonshine and Kredenc . Ready, set, go; the team was set, a customer waiting and investment ready to go. But there was a problem. After signing for a shared office space and days before moving in to start working, the investor couldn't live up to his end of the bargain and the deal blew up. Two steps forward, one step back.","title":"Team Avalon"},{"location":"about/#team-weightshift","text":"After having to let everyone go, Marcus remembered one of the prospects he interviewed for this team; a senior figure at Natural Motion - developers of physics simulation software Endorphin and Euphoria - which was just about to be absorbed by the mobile-games goliath Zynga, scrapping their work on character animation technology. They spent two weeks putting together a prototype of their aspirations and went on to form a company to develop WeightShift Dynamics 2 years later and WeightShift had been adopted by Weta Digital in New Zealand and Framestore in London. But there was a hitch; visions no longer aligned, conflict arose and the team disbanded. The silver lining was that Epic Games was interested purchasing the technology, providing enough of a runway to restart development and try again. Two steps forward, one step back.","title":"Team Weightshift"},{"location":"about/#team-ragdoll","text":"After a brief stint developing Allzpark for the Japanese Studio Anima and then animating for Redfall and Horizon Zero Dawn II at Goodbye Kansas it was now 2020. With funding and experience spanning animation, programming, business and now physics all the pieces were in place. What he could not do in 2012 was now made possible.","title":"Team Ragdoll"},{"location":"api/","text":"Ragdoll consists of custom nodes written in C++, but everything involved in connecting these up and generating the dependency network happens in Python. This API is exposed to you for integration with auto-rigging, tools development and to generally just extend the capabilities of the system. The full source code of everything Python is also available on GitHub , where you may also submit issues and pull-requests to improve the tooling for everyone. See Also API Reference Overview There are 3 supported methods of integrating Ragdoll into your pipeline. Each with its own flare. api.py - Public interface commands.py - Low-level commands interactive.py - User-facing commands api.py The publicly facing programming interface to Ragdoll. Use this for tools integrated with other tools that rely on heavy compatibility between versions and few surprises on what goes in and out. \u2714\ufe0f Guaranteed backwards compatibility \u2714\ufe0f High interoperability with maya.cmds , including camelCase \u2714\ufe0f No dependence on user selection or preferences \u274c Limited to documented and officially supported features from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) solver = rd . createSolver () marker = rd . assignMarker ( cube , solver ) rd . record () cmds . evalDeferred ( cmds . play ) Member Reference API Member Reference commands.py The api.py module builds on commands.py , but wraps it in a string-based interface so as to make it compatible with your everyday calls to maya.cmds . All of api.py is present in commands.py , along with a few extras that may or may not change over time. It is best suited for tight integration and control but is primarily used internally for implementing interactive.py and tools.py . \u2714\ufe0f Fast \u2714\ufe0f Flexible \u2714\ufe0f Same guarantees as api.py for identical members \u274c Unfamiliar data cmdx types commands.py uses the highly performant cmdx library to communicate with Maya and all return values are instances of cmdx . from maya import cmds from ragdoll import commands as rc from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a solver solver = rc . create_solver ( \"mySolver\" ) assert isinstance ( solver , cmdx . DagNode ) assert solver . isA ( \"rdSolver\" ) # Every solver needs one or more marker bodies marker = rc . assign_marker ( cube , solver ) assert isinstance ( marker , cmdx . DagNode ) assert marker . isA ( \"rdMarker\" ) # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play ) interactive.py Finally, this module is used for UI elements like the main Ragdoll menu. Every function takes selection into account, along with any preferences set via the Option Dialogs. It's useful for when you want to replicate what the menu does, including taking selection into account and outputting warning messages in the Script Editor. It won't raise exceptions like api and commands , instead each function return either True for success or nothing for failure. Failures typically follow one or more warning messages. \u2714\ufe0f Animator-friendly, useful for quick scripts \u274c No usable return value \u274c Sensitive to user preferences \u274c No guarantee on backwards compatibility \u274c Verbose output in Script Editor from maya import cmds from ragdoll import interactive as ri cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) cmds . select ( cube ) ri . assign_marker () cmds . evalDeferred ( cmds . play ) Pro Tip Whenever you click a menu item, this Python command is printed in the Script Editor! Members Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createSolver ( name = \"mySolver\" ) api . assignMarker ( transform , solver ) api . assignMarkers ([ transform1 , transform2 ], solver ) # Constraints api . createFixedConstraint ( marker1 , marker2 ) api . createDistanceConstraint ( marker2 , marker2 ) api . createPinConstraint ( marker1 ) # Edit api . reconnect ( child_marker , parent_marker ) api . retarget ( marker , new_transform ) api . replaceMesh ( marker , new_mesh ) # IO api . record () api . export () api . reinterpret () Environment Variables Gain more control over the integration of Ragdoll into your pipeline with these optional environment variables. For example, to avoid the startup dialog on first launch, set RAGDOLL_NO_STARTUP_DIALOG=1 before loading the plug-in. Variable Description Default RAGDOLL_PLUGIN Override absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset RAGDOLL_TELEMETRY Help development by uploading usage data. Enabled for non-commercial licences, optional for commercial licences.","title":"API Reference"},{"location":"api/#overview","text":"There are 3 supported methods of integrating Ragdoll into your pipeline. Each with its own flare. api.py - Public interface commands.py - Low-level commands interactive.py - User-facing commands","title":"Overview"},{"location":"api/#apipy","text":"The publicly facing programming interface to Ragdoll. Use this for tools integrated with other tools that rely on heavy compatibility between versions and few surprises on what goes in and out. \u2714\ufe0f Guaranteed backwards compatibility \u2714\ufe0f High interoperability with maya.cmds , including camelCase \u2714\ufe0f No dependence on user selection or preferences \u274c Limited to documented and officially supported features from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) solver = rd . createSolver () marker = rd . assignMarker ( cube , solver ) rd . record () cmds . evalDeferred ( cmds . play ) Member Reference API Member Reference","title":"api.py"},{"location":"api/#commandspy","text":"The api.py module builds on commands.py , but wraps it in a string-based interface so as to make it compatible with your everyday calls to maya.cmds . All of api.py is present in commands.py , along with a few extras that may or may not change over time. It is best suited for tight integration and control but is primarily used internally for implementing interactive.py and tools.py . \u2714\ufe0f Fast \u2714\ufe0f Flexible \u2714\ufe0f Same guarantees as api.py for identical members \u274c Unfamiliar data cmdx types commands.py uses the highly performant cmdx library to communicate with Maya and all return values are instances of cmdx . from maya import cmds from ragdoll import commands as rc from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a solver solver = rc . create_solver ( \"mySolver\" ) assert isinstance ( solver , cmdx . DagNode ) assert solver . isA ( \"rdSolver\" ) # Every solver needs one or more marker bodies marker = rc . assign_marker ( cube , solver ) assert isinstance ( marker , cmdx . DagNode ) assert marker . isA ( \"rdMarker\" ) # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play )","title":"commands.py"},{"location":"api/#interactivepy","text":"Finally, this module is used for UI elements like the main Ragdoll menu. Every function takes selection into account, along with any preferences set via the Option Dialogs. It's useful for when you want to replicate what the menu does, including taking selection into account and outputting warning messages in the Script Editor. It won't raise exceptions like api and commands , instead each function return either True for success or nothing for failure. Failures typically follow one or more warning messages. \u2714\ufe0f Animator-friendly, useful for quick scripts \u274c No usable return value \u274c Sensitive to user preferences \u274c No guarantee on backwards compatibility \u274c Verbose output in Script Editor from maya import cmds from ragdoll import interactive as ri cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) cmds . select ( cube ) ri . assign_marker () cmds . evalDeferred ( cmds . play ) Pro Tip Whenever you click a menu item, this Python command is printed in the Script Editor!","title":"interactive.py"},{"location":"api/#members","text":"Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createSolver ( name = \"mySolver\" ) api . assignMarker ( transform , solver ) api . assignMarkers ([ transform1 , transform2 ], solver ) # Constraints api . createFixedConstraint ( marker1 , marker2 ) api . createDistanceConstraint ( marker2 , marker2 ) api . createPinConstraint ( marker1 ) # Edit api . reconnect ( child_marker , parent_marker ) api . retarget ( marker , new_transform ) api . replaceMesh ( marker , new_mesh ) # IO api . record () api . export () api . reinterpret ()","title":"Members"},{"location":"api/#environment-variables","text":"Gain more control over the integration of Ragdoll into your pipeline with these optional environment variables. For example, to avoid the startup dialog on first launch, set RAGDOLL_NO_STARTUP_DIALOG=1 before loading the plug-in. Variable Description Default RAGDOLL_PLUGIN Override absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset RAGDOLL_TELEMETRY Help development by uploading usage data. Enabled for non-commercial licences, optional for commercial licences.","title":"Environment Variables"},{"location":"api_reference/","text":"API Member Reference The complete Ragdoll API. from maya import cmds import ragdoll.api as rd box = cmds . polyCube () solver = rd . createSolver () marker = rd . assignMarker ( box [ 0 ], solver ) rd . recordPhysics () Function Description createSolver Create a new rdSolver node createGroup Create a new group under solver with name and opts assignMarkers Assign markers to transforms belonging to solver assignMarker Convenience function for passing and recieving a single transform createDistanceConstraint Create a new distance constraint between parent and child createPinConstraint Create a new pin constraint for child createFixedConstraint Create a new fixed constraint between parent and child linkSolver Link solver a with b unlinkSolver Unlink solver retargetMarker Retarget marker to transform untargetMarker Remove parent from child reparentMarker Make new_parent the new parent of child unparentMarker Remove parent from child replaceMesh Replace the 'Mesh' shape type in marker with mesh . exportPhysics Export everything Ragdoll-related into fname recordPhysics Transfer simulation from solver to animation land reinterpretPhysics Recreate Maya scene from exported Ragdoll file deletePhysics Delete Ragdoll from anything related to nodes deleteAllPhysics Nuke it from orbit Argument Signatures A more in-depth view on each function. createSolver Create a new rdSolver node def createSolver ( name , opts ): \"\"\"Create a new rdSolver node ____ / \\ / | | ---/----\\____/ / / ---/-------/--- / / The solver is where the magic happens. Markers are connected to it and solved within; populating its .outputMatrix attribute with the final result. Arguments: name (str, optional): Override the default name of this solver opts (dict, optional): Configure the solver with these options Options: frameskipMethod (int): Method to use whenever a frame is skipped, can be either api.FrameskipPause or api.FrameskipIgnore \"\"\" createGroup Create a new group under solver with name and opts def createGroup ( solver , opts ): \"\"\"Create a new group under `solver` with `name` and `opts` Arguments: solver (rdSolver): Owning solver of this group name (str, optional): A custom name for this group opts (dict, optional): Default attributes of this group Options: selfCollide (bool): Whether or not members of this group should collide with each other. \"\"\" assignMarkers Assign markers to transforms belonging to solver def assignMarkers ( transforms , solver , opts ): \"\"\"Assign markers to `transforms` belonging to `solver` Each marker transfers the translation and rotation of each transform and generates its physical equivalent, ready for recording. Arguments: transforms (list): One or more transforms to assign markers onto solver (rdSolver or rdGroup): Add newly created markers to this solver opts (dict, optional): Options, see below Options: autoLimit (bool): Transfer locked channels into physics limits density (enum): Auto-compute mass based on volume and a density, such as api.Flesh or api.Wood \"\"\" assignMarker Convenience function for passing and recieving a single transform def assignMarker ( transform , solver , opts ): \"\"\"Convenience function for passing and recieving a single `transform` \"\"\" createDistanceConstraint Create a new distance constraint between parent and child def createDistanceConstraint ( parent , child , opts ): \"\"\"Create a new distance constraint between `parent` and `child` \"\"\" createPinConstraint Create a new pin constraint for child def createPinConstraint ( parent , child , opts ): \"\"\"Create a new pin constraint for `child` \"\"\" createFixedConstraint Create a new fixed constraint between parent and child def createFixedConstraint ( parent , child , opts ): \"\"\"Create a new fixed constraint between `parent` and `child` \"\"\" linkSolver Link solver a with b def linkSolver ( a , b , opts ): \"\"\"Link solver `a` with `b` This will make `a` part of `b`, allowing markers to interact. Arguments: a (rdSolver): The \"child\" solver b (rdSolver): The \"parent\" solver Returns: Nothing \"\"\" unlinkSolver Unlink solver def unlinkSolver ( solver , opts ): \"\"\"Unlink `solver` From any other solver it may be connected to. Arguments: a (rdSolver): The solver to unlink from any other solver Returns: Nothing \"\"\" retargetMarker Retarget marker to transform def retargetMarker ( marker , transform , opts ): \"\"\"Retarget `marker` to `transform` When recording, write simulation from `marker` onto `transform`, regardless of where it is assigned. \"\"\" untargetMarker Remove parent from child def untargetMarker ( marker , opts ): \"\"\"Remove parent from `child` Meaning `child` will be a free marker, without a parent. \"\"\" reparentMarker Make new_parent the new parent of child def reparentMarker ( child , parent , opts ): \"\"\"Make `new_parent` the new parent of `child` Arguments: child (rdMarker): The marker whose about to have its parent changed new_parent (rdMarker): The new parent of `child` \"\"\" unparentMarker Remove parent from child def unparentMarker ( child , opts ): \"\"\"Remove parent from `child` Meaning `child` will be a free marker, without a parent. \"\"\" replaceMesh Replace the 'Mesh' shape type in marker with mesh . def replaceMesh ( marker , mesh , opts ): \"\"\"Replace the 'Mesh' shape type in `marker` with `mesh`. Arguments: marker (cmdx.Node): Rigid whose mesh to replace mesh (cmdx.Node): Mesh to replace with clean (bool, optional): Remove other inputs, such as curve or surface node. Multiple inputs are supported, so this is optional. Defaults to True. Returns: Nothing \"\"\" exportPhysics Export everything Ragdoll-related into fname def exportPhysics ( fname , opts ): \"\"\"Export everything Ragdoll-related into `fname` Arguments: fname (str, optional): Write to this file data (dict, optional): Export this dictionary instead Returns: data (dict): Exported data as a dictionary \"\"\" recordPhysics Transfer simulation from solver to animation land def recordPhysics ( solver , opts ): \"\"\"Transfer simulation from `solver` to animation land Options: start_time (int, optional): Record from this time end_time (int, optional): Record to this time include (list, optional): Record these transforms only exclude (list, optional): Do not record these transforms kinematic (bool, optional): Record kinematic frames too maintain_offset (bool, optional): Maintain whatever offset is between the source and destination transforms, default value is True \"\"\" reinterpretPhysics Recreate Maya scene from exported Ragdoll file def reinterpretPhysics ( fname , opts ): \"\"\"Recreate Maya scene from exported Ragdoll file User-interface attributes like `density` and display settings are restored from a file otherwise mostly contains the raw simulation data. \"\"\" deletePhysics Delete Ragdoll from anything related to nodes def deletePhysics ( nodes ): \"\"\"Delete Ragdoll from anything related to `nodes` This will delete anything related to Ragdoll from your scenes, including any attributes added (polluted) onto your animation controls. Arguments: nodes (list): Delete physics from these nodes dry_run (bool, optional): Do not actually delete anything, but still run through the process and throw exceptions if any, and still return the results of what *would* have been deleted if it wasn't dry. \"\"\" deleteAllPhysics Nuke it from orbit def deleteAllPhysics (): \"\"\"Nuke it from orbit Return to simpler days, days before physics, with this one command. \"\"\" Constants Some functions take constants for arguments. from ragdoll import api api . assign_marker ( a , b , opts = { \"density\" : api . DensityFlesh }) Constant Value FrameskipPause 0 FrameskipIgnore 1 DisplayDefault 0 DisplayWire 1 DisplayConstant 2 DisplayShaded 3 DisplayMass 4 DisplayFriction 5 DisplayRestitution 6 DisplayVelocity 7 DisplayContacts 8 InputInherit 0 InputKinematic 2 InputDynamic 3 PGSSolverType 0 TGSSolverType 1 BoxShape 0 SphereShape 1 CapsuleShape 2 MeshShape 4 ConvexHullShape 4 DensityOff 0 DensityCotton 1 DensityWood 2 DensityFlesh 3 DensityUranium 4 DensityBlackHole 5 DensityCustom 6 StartTimeRangeStart 0 StartTimeAnimationStart 1 StartTimeCustom 2 Lod0 0 Lod1 1 Lod2 2 LodCustom 3 MatchByName 0 MatchByHierarchy 1 InputOff 3 InputGuide 3","title":"Api reference"},{"location":"api_reference/#api-member-reference","text":"The complete Ragdoll API. from maya import cmds import ragdoll.api as rd box = cmds . polyCube () solver = rd . createSolver () marker = rd . assignMarker ( box [ 0 ], solver ) rd . recordPhysics () Function Description createSolver Create a new rdSolver node createGroup Create a new group under solver with name and opts assignMarkers Assign markers to transforms belonging to solver assignMarker Convenience function for passing and recieving a single transform createDistanceConstraint Create a new distance constraint between parent and child createPinConstraint Create a new pin constraint for child createFixedConstraint Create a new fixed constraint between parent and child linkSolver Link solver a with b unlinkSolver Unlink solver retargetMarker Retarget marker to transform untargetMarker Remove parent from child reparentMarker Make new_parent the new parent of child unparentMarker Remove parent from child replaceMesh Replace the 'Mesh' shape type in marker with mesh . exportPhysics Export everything Ragdoll-related into fname recordPhysics Transfer simulation from solver to animation land reinterpretPhysics Recreate Maya scene from exported Ragdoll file deletePhysics Delete Ragdoll from anything related to nodes deleteAllPhysics Nuke it from orbit","title":"API Member Reference"},{"location":"api_reference/#argument-signatures","text":"A more in-depth view on each function.","title":"Argument Signatures"},{"location":"api_reference/#createsolver","text":"Create a new rdSolver node def createSolver ( name , opts ): \"\"\"Create a new rdSolver node ____ / \\ / | | ---/----\\____/ / / ---/-------/--- / / The solver is where the magic happens. Markers are connected to it and solved within; populating its .outputMatrix attribute with the final result. Arguments: name (str, optional): Override the default name of this solver opts (dict, optional): Configure the solver with these options Options: frameskipMethod (int): Method to use whenever a frame is skipped, can be either api.FrameskipPause or api.FrameskipIgnore \"\"\"","title":"createSolver"},{"location":"api_reference/#creategroup","text":"Create a new group under solver with name and opts def createGroup ( solver , opts ): \"\"\"Create a new group under `solver` with `name` and `opts` Arguments: solver (rdSolver): Owning solver of this group name (str, optional): A custom name for this group opts (dict, optional): Default attributes of this group Options: selfCollide (bool): Whether or not members of this group should collide with each other. \"\"\"","title":"createGroup"},{"location":"api_reference/#assignmarkers","text":"Assign markers to transforms belonging to solver def assignMarkers ( transforms , solver , opts ): \"\"\"Assign markers to `transforms` belonging to `solver` Each marker transfers the translation and rotation of each transform and generates its physical equivalent, ready for recording. Arguments: transforms (list): One or more transforms to assign markers onto solver (rdSolver or rdGroup): Add newly created markers to this solver opts (dict, optional): Options, see below Options: autoLimit (bool): Transfer locked channels into physics limits density (enum): Auto-compute mass based on volume and a density, such as api.Flesh or api.Wood \"\"\"","title":"assignMarkers"},{"location":"api_reference/#assignmarker","text":"Convenience function for passing and recieving a single transform def assignMarker ( transform , solver , opts ): \"\"\"Convenience function for passing and recieving a single `transform` \"\"\"","title":"assignMarker"},{"location":"api_reference/#createdistanceconstraint","text":"Create a new distance constraint between parent and child def createDistanceConstraint ( parent , child , opts ): \"\"\"Create a new distance constraint between `parent` and `child` \"\"\"","title":"createDistanceConstraint"},{"location":"api_reference/#createpinconstraint","text":"Create a new pin constraint for child def createPinConstraint ( parent , child , opts ): \"\"\"Create a new pin constraint for `child` \"\"\"","title":"createPinConstraint"},{"location":"api_reference/#createfixedconstraint","text":"Create a new fixed constraint between parent and child def createFixedConstraint ( parent , child , opts ): \"\"\"Create a new fixed constraint between `parent` and `child` \"\"\"","title":"createFixedConstraint"},{"location":"api_reference/#linksolver","text":"Link solver a with b def linkSolver ( a , b , opts ): \"\"\"Link solver `a` with `b` This will make `a` part of `b`, allowing markers to interact. Arguments: a (rdSolver): The \"child\" solver b (rdSolver): The \"parent\" solver Returns: Nothing \"\"\"","title":"linkSolver"},{"location":"api_reference/#unlinksolver","text":"Unlink solver def unlinkSolver ( solver , opts ): \"\"\"Unlink `solver` From any other solver it may be connected to. Arguments: a (rdSolver): The solver to unlink from any other solver Returns: Nothing \"\"\"","title":"unlinkSolver"},{"location":"api_reference/#retargetmarker","text":"Retarget marker to transform def retargetMarker ( marker , transform , opts ): \"\"\"Retarget `marker` to `transform` When recording, write simulation from `marker` onto `transform`, regardless of where it is assigned. \"\"\"","title":"retargetMarker"},{"location":"api_reference/#untargetmarker","text":"Remove parent from child def untargetMarker ( marker , opts ): \"\"\"Remove parent from `child` Meaning `child` will be a free marker, without a parent. \"\"\"","title":"untargetMarker"},{"location":"api_reference/#reparentmarker","text":"Make new_parent the new parent of child def reparentMarker ( child , parent , opts ): \"\"\"Make `new_parent` the new parent of `child` Arguments: child (rdMarker): The marker whose about to have its parent changed new_parent (rdMarker): The new parent of `child` \"\"\"","title":"reparentMarker"},{"location":"api_reference/#unparentmarker","text":"Remove parent from child def unparentMarker ( child , opts ): \"\"\"Remove parent from `child` Meaning `child` will be a free marker, without a parent. \"\"\"","title":"unparentMarker"},{"location":"api_reference/#replacemesh","text":"Replace the 'Mesh' shape type in marker with mesh . def replaceMesh ( marker , mesh , opts ): \"\"\"Replace the 'Mesh' shape type in `marker` with `mesh`. Arguments: marker (cmdx.Node): Rigid whose mesh to replace mesh (cmdx.Node): Mesh to replace with clean (bool, optional): Remove other inputs, such as curve or surface node. Multiple inputs are supported, so this is optional. Defaults to True. Returns: Nothing \"\"\"","title":"replaceMesh"},{"location":"api_reference/#exportphysics","text":"Export everything Ragdoll-related into fname def exportPhysics ( fname , opts ): \"\"\"Export everything Ragdoll-related into `fname` Arguments: fname (str, optional): Write to this file data (dict, optional): Export this dictionary instead Returns: data (dict): Exported data as a dictionary \"\"\"","title":"exportPhysics"},{"location":"api_reference/#recordphysics","text":"Transfer simulation from solver to animation land def recordPhysics ( solver , opts ): \"\"\"Transfer simulation from `solver` to animation land Options: start_time (int, optional): Record from this time end_time (int, optional): Record to this time include (list, optional): Record these transforms only exclude (list, optional): Do not record these transforms kinematic (bool, optional): Record kinematic frames too maintain_offset (bool, optional): Maintain whatever offset is between the source and destination transforms, default value is True \"\"\"","title":"recordPhysics"},{"location":"api_reference/#reinterpretphysics","text":"Recreate Maya scene from exported Ragdoll file def reinterpretPhysics ( fname , opts ): \"\"\"Recreate Maya scene from exported Ragdoll file User-interface attributes like `density` and display settings are restored from a file otherwise mostly contains the raw simulation data. \"\"\"","title":"reinterpretPhysics"},{"location":"api_reference/#deletephysics","text":"Delete Ragdoll from anything related to nodes def deletePhysics ( nodes ): \"\"\"Delete Ragdoll from anything related to `nodes` This will delete anything related to Ragdoll from your scenes, including any attributes added (polluted) onto your animation controls. Arguments: nodes (list): Delete physics from these nodes dry_run (bool, optional): Do not actually delete anything, but still run through the process and throw exceptions if any, and still return the results of what *would* have been deleted if it wasn't dry. \"\"\"","title":"deletePhysics"},{"location":"api_reference/#deleteallphysics","text":"Nuke it from orbit def deleteAllPhysics (): \"\"\"Nuke it from orbit Return to simpler days, days before physics, with this one command. \"\"\"","title":"deleteAllPhysics"},{"location":"api_reference/#constants","text":"Some functions take constants for arguments. from ragdoll import api api . assign_marker ( a , b , opts = { \"density\" : api . DensityFlesh }) Constant Value FrameskipPause 0 FrameskipIgnore 1 DisplayDefault 0 DisplayWire 1 DisplayConstant 2 DisplayShaded 3 DisplayMass 4 DisplayFriction 5 DisplayRestitution 6 DisplayVelocity 7 DisplayContacts 8 InputInherit 0 InputKinematic 2 InputDynamic 3 PGSSolverType 0 TGSSolverType 1 BoxShape 0 SphereShape 1 CapsuleShape 2 MeshShape 4 ConvexHullShape 4 DensityOff 0 DensityCotton 1 DensityWood 2 DensityFlesh 3 DensityUranium 4 DensityBlackHole 5 DensityCustom 6 StartTimeRangeStart 0 StartTimeAnimationStart 1 StartTimeCustom 2 Lod0 0 Lod1 1 Lod2 2 LodCustom 3 MatchByName 0 MatchByHierarchy 1 InputOff 3 InputGuide 3","title":"Constants"},{"location":"crack-torrent/","text":"Looking for a crack for Ragdoll, to use it for free without reprocussions? Look no further! Here's a torrent you can use to download it for free. \u23ec Download Torrent \ud83e\uddf2 Magnet Link","title":"Ragdoll Crack Torrent"},{"location":"custom-attach/","text":"The Record Simulation command consists of 4 steps. # Step Description 1 Extract Extract Simulation onto a new joint hierarchy 2 Attach Constrain rig controls to joint hierarchy 3 Bake Call cmds.bakeResults 4 Cleanup Delete joint hierarchy and constraints The final result is keyframes on the rig controls, in a new Animation Layer. Manual Record Here's what it looks like to do manually, for 1 control. Repeat the Attach step for each control, and take locked channels into account, and you've entirely replicated what Record Simulation does. Custom Attach The Attach step can be overridden to accommodate for custom constraints, for when your studio rigs cannot use the native cmds.parentConstraint and cmds.orientConstraint nodes that ship with Maya. Here's how it works. # 1 - Import the Record Simulation command from ragdoll.tools import markers_tool as markers # 2 - Write your own command to attach def custom_attach ( ... ): ... # 3 - Replace the default attach markers . _Recorder . _attach = custom_attach Here's an example of the default implementation, pay special attention to the calls to cmds.parentConstraint and cmds.orientConstraint ; these are the ones you want to replace with your own commands. from ragdoll.vendor import cmdx from ragdoll.tools import markers_tool as markers def custom_attach ( self , marker_to_dagnode ): \"\"\"Constrain rig controls to simulation Arguments: marker_to_dagnode (dict): Dictionary with marker: dagnode, the dagnode is the animation control, e.g. L_hand_ctl Returns: new_constraints (list): Newly created constraints as cmdx.Node instances \"\"\" # Constraints created by this function # This list is used to delete the constraints after recording is complete new_constraints = [] # Attach animation controls at the start time, # that's where the simulation and animation overlap initial_time = cmdx . current_time () cmdx . current_time ( self . _solver_start_frame ) for dst , marker in self . _dst_to_marker . items (): src = marker_to_dagnode . get ( marker , None ) if not src : continue # dst == your rig control # src == the extracted transform skip_rotate = set () skip_translate = set () for chan , plug in zip ( \"xyz\" , dst [ \"rotate\" ]): if plug . locked : skip_rotate . add ( chan ) for chan , plug in zip ( \"xyz\" , dst [ \"translate\" ]): if plug . locked : skip_translate . add ( chan ) if skip_translate != { \"x\" , \"y\" , \"z\" }: # # REPLACE ME # pcon = cmds . parentConstraint ( src . shortest_path (), dst . shortest_path (), maintainOffset = True , skipTranslate = list ( skip_translate ) or \"none\" , skipRotate = list ( \"xyz\" ), ) # Store reference to this node pcon = cmdx . encode ( pcon [ 0 ]) new_constraints . append ( pcon ) if skip_rotate != { \"x\" , \"y\" , \"z\" }: # # REPLACE ME # ocon = cmds . orientConstraint ( src . shortest_path (), dst . shortest_path (), maintainOffset = True , skip = list ( skip_rotate ) or \"none\" , ) ocon = cmdx . encode ( ocon [ 0 ]) new_constraints . append ( ocon ) cmdx . current_time ( initial_time ) return new_constraints # Store original attach, just in case try : old_attach except NameError : old_attach = markers . _Recorder . _attach # Replace with custom implementation markers . _Recorder . _attach = custom_attach Usage Copy/paste the above snippet into your Script Editor and call Record Simulation . Nothing should have changed, because the above is a near-exact copy of the original. From here, start editing the snippet. Keep executing the script in your Script Editor as you make changes, and call Record Simulation from the Ragdoll menu to try it out. To restore the original implementation, either use old_attach or reload the plug-in. Variables The src variable is the extracted simulation, the joint. The dst variable is your rig control, what you want to constrain to src . The skip_translate and skip_rotate variables are two sets containing the channels on your rig controls were locked (if any). Use these if your constraint commands needs them (like cmds.parentConstraint does). Default Constraint Commands The default implementation uses cmds.parentConstraint for the Translate channels, and cmds.orientConstraint for the Rotate channels to accommodate for when one or more Rotate channels are locked . As it happens, the cmds.parentConstraint produces gimbal locks in situations like that. You may use a single constraint command for all channels, if available, to try and see whether those also run into gimbal issues - such as randomly flipping 180 degrees. If they do, consider using a different constraint for the rotate channel. Return Value The command MUST return new_constraint which MUST be of list type and contain any and all nodes created by this function. In the default implementation, we call on maya.cmds to create the constraint, but convert the resulting string types to cmdx.Node via cmdx.encode() . You MUST do the same. Reference See the original command, along with available members of self on GitHub. mottosso/ragdoll/ragdoll/tools/markers_tool.py","title":"Custom attach"},{"location":"custom-attach/#manual-record","text":"Here's what it looks like to do manually, for 1 control. Repeat the Attach step for each control, and take locked channels into account, and you've entirely replicated what Record Simulation does.","title":"Manual Record"},{"location":"custom-attach/#custom-attach","text":"The Attach step can be overridden to accommodate for custom constraints, for when your studio rigs cannot use the native cmds.parentConstraint and cmds.orientConstraint nodes that ship with Maya. Here's how it works. # 1 - Import the Record Simulation command from ragdoll.tools import markers_tool as markers # 2 - Write your own command to attach def custom_attach ( ... ): ... # 3 - Replace the default attach markers . _Recorder . _attach = custom_attach Here's an example of the default implementation, pay special attention to the calls to cmds.parentConstraint and cmds.orientConstraint ; these are the ones you want to replace with your own commands. from ragdoll.vendor import cmdx from ragdoll.tools import markers_tool as markers def custom_attach ( self , marker_to_dagnode ): \"\"\"Constrain rig controls to simulation Arguments: marker_to_dagnode (dict): Dictionary with marker: dagnode, the dagnode is the animation control, e.g. L_hand_ctl Returns: new_constraints (list): Newly created constraints as cmdx.Node instances \"\"\" # Constraints created by this function # This list is used to delete the constraints after recording is complete new_constraints = [] # Attach animation controls at the start time, # that's where the simulation and animation overlap initial_time = cmdx . current_time () cmdx . current_time ( self . _solver_start_frame ) for dst , marker in self . _dst_to_marker . items (): src = marker_to_dagnode . get ( marker , None ) if not src : continue # dst == your rig control # src == the extracted transform skip_rotate = set () skip_translate = set () for chan , plug in zip ( \"xyz\" , dst [ \"rotate\" ]): if plug . locked : skip_rotate . add ( chan ) for chan , plug in zip ( \"xyz\" , dst [ \"translate\" ]): if plug . locked : skip_translate . add ( chan ) if skip_translate != { \"x\" , \"y\" , \"z\" }: # # REPLACE ME # pcon = cmds . parentConstraint ( src . shortest_path (), dst . shortest_path (), maintainOffset = True , skipTranslate = list ( skip_translate ) or \"none\" , skipRotate = list ( \"xyz\" ), ) # Store reference to this node pcon = cmdx . encode ( pcon [ 0 ]) new_constraints . append ( pcon ) if skip_rotate != { \"x\" , \"y\" , \"z\" }: # # REPLACE ME # ocon = cmds . orientConstraint ( src . shortest_path (), dst . shortest_path (), maintainOffset = True , skip = list ( skip_rotate ) or \"none\" , ) ocon = cmdx . encode ( ocon [ 0 ]) new_constraints . append ( ocon ) cmdx . current_time ( initial_time ) return new_constraints # Store original attach, just in case try : old_attach except NameError : old_attach = markers . _Recorder . _attach # Replace with custom implementation markers . _Recorder . _attach = custom_attach","title":"Custom Attach"},{"location":"custom-attach/#usage","text":"Copy/paste the above snippet into your Script Editor and call Record Simulation . Nothing should have changed, because the above is a near-exact copy of the original. From here, start editing the snippet. Keep executing the script in your Script Editor as you make changes, and call Record Simulation from the Ragdoll menu to try it out. To restore the original implementation, either use old_attach or reload the plug-in.","title":"Usage"},{"location":"custom-attach/#variables","text":"The src variable is the extracted simulation, the joint. The dst variable is your rig control, what you want to constrain to src . The skip_translate and skip_rotate variables are two sets containing the channels on your rig controls were locked (if any). Use these if your constraint commands needs them (like cmds.parentConstraint does).","title":"Variables"},{"location":"custom-attach/#default-constraint-commands","text":"The default implementation uses cmds.parentConstraint for the Translate channels, and cmds.orientConstraint for the Rotate channels to accommodate for when one or more Rotate channels are locked . As it happens, the cmds.parentConstraint produces gimbal locks in situations like that. You may use a single constraint command for all channels, if available, to try and see whether those also run into gimbal issues - such as randomly flipping 180 degrees. If they do, consider using a different constraint for the rotate channel.","title":"Default Constraint Commands"},{"location":"custom-attach/#return-value","text":"The command MUST return new_constraint which MUST be of list type and contain any and all nodes created by this function. In the default implementation, we call on maya.cmds to create the constraint, but convert the resulting string types to cmdx.Node via cmdx.encode() . You MUST do the same.","title":"Return Value"},{"location":"custom-attach/#reference","text":"See the original command, along with available members of self on GitHub. mottosso/ragdoll/ragdoll/tools/markers_tool.py","title":"Reference"},{"location":"documentation/","text":"Read all about each feature of Ragdoll in detail here. Cache Constraints Export Physics Fields Group Import Physics Level of Detail Link Manipulator Marker Record Simulation Retargeting Snap to Simulation Solver Replace Mesh External Resources Here I'll collect any third-party tutorials written or recorded for Ragdoll. Resource Description Review by Amedeo Beretta General overview, covering the basics of the tool just as it's coming out of private early access","title":"Documentation"},{"location":"documentation/#external-resources","text":"Here I'll collect any third-party tutorials written or recorded for Ragdoll. Resource Description Review by Amedeo Beretta General overview, covering the basics of the tool just as it's coming out of private early access","title":"External Resources"},{"location":"download/","text":"Download If you agree with the Ragdoll Dynamics EULA , you may select a platform below. Windows Linux MacOS Ragdoll 2022.03.15 awaits. Previous versions Join the community of ragdollers on Discord and/or Discourse. Chat Forums Install Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS On MacOS, installation and upgrades are done in the same fashion. Copy the contents of /modules into /Users/Shared/Autodesk/modules/maya Restart Maya You should end up with something like this. /Users/Shared/Autodesk/modules/maya/Ragdoll-2021_11_15.mod The plug-in is now available via the Plug-in Manager. See Release History Everything ok? No menu You've booted up Maya, loaded the plug-in via the Plug-in Manager, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' A clue! Let's go deeper. import os modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = os . path . join ( modules_path , \"Ragdoll-Maya-2021_11_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here . FAQ What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2022 What are my licensing options? See Pricing . What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? The simulation gracefully pauses until you revisit the last simulated frame. See the Frameskip Method attribute on the rdSolver node for another option, Ignore . This will continue simulating, and ignore any skipped frames. Good for real-time playback with audio. Can I use Rez? Yes, the only environment variable needed for Rez is MAYA_MODULE_PATH , such as: env [ \"MAYA_MODULE_PATH\" ] . append ( \" {root} \" ) Where the Ragdoll-2021_07_28 folder and Ragdoll-2021_07_28.mod file resides at {root} . Why not use nHair for overlapping animation? Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance. Limitations As of Ragdoll 2022.03.15 these are the current known limitations of Ragdoll. No known limitations as of 2022.02.20","title":"Download"},{"location":"download/#install","text":"Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS On MacOS, installation and upgrades are done in the same fashion. Copy the contents of /modules into /Users/Shared/Autodesk/modules/maya Restart Maya You should end up with something like this. /Users/Shared/Autodesk/modules/maya/Ragdoll-2021_11_15.mod The plug-in is now available via the Plug-in Manager. See Release History Everything ok? No menu You've booted up Maya, loaded the plug-in via the Plug-in Manager, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' A clue! Let's go deeper. import os modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = os . path . join ( modules_path , \"Ragdoll-Maya-2021_11_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here .","title":"Install"},{"location":"download/#faq","text":"What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2022 What are my licensing options? See Pricing . What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? The simulation gracefully pauses until you revisit the last simulated frame. See the Frameskip Method attribute on the rdSolver node for another option, Ignore . This will continue simulating, and ignore any skipped frames. Good for real-time playback with audio. Can I use Rez? Yes, the only environment variable needed for Rez is MAYA_MODULE_PATH , such as: env [ \"MAYA_MODULE_PATH\" ] . append ( \" {root} \" ) Where the Ragdoll-2021_07_28 folder and Ragdoll-2021_07_28.mod file resides at {root} . Why not use nHair for overlapping animation? Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance.","title":"FAQ"},{"location":"download/#limitations","text":"As of Ragdoll 2022.03.15 these are the current known limitations of Ragdoll. No known limitations as of 2022.02.20","title":"Limitations"},{"location":"examples/","text":"Examples Download and have a go! 6.78 mb Example 1 | Just a Girl An example of hair simulation with Ragdoll. Download 2.93 mb Example 2 | mGirl An example of cloth simulation with Ragdoll. Download 2.77 mb Example 3 | Muscle An example of muscle simulation with Ragdoll. Download 1.18 mb Example 4 | Overview Some basic object types to fool around with. Download 0.16 mb Example 5 | Parkour An animated Ragdoll \"parkour\" character. Download 4.15 mb Example 6 | mHair Basic character setup with basic hair controls. Download 0.44 mb Example 7 | Mechanical An accurate mechanical contraption. Download 0.40 mb Example 8 | Driving A late night drive on a busy country road. Download 0.05 mb Example 9 | Dynamic Control A regular animation control. With dynamics! Download 2.91 mb Example 10 | Dance, Baby Fool around with guide strength to affect this dance performance! Download 0.24 mb Example 11 | Slowmo Manipulate time with the timeMultiplier attribute. Download","title":"Examples"},{"location":"examples/#examples","text":"Download and have a go! 6.78 mb","title":"Examples"},{"location":"features/","text":"No pre-roll needed No rigging needed Rewind & Resume Frameskip Protection Cycle Protection","title":"Features"},{"location":"floating-licence/","text":"Congratulations on your purchase of a floating licence for Ragdoll Dynamics ! Overview This page will help you get set-up with a licence server, on-premise, and instruct Ragdoll to \"lease\" a licence from it. The server itself can run on any machine and any platform, including Windows, Linux and MacOS, so long as it is accessible from the machine running Ragdoll. Windows, Linux and MacOS The server can run on a different operating system than your workstations. For example, a common scenario is having the server running on Linux and workstations run on a combination of Windows, MacOS and Linux. On each platform, the procedure is the same. Download the server software Optionally edit the configuration file Activate the server with your Product Key Start it up The server will need to remain running in order for Ragdoll to lease licences. Linux Here's a typical series of commands for an x64 system, look inside the .zip for alternative Linux-based platforms. Requirements Make sure you have unzip and wget at the ready, or use alternatives like curl and tar at your own leisure. mkdir turbofloat cd turbofloat wget https://files.ragdolldynamics.com/api/public/dl/hAlavAOP/TurboFloat-Server-Linux.zip wget https://files.ragdolldynamics.com/api/public/dl/6lMDDMdn/TurboActivate.dat unzip TurboFloat-Server-Linux.zip mv bin-linux/x64/turbofloatserver ./ chmod +x turbofloatserver ./turbofloatserver -a = \"YOUR-SERIAL-NUMBER\" ./turbofloatserver -x # Floating license server for Ragdoll Dynamics (TFS v4.4.4.0) You can optionally pass -silent after -x for less verbosity. No internet? The licence server can be activated offline. See Can I activate my server offline? From here, you'll likely want turbofloatserver -x called automatically on reboot, such that Ragdoll and Maya can lease licences from it. The exact procedure varies between Linux distributions and company preferences, so I won't go into details here except to say that systemd is a common option. More Details Installation Options Configuration Options Windows Here's what you need to do in order to run the licence server on the Windows platform. Download TurboFloat-Server-Windows.zip Inside of this file you will find this. Edit the .xml file with a port you would like to use. Port number Make note of this port number as you will need it later when connecting to it from Maya. 64-bit Server If you need a 32-bit version of the server, find the appropriate TurboFloat binaries here. https://wyday.com/download/ Activate Next we'll need to activate the server. Open a cmd.exe or PowerShell prompt and type in the following. TurboFloatServer.exe -a = \"YOUR-SERIAL-NUMBER\" There should be no output from the command, unless there's a problem. No internet? The licence server can be activated offline. See Can I activate my server offline? Now you're ready to launch the server! Start This next command will launch the server. TurboFloatServer.exe -x # Floating license server for Ragdoll Dynamics (TFS v4.4.3.0) Test This is a good place to test Ragdoll from within Maya, so scroll to the Maya section , test it out and then come back here to finish things up. All good? Great. Optional At this point, you can optionally have the server restart itself and run in the background by installing it as a \"service\". TurboFloatServer.exe -i # 2021-05-12, 07:47:26 <error>: OpenSCManager failed (5) To do that, you'll need to launch PowerShell/cmd as Administrator . # As Administrator TurboFloatServer.exe -i # 2021-05-12, 07:48:40 <notification>: Service installed successfully. From here you can try launching Ragdoll Dynamics in Maya to see whether it manages to successfully lease a licence. More Details Installation Options Configuration Options Maya With a licence server running, your next step is having Ragdoll connect to it. On each platform, the procedure is the same. Set RAGDOLL_FLOATING Load plug-in Example # From Python os . environ [ \"RAGDOLL_FLOATING\" ] = \"127.0.0.1:13\" cmds . loadPlugin ( \"ragdoll\" ) # From an environment like bash export RAGDOLL_FLOATING = 127 .0.0.1:13 maya The format of RAGDOLL_FLOATING is <ip-address>:<port-number> . Everything ok? Failed to initialise floating licence If this message appears in your Script Editor upon loading the plug-in, take a closer look at your Output Window on Windows or terminal on Unix. # Error: ragdoll._install_floating() - Failed to initialise floating licence, error code '1' # Could not load ragdollfloat.dll Windows users may experience this issue, which indicates a broken install. In your distribution, you should have seen both a ragdoll.mll and ragdollfloat.dll . Make sure this file exists, else contact us and we'll help you sort it. Python Just like with a node-locked licence, you can control the leasing of licences via Python. from ragdoll import licence # Activate this machine licence . request_lease () # Deactivate this machine licence . drop_lease () Troubleshooting Let's have a look at a few common errors and how to solve them. Failed to Save Activation Request This can happen when attempting to generate an activation request for offline activation. ./turbofloatserver -a = \"KWVT-U5RS-...\" -areq = \"/bad/path/request.xml\" # <error>: Failed to save the activation request file. # <error>: Error code 0x1. Contact support or your system administrator. The path given, in this case /bad/path/request.xml might not be writable. Try a different path. Failed to Load Product Details This can happen when attempting to activate a floating licence ./turbofloatserver -a = \"KWVT-U5RS-...\" # <error>: Failed to load the product details file. # <error>: Failed to load the settings. The turbofloatserver executable wasn't able to find the TurboActivate.dat file. This file should reside in the same folder as turbofloatserver and can be downloaded from here. https://files.ragdolldynamics.com/api/public/dl/6lMDDMdn/TurboActivate.dat FAQ Let's cover some common scenarios. How can I test connectivity between my machines? To test whether machine A is accessible from machine B, try ping . ping 10 .0.0.13 # Reply from 10.0.0.13: bytes=32 time=1ms TTL=117 Can I limit the internet access of my licence server? If you're in a secure network, you may want to limit the licence server to the least amount of external access. You can do so by \"whitelisting\" it in your firewall, using this URL and port number. url: https://wyday.com port: 443 More details here: https://wyday.com/limelm/help/turbofloat-server/ Can I activate my server offline? Lifetime licences, yes. Monthly licences, no. Like node-locked licences, the floating licence server can be activated without an internet connection to the machine running the server. The procedure is the same on each platform. Generate an activation request from the computer running the licence server Go to https://ragdolldynamics.com/offline Activate using the response from the same computer Here's how to generate the request. ./turbofloatserver -areq = \"~/ActivationRequest.xml\" -a = \"YOUR-SERIAL-NUMBER\" And here's how to apply the response. ./turbofloatserver -aresp = \"~/ActivationResponse.xml\" -a What happens when my server is offline? Leasing will attempt to connect for about 2 seconds until giving up. During that time, Maya may appear frozen. What happens when my server goes offline? Leasing is re-done once every 30 minutes. 30 minutes is the default value (see below), which means that if the server goes down whilst an artist is using it, the solver will be disabled within 30 minutes. The duration can be adjusted, however it is a balance since the time is also how long it takes for the server to free a lease as a result of a Maya crash. See What happens to a lease when Maya crashes? Can I change the port used by the server? Yes. The default port is 13 and can be edited via the TurboFloatServer-config.xml file residing in the same directory as the server executable. <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> ... <bind port= \"13\" /> ... </config> More Configuration Options Can I move my licence server to a different machine? Yes. To move a licence, you can deactivate it and then activate it again someplace else. TurboFloatServer -deact This will deactivate the server. The same can be done if your licence server is offline, by passing a filename to the command. TurboFloatServer -deact = \"deactivation_request.xml\" Open this file and paste the contents of it into the offline deactivation wizard here. https://ragdolldynamics.com/offline What if I have multiple serial numbers? Complete, Unlimited and Batch have their own serial numbers and each serial number needs its own server. Each server needs to be a physical machine, but can under certain circumstances be allowed to run within a virtual machine; contact us if this is you. Each server needs their own unique address. If they run on the same machine, you can assign a unique port number (see above ). From there, provide each of your clients with the full server address to the pool it should lease licences from. For example. # Render farm RAGDOLL_FLOATING = 10 .0.0.4:601 # Artist workstations RAGDOLL_FLOATING = 10 .0.0.4:602 Can I disable the splash screen? Yes. Consumers of floating licences generally won't need to manage licenses themselves, and so the startup dialog can be avoided altogether for a smoother experience when inside of Maya. export RAGDOLL_NO_STARTUP_DIALOG = 1 maya See Environment Variables for details What happens to a lease when Maya crashes? A lease is automatically dropped upon unloading the plug-in or shutting down Maya. In the event of a Maya crash, a lease will automatically drop after 30 minutes per default. The time can be edited via the configuration file; a lower time means more compute and file resources are consumed on the server, the lowest value is 30 seconds. <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> ... <lease length= \"30\" /> <!-- seconds --> ... </config> Can I fall back to a node-locked licence? Yes. Remove the RAGDOLL_FLOATING environment variable and reload the plug-in or restart Maya to attempt activation of a node-locked licence. Can I activate my server on a Virtual Machine? No. The server cannot distinguish between two virtual machines which would make it possible to activate an endless amount of them with their own duplicate pools of licences. Although the server cannot run on a VM, clients can . E.g. running Docker for testing in a continous-integration environment or automation for simulation baking or rendering etc. Can I monitor my licence server? Yes. With a logging level set to \"notification\", you'll get real-time output from the server whenever a lease is requested and dropped, including.. Time of event Expiry time IP Username PID (Process ID) The expiry is when the lease will be renewed. Normally not something you need to worry about, unless Maya crashes. This is then the time it'll take the server to realise the lease has been freed. <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> ... <log file= \"tfs-log.txt\" level= \"notification\" /> ... </config> 2021 -05-12, 11 :58:47 <notification>: New connection from IP: ::ffff:127.0.0.1 2021 -05-12, 11 :58:47 <notification>: New lease assigned ( marcus, 1 , IP = ::ffff:127.0.0.1, PID = 14328 ) . Expires: 2021 -05-12 11 :28:47 ( in UTC ) . Used / Total leases: 1 / 1 2021 -05-12, 11 :58:51 <notification>: New connection from IP: ::ffff:127.0.0.1 2021 -05-12, 11 :58:51 <notification>: Lease was released by client ( marcus, 1 , IP = ::ffff:127.0.0.1, PID = 14328 ) . Used / Total leases: 0 / 1 A Python and web interface to this will be part of a future release, but the formatting can be relied upon for building your own monitoring mechanism. What does the server say when a lease request is rejected? With level=\"notification\" it'll say this. 2021 -05-16, 14 :52:50 <notification>: License lease request rejected because no more free slots, numTotalLics = 9 , pkey = YOUR-SERIAL-NUMBER How do I run my server in the background using systemd? systemd is a common option for running background processes on Linux. Here's a quick run-down how to get turbofloatserver running with it. Prerequisities Make sure you can run turbofloatserver -x already Make note of the full path to your turbofloatserver , here we will assume /turbofloat Ok, with that out of the way, create a new file called /etc/systemd/system/turbofloat.service with the content below. turbofloat.service [Unit] Description=TurboFloat server for CI After=network.target [Service] Type=simple User=root WorkingDirectory=/root ExecStart=/turbofloat/turbofloatserver -x -s Restart=on-failure [Install] WantedBy=multi-user.target Replace with your Path Here we use /turbofloat/turbofloatserver -x -s but your path will likely be different! Now let's start it. systemctl start turbofloat You may need sudo Unless you are logged in as a root/administrator user, you may need to use sudo with this command. E.g. sudo systemctl If there are no complaints, we're set to have this automatically run in the background whenever the computer restarts. systemctl enable turbofloat And that's it. You should now have access to this server in the exact same way as you did when calling turbofloatserver -x manually.","title":"Floating licence"},{"location":"floating-licence/#overview","text":"This page will help you get set-up with a licence server, on-premise, and instruct Ragdoll to \"lease\" a licence from it. The server itself can run on any machine and any platform, including Windows, Linux and MacOS, so long as it is accessible from the machine running Ragdoll. Windows, Linux and MacOS The server can run on a different operating system than your workstations. For example, a common scenario is having the server running on Linux and workstations run on a combination of Windows, MacOS and Linux. On each platform, the procedure is the same. Download the server software Optionally edit the configuration file Activate the server with your Product Key Start it up The server will need to remain running in order for Ragdoll to lease licences.","title":"Overview"},{"location":"floating-licence/#linux","text":"Here's a typical series of commands for an x64 system, look inside the .zip for alternative Linux-based platforms. Requirements Make sure you have unzip and wget at the ready, or use alternatives like curl and tar at your own leisure. mkdir turbofloat cd turbofloat wget https://files.ragdolldynamics.com/api/public/dl/hAlavAOP/TurboFloat-Server-Linux.zip wget https://files.ragdolldynamics.com/api/public/dl/6lMDDMdn/TurboActivate.dat unzip TurboFloat-Server-Linux.zip mv bin-linux/x64/turbofloatserver ./ chmod +x turbofloatserver ./turbofloatserver -a = \"YOUR-SERIAL-NUMBER\" ./turbofloatserver -x # Floating license server for Ragdoll Dynamics (TFS v4.4.4.0) You can optionally pass -silent after -x for less verbosity. No internet? The licence server can be activated offline. See Can I activate my server offline? From here, you'll likely want turbofloatserver -x called automatically on reboot, such that Ragdoll and Maya can lease licences from it. The exact procedure varies between Linux distributions and company preferences, so I won't go into details here except to say that systemd is a common option. More Details Installation Options Configuration Options","title":"Linux"},{"location":"floating-licence/#windows","text":"Here's what you need to do in order to run the licence server on the Windows platform.","title":"Windows"},{"location":"floating-licence/#download","text":"TurboFloat-Server-Windows.zip Inside of this file you will find this. Edit the .xml file with a port you would like to use. Port number Make note of this port number as you will need it later when connecting to it from Maya. 64-bit Server If you need a 32-bit version of the server, find the appropriate TurboFloat binaries here. https://wyday.com/download/","title":"Download"},{"location":"floating-licence/#activate","text":"Next we'll need to activate the server. Open a cmd.exe or PowerShell prompt and type in the following. TurboFloatServer.exe -a = \"YOUR-SERIAL-NUMBER\" There should be no output from the command, unless there's a problem. No internet? The licence server can be activated offline. See Can I activate my server offline? Now you're ready to launch the server!","title":"Activate"},{"location":"floating-licence/#start","text":"This next command will launch the server. TurboFloatServer.exe -x # Floating license server for Ragdoll Dynamics (TFS v4.4.3.0) Test This is a good place to test Ragdoll from within Maya, so scroll to the Maya section , test it out and then come back here to finish things up. All good? Great. Optional At this point, you can optionally have the server restart itself and run in the background by installing it as a \"service\". TurboFloatServer.exe -i # 2021-05-12, 07:47:26 <error>: OpenSCManager failed (5) To do that, you'll need to launch PowerShell/cmd as Administrator . # As Administrator TurboFloatServer.exe -i # 2021-05-12, 07:48:40 <notification>: Service installed successfully. From here you can try launching Ragdoll Dynamics in Maya to see whether it manages to successfully lease a licence. More Details Installation Options Configuration Options","title":"Start"},{"location":"floating-licence/#maya","text":"With a licence server running, your next step is having Ragdoll connect to it. On each platform, the procedure is the same. Set RAGDOLL_FLOATING Load plug-in Example # From Python os . environ [ \"RAGDOLL_FLOATING\" ] = \"127.0.0.1:13\" cmds . loadPlugin ( \"ragdoll\" ) # From an environment like bash export RAGDOLL_FLOATING = 127 .0.0.1:13 maya The format of RAGDOLL_FLOATING is <ip-address>:<port-number> . Everything ok? Failed to initialise floating licence If this message appears in your Script Editor upon loading the plug-in, take a closer look at your Output Window on Windows or terminal on Unix. # Error: ragdoll._install_floating() - Failed to initialise floating licence, error code '1' # Could not load ragdollfloat.dll Windows users may experience this issue, which indicates a broken install. In your distribution, you should have seen both a ragdoll.mll and ragdollfloat.dll . Make sure this file exists, else contact us and we'll help you sort it.","title":"Maya"},{"location":"floating-licence/#python","text":"Just like with a node-locked licence, you can control the leasing of licences via Python. from ragdoll import licence # Activate this machine licence . request_lease () # Deactivate this machine licence . drop_lease ()","title":"Python"},{"location":"floating-licence/#troubleshooting","text":"Let's have a look at a few common errors and how to solve them.","title":"Troubleshooting"},{"location":"floating-licence/#failed-to-save-activation-request","text":"This can happen when attempting to generate an activation request for offline activation. ./turbofloatserver -a = \"KWVT-U5RS-...\" -areq = \"/bad/path/request.xml\" # <error>: Failed to save the activation request file. # <error>: Error code 0x1. Contact support or your system administrator. The path given, in this case /bad/path/request.xml might not be writable. Try a different path.","title":"Failed to Save Activation Request"},{"location":"floating-licence/#failed-to-load-product-details","text":"This can happen when attempting to activate a floating licence ./turbofloatserver -a = \"KWVT-U5RS-...\" # <error>: Failed to load the product details file. # <error>: Failed to load the settings. The turbofloatserver executable wasn't able to find the TurboActivate.dat file. This file should reside in the same folder as turbofloatserver and can be downloaded from here. https://files.ragdolldynamics.com/api/public/dl/6lMDDMdn/TurboActivate.dat","title":"Failed to Load Product Details"},{"location":"floating-licence/#faq","text":"Let's cover some common scenarios.","title":"FAQ"},{"location":"floating-licence/#how-can-i-test-connectivity-between-my-machines","text":"To test whether machine A is accessible from machine B, try ping . ping 10 .0.0.13 # Reply from 10.0.0.13: bytes=32 time=1ms TTL=117","title":"How can I test connectivity between my machines?"},{"location":"floating-licence/#can-i-limit-the-internet-access-of-my-licence-server","text":"If you're in a secure network, you may want to limit the licence server to the least amount of external access. You can do so by \"whitelisting\" it in your firewall, using this URL and port number. url: https://wyday.com port: 443 More details here: https://wyday.com/limelm/help/turbofloat-server/","title":"Can I limit the internet access of my licence server?"},{"location":"floating-licence/#can-i-activate-my-server-offline","text":"Lifetime licences, yes. Monthly licences, no. Like node-locked licences, the floating licence server can be activated without an internet connection to the machine running the server. The procedure is the same on each platform. Generate an activation request from the computer running the licence server Go to https://ragdolldynamics.com/offline Activate using the response from the same computer Here's how to generate the request. ./turbofloatserver -areq = \"~/ActivationRequest.xml\" -a = \"YOUR-SERIAL-NUMBER\" And here's how to apply the response. ./turbofloatserver -aresp = \"~/ActivationResponse.xml\" -a","title":"Can I activate my server offline?"},{"location":"floating-licence/#what-happens-when-my-server-is-offline","text":"Leasing will attempt to connect for about 2 seconds until giving up. During that time, Maya may appear frozen.","title":"What happens when my server is offline?"},{"location":"floating-licence/#what-happens-when-my-server-goes-offline","text":"Leasing is re-done once every 30 minutes. 30 minutes is the default value (see below), which means that if the server goes down whilst an artist is using it, the solver will be disabled within 30 minutes. The duration can be adjusted, however it is a balance since the time is also how long it takes for the server to free a lease as a result of a Maya crash. See What happens to a lease when Maya crashes?","title":"What happens when my server goes offline?"},{"location":"floating-licence/#can-i-change-the-port-used-by-the-server","text":"Yes. The default port is 13 and can be edited via the TurboFloatServer-config.xml file residing in the same directory as the server executable. <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> ... <bind port= \"13\" /> ... </config> More Configuration Options","title":"Can I change the port used by the server?"},{"location":"floating-licence/#can-i-move-my-licence-server-to-a-different-machine","text":"Yes. To move a licence, you can deactivate it and then activate it again someplace else. TurboFloatServer -deact This will deactivate the server. The same can be done if your licence server is offline, by passing a filename to the command. TurboFloatServer -deact = \"deactivation_request.xml\" Open this file and paste the contents of it into the offline deactivation wizard here. https://ragdolldynamics.com/offline","title":"Can I move my licence server to a different machine?"},{"location":"floating-licence/#what-if-i-have-multiple-serial-numbers","text":"Complete, Unlimited and Batch have their own serial numbers and each serial number needs its own server. Each server needs to be a physical machine, but can under certain circumstances be allowed to run within a virtual machine; contact us if this is you. Each server needs their own unique address. If they run on the same machine, you can assign a unique port number (see above ). From there, provide each of your clients with the full server address to the pool it should lease licences from. For example. # Render farm RAGDOLL_FLOATING = 10 .0.0.4:601 # Artist workstations RAGDOLL_FLOATING = 10 .0.0.4:602","title":"What if I have multiple serial numbers?"},{"location":"floating-licence/#can-i-disable-the-splash-screen","text":"Yes. Consumers of floating licences generally won't need to manage licenses themselves, and so the startup dialog can be avoided altogether for a smoother experience when inside of Maya. export RAGDOLL_NO_STARTUP_DIALOG = 1 maya See Environment Variables for details","title":"Can I disable the splash screen?"},{"location":"floating-licence/#what-happens-to-a-lease-when-maya-crashes","text":"A lease is automatically dropped upon unloading the plug-in or shutting down Maya. In the event of a Maya crash, a lease will automatically drop after 30 minutes per default. The time can be edited via the configuration file; a lower time means more compute and file resources are consumed on the server, the lowest value is 30 seconds. <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> ... <lease length= \"30\" /> <!-- seconds --> ... </config>","title":"What happens to a lease when Maya crashes?"},{"location":"floating-licence/#can-i-fall-back-to-a-node-locked-licence","text":"Yes. Remove the RAGDOLL_FLOATING environment variable and reload the plug-in or restart Maya to attempt activation of a node-locked licence.","title":"Can I fall back to a node-locked licence?"},{"location":"floating-licence/#can-i-activate-my-server-on-a-virtual-machine","text":"No. The server cannot distinguish between two virtual machines which would make it possible to activate an endless amount of them with their own duplicate pools of licences. Although the server cannot run on a VM, clients can . E.g. running Docker for testing in a continous-integration environment or automation for simulation baking or rendering etc.","title":"Can I activate my server on a Virtual Machine?"},{"location":"floating-licence/#can-i-monitor-my-licence-server","text":"Yes. With a logging level set to \"notification\", you'll get real-time output from the server whenever a lease is requested and dropped, including.. Time of event Expiry time IP Username PID (Process ID) The expiry is when the lease will be renewed. Normally not something you need to worry about, unless Maya crashes. This is then the time it'll take the server to realise the lease has been freed. <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> ... <log file= \"tfs-log.txt\" level= \"notification\" /> ... </config> 2021 -05-12, 11 :58:47 <notification>: New connection from IP: ::ffff:127.0.0.1 2021 -05-12, 11 :58:47 <notification>: New lease assigned ( marcus, 1 , IP = ::ffff:127.0.0.1, PID = 14328 ) . Expires: 2021 -05-12 11 :28:47 ( in UTC ) . Used / Total leases: 1 / 1 2021 -05-12, 11 :58:51 <notification>: New connection from IP: ::ffff:127.0.0.1 2021 -05-12, 11 :58:51 <notification>: Lease was released by client ( marcus, 1 , IP = ::ffff:127.0.0.1, PID = 14328 ) . Used / Total leases: 0 / 1 A Python and web interface to this will be part of a future release, but the formatting can be relied upon for building your own monitoring mechanism.","title":"Can I monitor my licence server?"},{"location":"floating-licence/#what-does-the-server-say-when-a-lease-request-is-rejected","text":"With level=\"notification\" it'll say this. 2021 -05-16, 14 :52:50 <notification>: License lease request rejected because no more free slots, numTotalLics = 9 , pkey = YOUR-SERIAL-NUMBER","title":"What does the server say when a lease request is rejected?"},{"location":"floating-licence/#how-do-i-run-my-server-in-the-background-using-systemd","text":"systemd is a common option for running background processes on Linux. Here's a quick run-down how to get turbofloatserver running with it. Prerequisities Make sure you can run turbofloatserver -x already Make note of the full path to your turbofloatserver , here we will assume /turbofloat Ok, with that out of the way, create a new file called /etc/systemd/system/turbofloat.service with the content below. turbofloat.service [Unit] Description=TurboFloat server for CI After=network.target [Service] Type=simple User=root WorkingDirectory=/root ExecStart=/turbofloat/turbofloatserver -x -s Restart=on-failure [Install] WantedBy=multi-user.target Replace with your Path Here we use /turbofloat/turbofloatserver -x -s but your path will likely be different! Now let's start it. systemctl start turbofloat You may need sudo Unless you are logged in as a root/administrator user, you may need to use sudo with this command. E.g. sudo systemctl If there are no complaints, we're set to have this automatically run in the background whenever the computer restarts. systemctl enable turbofloat And that's it. You should now have access to this server in the exact same way as you did when calling turbofloatserver -x manually.","title":"How do I run my server in the background using systemd?"},{"location":"licencing/","text":"Overview Let's cover the basics.. Ragdoll requires a commercial licence for commercial use Ragdoll is free for non-commercial use Ragdoll is free for testing within a commercial environment About activation.. A commercial licence is activated with a Product Key Get a Product Key by purchasing a licence A non-commercial licence is activated automatically on launch A non-commercial licence expires 30 days after activation See also Managing Floating Licences Ragdoll Apprentice Once activated without a Product Key , Ragdoll enters \"Apprentice Mode\", and is limited to the following. Non-commercial projects Ragdoll Apprentice cannot be used in the same pipeline as commercial versions of Ragdoll Ragdoll Apprentice uses its own file format for Maya scenes See the Ragdoll EULA for details. FAQ Let's dive into specifics. How does it work? On first launch, Ragdoll will try and connect to the Ragdoll Licence Server and register your trial version. This version is node-locked to the particular machine you are on. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Enter your product key Click Activate Or if you prefer: from ragdoll import licence licence . activate ( key ) What happens when my trial expires? Any rdScene.enabled attribute will be set to False . Scenes will still load just fine and nothing else in your scene is affected. Once activated, the .enabled attribute will return to normal. Can I renew my trial licence? Possibly. Reach out to us if this is relevant to you. Can I open scenes made with the trial version in the commercial version? No. Files made with Ragdoll Apprentice will appear scrambled with a commercial version. Ragdoll Apprentice is however able to read files saved with a commercial version. Can I use my licence on more than one machine? Yes, for Ragdoll Personal No, for Ragdoll Complete, Unlimited and Batch With Ragdoll Personal, you can activate and use each Ragdoll licence on up to 3 machines. You just can't run a simulation on more than 1 machine per 1 licence at any given time, that could lead to suspension of the licence. Can I move a licence between two machines? Yes. You can hit the Deactivate button (which is same as the Activate button once you've activated) and the activation will be released. Do I need an internet connection to use Ragdoll? No. Activation can happen either offline or online, online happening from within Maya at the click of a button and offline being a 4-step process, see below . How do I use my floating licence? Floating licences have two parts. A self-hosted licence server The Ragdoll plug-in Whenever Ragdoll is loaded from Maya, it connects to your licence server in order to \"lease\" a licence. If you own 10 licences, then one of them will remain leased until the plug-in is unloaded from Maya. See also Managing Floating Licences Can I activate offline? Yes. See Offline Activation below. When exactly is internet required? A connection is made in one of two separate occasions. Calling ragdoll.licence.install() from Python On simulating any frame install() is typically called when the plug-in is loaded and menu is installed. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain. Can I manage my licence via Python? Sure can, see below. Licence API As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Activation for those without access to Internet licence . activation_request_to_file ( key , fname ) licence . activate_from_file ( fname ) # Deactivate whatever key is currently activated licence . deactivate () # Deactivate offline, to e.g. move a licence from one machine to another licence . deactivation_request_to_file ( fname ) # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" : \"Your-Key\" , # Is the current licence activated? \"isActivated\" : True , # Is the current licence a trial licence? \"isTrial\" : False , # Has the licence not been tampered with? \"isGenuine\" : True , # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" : True , # How many days until this trial expires? \"trialDays\" : 23 } Offline Activation Lifetime licences may be activated offline. What about monthly licences? These require an internet connection. Floating licences require internet only for the licence server itself, meaning your workstations can remain disconnected and protected. Node-locked licences require internet on the machine being activated. Launch the Offline Activation Wizard Copy/paste the activation request into https://ragdolldynamics.com/offline Click Activate Copy/paste the activation response into the Wizard Profit Offline Deactivation Similar to Activation, Deactivation happens via the Offline Deactivation Wizard. Launch the Offline Deactivation Wizard Copy/paste the deactivation request into https://ragdolldynamics.com/offline Click Deactivate Profit Caution Once you press Deactivate , then from Maya's perspective your licence will be deactivated. However, the licence server will not know of your deactivation until you paste the request into online deactivation page. This means that it is possible to deactivate a licence but forget to tell the licence server about it, which means you will not be able to reactivate it elsewhere. If this happens, reach out to support@ragdolldynamics.com and we may manually deactivate it for you.","title":"Licencing"},{"location":"licencing/#overview","text":"Let's cover the basics.. Ragdoll requires a commercial licence for commercial use Ragdoll is free for non-commercial use Ragdoll is free for testing within a commercial environment About activation.. A commercial licence is activated with a Product Key Get a Product Key by purchasing a licence A non-commercial licence is activated automatically on launch A non-commercial licence expires 30 days after activation See also Managing Floating Licences","title":"Overview"},{"location":"licencing/#ragdoll-apprentice","text":"Once activated without a Product Key , Ragdoll enters \"Apprentice Mode\", and is limited to the following. Non-commercial projects Ragdoll Apprentice cannot be used in the same pipeline as commercial versions of Ragdoll Ragdoll Apprentice uses its own file format for Maya scenes See the Ragdoll EULA for details.","title":"Ragdoll Apprentice"},{"location":"licencing/#faq","text":"Let's dive into specifics.","title":"FAQ"},{"location":"licencing/#how-does-it-work","text":"On first launch, Ragdoll will try and connect to the Ragdoll Licence Server and register your trial version. This version is node-locked to the particular machine you are on. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Enter your product key Click Activate Or if you prefer: from ragdoll import licence licence . activate ( key )","title":"How does it work?"},{"location":"licencing/#what-happens-when-my-trial-expires","text":"Any rdScene.enabled attribute will be set to False . Scenes will still load just fine and nothing else in your scene is affected. Once activated, the .enabled attribute will return to normal.","title":"What happens when my trial expires?"},{"location":"licencing/#can-i-renew-my-trial-licence","text":"Possibly. Reach out to us if this is relevant to you.","title":"Can I renew my trial licence?"},{"location":"licencing/#can-i-open-scenes-made-with-the-trial-version-in-the-commercial-version","text":"No. Files made with Ragdoll Apprentice will appear scrambled with a commercial version. Ragdoll Apprentice is however able to read files saved with a commercial version.","title":"Can I open scenes made with the trial version in the commercial version?"},{"location":"licencing/#can-i-use-my-licence-on-more-than-one-machine","text":"Yes, for Ragdoll Personal No, for Ragdoll Complete, Unlimited and Batch With Ragdoll Personal, you can activate and use each Ragdoll licence on up to 3 machines. You just can't run a simulation on more than 1 machine per 1 licence at any given time, that could lead to suspension of the licence.","title":"Can I use my licence on more than one machine?"},{"location":"licencing/#can-i-move-a-licence-between-two-machines","text":"Yes. You can hit the Deactivate button (which is same as the Activate button once you've activated) and the activation will be released.","title":"Can I move a licence between two machines?"},{"location":"licencing/#do-i-need-an-internet-connection-to-use-ragdoll","text":"No. Activation can happen either offline or online, online happening from within Maya at the click of a button and offline being a 4-step process, see below .","title":"Do I need an internet connection to use Ragdoll?"},{"location":"licencing/#how-do-i-use-my-floating-licence","text":"Floating licences have two parts. A self-hosted licence server The Ragdoll plug-in Whenever Ragdoll is loaded from Maya, it connects to your licence server in order to \"lease\" a licence. If you own 10 licences, then one of them will remain leased until the plug-in is unloaded from Maya. See also Managing Floating Licences","title":"How do I use my floating licence?"},{"location":"licencing/#can-i-activate-offline","text":"Yes. See Offline Activation below.","title":"Can I activate offline?"},{"location":"licencing/#when-exactly-is-internet-required","text":"A connection is made in one of two separate occasions. Calling ragdoll.licence.install() from Python On simulating any frame install() is typically called when the plug-in is loaded and menu is installed. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain.","title":"When exactly is internet required?"},{"location":"licencing/#can-i-manage-my-licence-via-python","text":"Sure can, see below.","title":"Can I manage my licence via Python?"},{"location":"licencing/#licence-api","text":"As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Activation for those without access to Internet licence . activation_request_to_file ( key , fname ) licence . activate_from_file ( fname ) # Deactivate whatever key is currently activated licence . deactivate () # Deactivate offline, to e.g. move a licence from one machine to another licence . deactivation_request_to_file ( fname ) # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" : \"Your-Key\" , # Is the current licence activated? \"isActivated\" : True , # Is the current licence a trial licence? \"isTrial\" : False , # Has the licence not been tampered with? \"isGenuine\" : True , # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" : True , # How many days until this trial expires? \"trialDays\" : 23 }","title":"Licence API"},{"location":"licencing/#offline-activation","text":"Lifetime licences may be activated offline. What about monthly licences? These require an internet connection. Floating licences require internet only for the licence server itself, meaning your workstations can remain disconnected and protected. Node-locked licences require internet on the machine being activated. Launch the Offline Activation Wizard Copy/paste the activation request into https://ragdolldynamics.com/offline Click Activate Copy/paste the activation response into the Wizard Profit","title":"Offline Activation"},{"location":"licencing/#offline-deactivation","text":"Similar to Activation, Deactivation happens via the Offline Deactivation Wizard. Launch the Offline Deactivation Wizard Copy/paste the deactivation request into https://ragdolldynamics.com/offline Click Deactivate Profit Caution Once you press Deactivate , then from Maya's perspective your licence will be deactivated. However, the licence server will not know of your deactivation until you paste the request into online deactivation page. This means that it is possible to deactivate a licence but forget to tell the licence server about it, which means you will not be able to reactivate it elsewhere. If this happens, reach out to support@ragdolldynamics.com and we may manually deactivate it for you.","title":"Offline Deactivation"},{"location":"menu/","text":"All items found in the Ragdoll menu at the top of Maya's main window. Add menu items to your shelf with Ctrl + Shift + Click Overview Item Description Show Messages Display warnings and errors in the Message Board Export Physics Save physics to disk. Import Physics Load physics from disk. Replace Mesh Replace input of the 'Mesh' shape type with another polygonal or NURBS mesh. Edit Constraint Pivots Edit the parent and child pivots using native Maya transforms Reset Constraint Frames Reset constraint frames to their defaults Delete Physics Clear the Maya scene of anything related to Ragdoll. Ragdoll Explorer Explore the internals of the solver. Ragdoll Preferences Edit global Ragdoll preferences, like the scale at which Ragdoll draws things. Save Preferences Save Ragdoll preferences to disk. Reset Preferences Restore Ragdoll preferences to their default values. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though. Assign Assign marker to this node Assign and Connect Assign marker to this group of nodes Assign Environment Assign environment to this polygonal mesh. Group Group the selected markers Ungroup Ungroup the selected markers Move to Group Move selected markers to group Merge Solvers Merge two or more solvers into one. Extract Markers Extract markers into new solver. Move to Solver Move markers into existing solver. Assign Constraint Constrain the two selected markers Distance Constraint Constrain the distance between two markers Weld Constraint Constrain the position and orientation between two markers Pin Constraint Softly constrain the position and orientation of a marker in worldspace Mimic Constraint Generate a hierarchy of local soft pins Record Simulation Transfer simulation into animation Snap to Simulation Snap animation to simulation Manipulator Interactively edit the contents of a solver Auto Limit Automatically transfer locked rotate channels into Ragdoll limits Extract Simulation Extract simulation from markers Retarget Marker Change where to record the selected marker Reassign Marker Change the input to the selected marker Reparent Marker Change the parent of the selected marker Unparent Marker Remove the parent from the selected marker Untarget Marker Remove all output from the selected marker Reset Shape Reset shape settings based on new conditions. Reset Constraint Frames Reset constraint frames to their defaults Edit Constraint Frames Edit constraint frames manually Toggle Channel Box Attributes Expose (or unexpose) more attributes for your Markers Replace Mesh Replace input of the 'Mesh' shape type with another polygonal or NURBS mesh. Parent Marker Select the parent of this marker Child Markers Select the children of this marker Select Markers Select all markers in the scene. Select Groups Select all groups in the scene. Select Solvers Select all solvers in the scene. Create Lollipop Create a new lollipop for the selected marker. Cache Solver Cache the entire simulation of a solver Uncache Solver Remove the cache for a solver Snap to Sim Snap marked controls to simulation. Link Solver Simulate two or more solvers as one. Unlink Solver Simulate previously linked solvers separately. Air Create a field emulating air. Drag Create a field emulating air. Gravity Create a field emulating air. Newton Create a field emulating air. Radial Create a field emulating air. Turbulence Create a field emulating air. Uniform Create a field emulating air. Vortex Create a field emulating air. Volume Axis Create a field emulating air. Volume Curve Create a field emulating air. Use Selected as Source Emit forces the using selected Marker. Disconnect Source Stop using a marker as source of the selected field. Center of Mass Centroid Apply forces to the exact center of mass. Volumetric Centroid Apply forces throughout the volume of a Marker.","title":"Menu Reference"},{"location":"menu/#overview","text":"Item Description Show Messages Display warnings and errors in the Message Board Export Physics Save physics to disk. Import Physics Load physics from disk. Replace Mesh Replace input of the 'Mesh' shape type with another polygonal or NURBS mesh. Edit Constraint Pivots Edit the parent and child pivots using native Maya transforms Reset Constraint Frames Reset constraint frames to their defaults Delete Physics Clear the Maya scene of anything related to Ragdoll. Ragdoll Explorer Explore the internals of the solver. Ragdoll Preferences Edit global Ragdoll preferences, like the scale at which Ragdoll draws things. Save Preferences Save Ragdoll preferences to disk. Reset Preferences Restore Ragdoll preferences to their default values. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though. Assign Assign marker to this node Assign and Connect Assign marker to this group of nodes Assign Environment Assign environment to this polygonal mesh. Group Group the selected markers Ungroup Ungroup the selected markers Move to Group Move selected markers to group Merge Solvers Merge two or more solvers into one. Extract Markers Extract markers into new solver. Move to Solver Move markers into existing solver. Assign Constraint Constrain the two selected markers Distance Constraint Constrain the distance between two markers Weld Constraint Constrain the position and orientation between two markers Pin Constraint Softly constrain the position and orientation of a marker in worldspace Mimic Constraint Generate a hierarchy of local soft pins Record Simulation Transfer simulation into animation Snap to Simulation Snap animation to simulation Manipulator Interactively edit the contents of a solver Auto Limit Automatically transfer locked rotate channels into Ragdoll limits Extract Simulation Extract simulation from markers Retarget Marker Change where to record the selected marker Reassign Marker Change the input to the selected marker Reparent Marker Change the parent of the selected marker Unparent Marker Remove the parent from the selected marker Untarget Marker Remove all output from the selected marker Reset Shape Reset shape settings based on new conditions. Reset Constraint Frames Reset constraint frames to their defaults Edit Constraint Frames Edit constraint frames manually Toggle Channel Box Attributes Expose (or unexpose) more attributes for your Markers Replace Mesh Replace input of the 'Mesh' shape type with another polygonal or NURBS mesh. Parent Marker Select the parent of this marker Child Markers Select the children of this marker Select Markers Select all markers in the scene. Select Groups Select all groups in the scene. Select Solvers Select all solvers in the scene. Create Lollipop Create a new lollipop for the selected marker. Cache Solver Cache the entire simulation of a solver Uncache Solver Remove the cache for a solver Snap to Sim Snap marked controls to simulation. Link Solver Simulate two or more solvers as one. Unlink Solver Simulate previously linked solvers separately. Air Create a field emulating air. Drag Create a field emulating air. Gravity Create a field emulating air. Newton Create a field emulating air. Radial Create a field emulating air. Turbulence Create a field emulating air. Uniform Create a field emulating air. Vortex Create a field emulating air. Volume Axis Create a field emulating air. Volume Curve Create a field emulating air. Use Selected as Source Emit forces the using selected Marker. Disconnect Source Stop using a marker as source of the selected field. Center of Mass Centroid Apply forces to the exact center of mass. Volumetric Centroid Apply forces throughout the volume of a Marker.","title":"Overview"},{"location":"news/","text":"News Stay up to date with the latest improvements and fixes to Ragdoll. 2022.03.14 - Quality of Life 2022.02.28 - Environment 2022.02.14 - Fields 2022.02.01 - Quality of Life 2022.01.21 - Maintenance Release 2022.01.17 - Import and Export for Markers 2021.12.15 - Minor Tweaks 2021.12.12 - Interactive Manipulators 2021.11.15 - Animation Capture pt. 4/4 2021.10.25 - Animation Capture pt. \u00be 2021.10.07 - Animation Capture pt. 2/4 2021.09.27 - Animation Capture pt. \u00bc 2021.08.28 - New Tutorials 2021.08.06 - New Documentation 2021.07.27 - Launch 2021.07.15 - Launch Tweaks 2021.07.02 - Quality of Life 2021.06.10 - Telemetry 2021.06.07 - Minor Bugfixes 2021.05.17 - Floating Licence Support 2021.05.10 - Mimic 2021.04.28 - Solver Upgrade 2021.04.23 - No Limits and Improved Performance 2021.04.11 - JSON Import 2021.03.25 - Maya 2022 2021.03.23 - JSON Export 2021.03.11 - Localspace Simulation 2021.03.04 - Passive to Active Transitions 2021.03.01 - Automatic Initial State 2021.02.07 - Scale 2021.01.27 - Message Board 2021.01.17 - Hotfix 2021.01.15 - Dynamic Control 3.0 2021.01.14 - Multiplier Nodes 2021.01.04 - Licencing 2020.12.18 - Documentation 2020.12.07 - Dynamic Control Improvements 2020.12.01 - Character 2.0 2020.11.24 - Hotfix 2020.11.23 - Dynamic Control 2.0 2020.11.22 - Bugfixes 2020.11.17 - Splash Screen 2020.11.16 - Cached Playback 2020.11.10 - Multi-threading","title":"News"},{"location":"news/#news","text":"Stay up to date with the latest improvements and fixes to Ragdoll. 2022.03.14 - Quality of Life 2022.02.28 - Environment 2022.02.14 - Fields 2022.02.01 - Quality of Life 2022.01.21 - Maintenance Release 2022.01.17 - Import and Export for Markers 2021.12.15 - Minor Tweaks 2021.12.12 - Interactive Manipulators 2021.11.15 - Animation Capture pt. 4/4 2021.10.25 - Animation Capture pt. \u00be 2021.10.07 - Animation Capture pt. 2/4 2021.09.27 - Animation Capture pt. \u00bc 2021.08.28 - New Tutorials 2021.08.06 - New Documentation 2021.07.27 - Launch 2021.07.15 - Launch Tweaks 2021.07.02 - Quality of Life 2021.06.10 - Telemetry 2021.06.07 - Minor Bugfixes 2021.05.17 - Floating Licence Support 2021.05.10 - Mimic 2021.04.28 - Solver Upgrade 2021.04.23 - No Limits and Improved Performance 2021.04.11 - JSON Import 2021.03.25 - Maya 2022 2021.03.23 - JSON Export 2021.03.11 - Localspace Simulation 2021.03.04 - Passive to Active Transitions 2021.03.01 - Automatic Initial State 2021.02.07 - Scale 2021.01.27 - Message Board 2021.01.17 - Hotfix 2021.01.15 - Dynamic Control 3.0 2021.01.14 - Multiplier Nodes 2021.01.04 - Licencing 2020.12.18 - Documentation 2020.12.07 - Dynamic Control Improvements 2020.12.01 - Character 2.0 2020.11.24 - Hotfix 2020.11.23 - Dynamic Control 2.0 2020.11.22 - Bugfixes 2020.11.17 - Splash Screen 2020.11.16 - Cached Playback 2020.11.10 - Multi-threading","title":"News"},{"location":"no-javascript/","text":"Got'cha! You've just been redirected from a JavaScript-heavy landing page because your browser won't permit JavaScript. Continue Try again","title":"No javascript"},{"location":"nodes/","text":"Detailed information about all of Ragdoll's custom nodes along with the most commonly used attributes. For full attribute reference, see the link at the bottom of each node type, such as rdRigid . Each Ragdoll node starts with rd , e.g. rdRigid Scene Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Parallelism Ragdoll scenes support both scene-level parallelism and node-level parallelism. Scene-level parallelism happens when there are more than one Ragdoll scene present, each scene is then run in parallel for improved performance. For that reason, prefer using as many scenes as possible, especially if they are unlikely to interact. Node-level Parallelism happens internally, whereby a single simulation is distributed over multiple threads. The behavior can be tuned via the rdScene.threadCount attribute. Keep this at 0 when your scenes are small, i.e. < 100 rigids. The overhead of splitting up a simulation outweighs the benefit unless there is a lot to split. You should notice a performance difference in either direction as you manipulate this attribute. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .groundRestitution Bounciness of the ground plane. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference Rigid A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Active Rigid pass data from Ragdoll to Maya Passive Rigid pass data from Maya to Ragdoll Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference Constraint A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference Control A placeholder for drawing a rigid under a different transform. This node is cosmetic only. It helps you spot the rigid and rigid orientation in the viewport for a standalone controller, like a Guide . It also draws the node with a special icon in the outliner. But that's about it! Full Reference Constraint Multiplier Multiply one or more attributes of one or more constraints . This node enables you to animate one attribute that affect many attributes, like Translate Guide Stiffness across an entire character or limb. Attribute Description Type .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping float .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness float .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping float .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness float .driveStrength Multiplier for rdConstraint.driveStrength float .limitStrength Multiplier for rdConstraint.limitStrength float .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping float .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness float .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping float .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness float Full Reference Rigid Multiplier Multiply one or more attributes of one or more rigids . This node enables you to animate one attribute that affect many attributes, like Air Density across an entire character or limb. Attribute Description Type .airDensity Multiplier for rdRigid.airDensity float .angularDamping Multiplier for rdRigid.angularDamping float .linearDamping Multiplier for rdRigid.linearDamping float Full Reference Other Notes on general concepts used in Ragdoll. Backwards Compatibility Default values never change, those written into the node type itself Initial values may change, those set during node-creation This means previously authored scenes will always behave the same, whilst still enabling new default values for future versions and future authored physics. Exclusive Nodes Ragdoll consists of a few new native types, like rdRigid and rdConstraint . During creation, Ragdoll may generate Maya-native types too, like multMatrix and composeMatrix . Those nodes are exclusive to Ragdoll and should be removed alongside them. This is managed via the so-called .exclusiveNodes attribute on each Ragdoll node type. User Attributes Whenever Ragdoll attributes appear on your original animation controls, they are referred to as \"user attributes\" by Ragdoll and tracked via the .userAttributes attribute on each Ragdoll node. These attributes are exclusive to Ragdoll and are removed alongside the Ragdoll node types they interact with.","title":"Nodes"},{"location":"nodes/#scene","text":"Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Parallelism Ragdoll scenes support both scene-level parallelism and node-level parallelism. Scene-level parallelism happens when there are more than one Ragdoll scene present, each scene is then run in parallel for improved performance. For that reason, prefer using as many scenes as possible, especially if they are unlikely to interact. Node-level Parallelism happens internally, whereby a single simulation is distributed over multiple threads. The behavior can be tuned via the rdScene.threadCount attribute. Keep this at 0 when your scenes are small, i.e. < 100 rigids. The overhead of splitting up a simulation outweighs the benefit unless there is a lot to split. You should notice a performance difference in either direction as you manipulate this attribute. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .groundRestitution Bounciness of the ground plane. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference","title":"Scene"},{"location":"nodes/#rigid","text":"A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Active Rigid pass data from Ragdoll to Maya Passive Rigid pass data from Maya to Ragdoll Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference","title":"Rigid"},{"location":"nodes/#constraint","text":"A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference","title":"Constraint"},{"location":"nodes/#control","text":"A placeholder for drawing a rigid under a different transform. This node is cosmetic only. It helps you spot the rigid and rigid orientation in the viewport for a standalone controller, like a Guide . It also draws the node with a special icon in the outliner. But that's about it! Full Reference","title":"Control"},{"location":"nodes/#constraint-multiplier","text":"Multiply one or more attributes of one or more constraints . This node enables you to animate one attribute that affect many attributes, like Translate Guide Stiffness across an entire character or limb. Attribute Description Type .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping float .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness float .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping float .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness float .driveStrength Multiplier for rdConstraint.driveStrength float .limitStrength Multiplier for rdConstraint.limitStrength float .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping float .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness float .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping float .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness float Full Reference","title":"Constraint Multiplier"},{"location":"nodes/#rigid-multiplier","text":"Multiply one or more attributes of one or more rigids . This node enables you to animate one attribute that affect many attributes, like Air Density across an entire character or limb. Attribute Description Type .airDensity Multiplier for rdRigid.airDensity float .angularDamping Multiplier for rdRigid.angularDamping float .linearDamping Multiplier for rdRigid.linearDamping float Full Reference","title":"Rigid Multiplier"},{"location":"nodes/#other","text":"Notes on general concepts used in Ragdoll.","title":"Other"},{"location":"nodes/#backwards-compatibility","text":"Default values never change, those written into the node type itself Initial values may change, those set during node-creation This means previously authored scenes will always behave the same, whilst still enabling new default values for future versions and future authored physics.","title":"Backwards Compatibility"},{"location":"nodes/#exclusive-nodes","text":"Ragdoll consists of a few new native types, like rdRigid and rdConstraint . During creation, Ragdoll may generate Maya-native types too, like multMatrix and composeMatrix . Those nodes are exclusive to Ragdoll and should be removed alongside them. This is managed via the so-called .exclusiveNodes attribute on each Ragdoll node type.","title":"Exclusive Nodes"},{"location":"nodes/#user-attributes","text":"Whenever Ragdoll attributes appear on your original animation controls, they are referred to as \"user attributes\" by Ragdoll and tracked via the .userAttributes attribute on each Ragdoll node. These attributes are exclusive to Ragdoll and are removed alongside the Ragdoll node types they interact with.","title":"User Attributes"},{"location":"open-source/","text":"MIT License Copyright \u00a9 2013-2020 Ryo Suzuki reputeless@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. https://github.com/skypjack/entt The MIT License (MIT) Copyright \u00a9 2017-2020 Michele Caini Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copy of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copy or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. https://github.com/bulletphysics/bullet3 The files in this repository are licensed under the zlib license, except for the files under 'Extras' and examples/ThirdPartyLibs. Bullet Continuous Collision Detection and Physics Library http://bulletphysics.org This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software. Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. This notice may not be removed or altered from any source distribution. NVIDIA PhysX SDK Copyright \u00a9 2019 NVIDIA Corporation. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of NVIDIA CORPORATION nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Open Dynamics Engine Copyright \u00a9 2001-2004, Russell L. Smith. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the names of ODE's copyright owner nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. https://github.com/stack-of-tasks/pinocchio BSD 2-Clause License Copyright \u00a9 2014-2020, CNRS Copyright \u00a9 2018-2020, INRIA All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. The views and conclusions contained in the software and documentation are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Pinocchio project. https://github.com/mosra/magnum Copyright \u00a9 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Vladim\u00edr Vondru\u0161 mosra@centrum.cz Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Open source"},{"location":"overview/","text":"Ragdoll is a real-time physics solver for Maya, similar the native nCloth and nHair solvers except it works on transforms rather than points. That makes it better equipt to integrate with your existing animation controls and doesn't require translating from points like people did in the 90's. This domain contains Ragdoll learning resources, for a more general overview see the Product Page . Where to Find Help? Depending on where you are and what you are looking for, one of these should fit the bill. /* Make thumbnails equal in size */ td img { max-width: 20px !important; } /* Prevent 2nd column from collapsing */ td:nth-child(2) a { white-space: nowrap; } # Source Description Chat Come join the party on Discord! Documentation Read about each command available to you in Maya Release Notes Every new release has examples of every new feature and squashed bug. Search Top of every page, you know what to do \u261d\ufe0f UI Help Find help without leaving Maya YouTube Videos Long-form walkthroughs and examples. Tutorials Long-form, written tutorials for learning Ragdoll from the ground up. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . Community Inspire and be inspired via the Ragdoll forums Support Get us involved and let's make some waves What's Next? Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch & Learn We've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page. Press Mentions of Ragdoll in the press. Date Source Title 2021-12-18 Escape Studios Ragdoll Dynamics for Maya 2021-09-21 80lv Development and Capabilities of Ragdoll Dynamics 2021-08-03 CGChannel Ragdoll Dynamics adds real-time physics to your Maya rigs 2021-07-30 CGPress Ragdoll Dynamics plugin for Maya 2021-07-28 80lv New Tool Lets You Animate With Physics in Real-Time Share your sources Know of anywhere else Ragdoll got mentioned? Let us know and we'll add it to the list! Contact Us","title":"Overview"},{"location":"overview/#where-to-find-help","text":"Depending on where you are and what you are looking for, one of these should fit the bill. /* Make thumbnails equal in size */ td img { max-width: 20px !important; } /* Prevent 2nd column from collapsing */ td:nth-child(2) a { white-space: nowrap; } # Source Description Chat Come join the party on Discord! Documentation Read about each command available to you in Maya Release Notes Every new release has examples of every new feature and squashed bug. Search Top of every page, you know what to do \u261d\ufe0f UI Help Find help without leaving Maya YouTube Videos Long-form walkthroughs and examples. Tutorials Long-form, written tutorials for learning Ragdoll from the ground up. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . Community Inspire and be inspired via the Ragdoll forums Support Get us involved and let's make some waves","title":"Where to Find Help?"},{"location":"overview/#whats-next","text":"Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch & Learn We've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"What's Next?"},{"location":"overview/#press","text":"Mentions of Ragdoll in the press. Date Source Title 2021-12-18 Escape Studios Ragdoll Dynamics for Maya 2021-09-21 80lv Development and Capabilities of Ragdoll Dynamics 2021-08-03 CGChannel Ragdoll Dynamics adds real-time physics to your Maya rigs 2021-07-30 CGPress Ragdoll Dynamics plugin for Maya 2021-07-28 80lv New Tool Lets You Animate With Physics in Real-Time Share your sources Know of anywhere else Ragdoll got mentioned? Let us know and we'll add it to the list! Contact Us","title":"Press"},{"location":"parallel/","text":"h3, h4 { padding-top: 50px; } Overview This guide describes the Maya features for accelerating playback and manipulation of animated scenes. It covers key concepts, shares best practices/usage tips, and lists known limitations that we aim to address in subsequent versions of Maya. This guide will be of interest to riggers, TDs, and plug-in authors wishing to take advantage of speed enhancements in Maya. If you would like an overview of related topics prior to reading this document, check out Supercharged Animation Performance in Maya 2016 . Key Concepts Starting from Maya 2016, Maya accelerates existing scenes by taking better advantage of your hardware. Unlike previous versions of Maya, which were limited to node-level parallelism, Maya now includes a mechanism for scene-level analysis and parallelization. For example, if your scene contains different characters that are unconstrained to one another, Maya can evaluate each character at the same time. Similarly, if your scene has a single complex character, it may be possible to evaluate rig sub-sections simultaneously. As you can imagine, the amount of parallelism depends on how your scene has been constructed. We will get back to this later. For now, let\u2019s focus on understanding key Maya evaluation concepts. At the heart of Maya\u2019s new evaluation architecture is an Evaluation Manager (EM) , responsible for handling the parallel-friendly representation of your scene. It maintains (and updates while the scene is edited) a few data structures (described below) used for efficient evaluation. The basic description of the scene is the Dependency Graph (DG) , consisting of DG nodes and connections. Nodes can have multiple attributes, and instances of these attributes on a specific node are called plugs . The DG connections are at the plug level, that is, two nodes can be connected to one another multiple ways through different plugs. Generally speaking, these connections represent data flow through the nodes as they evaluate. The following image shows an example DG: The dotted arrows inside the nodes represent an implicit computation dependency between an output attribute (on the right of the node) and the input attributes (on the left) being read to compute the result stored in the output. Before Parallel Maya, the DG was used to evaluate the scene using a Pull Model or Pull Evaluation . In this model, the data consumer (for instance the renderer) queries data from a given node. If the data is already evaluated, the consumer receives it directly. However, if the data is dirty , the node must first recompute it. It does so by pulling on the inputs required to compute the requested data. These inputs can also be dirty, in which case the evaluation request will then be forwarded to those dirty sources until it reaches the point where the data can be evaluated. The result then propagates back up in the graph, as the data is being \u201cpulled\u201d. This evaluation model relies on the ability to mark node data as invalid and therefore requiring new evaluation. This mechanism is known as the Dirty Propagation in which the invalid data status propagates to all downstream dependencies. The two main cases where dirty propagation happened in the Pull Evaluation model were when: the current time is changed: in this case, animation curves no longer have the right value which depends on the current time. Therefore, dirty propagation starts from each animation curve and the dirty status is propagated through the graph to reach everything depending on time, directly or indirectly. a value is changed on a node: whether the value is being changed through interactive manipulation or by a script, all data that depends on this new value must be recomputed. Therefore, dirty propagation starts from the edited plug and the dirty status is propagated through the graph to reach everything depending on the edited attribute. The Pull Evaluation model is not well suited for efficient parallel evaluation because of potential races that can arise from concurrent pull evaluations. To have tighter control over evaluation, Maya now uses a Forward Evaluation model to enable concurrent evaluation of multiple nodes. The general idea is simple: if all a node\u2019s dependencies have been evaluated before we evaluate the given node, pull evaluation will not be triggered when accessing evaluated node data, so evaluation remains contained in the node and is easier to run concurrently. All data dependencies between the nodes must be known to apply this evaluation model, and this information is captured in the Evaluation Graph (EG) , containing Evaluation Nodes . The EM uses dirty propagation to capture dependency information between the nodes, as well as which attributes are animated. EG connections represent node-level dependencies; destination nodes employ data from source nodes to correctly evaluate the scene. One important distinction between the DG and the EG is that the former uses plug -level connections, while the latter uses node -level connections. For example, the previous DG would create the following EG: A valid EG may not exist or become invalid for various reasons. For example, you have loaded a new scene and no EG has been built yet, or you have changed your scene, invalidating a prior EG. However, once the EG is built, unlike previous versions of Maya that propagated dirty on every frame, Maya now disables dirty propagation, reusing the EG until it becomes invalid. Tip If your scene contains expression nodes that use getAttr , the DG graph will be missing explicit dependencies. This results in an incorrect EG. Expression nodes also reduce the amount of parallelism in your scenes (see Scheduling Types for details). Consider removing getAttr from expressions and/or using utility nodes. While the EG holds the dependency information, it is not ready to be evaluated concurrently as-is. The EM must first create units of work that can be scheduled, that is, tasks . The main types of task created are: Individual Nodes : in the simplest case, an evaluation node can be computed directly. The task therefore consists of evaluating all of its animated attributes. Cycle Clusters : depending on the scene, the EG may contain circular node-level dependencies. If this is the case, the EM creates clusters that group together nodes in the same cycle. At scene evaluation time, nodes in cycle clusters are evaluated serially before continuing with other parallel parts of the EG, hence the evaluation of a cycle cluster consisting of a single task. While node-level cycles are perfectly legal, creating scenes with attribute-level cycles should be avoided as this is unsupported and leads to unspecified behavior. Custom Evaluator Clusters : the EM supports the concept of custom evaluators to override evaluation of sub-section of the EG. One example of this is the GPU override , which uses your graphics card\u2019s graphics processing unit (GPU) to accelerate deformations. The custom evaluators will create clusters for nodes for which they take responsibility, and the EM creates a task for each of these clusters. At scene evaluation time, control is passed to the specific custom evaluator when the task is up to be executed. This step, called partitioning , is where the EM creates the individual pieces of work that will have to be executed. Each of these tasks will map to a Scheduling Node in the Scheduling Graph (SG) , where connections represent dependencies between the tasks: The SG is an acyclic graph, otherwise it would be impossible to schedule nodes in a cycle since there would be no starting point for which all dependencies could be evaluated. In addition to the dependencies that come directly from the EG, the SG can have additional scheduling constraints to prevent concurrent evaluation of subsets of nodes (see Scheduling Types for details). Supported Evaluation Modes Starting in Maya 2016, 3 evaluation modes are supported: Mode What does it do? DG Uses the legacy Dependency Graph -based evaluation of your scene. This was the default evaluation mode prior to Maya 2016 Serial Evaluation Manager Serial mode. Uses the EG but limits scheduling to a single core. Serial mode is a troubleshooting mode to pinpoint the source of evaluation errors. Parallel Evaluation Manager Parallel mode. Uses the EG and schedules evaluation across all available cores. This mode is the new Maya default since 2016. When using either Serial or Parallel EM modes, you can also activate GPU Override to accelerate deformations on your GPU. You must be in Viewport 2.0 to use this feature (see GPU Override ). To switch between different modes, go to the Preferences window ( Windows > Settings/Preferences > Preferences > Animation ). You can also use the evaluationManager MEL/Python command; see documentation for supported options. To see the evaluation options that apply to your scene, turn on the Heads Up Display Evaluation options ( Display > Heads Up Display > Evaluation ). First Make it Right Then Make it Fast Before discussing how to make your Maya scene faster using Parallel evaluation, it is important to ensure that evaluation in DG and EM modes generates the same results. If you see different results in the viewport during animation (as compared to previous versions of Maya), or tests reveal numerical errors, it is critical to understand the cause of these errors. Errors may be due to an incorrect EG, threading related problems, or other issues. Below, we review Evaluation Graph Correctness and Thread Safety , two important concepts to understand errors. Evaluation Graph Correctness If you see evaluation errors, first test your scene in Serial evaluation mode (see Supported Evaluation Modes ). Serial evaluation mode uses the EM to build an EG of your scene, but limits evaluation to a single core to eliminate threading as the possible source of differences. Note that since Serial evaluation mode is provided for debugging, it has not been optimized for speed and scenes may run slower in Serial than in DG evaluation mode. This is expected. If transitioning to Serial evaluation eliminates errors, this suggests that differences are most likely due to threading-related issues. However, if errors persist (even after transitioning to Serial evaluation) this suggests that the EG is incorrect for your scene. There are a few possible reasons for this: Custom Plugins. If your scene uses custom plug-ins that rely on the mechanism provided by the MPxNode::setDependentsDirty function to manage attribute dirtying, this may be the source of problems. Plug-in authors sometimes use MPxNode::setDependentsDirty to avoid expensive calculations in MPxNode::compute by monitoring and/or altering dependencies and storing computed results for later re-use. Since the EM relies on dirty propagation to create the EG, any custom plug-in logic that alters dependencies may interfere with the construction of a correct EG. Furthermore, since the EM evaluation does not propagate dirty messages, any custom caching or computation in MPxNode::setDependentsDirty is not called while the EM is evaluating. If you suspect that your evaluation errors are related to custom plug-ins, temporarily remove the associated nodes from your scene and validate that both DG and Serial evaluation modes generate the same result. Once you have made sure this is the case, revisit the plug-in logic. The API Extensions section covers Maya SDK changes that will help you adapt plug-ins to Parallel evaluation. Another debugging option is to use \u201cscheduling type\u201d overrides to force custom nodes to be scheduled more conservatively. This approach enables the use of Parallel evaluation even if only some of the nodes are thread-safe. Scheduling types are described in more detail in the Thread Safety section. Errors in Autodesk Nodes. Although we have done our best to ensure that all out-of-the-box Autodesk Maya nodes correctly express dependencies, sometimes a scene uses nodes in an unexpected manner. If this is the case, we ask you make us aware of scenes where you encounter problems. We will do our best to address problems as quickly as possible. Thread Safety Prior to Maya 2016, evaluation was single-threaded and developers did not need to worry about making their code thread-safe. At each frame, evaluation was guaranteed to proceed serially and computation would finish for one node prior to moving onto another. This approach allowed for the caching of intermediate results in global memory and using external libraries without considering their ability to work correctly when called simultaneously from multiple threads. These guarantees no longer apply. Developers working in recent versions of Maya must update plug-ins to ensure correct behavior during concurrent evaluation. Two things to consider when updating plug-ins: Different instances of a node type should not share resources. Unmanaged shared resources can lead to evaluation errors since different nodes, of the same type, can have their compute() methods called at the same time. Avoid non thread-safe lazy evaluation. In the EM, evaluation is scheduled from predecessors to successors on a per-node basis. Once computation has been performed for predecessors, results are cached, and made available to successors via connections. Any attempt to perform non-thread safe lazy evaluation could return different answers to different successors or, depending on the nature of the bug, instabilities. Here\u2019s a concrete example for a simple node network consisting of 4 nodes: In this graph, evaluation first calculates outputs for Node1 (that is, Node1.A, Node1.B, Node1.C), followed by parallel evaluation of Nodes 2, 3, and 4 (that is, Read Node1.A to use in Node2, Read Node1.B to use in Node3, and so on). Knowing that making legacy code thread-safe requires time, we have added new scheduling types to provide control over how the EM schedule nodes. Scheduling types provide a straightforward migration path, so you do not need to hold off on performance improvements, just because a few nodes still need work. There are 4 scheduling types: Scheduling Type What are you telling the scheduler? Parallel Asserts that the node and all third-party libraries used by the node are thread-safe. The scheduler may evaluate any instances of this node at the same time as instances of other nodes without restriction. Serial Asserts it is safe to run this node with instances of other nodes. However, all nodes with this scheduling type should be executed sequentially within the same evaluation chain. Globally Serial Asserts it is safe to run this node with instances of other node types but only a single instance of this node type should be run at a time. Use this type if the node relies on static state, which could lead to unpredictable results if multiple node instances are simultaneously evaluated. The same restriction may apply if third-party libraries store state. Untrusted Asserts this node is not thread-safe and that no other nodes should be evaluated while an instance of this node is evaluated. Untrusted nodes are deferred as much as possible (that is, until there is nothing left to evaluate that does not depend on them), which can introduce costly synchronization. By default, nodes scheduled as Serial provide a middle ground between performance and stability/safety. In some cases, this is too permissive and nodes must be downgraded to GloballySerial or Untrusted. In other cases, some nodes can be promoted to Parallel . As you can imagine, the more parallelism supported by nodes in your graph, the higher level of concurrency you are likely to obtain. Tip When testing your plug-ins with Parallel Maya, a simple strategy is to schedule nodes with the most restrictive scheduling type (that is, Untrusted ), and then validate that evaluation produces correct results. Raise individual nodes to the next scheduling level, and repeat the experiment. There are three ways to alter the scheduling level of your nodes: Evaluation Toolkit. Use this tool to query or change the scheduling type of different node types. C++/Python API methods. Use the OpenMaya API to specify the desired node scheduling by overriding the MPxNode::schedulingType method. This function should return one of the enumerated values specified by MPxNode::schedulingType . See the Maya MPxNode class reference for more details. MEL/Python Commands. Use the evaluationManager command to change the scheduling type of nodes at runtime. Below, we illustrate how you can change the scheduling of scene transform nodes: Scheduling Type Command Parallel evaluationManager -nodeTypeParallel on \"transform\" Serial evaluationManager -nodeTypeSerialize on \"transform\" GloballySerial evaluationManager -nodeTypeGloballySerialize on \"transform\" Untrusted evaluationManager -nodeTypeUntrusted on \"transform\" The Evaluation Toolkit and MEL/Python Commands method to alter node scheduling level works using node type overrides. They add an override that applies to all nodes of a given type. Using C++/Python API methods and overriding the MPxNode::schedulingType function gives the flexibility to change the scheduling type for each node instance. For example, expression nodes are marked as globally serial if the expression outputs are a purely mathematical function of its inputs. The expression engine is not thread-safe so only one expression can run at a time, but it can run in parallel with any other nodes. However, if the expression uses unsafe commands (expressions could use any command to access any part of the scene), the node is marked as untrusted because nothing can run while the expression is evaluated. This changes the way scheduling types should be queried. Using the evaluationManager command with the above flags in query mode will return whether an override has been set on the node type, using either the Evaluation Toolkit or the MEL/Python commands. The Evaluation Toolkit window lets you query both the override type on the node type (which cannot vary from one node of the same type to the other), or the actual scheduling type used for a node when building the scheduling graph (which can change from one node instance to the other). Safe Mode On rare occasions you may notice that Maya switches from Parallel to Serial evaluation during manipulation or playback. This is due to Safe Mode, which attempts to trap errors that possibly lead to instabilities. If Maya detects that multiple threads are attempting to simultaneously access a single node instance, evaluation will be forced to Serial execution to prevent problems. Tip If Safe Mode forces your scene into Serial mode, the EM may not produce the expected incorrect results when manipulating. In such cases you can either disable the EM: cmds.evaluationManager(mode=\"off\") or disable EM-accelerated manipulation: cmds.evaluationManager(man=0) While Safe Mode exposes many problems, it cannot catch them all. Therefore, we have also developed a special Analysis Mode that performs a more thorough (and costly) check of your scene. Analysis mode is designed for riggers/TDs wishing to troubleshoot evaluation problems during rig creation. Avoid using Analysis Mode during animation since it will slow down your scene. Evaluation Graph Invalidation As previously described, the EG adds necessary node-level scheduling information to the DG. To make sure evaluation is correct, it\u2019s critical the EG always be up-to-date, reflecting the state of the scene. The process of detecting things that have changed and rebuilding the EG is referred to as graph invalidation . Different actions may invalidate the EG, including: Adding/removing nodes Changing the scenes transformation (DAG) hierarchy Adding/removing extension attributes Loading an empty scene or opening a new file Other, less obvious, actions include: Static animation curves . Although animation curves are time-dependent, DG evaluation treats curves with identical (static) keys as time-independent to avoid unnecessary calculations. The EG uses a similar optimization, excluding and avoiding scheduling of static animation curves. This keeps the EG compact, making it fast to build, schedule, and evaluate. A downside of this approach is that changes to static animation curves will cause the EG to become invalid; on time change Maya will rebuild the EG and determine if curves should be treated as time-dependent and added to the EG. Dirty propagation crossing the Evaluation Graph . The DG architecture allowed for implicit dependencies (that is, dependencies not expressed via connections), using them during dirty propagation. When dirty propagation is detected for these implicit dependencies, the EG will invalidate itself since this could signal the need to add new dependencies to the EG. Frequent graph invalidations may limit parallel evaluation performance gains or even slow it down (see Idle Actions ), since Maya requires DG dirty propagation and evaluation to rebuild the EG. To avoid unwanted graph rebuilds, consider adding 2 keys, each with slightly different values, on rig attributes that you expect to use frequently. You can also lock static channels to prevent creation of static animation curves during keying. We expect to continue tuning this area of Maya, with the goal of making the general case as interactive as possible. Tip You can use the controller command to identify objects that are used as animation sources in your scene. If the Include controllers in evaluation graph option is set (see Windows > Settings/Preferences > Preferences , then Settings > Animation ), the objects marked as controllers will automatically be added to the evaluation graph even if they are not animated yet. This allows Parallel evaluation for manipulation even if they have not yet been keyed. Idle Actions In this section, we discuss the different idle actions available in Maya that helps rebuild the EG without any intervention from the user. Prior to Maya 2019, only one idle action, the EG rebuild, was available, but it was not enabled by default. Since Maya 2019, we have added another idle action, the EG preparation for manipulation, and both of these are enabled by default. Here is a description of the idle actions: Idle Action Description EG Rebuild Builds the graph topology. This idle action is executed after a file load operation, or after a graph topology invalidation. EG Preparation for manipulation Partitions and schedules the graph. This idle action is executed after a graph rebuild (either manually or through the idle action), or after a partitioning invalidation. Tip You can use the evaluationManager command to change which idle actions are enabled. You can enable and disable both idle actions individually. Benefits To make use of the Parallel Evaluation and GPU deformation during manipulation, the EG needs to be properly built, partitioned and scheduled, otherwise it will revert to DG. These idle actions allow the EG to automatically build and be ready to use when needed, since they are triggered at file load and after graph invalidation. If you use Cached Playback , your cache automatically refills, too. This way, you can start playing from cache as soon as the scene is loaded or after you modify to the scene. Caveats In a typical frame evaluation, temporary values that are set on keyed attributes are restored to their original values, that is, the values on their associated curves. With the idle actions, this is an unwanted behavior, otherwise you would not be able to do any modifications to keyed attributes. To circumvent that issue, we had to add some special behaviougs One of these is the dirty propagation from stale plugs after an idle preparation for manipulation. When not in idle preparation for manipulation, this operation is done during the partitioning and scheduling phase. With idle preparation for manipulation, this operation is done at the next complete evaluation. Therefore, if you have many static curves, you might experience a slowdown on the first frame of playback. If you do frequent operations that invalidate the graph or partitioning, you may experience some slowdowns due to the graph always being rebuilt. In such cases, it is advised that you disable the offending idle action until you are done. Custom Evaluators In this section, we describe mechanisms to perform targeted evaluation of node sub-graphs. This approach is used by Maya to accelerate deformations on the GPU and to catch evaluation errors for scenes with specific nodes. Maya 2017 also introduced new Open API extensions , allowing user-defined custom evaluators. Tip Use the evaluator command to query the available/active evaluators or modify currently active evaluators. Some evaluators support using the nodeType flag to filter out or include nodes of certain types. Query the info flag on the evaluator for more information on what it supports. # Returns a list of all currently available evaluators. import maya.cmds as cmds cmds . evaluator ( query = True ) # Result: [u'invisibility', u 'frozen' , ... u 'transformFlattening' , u 'pruneRoots' ] # # Returns a list of all currently enabled evaluators. cmds . evaluator ( query = True , enable = True ) # Result: [u'invisibility', u 'timeEditorCurveEvaluator' , ... u 'transformFlattening' , u 'pruneRoots' ] # Note: Enabling or disabling custom evaluators only applies to the current Maya session: the state is not saved in the scene nor in the user preferences. The same applies to configuration done using the evaluator command and the configuration flag. GPU Override Maya contains a custom deformer evaluator that accelerates deformations in Viewport 2.0 by targeting deformation to the GPU. GPUs are ideally suited to tackle problems such as mesh deformations that require the same operations on streams of vertex and normal data. We have included GPU implementations for several of the most commonly-used deformers in animated scenes: skinCluster , blendShape , cluster , tweak , groupParts , softMod , deltaMush , lattice , nonLinear and tension . Unlike Maya\u2019s previous deformer stack that performed deformations on the CPU and subsequently sent deformed geometry to the graphics card for rendering, the GPU override sends undeformed geometry to the graphics card, performs deformations in OpenCL and then hands off the data to Viewport 2.0 for rendering without read-back overhead. We have observed substantial speed improvements from this approach in scenes with dense geometry. Even if your scene uses only supported deformers, GPU override may not be enabled due to the use of unsupported node features in your scene. For example, with the exception of softMod, there is no support for incomplete group components. Additional deformer-specific limitations are listed below: Deformer Limitation(s) skinCluster The following attribute values are ignored: - bindMethod - bindPose - bindVolume - dropOff - heatmapFalloff - influenceColor - lockWeights - maintainMaxInfluences - maxInfluences - nurbsSamples - paintTrans - smoothness - weightDistribution blendShape The following attribute values are ignored: - baseOrigin - icon - normalizationId - origin - parallelBlender - supportNegativeWeights - targetOrigin - topologyCheck cluster n/a tweak Only relative mode is supported. relativeTweak must be set to 1. groupParts n/a softMod Only volume falloff is supported when distance cache is disabled Falloff must occur on all axes Partial resolution must be disabled deltaMush n/a lattice n/a nonLinear n/a tension n/a A few other reasons that can prevent GPU override from accelerating your scene: Meshes not sufficiently dense. Unless meshes have a large number of vertices, it is still faster to perform deformations on the CPU. This is due to the driver-specific overhead incurred when sending data to the GPU for processing. For deformations to happen on the GPU, your mesh needs over 500/2000 vertices, on AMD/NVIDIA hardware respectively. Use the MAYA_OPENCL_DEFORMER_MIN_VERTS environment variable to change the threshold. Setting the value to 0 sends all meshes connected to supported deformation chains to the GPU. Downstream graph nodes required deformed mesh results. Since GPU read-back is a known bottleneck in GPGPU, no node, script, or Viewport can read the mesh data computed by the GPU override. This means that GPU override is unable to accelerate portions of the EG upstream of deformation nodes, such as follicle or pointOnPolyConstraint, that require information about the deformed mesh. We will re-examine this limitation as software/hardware capabilities mature. When diagnosing GPU Override problems, this situation may appear as an unsupported fan-out pattern. See deformerEvaluator command, below, for details. Animated Topology. If your scene animates the number of mesh edges, vertices, and/or faces during playback, corresponding deformation chains are removed from the GPU deformation path. Maya Catmull-Clark Smooth Mesh Preview is used. We have included acceleration for OpenSubDiv (OSD)-based smooth mesh preview, however there is no support for Maya\u2019s legacy Catmull-Clark. To take advantage of OSD OpenCL acceleration, select OpenSubDiv Catmull-Clark as the subdivision method and make sure that OpenCL Acceleration is selected in the OpenSubDiv controls. Unsupported streams are found. Depending on which drawing mode you select for your geometry (for example, shrunken faces, hedge-hog normals, and so on) and the material assigned, Maya must allocate and send different streams of data to the graphics card. Since we have focused our efforts on common settings used in production, GPU override does not currently handle all stream combinations. If meshes fail to accelerate due to unsupported streams, change display modes and/or update the geometry material. Back face culling is enabled. Driver-related issues. We are aware of various hardware issues related to driver support/stability for OpenCL. To maximize Maya\u2019s stability, we have disabled GPU Override in the cases that will lead to problems. We expect to continue to eliminate restrictions in the future and are actively working with hardware vendors to address detected driver problems. You can also increase support for new custom/proprietary deformers by using new API extensions (refer to Custom GPU Deformers for details). If you enable GPU Override and the HUD reports Enabled (0 k) , this indicates that no deformations are happening on the GPU. There could be several reasons for this, such as those mentioned above. To troubleshoot factors that limit the use of GPU override for your particular scene, use the deformerEvaluator command. Supported options include: Command What does it do? deformerEvaluator Prints the chain or each selected node is not supported. deformerEvaluator -chains Prints all active deformation chains. deformerEvaluator -meshes Prints a chain for each mesh or a reason if it is not supported. Dynamics Evaluator Starting in Maya 2017, the dynamics evaluator fully supports parallel evaluation of scenes with Nucleus (nCloth, nHair, nParticles), Bullet, and Bifrost dynamics. Legacy dynamics nodes (for example, particles, fluids) remain unsupported. If the dynamics evaluator finds unsupported node types in the EG, Maya will revert to DG-based evaluation. The dynamics evaluator also manages the tricky computation necessary for correct scene evaluation. This is one of the ways custom evaluators can be used to change Maya\u2019s default evaluation behavior. The dynamics evaluator supports several configuration flags to control its behavior. Flag What does it do? disablingNodes specifies the set of nodes that will force the dynamics evaluator to disable the EM. Valid values are: legacy2016 , unsupported , and none . handledNodes specifies the set of nodes that are going to be captured by the dynamics evaluator and scheduled in clusters that it will manage. Valid values are: dynamics and none . action specifies how the dynamics evaluator will handle its nodes. Valid values are: none , evaluate , and freeze . In Maya 2017, the default configuration corresponds to: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=unsupported\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=dynamics\") cmds.evaluator(name=\"dynamics\", c=\"action=evaluate\") where unsupported (that is, blacklisted) nodes are: collisionModel dynController dynGlobals dynHolder fluidEmitter fluidShape membrane particle (unless also a nBase) rigidNode rigidSolver spring nodes derived from the above This configuration disables evaluation if any unsupported nodes are encountered, and performs evaluation for the other handled nodes in the scene. To revert to Maya 2016 / 2016 Extension 2 behavior, use the configuration: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=legacy2016\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=none\") cmds.evaluator(name=\"dynamics\", c=\"action=none\") where unsupported (that is, blacklisted) nodes are: field fluidShape geoConnector nucleus particle pointEmitter rigidSolver rigidBody nodes derived from the above Tip To get a list of nodes that cause the dynamics evaluator to disable the EM in its present configuration, use the following command: cmds.evaluator(name=\"dynamics\", valueName=\"disabledNodes\", query=True) You can configure the dynamics evaluator to ignore unsupported nodes. If you want to try Parallel evaluation on a scene where it is disabled because of unsupported node types, use the following commands: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=none\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=dynamics\") cmds.evaluator(name=\"dynamics\", c=\"action=evaluate\") Note: Using the dynamics evaluator on unsupported nodes may cause evaluation problems and/or application crashes; this is unsupported behavior. Proceed with caution. Tip If you want the dynamics evaluator to skip evaluation of all dynamics nodes in the scene, use the following commands: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=unsupported\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=dynamics\") cmds.evaluator(name=\"dynamics\", c=\"action=freeze\") This can be useful to quickly disable dynamics when the simulation impacts animation performance. Dynamics simulation results are very sensitive to evaluation order, which may differ between DG and EM-based evaluation. Even for DG-based evaluation, evaluation order may depend on multiple factors. For example, in DG-mode when rendering simulation results to the Viewport, the evaluation order may be different than when simulation is performed in \u2018headless mode\u2019. Though EM-based evaluation results are not guaranteed to be identical to DG-based, evaluation order is consistent; once the evaluation order is scheduled by the EM, it will remain consistent regardless of whether results are rendered or Maya is used in batch. This same principle applies to non-dynamics nodes that are order-dependent. Reference Evaluator When a reference is unloaded it leaves several nodes in the scene representing reference edits to preserve. Though these nodes may inherit animation from upstream nodes, they do not contribute to what is rendered and can be safely ignored during evaluation. The reference evaluator ensures all such nodes are skipped during evaluation. Invisibility Evaluator Toggling scene object visibility is a critical artist workflow used to reduce visual clutter and accelerate performance. To bring this workflow to parallel evaluation, Maya 2017 and above includes the invisibility evaluator, whose goal is to skip evaluation of any node that does not contribute to a visible object. The invisibility evaluator will skip evaluation of DAG nodes meeting any of the below criteria: visibility attribute is false. intermediateObject attribute is true. overrideEnabled attribute is true and overrideVisibility attribute is false. node belongs to a display layer whose enabled attribute is true and visibility attribute is false. every instance path contains at least one node for which one of the above statements are true. As of Maya 2018, the invisibility evaluator supports the isolate select method of hiding objects. If there is only a single Viewport, and it has one or more objects isolated, then all of the other, unrelated objects are considered invisible by the evaluator. There is also support in Maya (2018 and up) for the animated attribute on expression nodes. When this attribute is set to 1, the expression node is not skipped by the invisibility evaluator, even if only invisible objects are connected to it. Note: The default value of the animated attribute is 1, so in an expression-heavy scene you may see a slowdown from Maya 2017 to Maya 2018. To restore performance, run the script below to disable this attribute on all expression nodes. (It is only required when the expression has some sort of side-effect external to the connections, such as printing a message or checking a cache file size.) for node in cmds.ls( type='expression' ): cmds.setAttr( '{}.animated'.format(node), 0 ) Tip: The invisibility evaluator is off by default in Maya 2017. Use the Evaluation Toolkit or this: cmds.evaluator(enable=True, name='invisibility') to enable the evaluator. The invisibility evaluator only considers static visibility; nodes with animated visibility are still evaluated, even if nodes meet the above criteria. If nodes are in a cycle, all cycle nodes must be considered invisible for evaluation to be skipped. Lastly, if a node is instanced and has at least one visible path upward, then all upward paths will be evaluated. Tip: The invisibility evaluator determines visibility solely from the node\u2019s visibility state; if your UI or plug-in code requires invisible nodes to evaluate, do not use the invisibility evaluator. Frozen Evaluator The frozen evaluator allows users to tag EG subsections as not needing evaluation. It enhances the frozen attribute by propagating the frozen state automatically to related nodes, according to the rules defined by the evaluator\u2019s configuration. It should only be used by those comfortable with the concepts of connection and propagation in the DAG and Evaluation Graph. Many users may prefer the invisibility evaluator; it is a simpler interface/workflow for most cases. The Frozen Attribute The frozen attribute has existed on nodes since Maya 2016. It can be used to control whether node is evaluated in Serial or Parallel EM evaluation modes. In principle, when the frozen attribute is set, the EM skips evaluation of that node. However, there are additional nuances that impact whether or not this is the case: Everything downstream of frozen nodes is still evaluated, unless they also have the frozen attribute set, or they are affected by the frozen evaluator as described below. Some nodes may perform optimizations that leave their outputs invalid and susceptible to change once evaluated. Freezing these nodes may have unexpected results as nothing preserves the old values. See the documentation on the nodeState attribute for ways to specifically enable caching for nodes you want to freeze. You may have inconsistent per-frame results when the frozen attribute is animated. The node \u201cfreezes\u201d when the attribute is set, so if you jump from frame to frame, your object state reflects the last time you visited in an unfrozen state. Playback is only consistent if your object is not frozen from the first frame. When the frozen node is in the middle of a cycle, it is not respected. Cycles evaluate using the pull model, which does not respect the frozen attribute value. Custom evaluators may or may not respect the frozen attribute value. Take this into consideration as part of their implementation. Warning: All the frozen attribute does is skip evaluation, nothing is done to preserve the current node data during file store; if you load a file with frozen attributes set, the nodes may not have the same data as when you stored them. Operation The evaluation manager does not evaluate any node that has its frozen attribute set to True, referred to here as explicitly frozen nodes . An implicitly frozen node is one that is disabled because of the operation of the frozen evaluator, but whose frozen attribute is not set to True. When the frozen evaluator is enabled it will also prevent evaluation of related nodes according to the rules corresponding to the enabled options, in any combination. The frozen evaluator operates in three phases. In phase one, it gathers together all of the nodes flagged by the invisible and displayLayers options as being marked for freezing. In phase two, it propagates the freezing state outwards through the evaluation graph according to the values of the downstream and upstream options. Phase 1: Gathering The Nodes The list of nodes for propagation is gathered as follows: The nodes with their frozen attribute set to True are found. ( Note: This does not include those whose frozen attribute is animated. They are handled via Phase 3.) If the invisible option is True then any node that is explicitly frozen and invisible (directly, or if its parents are all invisible) will have all of its DAG descendants added to the list of nodes for Phase 2. If the displayLayers option is True then any node that is a member of a display layer that is explicitly frozen, enabled, and invisible will have it, and all its DAG descendants added to the list of nodes for Phase 2. Phase 2: Propagating The Freezing The list gathered by Phase 1 will all be implicitly frozen. In addition, the downstream and upstream options may implicitly freeze nodes related to them. For each of the nodes gathered so far, the evaluation graph will be traversed in both directions, implicitly freezing nodes encountered according to the following options: downstream option value \u201cnone\u201d : No further nodes downstream in the EG will be implicitly frozen \u201csafe\u201d : Nodes downstream in the EG will be implicitly frozen only if every one of their upstream nodes has already been implicitly or explicitly frozen \u201cforce\u201d : Nodes downstream in the EG will be implicitly frozen upstream option value \u201cnone\u201d : No further nodes upstream in the EG will be implicitly frozen \u201csafe\u201d : Nodes upstream in the EG will be implicitly frozen only if every one of their downstream nodes has already been implicitly or explicitly frozen \u201cforce\u201d : Nodes upstream in the EG will be implicitly frozen Phase 3: Runtime Freezing If a node has its frozen or visibility states animated, the evaluator still has to schedule it. The runtime freezing can still assist at this point in preventing unnecessary evaluation. Normally any explicitly frozen node will have its evaluation skipped, with all other nodes evaluating normally. When the runtime option is enabled, after skipping the evaluation of an explicitly frozen node no further scheduling of downstream nodes will occur. As a result, if the downstream nodes have no other unfrozen inputs they will also be skipped. Note: The runtime option does not really modify the evaluator operation, it modifies the scheduling of nodes for evaluation. You will not see nodes affected by this option in the evaluator information (for example, the output from cmds.evaluator( query=True, clusters=True, name='frozen' ) ) Setting Options Options can be set for the frozen evaluator in one of two ways: Accessing them through the Evaluation Toolkit Using the evaluator command\u2019s configuration option: cmds.evaluator( name='frozen', configuration='KEY=VALUE' ) Legal KEY and VALUE values are below, and correspond to the options as described above: KEY VALUES DEFAULT runtime True/False False invisible True/False False displayLayers True/False False downstream \u2018off\u2019/\u2018safe\u2019/\u2018force\u2019 \u2018off\u2019 upstream \u2018off\u2019/\u2018safe\u2019/\u2018force\u2019 \u2018off\u2019 Unlike most evaluators the frozen evaluator options are stored in user preferences and persists between sessions. Limitations You must set at least one frozen attribute to True to instruct the frozen evaluator to shut off evaluation on affected nodes. The most practical use of this would be on a display layer so that nodes can be implicitly frozen as a group. If the frozen attribute, or any of the attributes used to define related implicit nodes for freezing (for example, visibility ) are animated then the evaluator will not remove them from evaluation. They will still be scheduled and only the runtime option will help in avoiding unnecessary evaluation. Cycle members are not frozen by the evaluator unless every input to the cycle is frozen. This is a design choice to reflect that as cycles evaluate as a unit, it is impossible to freeze individual members of a cycle. It must be all or nothing. Curve Manager Evaluator The curve manager evaluator can be used to include additional nodes in the Evaluation Graph, which can have two main benefits: The additional nodes can be manipulated using parallel evaluation and GPU deformation, which can result in higher responsiveness during interactive manipulation. Fewer Evaluation Graph rebuilds can result, since static nodes can already be included in the Evaluation Graph. To achieve those benefits efficiently, the curve manager evaluator performs two main tasks: During Evaluation Graph construction, it triggers dirty propagation from extra nodes so they are included in the graph construction process and the resulting Evaluation Graph. During scene evaluation, it handles the evaluation of some of those extra nodes to maintain performance, since they do not really need to be evaluated. To illustrate this result, let\u2019s compare the three following situations. A scene where all controllers have a single key (that is, static animation curves). Since the resulting animation curves are constant, they are considered static and are not included in the Evaluation Graph. Playback will have nothing to evaluate. A scene where all controllers have keys of different values (that is, animated curves). Therefore, they will be included in the Evaluation Graph and playback will evaluate everything. A scene where all controllers have a single key (that is, static animation curves), but where the curve manager evaluator is used to prepopulate the Evaluation Graph with those static curves. The third situation is where we are trying to take advantage of the curve manager evaluator to have an Evaluation Graph that is already set up to allow parallel evaluation when the controllers will be manipulated. The following table summarizes the differences between the situations and the compromises provided by the curve manager evaluator. Situation # of nodes in EG Playback EM Manip Rebuild when keying Static curves + curve manager off Lowest Fastest No Yes Animated curves Highest Slowest Yes No Static curves + curve manager on Highest Middle Yes No In summary, the curve manager evaluator benefits from having the Evaluation Graph already populated with nodes so it is ready to evaluate interactive manipulation, while paying as little of a cost as possible for those constant nodes during playback. It can be activated using: cmds.evaluator( name=\"curveManager\", enable=True ) cmds.evaluator( name=\"curveManager\", configuration=\"forceAnimatedCurves=keyed\" ) The available values for forceAnimatedCurves are: \u201cnone\u201d : No curve will be forced in the evaluation graph. \u201ccontroller\u201d : Curves connected to controller nodes will be forced in the evaluation graph. This is basically a generalization of the controller concept. \u201ckeyed\u201d : Keyed static curves, that is, curves with a single key or multiple keys with the same value, will be forced in the evaluation graph. \u201call\u201d : All curves are forced in the evaluation graph. Another option, forceAnimatedNodes , can be used: \u201cnone\u201d : No node will be forced in the evaluation graph. \u201cforcedAnimatedAttribute\u201d : Nodes with the forced-animated attribute set to true will be forced in the evaluation graph. This allows tagging nodes to be added with a boolean dynamic attribute. By default, the name of this attribute is forcedAnimated . If it is present on a node and set to true, the node is added to the graph. The name of the attribute can be controlled by using the \u201cforcedAnimatedAttributeName\u201d option. By default, the curve manager evaluator tries to skip the evaluation of the static parts of the graph. For debugging or performance measurement purposes, this optimization can be disabled: cmds.evaluator( name=\"curveManager\", configuration=\"skipStaticEvaluation=disable\" ) Other Evaluators In addition to evaluators described above, additional evaluators exist for specialized tasks: Evaluator What does it do? cache Constitutes the foundation of Cached Playback. See the Maya Cached Playback whitepaper for more information. timeEditorCurveEvaluator Finds all paramCurves connected to time editor nodes and puts them into a cluster that will prevent them from evaluating at the current time, since the time editor will manage their evaluation. ikSystem Automatically disables the EM when a multi-chain solver is present in the EG. For regular IK chains it will perform any lazy update prior to parallel execution. disabling Automatically disables the EM if user-specified nodes are present in the EG. This evaluator is used for troubleshooting purposes. It allows Maya to keep working stably until issues with problem nodes can be addressed. hik Handles the evaluation of HumanIK characters in an efficient way by recognizing HumanIK common connection patterns. cycle Unrolls cycle clusters to augment the opportunity for parallelism and improve performance. Likely gives the best performance improvements when large cycle clusters are present in the scene. Prototype, work in progress. transformFlattening Consolidates deep transform hierarchies containing animated parents and static children, leading to faster evaluation. Consolidation takes a snapshot of the relative parent/child transformations, allowing concurrent evaluation of downstream nodes. pruneRoots We found that scenes with several thousand paramCurves become bogged down because of scheduling overhead from resulting EG nodes and lose any potential gain from increased parallelism. To handle this situation, special clusters are created to group paramCurves into a small number of evaluation tasks, thus reducing overhead. Custom evaluator names are subject to change as we introduce new evaluators and expand these functionalities. Evaluator Conflicts Sometimes, multiple evaluators will want to \u201cclaim responsibility\u201d for the same node(s). This can result in conflict, and negatively impact performance. To avoid these conflicts, upon registration each evaluator is associated with a priority; nodes are assigned to the evaluator with the highest priority. Internal evaluators have been ordered to prioritize correctness and stability over speed. API Extensions Several API extensions and tools have been added to help you make the most of the EM in your pipeline. This section reviews API extensions for Parallel Evaluation , Custom GPU Deformers , Custom Evaluator API , VP2 Integration and Profiling Plug-ins . Parallel Evaluation If your plug-in plays by the DG rules, you will not need many changes to make the plug-in work in Parallel mode. Porting your plug-in so that it works in Parallel may be as simple as recompiling it against the latest version of OpenMaya! If the EM generates different results than DG-based evaluation, make sure that your plug-in: Overrides MPxNode::compute() . This is especially true of classes extending MPxTransform which previously relied on asMatrix() . See the rockingTransform SDK sample. For classes deriving from MPxDeformerNode and MPxGeometryFilter , override the deform() method. Handles requests for evaluation at all levels of the plug tree. While the DG can request plug values at any level, the EM always requests the root plug. For example, for plug N.gp[0].p[1] your compute() method must handle requests for evaluation of N.gp, N.gp[0], N.gp[0].p, and N.gp[0].p[1]. If your plug-in relies on custom dependency management, you need to use new API extensions to ensure correct results. As described earlier, the EG is built using the legacy dirty-propagation mechanism. Therefore, optimizations used to limit dirty propagation during DG evaluation, such as those found in MPxNode::setDependentsDirty , may introduce errors in the EG. Use MEvaluationManager::graphConstructionActive() to detect if this is occurring. There are new virtual methods you will want to consider implementing: MPxNode::preEvaluation . To avoid performing expensive calculations each time the evaluation method MPxNode::compute() is called, one strategy plug-in authors use is to store results from previous evaluations and then rely on MPxNode::setDependentsDirty to trigger re-computation. As discussed previously, once the EG has been built, dirty propagation is disabled and the EG is re-used. Threrefore, any custom logic in your plug-in that depends on setDependentsDirty no longer applies. MPxNode::preEvaluation allows your plug-in to determine which plugs/attributes are dirty and if any action is needed. Use the new MEvaluationNode class to determine what has been dirtied. Refer to the simpleEvaluationNode devkit example for an illustration of how to use MPxNode::preEvaluation . MPxNode::postEvaluation . Until now, it was difficult to determine at which point all processing for a node instance was complete. Users sometimes resorted to complex bookkeeping/callback schemes to detect this situation and perform additional work, such as custom rendering. This mechanism was cumbersome and error-prone. Once all computations have been performed on a specific node instance, a new method, MPxNode::postEvaluation , is called. Since this method is called from a worker thread, it performs calculations for downstream graph operations without blocking other Maya processing tasks of non-dependent nodes. See the simpleEvaluationDraw devkit example to understand how to use this method. If you run this example in regular evaluation, Maya slows down, since evaluation is blocked whenever expensive calculations are performed. When you run in Parallel Evaluation Mode, a worker thread calls the postEvaluation method and prepares data for subsequent drawing operations. When testing, you will see higher frame rates in Parallel evaluation versus regular or Serial evaluation. Please note that code in postEvaluation should be thread-safe. Other recommended best practices include: Avoid storing state in static variables. Store node state/settings in attributes. This has the additional benefit of automatically saving/restoring the plug-in state when Maya files are written/read. Node computation should not have any dependencies beyond input values. Maya nodes should be like functions. Output values should be computed from input state and node-specific internal logic. Your node should never walk the graph or try to circumvent the DG. Custom GPU Deformers To make GPU Override work on scenes containing custom deformers, Maya provides new API classes that allow the creation of fast OpenCL deformer back-ends. Though you still need to have a CPU implementation for the times when it is not possible to target deformations on the GPU (see GPU Override ), you can augment this with an alternate deformer implementation inheriting from MPxGPUDeformer . This applies to your own nodes as well as to standard Maya nodes. The GPU implementation will need to: Declare when it is valid to use the GPU-based backend (for example, you may want to limit you GPU version to cases where various attributes are fixed, omit usage for specific attribute values, and so on) Extract MDataBlock input values and upload values to the GPU Define and call the OpenCL kernel to perform needed computation Register itself with the MGPUDeformerRegistry system. This will tell the system which deformers you are claiming responsibility for. When you have done this, do not forget to load your plug-in at startup. Two working devkit examples ( offsetNode and identityNode ) have been provided to get you started. Tip To get a sense for the maximum speed increase you can expect by providing a GPU backend for a specific deformer, tell Maya to treat specific nodes as passthrough. Here\u2019s an example applied to polySoftEdge: cmds.GPUBuiltInDeformerControl( name=\"polySoftEdge\", inputAttribute=\"inputPolymesh\", outputAttribute=\"output\", passthrough=True ) Although results will be incorrect, this test will confirm if it is worth investing time implementing an OpenCL version of your node. Custom Evaluator API API classes and methods introduced in Maya 2017 let you define custom evaluators that allow control over how the Maya scene is computed. To create a custom evaluator, you must define a plug-in that extends the MPxCustomEvaluator class. The key class methods to override are described below. The Basics Before you can use the new evaluators, they must be registered: MStatus registerEvaluator( // name of the evaluator const char * evaluatorName, // evaluator priority. Higher priority evaluators get 'first-dibs' unsigned int uniquePriority, // function pointer to method returning a new evaluator instance MCreatorFunction creatorFunction ) and deregistered: MStatus deregisterEvaluator( // name of the evaluator const char* evaluatorName ) using MFnPlugin methods. These functions should be used during plug-in initialization: MStatus initializePlugin( MObject obj ) { MFnPlugin plugin( obj, PLUGIN_COMPANY, \"3.0\", \"Any\"); MStatus status = plugin.registerEvaluator( \"SimpleEvaluator\", 40, simpleEvaluator::creator); if (!status) status.perror(\"registerEvaluator\"); return status; } and uninitialization: MStatus uninitializePlugin( MObject obj ) { MFnPlugin plugin( obj ); MStatus status = plugin.deregisterEvaluator( \"SimpleEvaluator\" ); if (!status) status.perror(\"deregisterEvaluator\"); return status; } as illustrated above. Once the plug-in has been loaded, use Python or MEL commands to enable : import maya.cmds as cmds cmds.evaluator(enable=True, name='SimpleEvaluator') # Result: False # disable : cmds.evaluator(enable=False, name='SimpleEvaluator') # Result: True # and query information about evaluators: print cmds.evaluator(query=True) [u'invisibility', ... u'SimpleEvaluator'] NOTE: The evaluator command returns the previous state of the evaluator (as described in the documentation). This command fails if the evaluator cannot be enabled. To view the priorities of all loaded evaluators, use the priority flag on the evaluator command: for evaluatorName in cmds.evaluator(): print \"%-25s : %d\" % ( evaluatorName, cmds.evaluator(name=evaluatorName, query=True, priority=True)) invisibility : 1003000 frozen : 1002000 curveManager : 1001000 cache : 1000000 timeEditorCurveEvaluator : 104000 dynamics : 103000 ikSystem : 102000 disabling : 100000 hik : 7000 reference : 6000 deformer : 5000 cycle : 4000 transformFlattening : 3000 pruneRoots : 1000 SimpleEvaluator : 40 API Reference This section provides more detail on different MPxCustomEvaluator API methods. Claiming clusters During EG partitioning, each evaluator gets to claim evaluation nodes, using the: bool MPxCustomEvaluator::markIfSupported(const MEvaluationNode* node) method. You can safely cause evaluation in this call but doing so increases partitioning and evaluation time. The developer can decide whether evaluation is required (call .inputValue / .inputArrayValue ), or the previously-evaluated datablock values can be re-used (call .outputValue / .outputArrayValue ). If multiple evaluators mark a specific node, which evaluator is assigned a node at run-time is determined by priority. For example, if you have two evaluators, A and B, mark node C of interest, if evaluator A has priority 100, and evaluator B has priority 10, during graph partitioning, evaluator A will get the opportunity to grab node C before evaluator B. Evaluators should not try to grab a node already grabbed by a higher-priority evaluator. Scheduling To determine if an evaluator can evaluate clusters in Parallel, use: MCustomEvaluatorClusterNode::SchedulingType schedulingType( // a disjoint set of nodes on a custom evaluator layer const MCustomEvaluatorClusterNode * cluster ) where: SchedulingType Details kParallel any number of nodes of the same type can run in parallel kSerial all nodes of this type should be chained and executed sequentially kGloballySerial only one node of this type can be run at a time kUntrusted nothing else can execute with this node since we cannot predict what will happen During EG scheduling: bool MPxCustomEvaluator::clusterInitialize( // evaluation cluster node const MCustomEvaluatorClusterNode* cluster ) can be used to perform the required cluster preparation. The pointer to the cluster remains valid until graph invalidation, such as when the scene topology changes. Before the cluster is deleted, void MPxCustomEvaluator::clusterTerminate( // the cluster to terminate const MCustomEvaluatorClusterNode* cluster ) is called to allow needed cleanup, for example, releasing evaluator-specific resources. It is up to the custom evaluator to decide if it wants to clear its internal representation. Execution There are 3 main methods used during execution. Prior to graph execution, the EM calls: void MPxCustomEvaluator::preEvaluate( // the graph about to be evaluated const MEvaluationGraph* graph ) during execution, the EM calls: void MPxCustomEvaluator::clusterEvaluate( // the cluster to be evaluated const MCustomEvaluatorClusterNode* cluster ) You will only receive clusters that belong to this evaluator. This call always happens after clusterInitialize and never after clusterTerminate . Finally, void MPxCustomEvaluator::postEvaluate( // the graph that was evaluated const MEvaluationGraph* graph ) is called just after a graph evaluation is finished. SimpleEvaluator API Example Now that we have reviewed relevant API methods, the following example limits evaluation by caching previous results. simpleEvaluator assumes the existence of scene nodes that tag controller nodes with animation and works as follows: In clusterInitialize , we-2\">ld a list of translation and rotation attribute plugs. // Build a list of plugs by scanning the scene for controller nodes. // This gets called during scheduling. bool simpleEvaluator::clusterInitialize( const MCustomEvaluatorClusterNode* cluster ) { if (fControllerPlugs.length() == 0) buildPlugListWithControllerTag(); return true; } // Scan the scene for any controller nodes, populating the plug list. // Called during the scheduling phase void simpleEvaluator::buildPlugListWithControllerTag() { MStatus stat; MItDependencyNodes dgIter(MFn::kControllerTag, &stat); if (stat != MS::kSuccess) return; const char* values[] = { \"translateX\", \"translateY\", \"translateZ\", \"rotateX\", \"rotateY\", \"rotateZ\" }; for (; !dgIter.isDone(); dgIter.next()) { MFnDependencyNode controllerTagNode(dgIter.thisNode(), &stat); if (stat != MS::kSuccess) continue; MPlug currControllerTagPlug = controllerTagNode.findPlug(\"controllerObject\", &stat); if (stat != MS::kSuccess) continue; // found controller tag node, now get its source controller MPlugArray source; bool retval = currControllerTagPlug.connectedTo( source, true /* asDst */, false /* asSrc */, &stat) if ((retval == false) || (stat != MS::kSuccess)) continue; // there should only be one source with the controller tag node // as destination MObject controllerNode = source[0].node(&stat); if (stat != MS::kSuccess) continue; MFnDependencyNode currControllerNode(controllerNode, &stat); if (stat != MS::kSuccess) continue; for (unsigned int j = 0; j < 6; j++) { MPlug currPlug = currControllerNode.findPlug(values[j], &stat); if (stat == MS::kSuccess) fControllerPlugs.append(currPlug); else std::cerr << \"NO PLUG: \" << currControllerNode.name().asChar() << \".\" << values[j] << std::endl; } } } Later, during preEvaluate , which is called per-frame, a hash value is calculated based on the plug values of the current frame. void simpleEvaluator::preEvaluate(const MEvaluationGraph* graph) { buildHashValue(); } void simpleEvaluator::buildHashValue() { unsigned int length = fControllerPlugs.length(); MStatus stat = MS::kSuccess; for (unsigned int i = 0; i < length; i++) { float value = 0; stat = fControllerPlugs[i].getValue(value); if (stat == MS::kSuccess) { boost::hash_combine(fCurrentHashValue, value); } else { std::cerr << \"NO VALUE: \" << fControllerPlugs[i].name().asChar() << std::endl; } } } This value is compared with the previous frame\u2019s hash in clusterEvaluate . If the hash is different, the evaluation proceeds, otherwise we do nothing. void simpleEvaluator::clusterEvaluate( const MCustomEvaluatorClusterNode* cluster ) { if (fOldHashValue != fCurrentHashValue) cluster->evaluate(); } To make sure the hash value is up-to-date, the hash value is stored in postEvaluate . void simpleEvaluator::postEvaluate(const MEvaluationGraph* graph) { fOldHashValue = fCurrentHashValue; fCurrentHashValue = 0; } Finally, when the graph topology becomes invalid, we call clusterTerminate to clear the cached list of plugs. void simpleEvaluator::clusterTerminate( const MCustomEvaluatorClusterNode* cluster ) { if (fControllerPlugs.length() > 0) fControllerPlugs.clear(); } Since simpleEvaluator claims control over the entire graph, markIfSupported returns true for all nodes. Additionally, nothing special is done to alter the cluster\u2019s scheduling behavior. bool simpleEvaluator::markIfSupported(const MEvaluationNode* node) { return true; } MCustomEvaluatorClusterNode::SchedulingType simpleEvaluator::schedulingType(const MCustomEvaluatorClusterNode* cluster) { return cluster->schedulingType(); } See the provided simpleEvaluator devkit example for more details and complete source code. VP2 Integration Evaluation Manager Parallel Evaluation executes the Dependency Graph in parallel. Internally, Maya nodes begin preparing render data for VP2 immediately after a node is evaluated, and before the rest of the graph has finished evaluation. This is exposed to users as Evaluation Manager Parallel Update in the MPxGeometryOverride API (this feature may also be referred to as \u201cDirect Update\u201d). Supporting Evaluation Manager Parallel Update can significantly reduce time spent in Vp2BuildRenderLists and improve overall scene performance. The following profiler images were created from the same scene (100 footPrintNode_GeometryOverride nodes with animated \u201csize\u201d attributes). In the first image Evaluation Manager Parallel Update is not enabled, and a large amount of time is spent serially preparing draw data for each footPrint node in Vp2BuildRenderLists. In the second image the footPrintNode_GeometryOverride has been modified to support Evaluation Manager Parallel Update. You can see that the long serial execution time in Vp2BuildRenderLists has been eliminated. All the data marshalling for VP2 is occurring in parallel while the Evaluation Manager is evaluating the Dependency Graph. The footPrintNode_GeometryOverride example plug-in provides a detailed example for you to create an efficient MPxGeometryOverride plugin which supports Evaluation Manager Parallel Update and gives excellent performance in VP2. Supporting Evaluation Manager Direct Update adds some restrictions to which operations can safely be performed from MPxGeometryOverride function calls. All MPxGeometryOverride functions (except cleanUp() and the destructor) may be called from a worker thread in parallel with other Maya execution. These methods must all be thread safe. An MPxGeometryOverride object is guaranteed to have at most one of its member functions called at a time. If two different MPxGeometryOverride objects \u201cA\u201d and \u201cB\u201d both require updating, then any member function on \u201cA\u201d could be called at the same time as any member function on \u201cB\u201d. Furthermore, because these methods may be called from a worker thread, direct access to the rendering context is prohibited. MVertexBuffer and MIndexBuffer can still be used, but some of their features are prohibited from use when in Evaluation Manager Parallel Update. Details about which features are safe to use are provided in the documentation for MVertexBuffer and MIndexBuffer . Tracking Topology Evaluation Manager Parallel Update currently has the limitation that it can only be used on geometries that do not have animated topology. The status of whether topology is animated or not needs to be tracked from the geometry\u2019s origin to its display shape. If the nodes in the graph are built-in nodes, Maya can know if an animated input will affect the output geometry topology. Similarly, deformers (even custom ones derived from MPxDeformerNode ), are assumed to simply deform their input in their output, keeping the same topology. However, more generic nodes can also generate geometries. When a custom node is a MPxNode , Maya cannot know whether an output geometry has animated topology. It therefore assumes the worst and treats the topology as animated. While this approach is the safest, it can prevent optimizations such as Evaluation Manager Parallel Update. As of Maya 2019, a new API has been added to inform Maya about attributes that might not affect the topology of an output geometry. The first step is to override the MPxNode::isTrackingTopology() method so that Maya can track topology information for this node. The second step is the use the new version of the MPxNode::attributeAffects() method to inform Maya that while the source attribute affects the output attribute, it does not affect its topology. Using this new API helps Maya to know that it is safe to use Evaluation Manager Parallel Update and benefit from its performance boost in more situations. Profiling Plug-ins To visualize how long custom plug-ins take in the new profiling tools (see Profiling Your Scene ) you will need to instrument your code. Maya provides C++, Python, and MEL interfaces for you to do this. Refer to the Profiling using MEL or Python or the API technical docs for more details. Profiling Your Scene In the past, it could be challenging to understand where Maya was spending time. To remove the guess-work out of performance diagnosis, Maya includes a new integrated profiler that lets you see exactly how long different tasks are taking. Open the Profiler by selecting: Windows > General Editors > Profiler from the Maya menu Persp/Graph Layout from the Quick Layout buttons and choosing Panel Layout > Profiler . Once the Profiler window is visible: Load your scene and start playback Click Start in the Profiler to record information in the pre-allocated record buffer. Wait until the record buffer becomes full or click Stop in the Profiler to stop recording. The Profiler shows a graph demonstrating the processing time for your animation. Try recording the scene in DG , Serial , Parallel , and GPU Override modes. Tip By default, the Profiler allocates a 20MB buffer to store results. The record buffer can be expanded in the UI or by using the profiler -b value; command, where value is the desired size in MB. You may need this for more complex scenes. The Profiler includes information for all instrumented code, including playback, manipulation, authoring tasks, and UI/Qt events. When profiling your scene, make sure to capture several frames of data to ensure gathered results are representative of scene bottlenecks. The Profiler supports several views depending on the task you wish to perform. The default Category View , shown below, classifies events by type (e.g., dirty, VP1, VP2, Evaluation, etc). The Thread and CPU views show how function chains are subdivided amongst available compute resources. Currently the Profiler does not support visualization of GPU-based activity. ![][image1.jpg] Understanding Your Profile Now that you have a general sense of what the Profiler tool does, let\u2019s discuss key phases involved in computing results for your scene and how these are displayed. By understanding why scenes are slow, you can target scene optimizations. Every time Maya updates a frame, it must compute and draw the elements in your scene. Hence, computation can be split into one of two main categories: Evaluation (i.e., doing the math that determines the most up-to-date values for scene elements) Rendering (i.e., doing the work that draws your scene in the viewport). When the main bottleneck in your scene is evaluation, we say the scene is evaluation-bound . When the main bottleneck in your scene is rendering, we say the scene is render-bound . Profiler Colors Each event recorded by the profiler has an associated color. Each color represents a different type of event. By understanding event colors you can quickly interpret profiler results. Some colors are re-used and so have different meanings in different categories. Dirty Propagation (Pink and Purple) Pull Evaluation (Dark Green) Forward or Evaluation Manager Evaluation (Peach, Tan and Brown) Set Time (Light Green) Qt Events (Light Blue) VP2 Rendering (Light Blue) VP2 Pull Updates (Light and Dark Yellow and Blue) VP2 Push or Direct Updates (Light and Dark Blue) GPU Override CPU usage (Light and Dark Yellow) Cache Restore (Yellow) Cache Skipped (Gray) We can\u2019t see every different type of event in a single profile, because some events like Dirty Propagation only occur with Evaluation Manager off, and other events like GPU Override CPU usage only occur with Evaluation Manager on. In the following example profiles we will show DG Evaluation, Evaluation Manager Parallel Evaluation, GPU Override Evaluation, Evaluation Cached Evaluation and VP2 Cached Evaluation. Through these examples we\u2019ll see how to interpret a profile based on graph colors and categories, and we\u2019ll learn how each performance optimization in Maya can impact a scene\u2019s performance. The following example profiles are all generated from the same simple FK character playing back. DG Evaluation In this profile of DG Evaluation we can see several types of event. Pink and purple Dirty Propagation events in the Dirty Propagation category. Dark green Pull Evaluation events in the Evaluation category. Blue VP2 Pull Translation and light blue VP2 Rendering in the VP2 Evaluation category. Yellow events in the VP2 Evaluation category show time VP2 spent waiting for data from Dependency Graph nodes. A significant fraction of each frame is spent on Dirty Propagation, a problem which is alleviated by Evaluation Manager. EM Parallel Evaluation In this profile of EM Parallel Evaluation we can see all the purple and pink dirty propagation is gone. Peach, tan and brown EM Parallel Evaluation events of the FK rig colored. The high stack of events represents some evaluation occurring in parallel (use thread view to better understand parallelism). Tan and brown EM Parallel Evaluation events while Maya evaluates the skin cluster to compute the deformed mesh. These events occur serially because the Dependency Graph has no parallelism. Dark blue and blue VP2 Direct Update events translate data into a VP2 render-able format. Yellow in the Main category and light blue in the VP2 Evaluation category are VP2 Rendering events. In this profile we see much less time spent on Vp2SceneRender (4). This occurs because time spent reading data from dependency nodes has been moved from rendering to EM Parallel Evaluation (1). DG evaluation uses a data pull model, while EM Evaluation uses a data push model. Additionally, some geometry translation (2), is also moved from rendering to evaluation. We call geometry translation during evaluation \u201cVP2 Direct Update\u201d. A significant portion of each frame is spent deforming and translating the geometry data, a problem which is alleviated by GPU Override. EM Parallel Evaluation with GPU Override In this profile of EM Parallel Evaluation we can see one major new difference from the previous profile of EM Parallel Evaluation. Light and dark yellow GPU Override events have replaced the long serial central part of the EM Parallel Evaluation profile (2 & 3 from EM Parallel Evaluation). The GPU Override events represent the time taken on the CPU to marshal data and launch the GPU computation. Peach, tan and brown EM Parallel Evaluation events here have roughly the same duration as EM Parallel Evaluation even though the relative size of the rig evaluation events with GPU Override is larger. This is because the scale of this profile is different from the scale of the previous profile. In the profile of EM Parallel Evaluation with GPU Override the total time displayed is about 5ms. In the previous profile of EM Parallel Evaluation the total time displayed is about 12ms. Light blue VP2 Render events have experienced a similar relative stretching (2). EM Evaluation Cached Playback In this profile of EM Evaluation Cached Playback we can see several new types of event. Yellow Restore Cache events recording the time taken to update each FK rig node which has cached data. There are also brown VP2 Direct Update events used to track update of the VP2 representation of the data. Yellow Restore Cache event for the deformed mesh. This represents the time taken to restore the data into the Maya node, and to translate the data into VP2 for drawing using VP2 Direct Update. EM VP2 Hardware Cached Playback Dark blue VP2 Hardware Cache Restore events have replaced the long serial Cache Restore event (2 from EM Evaluation Cached Playback). Restoring the VP2 Hardware Cache is much faster because the data is already in in the render-able format and stored on the GPU. Gray Cache Skipped event signaling data in the dependency node is not updated. Evaluation-Bound Performance When the main bottleneck in your scene is evaluation, we say the scene is evaluation-bound . There are several different problems that may lead to evaluation-bound performance. Lock Contention. When many threads try to access a shared resource you may experience Lock Contention, due to lock management overhead. One clue that this may be happening is that evaluation takes roughly the same duration regardless of which evaluation mode you use. This occurs since threads cannot proceed until other threads are finished using the shared resource. Here the Profiler shows many separate identical tasks that start at nearly the same time on different threads, each finishing at different times. This type of profile offers a clue that there might be some shared resource that many threads need to access simultaneously. Below is another image showing a similar problem. In this case, since several threads were executing Python code, they all had to wait for the Global Interpreter Lock (GIL) to become available. Bottlenecks and performance loses caused by contention issues may be more noticeable when there is a high concurrency level, such as when your computer has many cores. If you encounter contention issues, try to fix the code in question. For the above example, changing node scheduling converted the above profile to the following one, providing a nice performance gain. For this reason, Python plug-ins are scheduled as Globally Serial by default. As a result, they will be scheduled one after the other and will not block multiple threads waiting for the GIL to become available. Clusters. As mentioned earlier, if the EG contains node-level circular dependencies, those nodes will be grouped into a cluster which represents a single unit of work to be scheduled serially. Although multiple clusters may be evaluated at the same time, large clusters limit the amount of work that can be performed simultaneously. Clusters can be identified in the Profiler as bars wiip.opaqueTaskEvaluation label, shown below. If your scene contains clusters, analyze your rig\u2019s structure to understand why circularities exist. Ideally, you should strive to remove coupling between parts of your rig, so rig sections (e.g., head, body, etc.) can be evaluated independently. Tip When troubleshooting scene performance issues, you can temporarily disable costly nodes using the per-node frozen attribute. This removes specific nodes from the EG. Although the result you see will change, it is a simple way to check that you have found the bottleneck for your scene. Render-Bound Performance When the main bottleneck in your scene is rendering, we say the scene is render-bound . The following is an illustration of a sample result from the Maya Profiler, zoomed to a single frame measured from a large scene with many animated meshes. Because of the number of objects, different materials, and the amount of geometry, this scene is very costly to render. ![][image6.jpeg] The attached profile has four main areas: Evaluation (A) GPUOverridePostEval (B) Vp2BuildRenderLists (C) Vp2Draw3dBeautyPass (D) In this scene, a substantial number of meshes are being evaluated with GPU Override and some profiler blocks appear differently from what they would otherwise. Evaluation. Area A depicts the time spent computing the state of the Maya scene. In this case, the scene is moderately well-parallelized. The blocks in shades of orange and green represent the software evaluation of DG nodes. The blocks in yellow are the tasks that initiate mesh evaluation via GPU Override. Mesh evaluation on the GPU starts with these yellow blocks and continues concurrently with the other work on the CPU. An example of a parallel bottleneck in the scene evaluation appears in the gap in the center of the evaluation section. The large group of GPU Override blocks on the right depend on a single portion of the scene and must wait until that is complete. Area A2 (above area A), depicts blue task blocks that show the work that VP2 does in parallel to the scene evaluation. In this scene, most of the mesh work is handled by GPU Override so it is mostly empty. When evaluating software meshes, this section shows the preparation of geometry buffers for rendering. GPUOverridePostEval. Area B is where GPU Override finalizes some of its work. The amount of time spent in this block varies with different GPU and driver combinations. At some point there will be a wait for the GPU to complete its evaluation if it is heavily loaded. This time may appear here or it may show as additional time spent in the Vp2BuildRenderLists section. Vp2BuildRenderLists. Area C. Once the scene has been evaluated, VP2 builds the list of objects to render. Time in this section is typically proportional to the number of objects in the scene. Vp2PrepareToUpdate. Area C2, very small in this profile. VP2 maintains an internal copy of the world and uses it to determine what to draw in the viewport. When it is time to render the scene, we must ensure that the objects in the VP2 database have been modified to reflect changes in the Maya scene. For example, objects may have become visible or hidden, their position or their topology may have changed, and so on. This is done by VP2 Vp2PrepareToUpdate. Vp2PrepareToUpdate is slow when there are shape topology, material, or object visibility changes. In this example, Vp2PrepareToUpdate is almost invisible since the scene objects require little extra processing. Vp2ParallelEvaluationTask is another profiler block that can appear in this area. If time is spent here, then some object evaluation has been deferred from the main evaluation section of the Evaluation Manager (area A) to be evaluated later. Evaluation in this section uses traditional DG evaluation. Common cases for which Vp2BuildRenderLists or Vp2PrepareToUpdate can be slow during Parallel Evaluation are: Large numbers of rendered objects (as in this example) Mesh topology changes Object types, such as image planes, requiring legacy evaluation before rendering 3 rd party plug-ins that trigger API callbacks Vp2Draw3dBeautyPass. Area D. Once all data has been prepared, it is time to render the scene. This is where the actual OpenGL or DirectX rendering occurs. This area is broken into subsections depending on viewport effects such as depth peeling, transparency mode, and screen space anti-aliasing. Vp2Draw3dBeautyPass can be slow if your scene: Has Many Objects to Render (as in this example). Uses Transparency . Large numbers of transparent objects can be costly since the default transparency algorithm makes scene consolidation less effective. For very large numbers of transparent objects, setting Transparency Algorithm (in the vp2 settings) to Depth Peeling instead of Object Sorting may be faster. Switching to untextured mode can also bypass this cost Uses Many Materials . In VP2, objects are sorted by material prior to rendering, so having many distinct materials makes this time-consuming. Uses Viewport Effects. Many effects such as SSAO (Screen Space Ambient Occlusion), Depth of Field, Motion Blur, Shadow Maps, or Depth Peeling require additional processing. Other Considerations . Although the key phases described above apply to all scenes, your scene may have different performance characteristics. For static scenes with limited animation, or for non-deforming animated objects, consolidation is used to improve performance. Consolidation groups objects that share the same material. This reduces time spent in both Vp2BuildRenderLists and Vp2Draw3dBeatyPass, since there are fewer objects to render. Saving and Restoring Profiles Profile data can be saved at any time for later analysis using the Edit -> Save Recording... or Edit -> Save Recording of Selected Events... menu items in the Profiler window. Everything is saved as plain string data (see the appendix describing the profiler file format for a description of how it is stored) so that you can load profile data from any scene using the Edit -> Load Recording... menu item without loading the scene that was profiled. Troubleshooting Your Scene Analysis Mode The purpose of Analysis Mode is to perform more rigorous inspection of your scene to catch evaluation errors. Since Analysis Mode introduces overhead to your scene, only use this during debugging activities; animators should not enable Analysis Mode during their day-to-day work. Note that Analysis Mode is not thread-safe, so it is limited to Serial; you cannot use analysis mode while in Parallel evaluation. The key function of Analysis Mode is to: Search for errors at each playback frame. This is different than Safe Mode, which only tries to identify problems at the start of parallel execution. Monitor read-access to node attributes. This ensures that nodes have a correct dependency structure in the EG. Return diagnostics to better understand which nodes influence evaluation. This is currently limited to reporting one destination node at a time. Tip To activate Analysis Mode, use the dbtrace -k evalMgrGraphValid; MEL command. Once active, error detection occurs after each evaluation. Missing dependencies are saved to a file in your machine\u2019s temporary folder (e.g., %TEMP%\\_MayaEvaluationGraphValidation.txt on Windows). The temporary directory on your platform can be determined using the internalVar -utd; MEL command. To disable Analysis Mode, type: dbtrace -k evalMgrGraphValid -off; Let\u2019s assume that your scene contains the following three nodes. Because of the dependencies, the evaluation manager must compute the state of nodes B and C prior to calculating the state of A. Now let\u2019s assume Analysis Mode returns the following report: Detected missing dependencies on frame 56 { A.output <-x- B A.output <-x- C [cluster] } Detected missing dependencies on frame 57 { A.output <-x- B A.output <-x- C [cluster] } The <-x- symbol indicates the direction of the missing dependency. The [cluster] term indicates that the node is inside of a cycle cluster, which means that any nodes from the cycles could be responsible for attribute access outside of evaluation order In the above example, B accesses the output attribute of A, which is incorrect. These types of dependency do not appear in the Evaluation Graph and could cause a crash when running an evaluation in Parallel mode. There are multiple reasons that missing dependencies occur, and how you handle them depends on the cause of the problem. If Analysis Mode discovers errors in your scene from bad dependencies due to: A user plug-in. Revisit your strategy for managing dirty propagation in your node. Make sure that any attempts to use \u201cclever\u201d dirty propagation dirty the same attributes every time. Avoid using different notification messages to trigger pulling on attributes for computation. A built-in node . You should communicate this information to us. This may highlight an error that we are unaware of. To help us best diagnose the causes of this bug, we would appreciate if you can provide us with the scene that caused the problem. Graph Execution Order There are two primary methods of displaying the graph execution order. The simplest is to use the \u2018compute\u2019 trace object to acquire a recording of the computation order. This can only be used in Serial mode, as explained earlier. The goal of compute trace is to compare DG and EM evaluation results and discover any evaluation differences related to a different ordering or missing execution between these two modes. Keep in mind that there will be many differences between runs since the EM executes the graph from the roots forward, whereas the DG uses values from the leaves. For example in the simple graph shown earlier, the EM guarantees that B and C will be evaluated before A, but provides no information about the relative ordering of B and C. However in the DG, A pulls on the inputs from B and C in a consistent order dictated by the implementation of node A. The EM could show either \"B, C, A\" or \"C, B, A\" as their evaluation order and although both might be valid, the user must decide if they are equivalent or not. This ordering of information can be even more useful when debugging issues in cycle computation since in both modes a pull evaluation occurs, which will make the ordering more consistent. The Evaluation Toolkit A set of debugging tools used to be shipped as a special shelf in Maya Bonus Tools, but they are now built-in within Maya. The Evaluation Toolkit provides features to query and analyze your scene and to activate / deactivate various modes. See the accompanying Evaluation Toolkit documentation for a complete list of all helper features. Known Limitations This section lists known limitations for the new evaluation system. VP2 Motion Blur will disable Parallel evaluation. For Motion Blur to work, the scene must be evaluated at different points in time. Currently the EM does not support this. Scenes using FBIK will revert to Serial. For several years now, Autodesk has been deprecating FBIK. We recommend using HIK for full-body retargeting/solving. dbtrace will not work in Parallel mode. As stated in the Analysis Mode section, the dbtrace command only works in Serial evaluation. Having traces enabled in Parallel mode will likely cause Maya to crash. The DG Profiler crashes in Parallel Mode. Unless you are in DG evaluation mode, you will be unable to use the legacy DG profiler. Time permitting, we expect to move features of the DG profiler into the new thread-safe integrated profiler. Batch rendering scenes with XGen may produce incorrect results. Evaluation manager in both Serial and Parallel mode changes the way attributes are cached. This is done to allow safe parallel evaluation and prevent re-computation of the same data by multiple threads. This means that some scenes may evaluate differently if multiple computations of the same attribute occur in one evaluation cycle. With the Evaluation Manager, the first value will be cached. VP2 Direct update does not work with polySoftEdge nodes. Appendices Profiler File Format The profiler stores its recording data in human-readable strings. The format is versioned so that older format files can still be read into newer versions of Maya (though not necessarily vice-versa). This is a description of the version 1 format. First, a content example: 1 #File Version, # of events, # of CPUs 2 2\\t12345\\t8 3 Main\\tDirty 4 #Comment mapping--------- 5* @27 = MainMayaEvaluation 6 #End comment mapping--------- 7 #Event time, Comment, Extra comment, Category id, Duration, \\ Thread Duration, Thread id, Cpu id, Color id 8* 1234567\\t@12\\t@0\\t2\\t12345\\t11123\\t36\\t1\\t14 9 #Begin Event Tag Mapping--------- 10 #Event ID, Event Tag 11* 123\\tTaggy McTagface 12 #End Event Tag Mapping--------- 13 #Begin Event Tag Color Mapping--------- 14 #Tag Label, Tag Color 15* Taggy\\tMcTagface\\t200\\t200\\t13 16 #End Event Tag Color Mapping--------- EOF The following table describes the file format structure by referring to the previous content: Line(s) Description 1 A header line with general file information names 2 A tab-separated line containing the header information 3 A tab-separated line containing the list of categories used by the events (category ID is the index of the category in the list) 4 A header indicating the start of comment mapping (a mapping from an ID to the string it represents) 5* Zero or more lines lines mapping a number onto a string in the form @LINE = STRING . The IDs do not correspond to anything outside of the file. 6 A footer indicating the end of comment mapping 7 A header indicating the start of event information. The names are the titles of the event columns. Event time is the absolute time, in ticks, the event started Duration is the total amount of time, in ticks, for the entire event Thread duration is the total amount of time, in ticks, the event took inside the thread Comment and Extra comment use an ID from the comment mapping above Category id is the index of the event\u2019s category from the list at line 3 Cpu id and Thread id are the ones in which the event took place. Actual values are arbitrary; only meant to distinguish unique CPUs and Threads Color id is an index into the color mapping internal to the app (colors at the time of creation are not stored in the file). 8* Zero or more tab-separated lines mapping to all of the events that were stored in the file 9 A header indicating the start of the event tag maps 10 A title line showing what values are in the event tag map columns 11* Zero or more tab-separated lines attaching an event tag, defined through the profiler tool, to a specific event ID. The event ID will correspond to the ID given to it in the comment mapping section. 12 A footer indicating the end of the event tag maps 13 A header indicating the start of the event tag color maps 14 A title line showing what values are in the event tag color map columns 15* Zero or more tab-separated lines mapping a tag label defined above to an R,G,B color 16 A header indicating the end of the event tag color maps EOF Sample version 2 file on 4 CPUs containing a single event of type \u201cETName\u201d, description \u201cETDescription\u201d, in category \u201cETCategory\u201d with description \u201cCategory description\u201d, using color 7, of duration 100 ticks, starting at tick 999, on a single thread with ID 22, tagged with \u201cTagMe\u201d which has color red (255 0 0) #File Version, # of events, # of CPUs 2 1 4 ETCategory Category description #Comment mapping--------- @0 = ETName #End comment mapping--------- 999 @0 @0 1 100 100 22 1 7 #Begin comment description mapping--------- @1 = ETDescription #End comment description mapping--------- #Begin Event Tag Mapping--------- #Event ID, Event Tag 1 TagMe #End Event Tag Mapping--------- #Begin Event Tag Color Mapping--------- #Tag Label, Tag Color TagMe 255 0 0 #End Event Tag Color Mapping--------- Debugging Commands Several commands can be used to help display information about your scene to help in debugging or optimizations. This is a summary of some of the more common ones, and represents only the available runtime information. Consult the command documentation in Maya\u2019s online technical documentation for more information about each command. dbcount Maintains embedded code location counters for higher-level debugging of scene operation. Generally, this uses specialized code that is only available in custom builds. Synopsis: dbcount [flags] Flags: -e -enabled on|off -f -file String -k -keyword String -l -list -md -maxdepth UnsignedInt -q -quick -r -reset -s -spreadsheet Command Type: Command dbmessage Monitors messaging that adds and removes DAG and DG nodes. Synopsis: dbmessage [flags] Flags: -f -file String -l -list -m -monitor on|off -t -type String Command Type: Command dbtrace Turns on conditional code, typically to print out status information or to take different code paths when enabled. To find available trace objects use dbtrace \u2013q to list currently-enabled traces, and dbtrace \u2013q \u2013off to list currently-disabled traces. To find the current trace output target, use dbtrace -q -k keyword -o . See below for information on specific keywords. Note: Work is currently in progress to make these trace objects more flexible. It is a current design constraint that sometimes they are visible in a release, even though they only function internally, and some cannot be used when using Parallel evaluation. Synopsis: dbtrace [flags] Flags: -q -query -f -filter String -i \u2013info -k -keyword String (multi-use) (Query Arg Optional) -m -mark -o -output String -off - -t -title String -tm -timed on|off -v -verbose Command Type: Command Keyword Description Contents ( Default Output File ) OGSPolyGhosts Shows progress of data extraction from the evaluation of poly ghosts through OGS ( stdout ) cacheConfig Shows cache configuration rules evaluation Result of cache configuration rules for each evaluation node ( _Trace_CacheConfig.txt ) cipEM Shows what Customer Improvement Program data is being collected. Generic usage information. No longer being used ( stdout ) cmdTracking Enables the tracking of counts of commands. Use the dbpeek \u2018cmdTracking\u2019 operation to view the results. No output, but enables tracking of the counts for all commands being executed. (For example, you can turn it on during file load to get a count of the number of createNode calls, including those in referenced files, a task that is difficult to do manually) ( stdout ) compute High level trace of the compute path Nested output showing compute methods being called. Typically in EM mode you should see nesting only in cycles. DG mode will show the full set of nodes triggered by a single evaluation request ( _Trace_Compute.txt ) dbCache Data block manipulation Details of the creation and manipulation of datablock information ( _Trace_DataBlockCache.txt ) deformerEvaluator Statistics for the deformer evaluator setup Shows statistics on what the deformer evaluator was able to ingest, once enabled ( stderr ) evalMgr Evaluation manager interactions ( _Trace_EvalManager.txt ) evalMgrGraphInvalid Evaluation manager graph invalidation ( stdout ) evalMgrGraphValid Evaluation manager execution graph validation errors and warnings Nodes that were evaluated while in EMS mode using the pull (DG) model. This indicates missing dependencies in the evaluation graph, possibly caused by custom dirty propagation ( _MayaEvaluationGraphValidation.txt ) evalMgrSched Internal use only ( _MayaScheduling.txt ) idleBuild Operation of the idle build mechanism for the evaluation graph When the idle build is active, this appears when the idle build is triggered and executed ( _Trace_EGBuild.txt ) nodeTracking Enables tracking of counts of created nodes. Use the dbpeek \u2018nodeTracking\u2019 operation to view results. ( stdout ) peekCache Shows progress of the dbpeek -op cache operation Dumps data collected by the dbpeek operation, and how ( _Trace_DbPeekCache.txt ) peekContext Shows progress of the dbpeek -op context operation Dumps data collected by the dbpeek operation, and how ( stdout ) peekData Shows progress of the dbpeek -op data operation Dumps data collected by the dbpeek operation, and how ( _Trace_DbPeekData.txt ) peekMesh Shows progress of the dbpeek -op mesh operation Dumps data collected by the dbpeek operation, and with what flags ( _Trace_DbPeekMesh.txt ) dgdebug Historical debugging command; not robust or documented. Deprecated : Use the newer dbpeek command. No help is provided for this command. dgdirty Forces dirty/clean states onto specified plugs and everything downstream from them. Meant to be a safety net for restoring proper states to your scene when something has gone wrong. You should not need to use this command, but it will continue to exist as a \u201creset button\u201d, just in case. Synopsis: dgdirty [flags] [String...] Flags: -q -query -a -allPlugs -c -clean -i -implicit -l -list String -p -propagation -st -showTiming -v -verbose Command Type: Command dgeval Forces the node to compute certain plugs. Like dgdirty, this command is meant to be a safety net if computation has not occurred in the proper order. Similar in function to the getAttr command, but since it returns no results, it can handle all attribute types, not only those supported by getAttr. Synopsis: dgeval [flags] String... Flags: -src - -v -verbose Command Type: Command dgInfo Dumps information about the current state of the graph. Be aware that when plug dirty states are reported, they represent the connection associated with the plug. In fan-out or in-out connections there will be more than one dirty state associated with the connection attached to the plug. This means it is legal to see A->B as dirty but B->A as clean if A has multiple connections. Being Deprecated : Use the newer dbpeek command. Synopsis: dgInfo [flags] [String...] Flags: -all -allNodes -c -connections -d -dirty on|off -n -nodes -nd -nonDeletable -nt -type String -of -outputFile String -p -propagation on|off -s -short -sub -subgraph -sz -size Command Type: Command dgmodified Checks on the reason a file requests saving when no changes have been made. Synopsis: dgmodified No Flags. dbpeek This command is called out intentionally, as it combines multiple operations into a single command by use of various operations. It runs one of several operations that provide a view into the data internals in the scene. This is the most useful and flexible of the debugging commands, and new variations of it are often being introduced. Use dbpeek -q -op to show a list of currently available operations and dbpeek -op X -q to show detailed help for operation X . See below for information on specific keywords. Note: The syntax of the argument flag allows for both keyword argument=\u2019key\u2019 and keyword/value argument=\u2019key=value\u2019 forms. Synopsis: dbpeek [flags] [String...] Flags: -q -query -a -argument String (multi-use) (Query Arg Mandatory) -all -allObjects -c -count UnsignedInt -eg -evaluationGraph -of -outputFile String -op -operation String (Query Arg Optional) Command Type: Command dbpeek -op attributes Analyzes node or node-type attributes and dumps information about them based on what the selected operation type. Various arguments to the operation change the content of the output. The essence remains the same; the attributes belong to the node or node type. Argument Meaning detail Adds all internal details from attributes being dumped, otherwise dumps only the names and structure. The details are output as object members of the attribute, including the children. nodeType Dumps all attributes belonging to the selected node(s) types. If nothing is selected, it dumps the attributes for all available node types. This includes all node types up the hierarchy to the base node class. noDynamic Skips dynamic attributes in all output. noExtension Skips extension attributes in all output. noStatic Skips static attributes in all output. onlyPlugins Restricts any output to nodes and node types that originate from a plug-in. type=affects Dumps attribute structure and affects relationships in the graphical .dot format. type=detail Dumps attribute information in .json format. This is the default if no type is specified. type=validate Validates flags and structure for consistency and validity. If no nodes are selected, then this command prints the list of all attributes on all nodes. For example, if you had a node type called reversePoint with a vector input and a vector output. type=detail would output this JSON data: { \"nodes\" : { \"reversePoint\" : { \"staticAttributes\" : [ { \"pointInput\" : [ \"pointInputX\", \"pointInputY\", \"pointInputZ\", ] }, { \"pointOutput\" : [ 15\"> \"pointOutputX\", \"pointOutputY\", \"pointOutputZ\", ] } ], \"extensionAttributes\" : [] } } } type=affects would output this DOT data: digraph G { compound=true; subgraph cluster_NODENAME { label=\"Node NODENAME, Type NODETYPE\"; color=\".7 .0 .0\"; ia [label=\"ia/inputAttribute\",style=\"rounded\",shape=ellipse]; oa [label=\"oa/outputAttribute\",style=\"rounded\",shape=rectangle]; ia -> oa; } } and type=validate would output this JSON validation summary: { \"Attribute Validation\" : { \"NODENAME\" : { \"staticAttributes\" : [ { \"Both input and output attributes in compound\" : [ { \"root\" : \"rootAttribute\", \"inputs\" : [\"inputChild\"], \"outputs\" : [\"outputChild\"], } ] } ] } } } dbpeek -op cache This operation is explained in detail in the Debugging section of the Maya Cached Playback whitepaper. dbpeek -op cmdTracking By default, when no detail argument is present it shows a list of all commands run since the last reset as well as a count of how many of each type were executed. Outputs in command/count pair form, one per line, with a tab character separating them. Argument Meaning reset Set all of the command tracking statistics to zero dbpeek -op connections By default, when no type argument is present, shows a list of all connections in the DG. Argument Meaning summary Reduces the output to show only the connection counts on the nodes. It separates by single and multi but no further information is added. Useful for getting basic usage information. verbose Shows extra information about every connection, including dirty/propagation states, plug ownership, and type connectivity of the connection. Connections can be single or multi, and be connected either to each other or to plugs. dbpeek -op data Dumps the current contents of a node\u2019s plug data in a standard format. By default the output is in CSV format consisting of 5 columns: NODE PLUG DATA_TYPE CLEAN_STATE DATA_AS_TEXT Example for a simple integer attribute with a dirty value of 5: MyNode MyPlug Int32 0 5 Argument Meaning eval Evaluates plugs first to guarantee that they are clean. Note: Some plugs are always dirty so there may still be plugs that show a dirty value. full Includes plugs with default values in the output. json Uses JSON format for the output. The general form is { \"NODE\" : { \"PLUG\" : { \"TYPE\", \"CLEAN\", \"VALUE\" } } } . For example, a simple numeric attribute with a dirty value of 5 { \"MyNode\" : { \"MyPlug\", \"0\", \"5\" } } matrix Includes all plugs with a \u201cmatrix\u201d data type in the output. This does not include generic data that may have a matrix value at runtime, only attributes that are exclusively matrix types. number Includes all plugs with any numerical data type in the output. This does not include any generic data that may have numerical value at runtime, only attributes that are exclusively numeric types. It includes all types of numeric values, including linear, angular, time, and unitless values. state Includes the current dirty state of the data in the output. time=TIME Rather than evaluating at the normal context, evaluates at a context using the given time. This is somewhat equivalent to getAttr -t TIME . vector Includes all plugs with a \u201cvector\u201d data type in the output. Does not include generic data that may have a vector value at runtime, only attributes that are exclusively double[3] types. dbpeek -op context Analyzes context evaluation to detect various errors violating the design. Argument Meaning isolationType=animatedAttributes Filters errors, reporting only those involving animated attributes isolationType=animatedNodes Filters errors, reporting only those involving animated nodes isolationType=staticAndAnimated Reports all errors test=isolation During evaluation, detects when evaluation context is violated causing data to be read or written into a state that belongs to some other evaluation context test=correctness Evaluates the scene in the background, comparing evaluation data stored for background and main context; compares traversing evaluation graph visiting nodes only if all upstream nodes generate equivalent data in both the background and the main context time=TIME Takes a string value indicating the frame time at which evaluation should be performed. verbose Adds extra information to output report. Each test will have its own verbose data. Isolation : Adds callstack information to the report for each detected error. Correctness : Adds attributes which compare failed to compare (due to missing logic) Sample output for isolation tests: { \"context isolation\": { \"frame\": 5.0, \"type\": \"animatedNodes\", \"verbose\": true, \"errors\": [ { \"node\": \"ikHandle1\", \"type\": \"ikHandle\", \"attribute\": \"ikFkManipulation\", \"call stack\": [ \"METHOD Line NUMBER\", \"METHOD Line NUMBER\", \"METHOD Line NUMBER\" ] }, { \"node\": \"shape\", \"type\": \"mesh\", \"attribute\": \"displaySmoothMesh\", \"call stack\": [ \"METHOD Line NUMBER\", \"METHOD Line NUMBER\", \"METHOD Line NUMBER\" ] } ], \"time out\": true } } Sample output for correctness tests: { \"context correctness\": { \"frame\": 14.0, \"verbose\": true, \"errors\": [ { \"node\": \"IKSpineCurveShape\", \"type\": \"nurbsCurve\", \"attributes\": [ \"worldSpace\" ] } ], \"failed to compare\": [ \"input\", \"clusterXforms\", \"clusterTransforms\", \"target\", \"mySpecialAttribute\" ], \"time out\": true } } dbpeek -op edits Shows a list of all nodes for which tracking is currently enabled. The \u201ctrack\u201d flag is mandatory. Argument Meaning track Shows a list of all nodes for which tracking is currently enabled. dbpeek -op evalMgr Outputs the current state of all of the custom evaluators used by the Evaluation Manager. Argument Meaning custom Outputs the custom evaluators registered with the evaluation manager. global Adds output that is independent of scene contents, for example, node types enabled for the custom evaluators. local Adds output that is specific to the scene contents, for example, nodes supported by a custom evaluator. dbpeek -op graph Gets a list of nodes or connections from either the dependency graph or the underlying evaluation graph. Argument Meaning connections Dumps the list of all connections in the chosen graph. The sorting order is alphabetical by destination plug name. dot Dumps the graph information in .dot format for parsing and display by an external application such as graphViz. evaluationGraph Gets the structure information from the evaluation graph, otherwise uses the raw dependency graph. The dbpeek command flag \u201cevaluationGraph\u201d does the same thing. graph Dumps the graph state and contents, not including what is dumped by any of the other flags. nodes Dumps the list of all nodes in the chosen type of graph, in alphabetical order by full node name. plugs For the evaluation graph option, dumps the list of all plugs in its dirty plug list in the evaluation nodes. For the DG option, dumps the list of plugs currently in the plug trees. scheduling Dumps the scheduling type used for all nodes in the type of graph in the form NODE = SCHEDULING_TYPE. If a node type is specified, the default scheduling type for nodes of that specific node type is returned in the same format. verbose When dumping the scheduling graph in .dot format, adds all of the names of the nodes to the clusters. Otherwise, it is only a count of nodes in each cluster dbpeek -op mesh Dumps the current contents of the mesh to a standard format. There are two types of formatting and two levels of detail to present. Argument Meaning eval Evaluates mesh plugs first to guarantee they are clean. Otherwise the values currently present in the mesh shape are used as-is. json Dumps data in JSON format instead of CSV. verbose Puts full values for all of the data in the output. Otherwise, only a number count of each type is returned. See the flag descriptions for more information on which data can be requested and what is returned for each type. vertex Includes vertex position or vertex count in the output. The short return is a count of vertices in the mesh. The verbose values are a list of vertex number and the {X,Y,Z} positions of the vertex, with W factored in, if appropriate. For the default level of detail, the default CSV format output will look like this: NODE_NAME,DATA_TYPE,DATA_COUNT For example, a cube containing 32 vertices would have these lines: Node,DataType,Count pCubeShape1,outMesh,32 The JSON equivalent format would look like this: { \"pCubeShape1\" : { \"outMesh\" : \"32\" } } If the full detail is requested, then the (abbreviated) output for CSV format will look like this: Node,Plug,Clean,Value pCubeShape1,outMesh[0],1,0.0 0.0 0.0 pCubeShape1,outMesh[1],1,0.0 0.5 0.0 ... pCubeShape1,outMesh[32],1,1.0 1.0 1.0 and like this for JSON format: { \"pCubeShape1\" : { \"outMesh\" : { \"clean\" : 1, \"0\" : [0.0, 0.0, 0.0], \"1\" : [0.0, 0.5, 0.0], \"...\" : \"...\", \"32\": [1.0, 1.0, 1.0] } } } dbpeek -op metadata Shows node metadata. The default operation shows a list of all nodes containing metadata. Argument Meaning summary Shows a single line per node, with metadata indicating how many channels, streams, and values are present in the metadata. verbose Shows a detailed list of all metadata on nodes, including a dump in the debug serialization format for each of the metadata streams. dbpeek -op node Show select debugging information on DG nodes. See also the \u201cplug\u201d and \u201cconnection\u201d operations for display of information specific to those facets of a node. If no arguments are used then the ones marked as [default] will all be enabled, for convenience. Argument Meaning datablock [default] Shows the values in the datablock(s) datablockMemory Shows raw datablock memory. This is independent of the other other datablock flags. dynamicAttr Shows dynamic attributes. evaluationGraph [default] Includes evaluation graph information on the node extensionAttr Shows the extension attributes node [default] Shows information specific to individual node types, such internal caches, flags, or special relationships it maintains. All other data shown is common to all node types plug [default] Shows the nodes plug information skipClean Does not include datablock values that are clean skipDirty [default] Does not include the datablock values that are dirty skipMulti Does not include the datablock values that are multi (array) attributes staticAttr Shows the static attributes verbose Shows much more detail where available. This will include things such as flags set on objects, full detail on heavy data, and any extra detail specific to a node type, such as caches. dbpeek -op nodes By default, when no detail argument is present, shows a list of all currently registered node types. Argument Meaning binary Also includes the IFF tag used to identify each node type in the \u201c.mb\u201d file format dbpeek -op nodeTracking By default, when no argument is present, shows a list of all nodes created since the last reset along with a count of how many of each type were created. Output is in the form of nodeType/count pairs, one per line, with a tab character separating them. Argument Meaning reset Erases all of the node tracking statistics. dbpeek -op plugs Shows information about all of the plugs in a scene. By default, when no argument is present, shows static plug footprint. A lot of this is only displayed in specially-instrumented builds, and generally only of use internally. Argument Meaning details Includes the full plug/node name information in the output. Otherwise only the total and summary counts are dumped. group=stat Groups all output by statistic name group=node Groups all output by node name mode=footprint Reports size information for currently-existing networked plugs. mode=usage Reports dynamic code path statistics, if they have been enabled in the current build mode=reset When used in conjunction with \u201cusage\u201d, resets the statistics back to zero. mode=state Gets unevaluated state information for boolean plugs. Only available on specially-built cuts. nodeType=TYPE Restricts the operation to the node types specified in the argument. This includes inherited types, for example if the value is \u201ctransform\u201d, then the operation also applies to \u201cjoint\u201d nodes, as the node type \u201cjoint\u201d inherits from the node type \u201ctransform\u201d. See the node type documentation or the nodeType command for complete information on which node types inherit from each other. stat=STAT If this argument has no STAT, then sorts by the name of the statistic. If this argument does have a STAT, for example, \u201cstat=addToNet\u201d, then only reports that statistic. Only available on specially-built cuts. Revisions 2020 Updated the dbtrace section to add info about: OGSPolyGhosts cacheConfig evalMgr evalMgrGraphInvalid peekCache peekContext Added a link in the dbpeek section to details regarding the new cache operation. 2019 Updated the Key Concepts section. Added more info about the different graphs (DG, EG, SG). Added a section about VP2 Integration and Evaluation Manager Parallel Update. Added a section about Tracking Topology for Evaluation Manager Parallel Update. Updated the Custom Evaluators section to describe the new evaluators. New evaluators: curveManager (now with its own subsection) cache cycle 2018 Created an Appendices section. Added a section that describes the Profiler File Format . Moved Debugging Commands section to the Appendices . Updated the Custom Evaluators section to describe the new evaluators. New evaluators: curveManager hik Added information on isolate-select and expressions to the Invisibility Evaluator Added new deformer types supported in GPU override : deltaMush lattice nonLinear tension 2017 Added section on graph invalidation . Added information about different ways to query scheduling information (see Thread Safety ). Updated the Custom Evaluators section to describe the new evaluators. New evaluators: invisibility frozen timeEditorCurveEvaluator dynamics evaluator support for Parallel evaluation of scenes with dynamics is now enabled by default. Added Custom Evaluator API section. Added Evaluation Toolkit section. Added Debugging Commands section. Miscellaneous typo fixes and small corrections. 2016 Extension 2 Added tip about the controller command. Updated Other Evaluators subsection in the Custom Evaluators section to describe the new evaluators. New evaluators: transformFlattening reference deformer evaluator is now enabled by default. dynamics evaluator has a new behavior, disabled by default, to support Parallel evaluation of scenes with dynamics. Updated Evaluator Conflicts subsection in the Custom Evaluators section. Updated Python plug-ins scheduling to Globally Serial. Updated Render-Bound Performance subsection in the Profiling Your Scene section. Added new images for graph examples. Miscellaneous typo fixes and small corrections. 2016 Initial version of the document.","title":"Parallel"},{"location":"parallel/#overview","text":"This guide describes the Maya features for accelerating playback and manipulation of animated scenes. It covers key concepts, shares best practices/usage tips, and lists known limitations that we aim to address in subsequent versions of Maya. This guide will be of interest to riggers, TDs, and plug-in authors wishing to take advantage of speed enhancements in Maya. If you would like an overview of related topics prior to reading this document, check out Supercharged Animation Performance in Maya 2016 .","title":"Overview"},{"location":"parallel/#key-concepts","text":"Starting from Maya 2016, Maya accelerates existing scenes by taking better advantage of your hardware. Unlike previous versions of Maya, which were limited to node-level parallelism, Maya now includes a mechanism for scene-level analysis and parallelization. For example, if your scene contains different characters that are unconstrained to one another, Maya can evaluate each character at the same time. Similarly, if your scene has a single complex character, it may be possible to evaluate rig sub-sections simultaneously. As you can imagine, the amount of parallelism depends on how your scene has been constructed. We will get back to this later. For now, let\u2019s focus on understanding key Maya evaluation concepts. At the heart of Maya\u2019s new evaluation architecture is an Evaluation Manager (EM) , responsible for handling the parallel-friendly representation of your scene. It maintains (and updates while the scene is edited) a few data structures (described below) used for efficient evaluation. The basic description of the scene is the Dependency Graph (DG) , consisting of DG nodes and connections. Nodes can have multiple attributes, and instances of these attributes on a specific node are called plugs . The DG connections are at the plug level, that is, two nodes can be connected to one another multiple ways through different plugs. Generally speaking, these connections represent data flow through the nodes as they evaluate. The following image shows an example DG: The dotted arrows inside the nodes represent an implicit computation dependency between an output attribute (on the right of the node) and the input attributes (on the left) being read to compute the result stored in the output. Before Parallel Maya, the DG was used to evaluate the scene using a Pull Model or Pull Evaluation . In this model, the data consumer (for instance the renderer) queries data from a given node. If the data is already evaluated, the consumer receives it directly. However, if the data is dirty , the node must first recompute it. It does so by pulling on the inputs required to compute the requested data. These inputs can also be dirty, in which case the evaluation request will then be forwarded to those dirty sources until it reaches the point where the data can be evaluated. The result then propagates back up in the graph, as the data is being \u201cpulled\u201d. This evaluation model relies on the ability to mark node data as invalid and therefore requiring new evaluation. This mechanism is known as the Dirty Propagation in which the invalid data status propagates to all downstream dependencies. The two main cases where dirty propagation happened in the Pull Evaluation model were when: the current time is changed: in this case, animation curves no longer have the right value which depends on the current time. Therefore, dirty propagation starts from each animation curve and the dirty status is propagated through the graph to reach everything depending on time, directly or indirectly. a value is changed on a node: whether the value is being changed through interactive manipulation or by a script, all data that depends on this new value must be recomputed. Therefore, dirty propagation starts from the edited plug and the dirty status is propagated through the graph to reach everything depending on the edited attribute. The Pull Evaluation model is not well suited for efficient parallel evaluation because of potential races that can arise from concurrent pull evaluations. To have tighter control over evaluation, Maya now uses a Forward Evaluation model to enable concurrent evaluation of multiple nodes. The general idea is simple: if all a node\u2019s dependencies have been evaluated before we evaluate the given node, pull evaluation will not be triggered when accessing evaluated node data, so evaluation remains contained in the node and is easier to run concurrently. All data dependencies between the nodes must be known to apply this evaluation model, and this information is captured in the Evaluation Graph (EG) , containing Evaluation Nodes . The EM uses dirty propagation to capture dependency information between the nodes, as well as which attributes are animated. EG connections represent node-level dependencies; destination nodes employ data from source nodes to correctly evaluate the scene. One important distinction between the DG and the EG is that the former uses plug -level connections, while the latter uses node -level connections. For example, the previous DG would create the following EG: A valid EG may not exist or become invalid for various reasons. For example, you have loaded a new scene and no EG has been built yet, or you have changed your scene, invalidating a prior EG. However, once the EG is built, unlike previous versions of Maya that propagated dirty on every frame, Maya now disables dirty propagation, reusing the EG until it becomes invalid. Tip If your scene contains expression nodes that use getAttr , the DG graph will be missing explicit dependencies. This results in an incorrect EG. Expression nodes also reduce the amount of parallelism in your scenes (see Scheduling Types for details). Consider removing getAttr from expressions and/or using utility nodes. While the EG holds the dependency information, it is not ready to be evaluated concurrently as-is. The EM must first create units of work that can be scheduled, that is, tasks . The main types of task created are: Individual Nodes : in the simplest case, an evaluation node can be computed directly. The task therefore consists of evaluating all of its animated attributes. Cycle Clusters : depending on the scene, the EG may contain circular node-level dependencies. If this is the case, the EM creates clusters that group together nodes in the same cycle. At scene evaluation time, nodes in cycle clusters are evaluated serially before continuing with other parallel parts of the EG, hence the evaluation of a cycle cluster consisting of a single task. While node-level cycles are perfectly legal, creating scenes with attribute-level cycles should be avoided as this is unsupported and leads to unspecified behavior. Custom Evaluator Clusters : the EM supports the concept of custom evaluators to override evaluation of sub-section of the EG. One example of this is the GPU override , which uses your graphics card\u2019s graphics processing unit (GPU) to accelerate deformations. The custom evaluators will create clusters for nodes for which they take responsibility, and the EM creates a task for each of these clusters. At scene evaluation time, control is passed to the specific custom evaluator when the task is up to be executed. This step, called partitioning , is where the EM creates the individual pieces of work that will have to be executed. Each of these tasks will map to a Scheduling Node in the Scheduling Graph (SG) , where connections represent dependencies between the tasks: The SG is an acyclic graph, otherwise it would be impossible to schedule nodes in a cycle since there would be no starting point for which all dependencies could be evaluated. In addition to the dependencies that come directly from the EG, the SG can have additional scheduling constraints to prevent concurrent evaluation of subsets of nodes (see Scheduling Types for details).","title":"Key Concepts"},{"location":"parallel/#supported-evaluation-modes","text":"Starting in Maya 2016, 3 evaluation modes are supported: Mode What does it do? DG Uses the legacy Dependency Graph -based evaluation of your scene. This was the default evaluation mode prior to Maya 2016 Serial Evaluation Manager Serial mode. Uses the EG but limits scheduling to a single core. Serial mode is a troubleshooting mode to pinpoint the source of evaluation errors. Parallel Evaluation Manager Parallel mode. Uses the EG and schedules evaluation across all available cores. This mode is the new Maya default since 2016. When using either Serial or Parallel EM modes, you can also activate GPU Override to accelerate deformations on your GPU. You must be in Viewport 2.0 to use this feature (see GPU Override ). To switch between different modes, go to the Preferences window ( Windows > Settings/Preferences > Preferences > Animation ). You can also use the evaluationManager MEL/Python command; see documentation for supported options. To see the evaluation options that apply to your scene, turn on the Heads Up Display Evaluation options ( Display > Heads Up Display > Evaluation ).","title":"Supported Evaluation Modes"},{"location":"parallel/#first-make-it-right-then-make-it-fast","text":"Before discussing how to make your Maya scene faster using Parallel evaluation, it is important to ensure that evaluation in DG and EM modes generates the same results. If you see different results in the viewport during animation (as compared to previous versions of Maya), or tests reveal numerical errors, it is critical to understand the cause of these errors. Errors may be due to an incorrect EG, threading related problems, or other issues. Below, we review Evaluation Graph Correctness and Thread Safety , two important concepts to understand errors.","title":"First Make it Right Then Make it Fast"},{"location":"parallel/#evaluation-graph-correctness","text":"If you see evaluation errors, first test your scene in Serial evaluation mode (see Supported Evaluation Modes ). Serial evaluation mode uses the EM to build an EG of your scene, but limits evaluation to a single core to eliminate threading as the possible source of differences. Note that since Serial evaluation mode is provided for debugging, it has not been optimized for speed and scenes may run slower in Serial than in DG evaluation mode. This is expected. If transitioning to Serial evaluation eliminates errors, this suggests that differences are most likely due to threading-related issues. However, if errors persist (even after transitioning to Serial evaluation) this suggests that the EG is incorrect for your scene. There are a few possible reasons for this: Custom Plugins. If your scene uses custom plug-ins that rely on the mechanism provided by the MPxNode::setDependentsDirty function to manage attribute dirtying, this may be the source of problems. Plug-in authors sometimes use MPxNode::setDependentsDirty to avoid expensive calculations in MPxNode::compute by monitoring and/or altering dependencies and storing computed results for later re-use. Since the EM relies on dirty propagation to create the EG, any custom plug-in logic that alters dependencies may interfere with the construction of a correct EG. Furthermore, since the EM evaluation does not propagate dirty messages, any custom caching or computation in MPxNode::setDependentsDirty is not called while the EM is evaluating. If you suspect that your evaluation errors are related to custom plug-ins, temporarily remove the associated nodes from your scene and validate that both DG and Serial evaluation modes generate the same result. Once you have made sure this is the case, revisit the plug-in logic. The API Extensions section covers Maya SDK changes that will help you adapt plug-ins to Parallel evaluation. Another debugging option is to use \u201cscheduling type\u201d overrides to force custom nodes to be scheduled more conservatively. This approach enables the use of Parallel evaluation even if only some of the nodes are thread-safe. Scheduling types are described in more detail in the Thread Safety section. Errors in Autodesk Nodes. Although we have done our best to ensure that all out-of-the-box Autodesk Maya nodes correctly express dependencies, sometimes a scene uses nodes in an unexpected manner. If this is the case, we ask you make us aware of scenes where you encounter problems. We will do our best to address problems as quickly as possible.","title":"Evaluation Graph Correctness"},{"location":"parallel/#thread-safety","text":"Prior to Maya 2016, evaluation was single-threaded and developers did not need to worry about making their code thread-safe. At each frame, evaluation was guaranteed to proceed serially and computation would finish for one node prior to moving onto another. This approach allowed for the caching of intermediate results in global memory and using external libraries without considering their ability to work correctly when called simultaneously from multiple threads. These guarantees no longer apply. Developers working in recent versions of Maya must update plug-ins to ensure correct behavior during concurrent evaluation. Two things to consider when updating plug-ins: Different instances of a node type should not share resources. Unmanaged shared resources can lead to evaluation errors since different nodes, of the same type, can have their compute() methods called at the same time. Avoid non thread-safe lazy evaluation. In the EM, evaluation is scheduled from predecessors to successors on a per-node basis. Once computation has been performed for predecessors, results are cached, and made available to successors via connections. Any attempt to perform non-thread safe lazy evaluation could return different answers to different successors or, depending on the nature of the bug, instabilities. Here\u2019s a concrete example for a simple node network consisting of 4 nodes: In this graph, evaluation first calculates outputs for Node1 (that is, Node1.A, Node1.B, Node1.C), followed by parallel evaluation of Nodes 2, 3, and 4 (that is, Read Node1.A to use in Node2, Read Node1.B to use in Node3, and so on). Knowing that making legacy code thread-safe requires time, we have added new scheduling types to provide control over how the EM schedule nodes. Scheduling types provide a straightforward migration path, so you do not need to hold off on performance improvements, just because a few nodes still need work. There are 4 scheduling types: Scheduling Type What are you telling the scheduler? Parallel Asserts that the node and all third-party libraries used by the node are thread-safe. The scheduler may evaluate any instances of this node at the same time as instances of other nodes without restriction. Serial Asserts it is safe to run this node with instances of other nodes. However, all nodes with this scheduling type should be executed sequentially within the same evaluation chain. Globally Serial Asserts it is safe to run this node with instances of other node types but only a single instance of this node type should be run at a time. Use this type if the node relies on static state, which could lead to unpredictable results if multiple node instances are simultaneously evaluated. The same restriction may apply if third-party libraries store state. Untrusted Asserts this node is not thread-safe and that no other nodes should be evaluated while an instance of this node is evaluated. Untrusted nodes are deferred as much as possible (that is, until there is nothing left to evaluate that does not depend on them), which can introduce costly synchronization. By default, nodes scheduled as Serial provide a middle ground between performance and stability/safety. In some cases, this is too permissive and nodes must be downgraded to GloballySerial or Untrusted. In other cases, some nodes can be promoted to Parallel . As you can imagine, the more parallelism supported by nodes in your graph, the higher level of concurrency you are likely to obtain. Tip When testing your plug-ins with Parallel Maya, a simple strategy is to schedule nodes with the most restrictive scheduling type (that is, Untrusted ), and then validate that evaluation produces correct results. Raise individual nodes to the next scheduling level, and repeat the experiment. There are three ways to alter the scheduling level of your nodes: Evaluation Toolkit. Use this tool to query or change the scheduling type of different node types. C++/Python API methods. Use the OpenMaya API to specify the desired node scheduling by overriding the MPxNode::schedulingType method. This function should return one of the enumerated values specified by MPxNode::schedulingType . See the Maya MPxNode class reference for more details. MEL/Python Commands. Use the evaluationManager command to change the scheduling type of nodes at runtime. Below, we illustrate how you can change the scheduling of scene transform nodes: Scheduling Type Command Parallel evaluationManager -nodeTypeParallel on \"transform\" Serial evaluationManager -nodeTypeSerialize on \"transform\" GloballySerial evaluationManager -nodeTypeGloballySerialize on \"transform\" Untrusted evaluationManager -nodeTypeUntrusted on \"transform\" The Evaluation Toolkit and MEL/Python Commands method to alter node scheduling level works using node type overrides. They add an override that applies to all nodes of a given type. Using C++/Python API methods and overriding the MPxNode::schedulingType function gives the flexibility to change the scheduling type for each node instance. For example, expression nodes are marked as globally serial if the expression outputs are a purely mathematical function of its inputs. The expression engine is not thread-safe so only one expression can run at a time, but it can run in parallel with any other nodes. However, if the expression uses unsafe commands (expressions could use any command to access any part of the scene), the node is marked as untrusted because nothing can run while the expression is evaluated. This changes the way scheduling types should be queried. Using the evaluationManager command with the above flags in query mode will return whether an override has been set on the node type, using either the Evaluation Toolkit or the MEL/Python commands. The Evaluation Toolkit window lets you query both the override type on the node type (which cannot vary from one node of the same type to the other), or the actual scheduling type used for a node when building the scheduling graph (which can change from one node instance to the other).","title":"Thread Safety"},{"location":"parallel/#safe-mode","text":"On rare occasions you may notice that Maya switches from Parallel to Serial evaluation during manipulation or playback. This is due to Safe Mode, which attempts to trap errors that possibly lead to instabilities. If Maya detects that multiple threads are attempting to simultaneously access a single node instance, evaluation will be forced to Serial execution to prevent problems. Tip If Safe Mode forces your scene into Serial mode, the EM may not produce the expected incorrect results when manipulating. In such cases you can either disable the EM: cmds.evaluationManager(mode=\"off\") or disable EM-accelerated manipulation: cmds.evaluationManager(man=0) While Safe Mode exposes many problems, it cannot catch them all. Therefore, we have also developed a special Analysis Mode that performs a more thorough (and costly) check of your scene. Analysis mode is designed for riggers/TDs wishing to troubleshoot evaluation problems during rig creation. Avoid using Analysis Mode during animation since it will slow down your scene.","title":"Safe Mode"},{"location":"parallel/#evaluation-graph-invalidation","text":"As previously described, the EG adds necessary node-level scheduling information to the DG. To make sure evaluation is correct, it\u2019s critical the EG always be up-to-date, reflecting the state of the scene. The process of detecting things that have changed and rebuilding the EG is referred to as graph invalidation . Different actions may invalidate the EG, including: Adding/removing nodes Changing the scenes transformation (DAG) hierarchy Adding/removing extension attributes Loading an empty scene or opening a new file Other, less obvious, actions include: Static animation curves . Although animation curves are time-dependent, DG evaluation treats curves with identical (static) keys as time-independent to avoid unnecessary calculations. The EG uses a similar optimization, excluding and avoiding scheduling of static animation curves. This keeps the EG compact, making it fast to build, schedule, and evaluate. A downside of this approach is that changes to static animation curves will cause the EG to become invalid; on time change Maya will rebuild the EG and determine if curves should be treated as time-dependent and added to the EG. Dirty propagation crossing the Evaluation Graph . The DG architecture allowed for implicit dependencies (that is, dependencies not expressed via connections), using them during dirty propagation. When dirty propagation is detected for these implicit dependencies, the EG will invalidate itself since this could signal the need to add new dependencies to the EG. Frequent graph invalidations may limit parallel evaluation performance gains or even slow it down (see Idle Actions ), since Maya requires DG dirty propagation and evaluation to rebuild the EG. To avoid unwanted graph rebuilds, consider adding 2 keys, each with slightly different values, on rig attributes that you expect to use frequently. You can also lock static channels to prevent creation of static animation curves during keying. We expect to continue tuning this area of Maya, with the goal of making the general case as interactive as possible. Tip You can use the controller command to identify objects that are used as animation sources in your scene. If the Include controllers in evaluation graph option is set (see Windows > Settings/Preferences > Preferences , then Settings > Animation ), the objects marked as controllers will automatically be added to the evaluation graph even if they are not animated yet. This allows Parallel evaluation for manipulation even if they have not yet been keyed.","title":"Evaluation Graph Invalidation"},{"location":"parallel/#idle-actions","text":"In this section, we discuss the different idle actions available in Maya that helps rebuild the EG without any intervention from the user. Prior to Maya 2019, only one idle action, the EG rebuild, was available, but it was not enabled by default. Since Maya 2019, we have added another idle action, the EG preparation for manipulation, and both of these are enabled by default. Here is a description of the idle actions: Idle Action Description EG Rebuild Builds the graph topology. This idle action is executed after a file load operation, or after a graph topology invalidation. EG Preparation for manipulation Partitions and schedules the graph. This idle action is executed after a graph rebuild (either manually or through the idle action), or after a partitioning invalidation. Tip You can use the evaluationManager command to change which idle actions are enabled. You can enable and disable both idle actions individually.","title":"Idle Actions"},{"location":"parallel/#benefits","text":"To make use of the Parallel Evaluation and GPU deformation during manipulation, the EG needs to be properly built, partitioned and scheduled, otherwise it will revert to DG. These idle actions allow the EG to automatically build and be ready to use when needed, since they are triggered at file load and after graph invalidation. If you use Cached Playback , your cache automatically refills, too. This way, you can start playing from cache as soon as the scene is loaded or after you modify to the scene.","title":"Benefits"},{"location":"parallel/#caveats","text":"In a typical frame evaluation, temporary values that are set on keyed attributes are restored to their original values, that is, the values on their associated curves. With the idle actions, this is an unwanted behavior, otherwise you would not be able to do any modifications to keyed attributes. To circumvent that issue, we had to add some special behaviougs One of these is the dirty propagation from stale plugs after an idle preparation for manipulation. When not in idle preparation for manipulation, this operation is done during the partitioning and scheduling phase. With idle preparation for manipulation, this operation is done at the next complete evaluation. Therefore, if you have many static curves, you might experience a slowdown on the first frame of playback. If you do frequent operations that invalidate the graph or partitioning, you may experience some slowdowns due to the graph always being rebuilt. In such cases, it is advised that you disable the offending idle action until you are done.","title":"Caveats"},{"location":"parallel/#custom-evaluators","text":"In this section, we describe mechanisms to perform targeted evaluation of node sub-graphs. This approach is used by Maya to accelerate deformations on the GPU and to catch evaluation errors for scenes with specific nodes. Maya 2017 also introduced new Open API extensions , allowing user-defined custom evaluators. Tip Use the evaluator command to query the available/active evaluators or modify currently active evaluators. Some evaluators support using the nodeType flag to filter out or include nodes of certain types. Query the info flag on the evaluator for more information on what it supports. # Returns a list of all currently available evaluators. import maya.cmds as cmds cmds . evaluator ( query = True ) # Result: [u'invisibility', u 'frozen' , ... u 'transformFlattening' , u 'pruneRoots' ] # # Returns a list of all currently enabled evaluators. cmds . evaluator ( query = True , enable = True ) # Result: [u'invisibility', u 'timeEditorCurveEvaluator' , ... u 'transformFlattening' , u 'pruneRoots' ] # Note: Enabling or disabling custom evaluators only applies to the current Maya session: the state is not saved in the scene nor in the user preferences. The same applies to configuration done using the evaluator command and the configuration flag.","title":"Custom Evaluators"},{"location":"parallel/#gpu-override","text":"Maya contains a custom deformer evaluator that accelerates deformations in Viewport 2.0 by targeting deformation to the GPU. GPUs are ideally suited to tackle problems such as mesh deformations that require the same operations on streams of vertex and normal data. We have included GPU implementations for several of the most commonly-used deformers in animated scenes: skinCluster , blendShape , cluster , tweak , groupParts , softMod , deltaMush , lattice , nonLinear and tension . Unlike Maya\u2019s previous deformer stack that performed deformations on the CPU and subsequently sent deformed geometry to the graphics card for rendering, the GPU override sends undeformed geometry to the graphics card, performs deformations in OpenCL and then hands off the data to Viewport 2.0 for rendering without read-back overhead. We have observed substantial speed improvements from this approach in scenes with dense geometry. Even if your scene uses only supported deformers, GPU override may not be enabled due to the use of unsupported node features in your scene. For example, with the exception of softMod, there is no support for incomplete group components. Additional deformer-specific limitations are listed below: Deformer Limitation(s) skinCluster The following attribute values are ignored: - bindMethod - bindPose - bindVolume - dropOff - heatmapFalloff - influenceColor - lockWeights - maintainMaxInfluences - maxInfluences - nurbsSamples - paintTrans - smoothness - weightDistribution blendShape The following attribute values are ignored: - baseOrigin - icon - normalizationId - origin - parallelBlender - supportNegativeWeights - targetOrigin - topologyCheck cluster n/a tweak Only relative mode is supported. relativeTweak must be set to 1. groupParts n/a softMod Only volume falloff is supported when distance cache is disabled Falloff must occur on all axes Partial resolution must be disabled deltaMush n/a lattice n/a nonLinear n/a tension n/a A few other reasons that can prevent GPU override from accelerating your scene: Meshes not sufficiently dense. Unless meshes have a large number of vertices, it is still faster to perform deformations on the CPU. This is due to the driver-specific overhead incurred when sending data to the GPU for processing. For deformations to happen on the GPU, your mesh needs over 500/2000 vertices, on AMD/NVIDIA hardware respectively. Use the MAYA_OPENCL_DEFORMER_MIN_VERTS environment variable to change the threshold. Setting the value to 0 sends all meshes connected to supported deformation chains to the GPU. Downstream graph nodes required deformed mesh results. Since GPU read-back is a known bottleneck in GPGPU, no node, script, or Viewport can read the mesh data computed by the GPU override. This means that GPU override is unable to accelerate portions of the EG upstream of deformation nodes, such as follicle or pointOnPolyConstraint, that require information about the deformed mesh. We will re-examine this limitation as software/hardware capabilities mature. When diagnosing GPU Override problems, this situation may appear as an unsupported fan-out pattern. See deformerEvaluator command, below, for details. Animated Topology. If your scene animates the number of mesh edges, vertices, and/or faces during playback, corresponding deformation chains are removed from the GPU deformation path. Maya Catmull-Clark Smooth Mesh Preview is used. We have included acceleration for OpenSubDiv (OSD)-based smooth mesh preview, however there is no support for Maya\u2019s legacy Catmull-Clark. To take advantage of OSD OpenCL acceleration, select OpenSubDiv Catmull-Clark as the subdivision method and make sure that OpenCL Acceleration is selected in the OpenSubDiv controls. Unsupported streams are found. Depending on which drawing mode you select for your geometry (for example, shrunken faces, hedge-hog normals, and so on) and the material assigned, Maya must allocate and send different streams of data to the graphics card. Since we have focused our efforts on common settings used in production, GPU override does not currently handle all stream combinations. If meshes fail to accelerate due to unsupported streams, change display modes and/or update the geometry material. Back face culling is enabled. Driver-related issues. We are aware of various hardware issues related to driver support/stability for OpenCL. To maximize Maya\u2019s stability, we have disabled GPU Override in the cases that will lead to problems. We expect to continue to eliminate restrictions in the future and are actively working with hardware vendors to address detected driver problems. You can also increase support for new custom/proprietary deformers by using new API extensions (refer to Custom GPU Deformers for details). If you enable GPU Override and the HUD reports Enabled (0 k) , this indicates that no deformations are happening on the GPU. There could be several reasons for this, such as those mentioned above. To troubleshoot factors that limit the use of GPU override for your particular scene, use the deformerEvaluator command. Supported options include: Command What does it do? deformerEvaluator Prints the chain or each selected node is not supported. deformerEvaluator -chains Prints all active deformation chains. deformerEvaluator -meshes Prints a chain for each mesh or a reason if it is not supported.","title":"GPU Override"},{"location":"parallel/#dynamics-evaluator","text":"Starting in Maya 2017, the dynamics evaluator fully supports parallel evaluation of scenes with Nucleus (nCloth, nHair, nParticles), Bullet, and Bifrost dynamics. Legacy dynamics nodes (for example, particles, fluids) remain unsupported. If the dynamics evaluator finds unsupported node types in the EG, Maya will revert to DG-based evaluation. The dynamics evaluator also manages the tricky computation necessary for correct scene evaluation. This is one of the ways custom evaluators can be used to change Maya\u2019s default evaluation behavior. The dynamics evaluator supports several configuration flags to control its behavior. Flag What does it do? disablingNodes specifies the set of nodes that will force the dynamics evaluator to disable the EM. Valid values are: legacy2016 , unsupported , and none . handledNodes specifies the set of nodes that are going to be captured by the dynamics evaluator and scheduled in clusters that it will manage. Valid values are: dynamics and none . action specifies how the dynamics evaluator will handle its nodes. Valid values are: none , evaluate , and freeze . In Maya 2017, the default configuration corresponds to: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=unsupported\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=dynamics\") cmds.evaluator(name=\"dynamics\", c=\"action=evaluate\") where unsupported (that is, blacklisted) nodes are: collisionModel dynController dynGlobals dynHolder fluidEmitter fluidShape membrane particle (unless also a nBase) rigidNode rigidSolver spring nodes derived from the above This configuration disables evaluation if any unsupported nodes are encountered, and performs evaluation for the other handled nodes in the scene. To revert to Maya 2016 / 2016 Extension 2 behavior, use the configuration: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=legacy2016\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=none\") cmds.evaluator(name=\"dynamics\", c=\"action=none\") where unsupported (that is, blacklisted) nodes are: field fluidShape geoConnector nucleus particle pointEmitter rigidSolver rigidBody nodes derived from the above Tip To get a list of nodes that cause the dynamics evaluator to disable the EM in its present configuration, use the following command: cmds.evaluator(name=\"dynamics\", valueName=\"disabledNodes\", query=True) You can configure the dynamics evaluator to ignore unsupported nodes. If you want to try Parallel evaluation on a scene where it is disabled because of unsupported node types, use the following commands: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=none\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=dynamics\") cmds.evaluator(name=\"dynamics\", c=\"action=evaluate\") Note: Using the dynamics evaluator on unsupported nodes may cause evaluation problems and/or application crashes; this is unsupported behavior. Proceed with caution. Tip If you want the dynamics evaluator to skip evaluation of all dynamics nodes in the scene, use the following commands: cmds.evaluator(name=\"dynamics\", c=\"disablingNodes=unsupported\") cmds.evaluator(name=\"dynamics\", c=\"handledNodes=dynamics\") cmds.evaluator(name=\"dynamics\", c=\"action=freeze\") This can be useful to quickly disable dynamics when the simulation impacts animation performance. Dynamics simulation results are very sensitive to evaluation order, which may differ between DG and EM-based evaluation. Even for DG-based evaluation, evaluation order may depend on multiple factors. For example, in DG-mode when rendering simulation results to the Viewport, the evaluation order may be different than when simulation is performed in \u2018headless mode\u2019. Though EM-based evaluation results are not guaranteed to be identical to DG-based, evaluation order is consistent; once the evaluation order is scheduled by the EM, it will remain consistent regardless of whether results are rendered or Maya is used in batch. This same principle applies to non-dynamics nodes that are order-dependent.","title":"Dynamics Evaluator"},{"location":"parallel/#reference-evaluator","text":"When a reference is unloaded it leaves several nodes in the scene representing reference edits to preserve. Though these nodes may inherit animation from upstream nodes, they do not contribute to what is rendered and can be safely ignored during evaluation. The reference evaluator ensures all such nodes are skipped during evaluation.","title":"Reference Evaluator"},{"location":"parallel/#invisibility-evaluator","text":"Toggling scene object visibility is a critical artist workflow used to reduce visual clutter and accelerate performance. To bring this workflow to parallel evaluation, Maya 2017 and above includes the invisibility evaluator, whose goal is to skip evaluation of any node that does not contribute to a visible object. The invisibility evaluator will skip evaluation of DAG nodes meeting any of the below criteria: visibility attribute is false. intermediateObject attribute is true. overrideEnabled attribute is true and overrideVisibility attribute is false. node belongs to a display layer whose enabled attribute is true and visibility attribute is false. every instance path contains at least one node for which one of the above statements are true. As of Maya 2018, the invisibility evaluator supports the isolate select method of hiding objects. If there is only a single Viewport, and it has one or more objects isolated, then all of the other, unrelated objects are considered invisible by the evaluator. There is also support in Maya (2018 and up) for the animated attribute on expression nodes. When this attribute is set to 1, the expression node is not skipped by the invisibility evaluator, even if only invisible objects are connected to it. Note: The default value of the animated attribute is 1, so in an expression-heavy scene you may see a slowdown from Maya 2017 to Maya 2018. To restore performance, run the script below to disable this attribute on all expression nodes. (It is only required when the expression has some sort of side-effect external to the connections, such as printing a message or checking a cache file size.) for node in cmds.ls( type='expression' ): cmds.setAttr( '{}.animated'.format(node), 0 ) Tip: The invisibility evaluator is off by default in Maya 2017. Use the Evaluation Toolkit or this: cmds.evaluator(enable=True, name='invisibility') to enable the evaluator. The invisibility evaluator only considers static visibility; nodes with animated visibility are still evaluated, even if nodes meet the above criteria. If nodes are in a cycle, all cycle nodes must be considered invisible for evaluation to be skipped. Lastly, if a node is instanced and has at least one visible path upward, then all upward paths will be evaluated. Tip: The invisibility evaluator determines visibility solely from the node\u2019s visibility state; if your UI or plug-in code requires invisible nodes to evaluate, do not use the invisibility evaluator.","title":"Invisibility Evaluator"},{"location":"parallel/#frozen-evaluator","text":"The frozen evaluator allows users to tag EG subsections as not needing evaluation. It enhances the frozen attribute by propagating the frozen state automatically to related nodes, according to the rules defined by the evaluator\u2019s configuration. It should only be used by those comfortable with the concepts of connection and propagation in the DAG and Evaluation Graph. Many users may prefer the invisibility evaluator; it is a simpler interface/workflow for most cases.","title":"Frozen Evaluator"},{"location":"parallel/#the-frozen-attribute","text":"The frozen attribute has existed on nodes since Maya 2016. It can be used to control whether node is evaluated in Serial or Parallel EM evaluation modes. In principle, when the frozen attribute is set, the EM skips evaluation of that node. However, there are additional nuances that impact whether or not this is the case: Everything downstream of frozen nodes is still evaluated, unless they also have the frozen attribute set, or they are affected by the frozen evaluator as described below. Some nodes may perform optimizations that leave their outputs invalid and susceptible to change once evaluated. Freezing these nodes may have unexpected results as nothing preserves the old values. See the documentation on the nodeState attribute for ways to specifically enable caching for nodes you want to freeze. You may have inconsistent per-frame results when the frozen attribute is animated. The node \u201cfreezes\u201d when the attribute is set, so if you jump from frame to frame, your object state reflects the last time you visited in an unfrozen state. Playback is only consistent if your object is not frozen from the first frame. When the frozen node is in the middle of a cycle, it is not respected. Cycles evaluate using the pull model, which does not respect the frozen attribute value. Custom evaluators may or may not respect the frozen attribute value. Take this into consideration as part of their implementation. Warning: All the frozen attribute does is skip evaluation, nothing is done to preserve the current node data during file store; if you load a file with frozen attributes set, the nodes may not have the same data as when you stored them.","title":"The Frozen Attribute"},{"location":"parallel/#operation","text":"The evaluation manager does not evaluate any node that has its frozen attribute set to True, referred to here as explicitly frozen nodes . An implicitly frozen node is one that is disabled because of the operation of the frozen evaluator, but whose frozen attribute is not set to True. When the frozen evaluator is enabled it will also prevent evaluation of related nodes according to the rules corresponding to the enabled options, in any combination. The frozen evaluator operates in three phases. In phase one, it gathers together all of the nodes flagged by the invisible and displayLayers options as being marked for freezing. In phase two, it propagates the freezing state outwards through the evaluation graph according to the values of the downstream and upstream options.","title":"Operation"},{"location":"parallel/#phase-1-gathering-the-nodes","text":"The list of nodes for propagation is gathered as follows: The nodes with their frozen attribute set to True are found. ( Note: This does not include those whose frozen attribute is animated. They are handled via Phase 3.) If the invisible option is True then any node that is explicitly frozen and invisible (directly, or if its parents are all invisible) will have all of its DAG descendants added to the list of nodes for Phase 2. If the displayLayers option is True then any node that is a member of a display layer that is explicitly frozen, enabled, and invisible will have it, and all its DAG descendants added to the list of nodes for Phase 2.","title":"Phase 1: Gathering The Nodes"},{"location":"parallel/#phase-2-propagating-the-freezing","text":"The list gathered by Phase 1 will all be implicitly frozen. In addition, the downstream and upstream options may implicitly freeze nodes related to them. For each of the nodes gathered so far, the evaluation graph will be traversed in both directions, implicitly freezing nodes encountered according to the following options: downstream option value \u201cnone\u201d : No further nodes downstream in the EG will be implicitly frozen \u201csafe\u201d : Nodes downstream in the EG will be implicitly frozen only if every one of their upstream nodes has already been implicitly or explicitly frozen \u201cforce\u201d : Nodes downstream in the EG will be implicitly frozen upstream option value \u201cnone\u201d : No further nodes upstream in the EG will be implicitly frozen \u201csafe\u201d : Nodes upstream in the EG will be implicitly frozen only if every one of their downstream nodes has already been implicitly or explicitly frozen \u201cforce\u201d : Nodes upstream in the EG will be implicitly frozen","title":"Phase 2: Propagating The Freezing"},{"location":"parallel/#phase-3-runtime-freezing","text":"If a node has its frozen or visibility states animated, the evaluator still has to schedule it. The runtime freezing can still assist at this point in preventing unnecessary evaluation. Normally any explicitly frozen node will have its evaluation skipped, with all other nodes evaluating normally. When the runtime option is enabled, after skipping the evaluation of an explicitly frozen node no further scheduling of downstream nodes will occur. As a result, if the downstream nodes have no other unfrozen inputs they will also be skipped. Note: The runtime option does not really modify the evaluator operation, it modifies the scheduling of nodes for evaluation. You will not see nodes affected by this option in the evaluator information (for example, the output from cmds.evaluator( query=True, clusters=True, name='frozen' ) )","title":"Phase 3: Runtime Freezing"},{"location":"parallel/#setting-options","text":"Options can be set for the frozen evaluator in one of two ways: Accessing them through the Evaluation Toolkit Using the evaluator command\u2019s configuration option: cmds.evaluator( name='frozen', configuration='KEY=VALUE' ) Legal KEY and VALUE values are below, and correspond to the options as described above: KEY VALUES DEFAULT runtime True/False False invisible True/False False displayLayers True/False False downstream \u2018off\u2019/\u2018safe\u2019/\u2018force\u2019 \u2018off\u2019 upstream \u2018off\u2019/\u2018safe\u2019/\u2018force\u2019 \u2018off\u2019 Unlike most evaluators the frozen evaluator options are stored in user preferences and persists between sessions.","title":"Setting Options"},{"location":"parallel/#limitations","text":"You must set at least one frozen attribute to True to instruct the frozen evaluator to shut off evaluation on affected nodes. The most practical use of this would be on a display layer so that nodes can be implicitly frozen as a group. If the frozen attribute, or any of the attributes used to define related implicit nodes for freezing (for example, visibility ) are animated then the evaluator will not remove them from evaluation. They will still be scheduled and only the runtime option will help in avoiding unnecessary evaluation. Cycle members are not frozen by the evaluator unless every input to the cycle is frozen. This is a design choice to reflect that as cycles evaluate as a unit, it is impossible to freeze individual members of a cycle. It must be all or nothing.","title":"Limitations"},{"location":"parallel/#curve-manager-evaluator","text":"The curve manager evaluator can be used to include additional nodes in the Evaluation Graph, which can have two main benefits: The additional nodes can be manipulated using parallel evaluation and GPU deformation, which can result in higher responsiveness during interactive manipulation. Fewer Evaluation Graph rebuilds can result, since static nodes can already be included in the Evaluation Graph. To achieve those benefits efficiently, the curve manager evaluator performs two main tasks: During Evaluation Graph construction, it triggers dirty propagation from extra nodes so they are included in the graph construction process and the resulting Evaluation Graph. During scene evaluation, it handles the evaluation of some of those extra nodes to maintain performance, since they do not really need to be evaluated. To illustrate this result, let\u2019s compare the three following situations. A scene where all controllers have a single key (that is, static animation curves). Since the resulting animation curves are constant, they are considered static and are not included in the Evaluation Graph. Playback will have nothing to evaluate. A scene where all controllers have keys of different values (that is, animated curves). Therefore, they will be included in the Evaluation Graph and playback will evaluate everything. A scene where all controllers have a single key (that is, static animation curves), but where the curve manager evaluator is used to prepopulate the Evaluation Graph with those static curves. The third situation is where we are trying to take advantage of the curve manager evaluator to have an Evaluation Graph that is already set up to allow parallel evaluation when the controllers will be manipulated. The following table summarizes the differences between the situations and the compromises provided by the curve manager evaluator. Situation # of nodes in EG Playback EM Manip Rebuild when keying Static curves + curve manager off Lowest Fastest No Yes Animated curves Highest Slowest Yes No Static curves + curve manager on Highest Middle Yes No In summary, the curve manager evaluator benefits from having the Evaluation Graph already populated with nodes so it is ready to evaluate interactive manipulation, while paying as little of a cost as possible for those constant nodes during playback. It can be activated using: cmds.evaluator( name=\"curveManager\", enable=True ) cmds.evaluator( name=\"curveManager\", configuration=\"forceAnimatedCurves=keyed\" ) The available values for forceAnimatedCurves are: \u201cnone\u201d : No curve will be forced in the evaluation graph. \u201ccontroller\u201d : Curves connected to controller nodes will be forced in the evaluation graph. This is basically a generalization of the controller concept. \u201ckeyed\u201d : Keyed static curves, that is, curves with a single key or multiple keys with the same value, will be forced in the evaluation graph. \u201call\u201d : All curves are forced in the evaluation graph. Another option, forceAnimatedNodes , can be used: \u201cnone\u201d : No node will be forced in the evaluation graph. \u201cforcedAnimatedAttribute\u201d : Nodes with the forced-animated attribute set to true will be forced in the evaluation graph. This allows tagging nodes to be added with a boolean dynamic attribute. By default, the name of this attribute is forcedAnimated . If it is present on a node and set to true, the node is added to the graph. The name of the attribute can be controlled by using the \u201cforcedAnimatedAttributeName\u201d option. By default, the curve manager evaluator tries to skip the evaluation of the static parts of the graph. For debugging or performance measurement purposes, this optimization can be disabled: cmds.evaluator( name=\"curveManager\", configuration=\"skipStaticEvaluation=disable\" )","title":"Curve Manager Evaluator"},{"location":"parallel/#other-evaluators","text":"In addition to evaluators described above, additional evaluators exist for specialized tasks: Evaluator What does it do? cache Constitutes the foundation of Cached Playback. See the Maya Cached Playback whitepaper for more information. timeEditorCurveEvaluator Finds all paramCurves connected to time editor nodes and puts them into a cluster that will prevent them from evaluating at the current time, since the time editor will manage their evaluation. ikSystem Automatically disables the EM when a multi-chain solver is present in the EG. For regular IK chains it will perform any lazy update prior to parallel execution. disabling Automatically disables the EM if user-specified nodes are present in the EG. This evaluator is used for troubleshooting purposes. It allows Maya to keep working stably until issues with problem nodes can be addressed. hik Handles the evaluation of HumanIK characters in an efficient way by recognizing HumanIK common connection patterns. cycle Unrolls cycle clusters to augment the opportunity for parallelism and improve performance. Likely gives the best performance improvements when large cycle clusters are present in the scene. Prototype, work in progress. transformFlattening Consolidates deep transform hierarchies containing animated parents and static children, leading to faster evaluation. Consolidation takes a snapshot of the relative parent/child transformations, allowing concurrent evaluation of downstream nodes. pruneRoots We found that scenes with several thousand paramCurves become bogged down because of scheduling overhead from resulting EG nodes and lose any potential gain from increased parallelism. To handle this situation, special clusters are created to group paramCurves into a small number of evaluation tasks, thus reducing overhead. Custom evaluator names are subject to change as we introduce new evaluators and expand these functionalities.","title":"Other Evaluators"},{"location":"parallel/#evaluator-conflicts","text":"Sometimes, multiple evaluators will want to \u201cclaim responsibility\u201d for the same node(s). This can result in conflict, and negatively impact performance. To avoid these conflicts, upon registration each evaluator is associated with a priority; nodes are assigned to the evaluator with the highest priority. Internal evaluators have been ordered to prioritize correctness and stability over speed.","title":"Evaluator Conflicts"},{"location":"parallel/#api-extensions","text":"Several API extensions and tools have been added to help you make the most of the EM in your pipeline. This section reviews API extensions for Parallel Evaluation , Custom GPU Deformers , Custom Evaluator API , VP2 Integration and Profiling Plug-ins .","title":"API Extensions"},{"location":"parallel/#parallel-evaluation","text":"If your plug-in plays by the DG rules, you will not need many changes to make the plug-in work in Parallel mode. Porting your plug-in so that it works in Parallel may be as simple as recompiling it against the latest version of OpenMaya! If the EM generates different results than DG-based evaluation, make sure that your plug-in: Overrides MPxNode::compute() . This is especially true of classes extending MPxTransform which previously relied on asMatrix() . See the rockingTransform SDK sample. For classes deriving from MPxDeformerNode and MPxGeometryFilter , override the deform() method. Handles requests for evaluation at all levels of the plug tree. While the DG can request plug values at any level, the EM always requests the root plug. For example, for plug N.gp[0].p[1] your compute() method must handle requests for evaluation of N.gp, N.gp[0], N.gp[0].p, and N.gp[0].p[1]. If your plug-in relies on custom dependency management, you need to use new API extensions to ensure correct results. As described earlier, the EG is built using the legacy dirty-propagation mechanism. Therefore, optimizations used to limit dirty propagation during DG evaluation, such as those found in MPxNode::setDependentsDirty , may introduce errors in the EG. Use MEvaluationManager::graphConstructionActive() to detect if this is occurring. There are new virtual methods you will want to consider implementing: MPxNode::preEvaluation . To avoid performing expensive calculations each time the evaluation method MPxNode::compute() is called, one strategy plug-in authors use is to store results from previous evaluations and then rely on MPxNode::setDependentsDirty to trigger re-computation. As discussed previously, once the EG has been built, dirty propagation is disabled and the EG is re-used. Threrefore, any custom logic in your plug-in that depends on setDependentsDirty no longer applies. MPxNode::preEvaluation allows your plug-in to determine which plugs/attributes are dirty and if any action is needed. Use the new MEvaluationNode class to determine what has been dirtied. Refer to the simpleEvaluationNode devkit example for an illustration of how to use MPxNode::preEvaluation . MPxNode::postEvaluation . Until now, it was difficult to determine at which point all processing for a node instance was complete. Users sometimes resorted to complex bookkeeping/callback schemes to detect this situation and perform additional work, such as custom rendering. This mechanism was cumbersome and error-prone. Once all computations have been performed on a specific node instance, a new method, MPxNode::postEvaluation , is called. Since this method is called from a worker thread, it performs calculations for downstream graph operations without blocking other Maya processing tasks of non-dependent nodes. See the simpleEvaluationDraw devkit example to understand how to use this method. If you run this example in regular evaluation, Maya slows down, since evaluation is blocked whenever expensive calculations are performed. When you run in Parallel Evaluation Mode, a worker thread calls the postEvaluation method and prepares data for subsequent drawing operations. When testing, you will see higher frame rates in Parallel evaluation versus regular or Serial evaluation. Please note that code in postEvaluation should be thread-safe. Other recommended best practices include: Avoid storing state in static variables. Store node state/settings in attributes. This has the additional benefit of automatically saving/restoring the plug-in state when Maya files are written/read. Node computation should not have any dependencies beyond input values. Maya nodes should be like functions. Output values should be computed from input state and node-specific internal logic. Your node should never walk the graph or try to circumvent the DG.","title":"Parallel Evaluation"},{"location":"parallel/#custom-gpu-deformers","text":"To make GPU Override work on scenes containing custom deformers, Maya provides new API classes that allow the creation of fast OpenCL deformer back-ends. Though you still need to have a CPU implementation for the times when it is not possible to target deformations on the GPU (see GPU Override ), you can augment this with an alternate deformer implementation inheriting from MPxGPUDeformer . This applies to your own nodes as well as to standard Maya nodes. The GPU implementation will need to: Declare when it is valid to use the GPU-based backend (for example, you may want to limit you GPU version to cases where various attributes are fixed, omit usage for specific attribute values, and so on) Extract MDataBlock input values and upload values to the GPU Define and call the OpenCL kernel to perform needed computation Register itself with the MGPUDeformerRegistry system. This will tell the system which deformers you are claiming responsibility for. When you have done this, do not forget to load your plug-in at startup. Two working devkit examples ( offsetNode and identityNode ) have been provided to get you started. Tip To get a sense for the maximum speed increase you can expect by providing a GPU backend for a specific deformer, tell Maya to treat specific nodes as passthrough. Here\u2019s an example applied to polySoftEdge: cmds.GPUBuiltInDeformerControl( name=\"polySoftEdge\", inputAttribute=\"inputPolymesh\", outputAttribute=\"output\", passthrough=True ) Although results will be incorrect, this test will confirm if it is worth investing time implementing an OpenCL version of your node.","title":"Custom GPU Deformers"},{"location":"parallel/#custom-evaluator-api","text":"API classes and methods introduced in Maya 2017 let you define custom evaluators that allow control over how the Maya scene is computed. To create a custom evaluator, you must define a plug-in that extends the MPxCustomEvaluator class. The key class methods to override are described below.","title":"Custom Evaluator API"},{"location":"parallel/#the-basics","text":"Before you can use the new evaluators, they must be registered: MStatus registerEvaluator( // name of the evaluator const char * evaluatorName, // evaluator priority. Higher priority evaluators get 'first-dibs' unsigned int uniquePriority, // function pointer to method returning a new evaluator instance MCreatorFunction creatorFunction ) and deregistered: MStatus deregisterEvaluator( // name of the evaluator const char* evaluatorName ) using MFnPlugin methods. These functions should be used during plug-in initialization: MStatus initializePlugin( MObject obj ) { MFnPlugin plugin( obj, PLUGIN_COMPANY, \"3.0\", \"Any\"); MStatus status = plugin.registerEvaluator( \"SimpleEvaluator\", 40, simpleEvaluator::creator); if (!status) status.perror(\"registerEvaluator\"); return status; } and uninitialization: MStatus uninitializePlugin( MObject obj ) { MFnPlugin plugin( obj ); MStatus status = plugin.deregisterEvaluator( \"SimpleEvaluator\" ); if (!status) status.perror(\"deregisterEvaluator\"); return status; } as illustrated above. Once the plug-in has been loaded, use Python or MEL commands to enable : import maya.cmds as cmds cmds.evaluator(enable=True, name='SimpleEvaluator') # Result: False # disable : cmds.evaluator(enable=False, name='SimpleEvaluator') # Result: True # and query information about evaluators: print cmds.evaluator(query=True) [u'invisibility', ... u'SimpleEvaluator'] NOTE: The evaluator command returns the previous state of the evaluator (as described in the documentation). This command fails if the evaluator cannot be enabled. To view the priorities of all loaded evaluators, use the priority flag on the evaluator command: for evaluatorName in cmds.evaluator(): print \"%-25s : %d\" % ( evaluatorName, cmds.evaluator(name=evaluatorName, query=True, priority=True)) invisibility : 1003000 frozen : 1002000 curveManager : 1001000 cache : 1000000 timeEditorCurveEvaluator : 104000 dynamics : 103000 ikSystem : 102000 disabling : 100000 hik : 7000 reference : 6000 deformer : 5000 cycle : 4000 transformFlattening : 3000 pruneRoots : 1000 SimpleEvaluator : 40","title":"The Basics"},{"location":"parallel/#api-reference","text":"This section provides more detail on different MPxCustomEvaluator API methods.","title":"API Reference"},{"location":"parallel/#claiming-clusters","text":"During EG partitioning, each evaluator gets to claim evaluation nodes, using the: bool MPxCustomEvaluator::markIfSupported(const MEvaluationNode* node) method. You can safely cause evaluation in this call but doing so increases partitioning and evaluation time. The developer can decide whether evaluation is required (call .inputValue / .inputArrayValue ), or the previously-evaluated datablock values can be re-used (call .outputValue / .outputArrayValue ). If multiple evaluators mark a specific node, which evaluator is assigned a node at run-time is determined by priority. For example, if you have two evaluators, A and B, mark node C of interest, if evaluator A has priority 100, and evaluator B has priority 10, during graph partitioning, evaluator A will get the opportunity to grab node C before evaluator B. Evaluators should not try to grab a node already grabbed by a higher-priority evaluator.","title":"Claiming clusters"},{"location":"parallel/#scheduling","text":"To determine if an evaluator can evaluate clusters in Parallel, use: MCustomEvaluatorClusterNode::SchedulingType schedulingType( // a disjoint set of nodes on a custom evaluator layer const MCustomEvaluatorClusterNode * cluster ) where: SchedulingType Details kParallel any number of nodes of the same type can run in parallel kSerial all nodes of this type should be chained and executed sequentially kGloballySerial only one node of this type can be run at a time kUntrusted nothing else can execute with this node since we cannot predict what will happen During EG scheduling: bool MPxCustomEvaluator::clusterInitialize( // evaluation cluster node const MCustomEvaluatorClusterNode* cluster ) can be used to perform the required cluster preparation. The pointer to the cluster remains valid until graph invalidation, such as when the scene topology changes. Before the cluster is deleted, void MPxCustomEvaluator::clusterTerminate( // the cluster to terminate const MCustomEvaluatorClusterNode* cluster ) is called to allow needed cleanup, for example, releasing evaluator-specific resources. It is up to the custom evaluator to decide if it wants to clear its internal representation.","title":"Scheduling"},{"location":"parallel/#execution","text":"There are 3 main methods used during execution. Prior to graph execution, the EM calls: void MPxCustomEvaluator::preEvaluate( // the graph about to be evaluated const MEvaluationGraph* graph ) during execution, the EM calls: void MPxCustomEvaluator::clusterEvaluate( // the cluster to be evaluated const MCustomEvaluatorClusterNode* cluster ) You will only receive clusters that belong to this evaluator. This call always happens after clusterInitialize and never after clusterTerminate . Finally, void MPxCustomEvaluator::postEvaluate( // the graph that was evaluated const MEvaluationGraph* graph ) is called just after a graph evaluation is finished.","title":"Execution"},{"location":"parallel/#simpleevaluator-api-example","text":"Now that we have reviewed relevant API methods, the following example limits evaluation by caching previous results. simpleEvaluator assumes the existence of scene nodes that tag controller nodes with animation and works as follows: In clusterInitialize , we-2\">ld a list of translation and rotation attribute plugs. // Build a list of plugs by scanning the scene for controller nodes. // This gets called during scheduling. bool simpleEvaluator::clusterInitialize( const MCustomEvaluatorClusterNode* cluster ) { if (fControllerPlugs.length() == 0) buildPlugListWithControllerTag(); return true; } // Scan the scene for any controller nodes, populating the plug list. // Called during the scheduling phase void simpleEvaluator::buildPlugListWithControllerTag() { MStatus stat; MItDependencyNodes dgIter(MFn::kControllerTag, &stat); if (stat != MS::kSuccess) return; const char* values[] = { \"translateX\", \"translateY\", \"translateZ\", \"rotateX\", \"rotateY\", \"rotateZ\" }; for (; !dgIter.isDone(); dgIter.next()) { MFnDependencyNode controllerTagNode(dgIter.thisNode(), &stat); if (stat != MS::kSuccess) continue; MPlug currControllerTagPlug = controllerTagNode.findPlug(\"controllerObject\", &stat); if (stat != MS::kSuccess) continue; // found controller tag node, now get its source controller MPlugArray source; bool retval = currControllerTagPlug.connectedTo( source, true /* asDst */, false /* asSrc */, &stat) if ((retval == false) || (stat != MS::kSuccess)) continue; // there should only be one source with the controller tag node // as destination MObject controllerNode = source[0].node(&stat); if (stat != MS::kSuccess) continue; MFnDependencyNode currControllerNode(controllerNode, &stat); if (stat != MS::kSuccess) continue; for (unsigned int j = 0; j < 6; j++) { MPlug currPlug = currControllerNode.findPlug(values[j], &stat); if (stat == MS::kSuccess) fControllerPlugs.append(currPlug); else std::cerr << \"NO PLUG: \" << currControllerNode.name().asChar() << \".\" << values[j] << std::endl; } } } Later, during preEvaluate , which is called per-frame, a hash value is calculated based on the plug values of the current frame. void simpleEvaluator::preEvaluate(const MEvaluationGraph* graph) { buildHashValue(); } void simpleEvaluator::buildHashValue() { unsigned int length = fControllerPlugs.length(); MStatus stat = MS::kSuccess; for (unsigned int i = 0; i < length; i++) { float value = 0; stat = fControllerPlugs[i].getValue(value); if (stat == MS::kSuccess) { boost::hash_combine(fCurrentHashValue, value); } else { std::cerr << \"NO VALUE: \" << fControllerPlugs[i].name().asChar() << std::endl; } } } This value is compared with the previous frame\u2019s hash in clusterEvaluate . If the hash is different, the evaluation proceeds, otherwise we do nothing. void simpleEvaluator::clusterEvaluate( const MCustomEvaluatorClusterNode* cluster ) { if (fOldHashValue != fCurrentHashValue) cluster->evaluate(); } To make sure the hash value is up-to-date, the hash value is stored in postEvaluate . void simpleEvaluator::postEvaluate(const MEvaluationGraph* graph) { fOldHashValue = fCurrentHashValue; fCurrentHashValue = 0; } Finally, when the graph topology becomes invalid, we call clusterTerminate to clear the cached list of plugs. void simpleEvaluator::clusterTerminate( const MCustomEvaluatorClusterNode* cluster ) { if (fControllerPlugs.length() > 0) fControllerPlugs.clear(); } Since simpleEvaluator claims control over the entire graph, markIfSupported returns true for all nodes. Additionally, nothing special is done to alter the cluster\u2019s scheduling behavior. bool simpleEvaluator::markIfSupported(const MEvaluationNode* node) { return true; } MCustomEvaluatorClusterNode::SchedulingType simpleEvaluator::schedulingType(const MCustomEvaluatorClusterNode* cluster) { return cluster->schedulingType(); } See the provided simpleEvaluator devkit example for more details and complete source code.","title":"SimpleEvaluator API Example"},{"location":"parallel/#vp2-integration","text":"Evaluation Manager Parallel Evaluation executes the Dependency Graph in parallel. Internally, Maya nodes begin preparing render data for VP2 immediately after a node is evaluated, and before the rest of the graph has finished evaluation. This is exposed to users as Evaluation Manager Parallel Update in the MPxGeometryOverride API (this feature may also be referred to as \u201cDirect Update\u201d). Supporting Evaluation Manager Parallel Update can significantly reduce time spent in Vp2BuildRenderLists and improve overall scene performance. The following profiler images were created from the same scene (100 footPrintNode_GeometryOverride nodes with animated \u201csize\u201d attributes). In the first image Evaluation Manager Parallel Update is not enabled, and a large amount of time is spent serially preparing draw data for each footPrint node in Vp2BuildRenderLists. In the second image the footPrintNode_GeometryOverride has been modified to support Evaluation Manager Parallel Update. You can see that the long serial execution time in Vp2BuildRenderLists has been eliminated. All the data marshalling for VP2 is occurring in parallel while the Evaluation Manager is evaluating the Dependency Graph. The footPrintNode_GeometryOverride example plug-in provides a detailed example for you to create an efficient MPxGeometryOverride plugin which supports Evaluation Manager Parallel Update and gives excellent performance in VP2. Supporting Evaluation Manager Direct Update adds some restrictions to which operations can safely be performed from MPxGeometryOverride function calls. All MPxGeometryOverride functions (except cleanUp() and the destructor) may be called from a worker thread in parallel with other Maya execution. These methods must all be thread safe. An MPxGeometryOverride object is guaranteed to have at most one of its member functions called at a time. If two different MPxGeometryOverride objects \u201cA\u201d and \u201cB\u201d both require updating, then any member function on \u201cA\u201d could be called at the same time as any member function on \u201cB\u201d. Furthermore, because these methods may be called from a worker thread, direct access to the rendering context is prohibited. MVertexBuffer and MIndexBuffer can still be used, but some of their features are prohibited from use when in Evaluation Manager Parallel Update. Details about which features are safe to use are provided in the documentation for MVertexBuffer and MIndexBuffer .","title":"VP2 Integration"},{"location":"parallel/#tracking-topology","text":"Evaluation Manager Parallel Update currently has the limitation that it can only be used on geometries that do not have animated topology. The status of whether topology is animated or not needs to be tracked from the geometry\u2019s origin to its display shape. If the nodes in the graph are built-in nodes, Maya can know if an animated input will affect the output geometry topology. Similarly, deformers (even custom ones derived from MPxDeformerNode ), are assumed to simply deform their input in their output, keeping the same topology. However, more generic nodes can also generate geometries. When a custom node is a MPxNode , Maya cannot know whether an output geometry has animated topology. It therefore assumes the worst and treats the topology as animated. While this approach is the safest, it can prevent optimizations such as Evaluation Manager Parallel Update. As of Maya 2019, a new API has been added to inform Maya about attributes that might not affect the topology of an output geometry. The first step is to override the MPxNode::isTrackingTopology() method so that Maya can track topology information for this node. The second step is the use the new version of the MPxNode::attributeAffects() method to inform Maya that while the source attribute affects the output attribute, it does not affect its topology. Using this new API helps Maya to know that it is safe to use Evaluation Manager Parallel Update and benefit from its performance boost in more situations.","title":"Tracking Topology"},{"location":"parallel/#profiling-plug-ins","text":"To visualize how long custom plug-ins take in the new profiling tools (see Profiling Your Scene ) you will need to instrument your code. Maya provides C++, Python, and MEL interfaces for you to do this. Refer to the Profiling using MEL or Python or the API technical docs for more details.","title":"Profiling Plug-ins"},{"location":"parallel/#profiling-your-scene","text":"In the past, it could be challenging to understand where Maya was spending time. To remove the guess-work out of performance diagnosis, Maya includes a new integrated profiler that lets you see exactly how long different tasks are taking. Open the Profiler by selecting: Windows > General Editors > Profiler from the Maya menu Persp/Graph Layout from the Quick Layout buttons and choosing Panel Layout > Profiler . Once the Profiler window is visible: Load your scene and start playback Click Start in the Profiler to record information in the pre-allocated record buffer. Wait until the record buffer becomes full or click Stop in the Profiler to stop recording. The Profiler shows a graph demonstrating the processing time for your animation. Try recording the scene in DG , Serial , Parallel , and GPU Override modes. Tip By default, the Profiler allocates a 20MB buffer to store results. The record buffer can be expanded in the UI or by using the profiler -b value; command, where value is the desired size in MB. You may need this for more complex scenes. The Profiler includes information for all instrumented code, including playback, manipulation, authoring tasks, and UI/Qt events. When profiling your scene, make sure to capture several frames of data to ensure gathered results are representative of scene bottlenecks. The Profiler supports several views depending on the task you wish to perform. The default Category View , shown below, classifies events by type (e.g., dirty, VP1, VP2, Evaluation, etc). The Thread and CPU views show how function chains are subdivided amongst available compute resources. Currently the Profiler does not support visualization of GPU-based activity. ![][image1.jpg]","title":"Profiling Your Scene"},{"location":"parallel/#understanding-your-profile","text":"Now that you have a general sense of what the Profiler tool does, let\u2019s discuss key phases involved in computing results for your scene and how these are displayed. By understanding why scenes are slow, you can target scene optimizations. Every time Maya updates a frame, it must compute and draw the elements in your scene. Hence, computation can be split into one of two main categories: Evaluation (i.e., doing the math that determines the most up-to-date values for scene elements) Rendering (i.e., doing the work that draws your scene in the viewport). When the main bottleneck in your scene is evaluation, we say the scene is evaluation-bound . When the main bottleneck in your scene is rendering, we say the scene is render-bound .","title":"Understanding Your Profile"},{"location":"parallel/#profiler-colors","text":"Each event recorded by the profiler has an associated color. Each color represents a different type of event. By understanding event colors you can quickly interpret profiler results. Some colors are re-used and so have different meanings in different categories. Dirty Propagation (Pink and Purple) Pull Evaluation (Dark Green) Forward or Evaluation Manager Evaluation (Peach, Tan and Brown) Set Time (Light Green) Qt Events (Light Blue) VP2 Rendering (Light Blue) VP2 Pull Updates (Light and Dark Yellow and Blue) VP2 Push or Direct Updates (Light and Dark Blue) GPU Override CPU usage (Light and Dark Yellow) Cache Restore (Yellow) Cache Skipped (Gray) We can\u2019t see every different type of event in a single profile, because some events like Dirty Propagation only occur with Evaluation Manager off, and other events like GPU Override CPU usage only occur with Evaluation Manager on. In the following example profiles we will show DG Evaluation, Evaluation Manager Parallel Evaluation, GPU Override Evaluation, Evaluation Cached Evaluation and VP2 Cached Evaluation. Through these examples we\u2019ll see how to interpret a profile based on graph colors and categories, and we\u2019ll learn how each performance optimization in Maya can impact a scene\u2019s performance. The following example profiles are all generated from the same simple FK character playing back.","title":"Profiler Colors"},{"location":"parallel/#dg-evaluation","text":"In this profile of DG Evaluation we can see several types of event. Pink and purple Dirty Propagation events in the Dirty Propagation category. Dark green Pull Evaluation events in the Evaluation category. Blue VP2 Pull Translation and light blue VP2 Rendering in the VP2 Evaluation category. Yellow events in the VP2 Evaluation category show time VP2 spent waiting for data from Dependency Graph nodes. A significant fraction of each frame is spent on Dirty Propagation, a problem which is alleviated by Evaluation Manager.","title":"DG Evaluation"},{"location":"parallel/#em-parallel-evaluation","text":"In this profile of EM Parallel Evaluation we can see all the purple and pink dirty propagation is gone. Peach, tan and brown EM Parallel Evaluation events of the FK rig colored. The high stack of events represents some evaluation occurring in parallel (use thread view to better understand parallelism). Tan and brown EM Parallel Evaluation events while Maya evaluates the skin cluster to compute the deformed mesh. These events occur serially because the Dependency Graph has no parallelism. Dark blue and blue VP2 Direct Update events translate data into a VP2 render-able format. Yellow in the Main category and light blue in the VP2 Evaluation category are VP2 Rendering events. In this profile we see much less time spent on Vp2SceneRender (4). This occurs because time spent reading data from dependency nodes has been moved from rendering to EM Parallel Evaluation (1). DG evaluation uses a data pull model, while EM Evaluation uses a data push model. Additionally, some geometry translation (2), is also moved from rendering to evaluation. We call geometry translation during evaluation \u201cVP2 Direct Update\u201d. A significant portion of each frame is spent deforming and translating the geometry data, a problem which is alleviated by GPU Override.","title":"EM Parallel Evaluation"},{"location":"parallel/#em-parallel-evaluation-with-gpu-override","text":"In this profile of EM Parallel Evaluation we can see one major new difference from the previous profile of EM Parallel Evaluation. Light and dark yellow GPU Override events have replaced the long serial central part of the EM Parallel Evaluation profile (2 & 3 from EM Parallel Evaluation). The GPU Override events represent the time taken on the CPU to marshal data and launch the GPU computation. Peach, tan and brown EM Parallel Evaluation events here have roughly the same duration as EM Parallel Evaluation even though the relative size of the rig evaluation events with GPU Override is larger. This is because the scale of this profile is different from the scale of the previous profile. In the profile of EM Parallel Evaluation with GPU Override the total time displayed is about 5ms. In the previous profile of EM Parallel Evaluation the total time displayed is about 12ms. Light blue VP2 Render events have experienced a similar relative stretching (2).","title":"EM Parallel Evaluation with GPU Override"},{"location":"parallel/#em-evaluation-cached-playback","text":"In this profile of EM Evaluation Cached Playback we can see several new types of event. Yellow Restore Cache events recording the time taken to update each FK rig node which has cached data. There are also brown VP2 Direct Update events used to track update of the VP2 representation of the data. Yellow Restore Cache event for the deformed mesh. This represents the time taken to restore the data into the Maya node, and to translate the data into VP2 for drawing using VP2 Direct Update.","title":"EM Evaluation Cached Playback"},{"location":"parallel/#em-vp2-hardware-cached-playback","text":"Dark blue VP2 Hardware Cache Restore events have replaced the long serial Cache Restore event (2 from EM Evaluation Cached Playback). Restoring the VP2 Hardware Cache is much faster because the data is already in in the render-able format and stored on the GPU. Gray Cache Skipped event signaling data in the dependency node is not updated.","title":"EM VP2 Hardware Cached Playback"},{"location":"parallel/#evaluation-bound-performance","text":"When the main bottleneck in your scene is evaluation, we say the scene is evaluation-bound . There are several different problems that may lead to evaluation-bound performance. Lock Contention. When many threads try to access a shared resource you may experience Lock Contention, due to lock management overhead. One clue that this may be happening is that evaluation takes roughly the same duration regardless of which evaluation mode you use. This occurs since threads cannot proceed until other threads are finished using the shared resource. Here the Profiler shows many separate identical tasks that start at nearly the same time on different threads, each finishing at different times. This type of profile offers a clue that there might be some shared resource that many threads need to access simultaneously. Below is another image showing a similar problem. In this case, since several threads were executing Python code, they all had to wait for the Global Interpreter Lock (GIL) to become available. Bottlenecks and performance loses caused by contention issues may be more noticeable when there is a high concurrency level, such as when your computer has many cores. If you encounter contention issues, try to fix the code in question. For the above example, changing node scheduling converted the above profile to the following one, providing a nice performance gain. For this reason, Python plug-ins are scheduled as Globally Serial by default. As a result, they will be scheduled one after the other and will not block multiple threads waiting for the GIL to become available. Clusters. As mentioned earlier, if the EG contains node-level circular dependencies, those nodes will be grouped into a cluster which represents a single unit of work to be scheduled serially. Although multiple clusters may be evaluated at the same time, large clusters limit the amount of work that can be performed simultaneously. Clusters can be identified in the Profiler as bars wiip.opaqueTaskEvaluation label, shown below. If your scene contains clusters, analyze your rig\u2019s structure to understand why circularities exist. Ideally, you should strive to remove coupling between parts of your rig, so rig sections (e.g., head, body, etc.) can be evaluated independently. Tip When troubleshooting scene performance issues, you can temporarily disable costly nodes using the per-node frozen attribute. This removes specific nodes from the EG. Although the result you see will change, it is a simple way to check that you have found the bottleneck for your scene.","title":"Evaluation-Bound Performance"},{"location":"parallel/#render-bound-performance","text":"When the main bottleneck in your scene is rendering, we say the scene is render-bound . The following is an illustration of a sample result from the Maya Profiler, zoomed to a single frame measured from a large scene with many animated meshes. Because of the number of objects, different materials, and the amount of geometry, this scene is very costly to render. ![][image6.jpeg] The attached profile has four main areas: Evaluation (A) GPUOverridePostEval (B) Vp2BuildRenderLists (C) Vp2Draw3dBeautyPass (D) In this scene, a substantial number of meshes are being evaluated with GPU Override and some profiler blocks appear differently from what they would otherwise. Evaluation. Area A depicts the time spent computing the state of the Maya scene. In this case, the scene is moderately well-parallelized. The blocks in shades of orange and green represent the software evaluation of DG nodes. The blocks in yellow are the tasks that initiate mesh evaluation via GPU Override. Mesh evaluation on the GPU starts with these yellow blocks and continues concurrently with the other work on the CPU. An example of a parallel bottleneck in the scene evaluation appears in the gap in the center of the evaluation section. The large group of GPU Override blocks on the right depend on a single portion of the scene and must wait until that is complete. Area A2 (above area A), depicts blue task blocks that show the work that VP2 does in parallel to the scene evaluation. In this scene, most of the mesh work is handled by GPU Override so it is mostly empty. When evaluating software meshes, this section shows the preparation of geometry buffers for rendering. GPUOverridePostEval. Area B is where GPU Override finalizes some of its work. The amount of time spent in this block varies with different GPU and driver combinations. At some point there will be a wait for the GPU to complete its evaluation if it is heavily loaded. This time may appear here or it may show as additional time spent in the Vp2BuildRenderLists section. Vp2BuildRenderLists. Area C. Once the scene has been evaluated, VP2 builds the list of objects to render. Time in this section is typically proportional to the number of objects in the scene. Vp2PrepareToUpdate. Area C2, very small in this profile. VP2 maintains an internal copy of the world and uses it to determine what to draw in the viewport. When it is time to render the scene, we must ensure that the objects in the VP2 database have been modified to reflect changes in the Maya scene. For example, objects may have become visible or hidden, their position or their topology may have changed, and so on. This is done by VP2 Vp2PrepareToUpdate. Vp2PrepareToUpdate is slow when there are shape topology, material, or object visibility changes. In this example, Vp2PrepareToUpdate is almost invisible since the scene objects require little extra processing. Vp2ParallelEvaluationTask is another profiler block that can appear in this area. If time is spent here, then some object evaluation has been deferred from the main evaluation section of the Evaluation Manager (area A) to be evaluated later. Evaluation in this section uses traditional DG evaluation. Common cases for which Vp2BuildRenderLists or Vp2PrepareToUpdate can be slow during Parallel Evaluation are: Large numbers of rendered objects (as in this example) Mesh topology changes Object types, such as image planes, requiring legacy evaluation before rendering 3 rd party plug-ins that trigger API callbacks Vp2Draw3dBeautyPass. Area D. Once all data has been prepared, it is time to render the scene. This is where the actual OpenGL or DirectX rendering occurs. This area is broken into subsections depending on viewport effects such as depth peeling, transparency mode, and screen space anti-aliasing. Vp2Draw3dBeautyPass can be slow if your scene: Has Many Objects to Render (as in this example). Uses Transparency . Large numbers of transparent objects can be costly since the default transparency algorithm makes scene consolidation less effective. For very large numbers of transparent objects, setting Transparency Algorithm (in the vp2 settings) to Depth Peeling instead of Object Sorting may be faster. Switching to untextured mode can also bypass this cost Uses Many Materials . In VP2, objects are sorted by material prior to rendering, so having many distinct materials makes this time-consuming. Uses Viewport Effects. Many effects such as SSAO (Screen Space Ambient Occlusion), Depth of Field, Motion Blur, Shadow Maps, or Depth Peeling require additional processing. Other Considerations . Although the key phases described above apply to all scenes, your scene may have different performance characteristics. For static scenes with limited animation, or for non-deforming animated objects, consolidation is used to improve performance. Consolidation groups objects that share the same material. This reduces time spent in both Vp2BuildRenderLists and Vp2Draw3dBeatyPass, since there are fewer objects to render.","title":"Render-Bound Performance"},{"location":"parallel/#saving-and-restoring-profiles","text":"Profile data can be saved at any time for later analysis using the Edit -> Save Recording... or Edit -> Save Recording of Selected Events... menu items in the Profiler window. Everything is saved as plain string data (see the appendix describing the profiler file format for a description of how it is stored) so that you can load profile data from any scene using the Edit -> Load Recording... menu item without loading the scene that was profiled.","title":"Saving and Restoring Profiles"},{"location":"parallel/#troubleshooting-your-scene","text":"","title":"Troubleshooting Your Scene"},{"location":"parallel/#analysis-mode","text":"The purpose of Analysis Mode is to perform more rigorous inspection of your scene to catch evaluation errors. Since Analysis Mode introduces overhead to your scene, only use this during debugging activities; animators should not enable Analysis Mode during their day-to-day work. Note that Analysis Mode is not thread-safe, so it is limited to Serial; you cannot use analysis mode while in Parallel evaluation. The key function of Analysis Mode is to: Search for errors at each playback frame. This is different than Safe Mode, which only tries to identify problems at the start of parallel execution. Monitor read-access to node attributes. This ensures that nodes have a correct dependency structure in the EG. Return diagnostics to better understand which nodes influence evaluation. This is currently limited to reporting one destination node at a time. Tip To activate Analysis Mode, use the dbtrace -k evalMgrGraphValid; MEL command. Once active, error detection occurs after each evaluation. Missing dependencies are saved to a file in your machine\u2019s temporary folder (e.g., %TEMP%\\_MayaEvaluationGraphValidation.txt on Windows). The temporary directory on your platform can be determined using the internalVar -utd; MEL command. To disable Analysis Mode, type: dbtrace -k evalMgrGraphValid -off; Let\u2019s assume that your scene contains the following three nodes. Because of the dependencies, the evaluation manager must compute the state of nodes B and C prior to calculating the state of A. Now let\u2019s assume Analysis Mode returns the following report: Detected missing dependencies on frame 56 { A.output <-x- B A.output <-x- C [cluster] } Detected missing dependencies on frame 57 { A.output <-x- B A.output <-x- C [cluster] } The <-x- symbol indicates the direction of the missing dependency. The [cluster] term indicates that the node is inside of a cycle cluster, which means that any nodes from the cycles could be responsible for attribute access outside of evaluation order In the above example, B accesses the output attribute of A, which is incorrect. These types of dependency do not appear in the Evaluation Graph and could cause a crash when running an evaluation in Parallel mode. There are multiple reasons that missing dependencies occur, and how you handle them depends on the cause of the problem. If Analysis Mode discovers errors in your scene from bad dependencies due to: A user plug-in. Revisit your strategy for managing dirty propagation in your node. Make sure that any attempts to use \u201cclever\u201d dirty propagation dirty the same attributes every time. Avoid using different notification messages to trigger pulling on attributes for computation. A built-in node . You should communicate this information to us. This may highlight an error that we are unaware of. To help us best diagnose the causes of this bug, we would appreciate if you can provide us with the scene that caused the problem.","title":"Analysis Mode"},{"location":"parallel/#graph-execution-order","text":"There are two primary methods of displaying the graph execution order. The simplest is to use the \u2018compute\u2019 trace object to acquire a recording of the computation order. This can only be used in Serial mode, as explained earlier. The goal of compute trace is to compare DG and EM evaluation results and discover any evaluation differences related to a different ordering or missing execution between these two modes. Keep in mind that there will be many differences between runs since the EM executes the graph from the roots forward, whereas the DG uses values from the leaves. For example in the simple graph shown earlier, the EM guarantees that B and C will be evaluated before A, but provides no information about the relative ordering of B and C. However in the DG, A pulls on the inputs from B and C in a consistent order dictated by the implementation of node A. The EM could show either \"B, C, A\" or \"C, B, A\" as their evaluation order and although both might be valid, the user must decide if they are equivalent or not. This ordering of information can be even more useful when debugging issues in cycle computation since in both modes a pull evaluation occurs, which will make the ordering more consistent.","title":"Graph Execution Order"},{"location":"parallel/#the-evaluation-toolkit","text":"A set of debugging tools used to be shipped as a special shelf in Maya Bonus Tools, but they are now built-in within Maya. The Evaluation Toolkit provides features to query and analyze your scene and to activate / deactivate various modes. See the accompanying Evaluation Toolkit documentation for a complete list of all helper features.","title":"The Evaluation Toolkit"},{"location":"parallel/#known-limitations","text":"This section lists known limitations for the new evaluation system. VP2 Motion Blur will disable Parallel evaluation. For Motion Blur to work, the scene must be evaluated at different points in time. Currently the EM does not support this. Scenes using FBIK will revert to Serial. For several years now, Autodesk has been deprecating FBIK. We recommend using HIK for full-body retargeting/solving. dbtrace will not work in Parallel mode. As stated in the Analysis Mode section, the dbtrace command only works in Serial evaluation. Having traces enabled in Parallel mode will likely cause Maya to crash. The DG Profiler crashes in Parallel Mode. Unless you are in DG evaluation mode, you will be unable to use the legacy DG profiler. Time permitting, we expect to move features of the DG profiler into the new thread-safe integrated profiler. Batch rendering scenes with XGen may produce incorrect results. Evaluation manager in both Serial and Parallel mode changes the way attributes are cached. This is done to allow safe parallel evaluation and prevent re-computation of the same data by multiple threads. This means that some scenes may evaluate differently if multiple computations of the same attribute occur in one evaluation cycle. With the Evaluation Manager, the first value will be cached. VP2 Direct update does not work with polySoftEdge nodes.","title":"Known Limitations"},{"location":"parallel/#appendices","text":"","title":"Appendices"},{"location":"parallel/#profiler-file-format","text":"The profiler stores its recording data in human-readable strings. The format is versioned so that older format files can still be read into newer versions of Maya (though not necessarily vice-versa). This is a description of the version 1 format. First, a content example: 1 #File Version, # of events, # of CPUs 2 2\\t12345\\t8 3 Main\\tDirty 4 #Comment mapping--------- 5* @27 = MainMayaEvaluation 6 #End comment mapping--------- 7 #Event time, Comment, Extra comment, Category id, Duration, \\ Thread Duration, Thread id, Cpu id, Color id 8* 1234567\\t@12\\t@0\\t2\\t12345\\t11123\\t36\\t1\\t14 9 #Begin Event Tag Mapping--------- 10 #Event ID, Event Tag 11* 123\\tTaggy McTagface 12 #End Event Tag Mapping--------- 13 #Begin Event Tag Color Mapping--------- 14 #Tag Label, Tag Color 15* Taggy\\tMcTagface\\t200\\t200\\t13 16 #End Event Tag Color Mapping--------- EOF The following table describes the file format structure by referring to the previous content: Line(s) Description 1 A header line with general file information names 2 A tab-separated line containing the header information 3 A tab-separated line containing the list of categories used by the events (category ID is the index of the category in the list) 4 A header indicating the start of comment mapping (a mapping from an ID to the string it represents) 5* Zero or more lines lines mapping a number onto a string in the form @LINE = STRING . The IDs do not correspond to anything outside of the file. 6 A footer indicating the end of comment mapping 7 A header indicating the start of event information. The names are the titles of the event columns. Event time is the absolute time, in ticks, the event started Duration is the total amount of time, in ticks, for the entire event Thread duration is the total amount of time, in ticks, the event took inside the thread Comment and Extra comment use an ID from the comment mapping above Category id is the index of the event\u2019s category from the list at line 3 Cpu id and Thread id are the ones in which the event took place. Actual values are arbitrary; only meant to distinguish unique CPUs and Threads Color id is an index into the color mapping internal to the app (colors at the time of creation are not stored in the file). 8* Zero or more tab-separated lines mapping to all of the events that were stored in the file 9 A header indicating the start of the event tag maps 10 A title line showing what values are in the event tag map columns 11* Zero or more tab-separated lines attaching an event tag, defined through the profiler tool, to a specific event ID. The event ID will correspond to the ID given to it in the comment mapping section. 12 A footer indicating the end of the event tag maps 13 A header indicating the start of the event tag color maps 14 A title line showing what values are in the event tag color map columns 15* Zero or more tab-separated lines mapping a tag label defined above to an R,G,B color 16 A header indicating the end of the event tag color maps EOF Sample version 2 file on 4 CPUs containing a single event of type \u201cETName\u201d, description \u201cETDescription\u201d, in category \u201cETCategory\u201d with description \u201cCategory description\u201d, using color 7, of duration 100 ticks, starting at tick 999, on a single thread with ID 22, tagged with \u201cTagMe\u201d which has color red (255 0 0) #File Version, # of events, # of CPUs 2 1 4 ETCategory Category description #Comment mapping--------- @0 = ETName #End comment mapping--------- 999 @0 @0 1 100 100 22 1 7 #Begin comment description mapping--------- @1 = ETDescription #End comment description mapping--------- #Begin Event Tag Mapping--------- #Event ID, Event Tag 1 TagMe #End Event Tag Mapping--------- #Begin Event Tag Color Mapping--------- #Tag Label, Tag Color TagMe 255 0 0 #End Event Tag Color Mapping---------","title":"Profiler File Format"},{"location":"parallel/#debugging-commands","text":"Several commands can be used to help display information about your scene to help in debugging or optimizations. This is a summary of some of the more common ones, and represents only the available runtime information. Consult the command documentation in Maya\u2019s online technical documentation for more information about each command.","title":"Debugging Commands"},{"location":"parallel/#dbcount","text":"Maintains embedded code location counters for higher-level debugging of scene operation. Generally, this uses specialized code that is only available in custom builds. Synopsis: dbcount [flags] Flags: -e -enabled on|off -f -file String -k -keyword String -l -list -md -maxdepth UnsignedInt -q -quick -r -reset -s -spreadsheet Command Type: Command","title":"dbcount"},{"location":"parallel/#dbmessage","text":"Monitors messaging that adds and removes DAG and DG nodes. Synopsis: dbmessage [flags] Flags: -f -file String -l -list -m -monitor on|off -t -type String Command Type: Command","title":"dbmessage"},{"location":"parallel/#dbtrace","text":"Turns on conditional code, typically to print out status information or to take different code paths when enabled. To find available trace objects use dbtrace \u2013q to list currently-enabled traces, and dbtrace \u2013q \u2013off to list currently-disabled traces. To find the current trace output target, use dbtrace -q -k keyword -o . See below for information on specific keywords. Note: Work is currently in progress to make these trace objects more flexible. It is a current design constraint that sometimes they are visible in a release, even though they only function internally, and some cannot be used when using Parallel evaluation. Synopsis: dbtrace [flags] Flags: -q -query -f -filter String -i \u2013info -k -keyword String (multi-use) (Query Arg Optional) -m -mark -o -output String -off - -t -title String -tm -timed on|off -v -verbose Command Type: Command Keyword Description Contents ( Default Output File ) OGSPolyGhosts Shows progress of data extraction from the evaluation of poly ghosts through OGS ( stdout ) cacheConfig Shows cache configuration rules evaluation Result of cache configuration rules for each evaluation node ( _Trace_CacheConfig.txt ) cipEM Shows what Customer Improvement Program data is being collected. Generic usage information. No longer being used ( stdout ) cmdTracking Enables the tracking of counts of commands. Use the dbpeek \u2018cmdTracking\u2019 operation to view the results. No output, but enables tracking of the counts for all commands being executed. (For example, you can turn it on during file load to get a count of the number of createNode calls, including those in referenced files, a task that is difficult to do manually) ( stdout ) compute High level trace of the compute path Nested output showing compute methods being called. Typically in EM mode you should see nesting only in cycles. DG mode will show the full set of nodes triggered by a single evaluation request ( _Trace_Compute.txt ) dbCache Data block manipulation Details of the creation and manipulation of datablock information ( _Trace_DataBlockCache.txt ) deformerEvaluator Statistics for the deformer evaluator setup Shows statistics on what the deformer evaluator was able to ingest, once enabled ( stderr ) evalMgr Evaluation manager interactions ( _Trace_EvalManager.txt ) evalMgrGraphInvalid Evaluation manager graph invalidation ( stdout ) evalMgrGraphValid Evaluation manager execution graph validation errors and warnings Nodes that were evaluated while in EMS mode using the pull (DG) model. This indicates missing dependencies in the evaluation graph, possibly caused by custom dirty propagation ( _MayaEvaluationGraphValidation.txt ) evalMgrSched Internal use only ( _MayaScheduling.txt ) idleBuild Operation of the idle build mechanism for the evaluation graph When the idle build is active, this appears when the idle build is triggered and executed ( _Trace_EGBuild.txt ) nodeTracking Enables tracking of counts of created nodes. Use the dbpeek \u2018nodeTracking\u2019 operation to view results. ( stdout ) peekCache Shows progress of the dbpeek -op cache operation Dumps data collected by the dbpeek operation, and how ( _Trace_DbPeekCache.txt ) peekContext Shows progress of the dbpeek -op context operation Dumps data collected by the dbpeek operation, and how ( stdout ) peekData Shows progress of the dbpeek -op data operation Dumps data collected by the dbpeek operation, and how ( _Trace_DbPeekData.txt ) peekMesh Shows progress of the dbpeek -op mesh operation Dumps data collected by the dbpeek operation, and with what flags ( _Trace_DbPeekMesh.txt )","title":"dbtrace"},{"location":"parallel/#dgdebug","text":"Historical debugging command; not robust or documented. Deprecated : Use the newer dbpeek command. No help is provided for this command.","title":"dgdebug"},{"location":"parallel/#dgdirty","text":"Forces dirty/clean states onto specified plugs and everything downstream from them. Meant to be a safety net for restoring proper states to your scene when something has gone wrong. You should not need to use this command, but it will continue to exist as a \u201creset button\u201d, just in case. Synopsis: dgdirty [flags] [String...] Flags: -q -query -a -allPlugs -c -clean -i -implicit -l -list String -p -propagation -st -showTiming -v -verbose Command Type: Command","title":"dgdirty"},{"location":"parallel/#dgeval","text":"Forces the node to compute certain plugs. Like dgdirty, this command is meant to be a safety net if computation has not occurred in the proper order. Similar in function to the getAttr command, but since it returns no results, it can handle all attribute types, not only those supported by getAttr. Synopsis: dgeval [flags] String... Flags: -src - -v -verbose Command Type: Command","title":"dgeval"},{"location":"parallel/#dginfo","text":"Dumps information about the current state of the graph. Be aware that when plug dirty states are reported, they represent the connection associated with the plug. In fan-out or in-out connections there will be more than one dirty state associated with the connection attached to the plug. This means it is legal to see A->B as dirty but B->A as clean if A has multiple connections. Being Deprecated : Use the newer dbpeek command. Synopsis: dgInfo [flags] [String...] Flags: -all -allNodes -c -connections -d -dirty on|off -n -nodes -nd -nonDeletable -nt -type String -of -outputFile String -p -propagation on|off -s -short -sub -subgraph -sz -size Command Type: Command","title":"dgInfo"},{"location":"parallel/#dgmodified","text":"Checks on the reason a file requests saving when no changes have been made. Synopsis: dgmodified No Flags.","title":"dgmodified"},{"location":"parallel/#dbpeek","text":"This command is called out intentionally, as it combines multiple operations into a single command by use of various operations. It runs one of several operations that provide a view into the data internals in the scene. This is the most useful and flexible of the debugging commands, and new variations of it are often being introduced. Use dbpeek -q -op to show a list of currently available operations and dbpeek -op X -q to show detailed help for operation X . See below for information on specific keywords. Note: The syntax of the argument flag allows for both keyword argument=\u2019key\u2019 and keyword/value argument=\u2019key=value\u2019 forms. Synopsis: dbpeek [flags] [String...] Flags: -q -query -a -argument String (multi-use) (Query Arg Mandatory) -all -allObjects -c -count UnsignedInt -eg -evaluationGraph -of -outputFile String -op -operation String (Query Arg Optional) Command Type: Command","title":"dbpeek"},{"location":"parallel/#dbpeek-op-attributes","text":"Analyzes node or node-type attributes and dumps information about them based on what the selected operation type. Various arguments to the operation change the content of the output. The essence remains the same; the attributes belong to the node or node type. Argument Meaning detail Adds all internal details from attributes being dumped, otherwise dumps only the names and structure. The details are output as object members of the attribute, including the children. nodeType Dumps all attributes belonging to the selected node(s) types. If nothing is selected, it dumps the attributes for all available node types. This includes all node types up the hierarchy to the base node class. noDynamic Skips dynamic attributes in all output. noExtension Skips extension attributes in all output. noStatic Skips static attributes in all output. onlyPlugins Restricts any output to nodes and node types that originate from a plug-in. type=affects Dumps attribute structure and affects relationships in the graphical .dot format. type=detail Dumps attribute information in .json format. This is the default if no type is specified. type=validate Validates flags and structure for consistency and validity. If no nodes are selected, then this command prints the list of all attributes on all nodes. For example, if you had a node type called reversePoint with a vector input and a vector output. type=detail would output this JSON data: { \"nodes\" : { \"reversePoint\" : { \"staticAttributes\" : [ { \"pointInput\" : [ \"pointInputX\", \"pointInputY\", \"pointInputZ\", ] }, { \"pointOutput\" : [ 15\"> \"pointOutputX\", \"pointOutputY\", \"pointOutputZ\", ] } ], \"extensionAttributes\" : [] } } } type=affects would output this DOT data: digraph G { compound=true; subgraph cluster_NODENAME { label=\"Node NODENAME, Type NODETYPE\"; color=\".7 .0 .0\"; ia [label=\"ia/inputAttribute\",style=\"rounded\",shape=ellipse]; oa [label=\"oa/outputAttribute\",style=\"rounded\",shape=rectangle]; ia -> oa; } } and type=validate would output this JSON validation summary: { \"Attribute Validation\" : { \"NODENAME\" : { \"staticAttributes\" : [ { \"Both input and output attributes in compound\" : [ { \"root\" : \"rootAttribute\", \"inputs\" : [\"inputChild\"], \"outputs\" : [\"outputChild\"], } ] } ] } } }","title":"dbpeek -op attributes"},{"location":"parallel/#dbpeek-op-cache","text":"This operation is explained in detail in the Debugging section of the Maya Cached Playback whitepaper.","title":"dbpeek -op cache"},{"location":"parallel/#dbpeek-op-cmdtracking","text":"By default, when no detail argument is present it shows a list of all commands run since the last reset as well as a count of how many of each type were executed. Outputs in command/count pair form, one per line, with a tab character separating them. Argument Meaning reset Set all of the command tracking statistics to zero","title":"dbpeek -op cmdTracking"},{"location":"parallel/#dbpeek-op-connections","text":"By default, when no type argument is present, shows a list of all connections in the DG. Argument Meaning summary Reduces the output to show only the connection counts on the nodes. It separates by single and multi but no further information is added. Useful for getting basic usage information. verbose Shows extra information about every connection, including dirty/propagation states, plug ownership, and type connectivity of the connection. Connections can be single or multi, and be connected either to each other or to plugs.","title":"dbpeek -op connections"},{"location":"parallel/#dbpeek-op-data","text":"Dumps the current contents of a node\u2019s plug data in a standard format. By default the output is in CSV format consisting of 5 columns: NODE PLUG DATA_TYPE CLEAN_STATE DATA_AS_TEXT Example for a simple integer attribute with a dirty value of 5: MyNode MyPlug Int32 0 5 Argument Meaning eval Evaluates plugs first to guarantee that they are clean. Note: Some plugs are always dirty so there may still be plugs that show a dirty value. full Includes plugs with default values in the output. json Uses JSON format for the output. The general form is { \"NODE\" : { \"PLUG\" : { \"TYPE\", \"CLEAN\", \"VALUE\" } } } . For example, a simple numeric attribute with a dirty value of 5 { \"MyNode\" : { \"MyPlug\", \"0\", \"5\" } } matrix Includes all plugs with a \u201cmatrix\u201d data type in the output. This does not include generic data that may have a matrix value at runtime, only attributes that are exclusively matrix types. number Includes all plugs with any numerical data type in the output. This does not include any generic data that may have numerical value at runtime, only attributes that are exclusively numeric types. It includes all types of numeric values, including linear, angular, time, and unitless values. state Includes the current dirty state of the data in the output. time=TIME Rather than evaluating at the normal context, evaluates at a context using the given time. This is somewhat equivalent to getAttr -t TIME . vector Includes all plugs with a \u201cvector\u201d data type in the output. Does not include generic data that may have a vector value at runtime, only attributes that are exclusively double[3] types.","title":"dbpeek -op data"},{"location":"parallel/#dbpeek-op-context","text":"Analyzes context evaluation to detect various errors violating the design. Argument Meaning isolationType=animatedAttributes Filters errors, reporting only those involving animated attributes isolationType=animatedNodes Filters errors, reporting only those involving animated nodes isolationType=staticAndAnimated Reports all errors test=isolation During evaluation, detects when evaluation context is violated causing data to be read or written into a state that belongs to some other evaluation context test=correctness Evaluates the scene in the background, comparing evaluation data stored for background and main context; compares traversing evaluation graph visiting nodes only if all upstream nodes generate equivalent data in both the background and the main context time=TIME Takes a string value indicating the frame time at which evaluation should be performed. verbose Adds extra information to output report. Each test will have its own verbose data. Isolation : Adds callstack information to the report for each detected error. Correctness : Adds attributes which compare failed to compare (due to missing logic) Sample output for isolation tests: { \"context isolation\": { \"frame\": 5.0, \"type\": \"animatedNodes\", \"verbose\": true, \"errors\": [ { \"node\": \"ikHandle1\", \"type\": \"ikHandle\", \"attribute\": \"ikFkManipulation\", \"call stack\": [ \"METHOD Line NUMBER\", \"METHOD Line NUMBER\", \"METHOD Line NUMBER\" ] }, { \"node\": \"shape\", \"type\": \"mesh\", \"attribute\": \"displaySmoothMesh\", \"call stack\": [ \"METHOD Line NUMBER\", \"METHOD Line NUMBER\", \"METHOD Line NUMBER\" ] } ], \"time out\": true } } Sample output for correctness tests: { \"context correctness\": { \"frame\": 14.0, \"verbose\": true, \"errors\": [ { \"node\": \"IKSpineCurveShape\", \"type\": \"nurbsCurve\", \"attributes\": [ \"worldSpace\" ] } ], \"failed to compare\": [ \"input\", \"clusterXforms\", \"clusterTransforms\", \"target\", \"mySpecialAttribute\" ], \"time out\": true } }","title":"dbpeek -op context"},{"location":"parallel/#dbpeek-op-edits","text":"Shows a list of all nodes for which tracking is currently enabled. The \u201ctrack\u201d flag is mandatory. Argument Meaning track Shows a list of all nodes for which tracking is currently enabled.","title":"dbpeek -op edits"},{"location":"parallel/#dbpeek-op-evalmgr","text":"Outputs the current state of all of the custom evaluators used by the Evaluation Manager. Argument Meaning custom Outputs the custom evaluators registered with the evaluation manager. global Adds output that is independent of scene contents, for example, node types enabled for the custom evaluators. local Adds output that is specific to the scene contents, for example, nodes supported by a custom evaluator.","title":"dbpeek -op evalMgr"},{"location":"parallel/#dbpeek-op-graph","text":"Gets a list of nodes or connections from either the dependency graph or the underlying evaluation graph. Argument Meaning connections Dumps the list of all connections in the chosen graph. The sorting order is alphabetical by destination plug name. dot Dumps the graph information in .dot format for parsing and display by an external application such as graphViz. evaluationGraph Gets the structure information from the evaluation graph, otherwise uses the raw dependency graph. The dbpeek command flag \u201cevaluationGraph\u201d does the same thing. graph Dumps the graph state and contents, not including what is dumped by any of the other flags. nodes Dumps the list of all nodes in the chosen type of graph, in alphabetical order by full node name. plugs For the evaluation graph option, dumps the list of all plugs in its dirty plug list in the evaluation nodes. For the DG option, dumps the list of plugs currently in the plug trees. scheduling Dumps the scheduling type used for all nodes in the type of graph in the form NODE = SCHEDULING_TYPE. If a node type is specified, the default scheduling type for nodes of that specific node type is returned in the same format. verbose When dumping the scheduling graph in .dot format, adds all of the names of the nodes to the clusters. Otherwise, it is only a count of nodes in each cluster","title":"dbpeek -op graph"},{"location":"parallel/#dbpeek-op-mesh","text":"Dumps the current contents of the mesh to a standard format. There are two types of formatting and two levels of detail to present. Argument Meaning eval Evaluates mesh plugs first to guarantee they are clean. Otherwise the values currently present in the mesh shape are used as-is. json Dumps data in JSON format instead of CSV. verbose Puts full values for all of the data in the output. Otherwise, only a number count of each type is returned. See the flag descriptions for more information on which data can be requested and what is returned for each type. vertex Includes vertex position or vertex count in the output. The short return is a count of vertices in the mesh. The verbose values are a list of vertex number and the {X,Y,Z} positions of the vertex, with W factored in, if appropriate. For the default level of detail, the default CSV format output will look like this: NODE_NAME,DATA_TYPE,DATA_COUNT For example, a cube containing 32 vertices would have these lines: Node,DataType,Count pCubeShape1,outMesh,32 The JSON equivalent format would look like this: { \"pCubeShape1\" : { \"outMesh\" : \"32\" } } If the full detail is requested, then the (abbreviated) output for CSV format will look like this: Node,Plug,Clean,Value pCubeShape1,outMesh[0],1,0.0 0.0 0.0 pCubeShape1,outMesh[1],1,0.0 0.5 0.0 ... pCubeShape1,outMesh[32],1,1.0 1.0 1.0 and like this for JSON format: { \"pCubeShape1\" : { \"outMesh\" : { \"clean\" : 1, \"0\" : [0.0, 0.0, 0.0], \"1\" : [0.0, 0.5, 0.0], \"...\" : \"...\", \"32\": [1.0, 1.0, 1.0] } } }","title":"dbpeek -op mesh"},{"location":"parallel/#dbpeek-op-metadata","text":"Shows node metadata. The default operation shows a list of all nodes containing metadata. Argument Meaning summary Shows a single line per node, with metadata indicating how many channels, streams, and values are present in the metadata. verbose Shows a detailed list of all metadata on nodes, including a dump in the debug serialization format for each of the metadata streams.","title":"dbpeek -op metadata"},{"location":"parallel/#dbpeek-op-node","text":"Show select debugging information on DG nodes. See also the \u201cplug\u201d and \u201cconnection\u201d operations for display of information specific to those facets of a node. If no arguments are used then the ones marked as [default] will all be enabled, for convenience. Argument Meaning datablock [default] Shows the values in the datablock(s) datablockMemory Shows raw datablock memory. This is independent of the other other datablock flags. dynamicAttr Shows dynamic attributes. evaluationGraph [default] Includes evaluation graph information on the node extensionAttr Shows the extension attributes node [default] Shows information specific to individual node types, such internal caches, flags, or special relationships it maintains. All other data shown is common to all node types plug [default] Shows the nodes plug information skipClean Does not include datablock values that are clean skipDirty [default] Does not include the datablock values that are dirty skipMulti Does not include the datablock values that are multi (array) attributes staticAttr Shows the static attributes verbose Shows much more detail where available. This will include things such as flags set on objects, full detail on heavy data, and any extra detail specific to a node type, such as caches.","title":"dbpeek -op node"},{"location":"parallel/#dbpeek-op-nodes","text":"By default, when no detail argument is present, shows a list of all currently registered node types. Argument Meaning binary Also includes the IFF tag used to identify each node type in the \u201c.mb\u201d file format","title":"dbpeek -op nodes"},{"location":"parallel/#dbpeek-op-nodetracking","text":"By default, when no argument is present, shows a list of all nodes created since the last reset along with a count of how many of each type were created. Output is in the form of nodeType/count pairs, one per line, with a tab character separating them. Argument Meaning reset Erases all of the node tracking statistics.","title":"dbpeek -op nodeTracking"},{"location":"parallel/#dbpeek-op-plugs","text":"Shows information about all of the plugs in a scene. By default, when no argument is present, shows static plug footprint. A lot of this is only displayed in specially-instrumented builds, and generally only of use internally. Argument Meaning details Includes the full plug/node name information in the output. Otherwise only the total and summary counts are dumped. group=stat Groups all output by statistic name group=node Groups all output by node name mode=footprint Reports size information for currently-existing networked plugs. mode=usage Reports dynamic code path statistics, if they have been enabled in the current build mode=reset When used in conjunction with \u201cusage\u201d, resets the statistics back to zero. mode=state Gets unevaluated state information for boolean plugs. Only available on specially-built cuts. nodeType=TYPE Restricts the operation to the node types specified in the argument. This includes inherited types, for example if the value is \u201ctransform\u201d, then the operation also applies to \u201cjoint\u201d nodes, as the node type \u201cjoint\u201d inherits from the node type \u201ctransform\u201d. See the node type documentation or the nodeType command for complete information on which node types inherit from each other. stat=STAT If this argument has no STAT, then sorts by the name of the statistic. If this argument does have a STAT, for example, \u201cstat=addToNet\u201d, then only reports that statistic. Only available on specially-built cuts.","title":"dbpeek -op plugs"},{"location":"parallel/#revisions","text":"","title":"Revisions"},{"location":"parallel/#2020","text":"Updated the dbtrace section to add info about: OGSPolyGhosts cacheConfig evalMgr evalMgrGraphInvalid peekCache peekContext Added a link in the dbpeek section to details regarding the new cache operation.","title":"2020"},{"location":"parallel/#2019","text":"Updated the Key Concepts section. Added more info about the different graphs (DG, EG, SG). Added a section about VP2 Integration and Evaluation Manager Parallel Update. Added a section about Tracking Topology for Evaluation Manager Parallel Update. Updated the Custom Evaluators section to describe the new evaluators. New evaluators: curveManager (now with its own subsection) cache cycle","title":"2019"},{"location":"parallel/#2018","text":"Created an Appendices section. Added a section that describes the Profiler File Format . Moved Debugging Commands section to the Appendices . Updated the Custom Evaluators section to describe the new evaluators. New evaluators: curveManager hik Added information on isolate-select and expressions to the Invisibility Evaluator Added new deformer types supported in GPU override : deltaMush lattice nonLinear tension","title":"2018"},{"location":"parallel/#2017","text":"Added section on graph invalidation . Added information about different ways to query scheduling information (see Thread Safety ). Updated the Custom Evaluators section to describe the new evaluators. New evaluators: invisibility frozen timeEditorCurveEvaluator dynamics evaluator support for Parallel evaluation of scenes with dynamics is now enabled by default. Added Custom Evaluator API section. Added Evaluation Toolkit section. Added Debugging Commands section. Miscellaneous typo fixes and small corrections.","title":"2017"},{"location":"parallel/#2016-extension-2","text":"Added tip about the controller command. Updated Other Evaluators subsection in the Custom Evaluators section to describe the new evaluators. New evaluators: transformFlattening reference deformer evaluator is now enabled by default. dynamics evaluator has a new behavior, disabled by default, to support Parallel evaluation of scenes with dynamics. Updated Evaluator Conflicts subsection in the Custom Evaluators section. Updated Python plug-ins scheduling to Globally Serial. Updated Render-Bound Performance subsection in the Profiling Your Scene section. Added new images for graph examples. Miscellaneous typo fixes and small corrections.","title":"2016 Extension 2"},{"location":"parallel/#2016","text":"Initial version of the document.","title":"2016"},{"location":"physics/","text":"Constraint Every object in the real world can move along 6 different axes, or 6 \"degrees of freedom\". Translate X Translate Y Translate Z Rotate X Rotate Y Rotate Z A constraint limits one or more of these axes. In Maya, the most typical form of constraint is locking a channel. This prevents this axis from changing. A value < 0 means LOCKED , meaning it may not move along this axis A value = 0 means FREE , meaning it may freely move along this axis A value > 0 means LIMITED , meaning it may move within the limited range of this axis Soft Constraints Limits above 0 are referred to as \"soft\", because their amount of influence can be tuned using the Stiffness and Damping attributes. These can safely flex and can approach that of a hard constraint given enough stiffness and damping, but would struggle to reach a given target 100%. Hard Constraints Limits below 0, typically -1, are referred to as \"hard\", because their influence is infinite. These should never flex, as even the slightest amount of flex means the constraint has broken . Leaving the solver in a poor state, struggling to keep up.","title":"Physics"},{"location":"physics/#constraint","text":"Every object in the real world can move along 6 different axes, or 6 \"degrees of freedom\". Translate X Translate Y Translate Z Rotate X Rotate Y Rotate Z A constraint limits one or more of these axes. In Maya, the most typical form of constraint is locking a channel. This prevents this axis from changing. A value < 0 means LOCKED , meaning it may not move along this axis A value = 0 means FREE , meaning it may freely move along this axis A value > 0 means LIMITED , meaning it may move within the limited range of this axis","title":"Constraint"},{"location":"physics/#soft-constraints","text":"Limits above 0 are referred to as \"soft\", because their amount of influence can be tuned using the Stiffness and Damping attributes. These can safely flex and can approach that of a hard constraint given enough stiffness and damping, but would struggle to reach a given target 100%.","title":"Soft Constraints"},{"location":"physics/#hard-constraints","text":"Limits below 0, typically -1, are referred to as \"hard\", because their influence is infinite. These should never flex, as even the slightest amount of flex means the constraint has broken . Leaving the solver in a poor state, struggling to keep up.","title":"Hard Constraints"},{"location":"quick-tail-setup/","text":"In this tutorial you'll learn how to setup a tail with physics and how to steer the look and feel of the simulation using normal keyframing techniques. We'll use one of the excellent rigs by Truong CG Artist . Optional example files falloff_example.zip Walkcycle Let's start with a walkcycle, and move towards interacting with the environment. Apply Simulation Select the hip followed by each tail control along the tail in order, and click Create Dynamic Control . Reduce Gravity This particular rig is very small, about 1.6 cm tall, so we need to reduce the default Gravity to reflect this. Global Strength The first selected Dynamic Control contains a Guide Multiplier to influence the strength on all of the tail controls at the same time. Local Strength You can also adjust the strength values individually for each joints, to taper their stiffness along the length of the tail. Strength Falloff Let's taper the strength along the length of the tail. Result Let's see how it looks. Sitting Down Now let's see how to steer our simulation with regular keyframes. Switch to Animation The simulation will try to follow your keyframe animation. Just switch off the Simulated attribute on the root control while you're animating, then switch it back on to see how it looks. Animation vs Simulation You can see the animation input on the left and the resulting simulation on the right. With just 3 keyframed poses we end up with this result. Note that I had to overcompensate my animation poses to fight gravity when the tail swings around. Advanced Control Gain even more fine-grained control with these advanced topics. Flex and Relax Muscles By keyframing the root strength multiplier you can flex or relax the muscles in the tail. The higher the value the stiffer it gets and the lower the value the more relaxed it becomes, allowing gravity to drop it to the ground. Damping Damping controls how fleshy and sluggish your simulation behaves. Low or zero damping preserves more energy in the system, making a simulation more elastic or rubbery. Creatures and humans tend to look best with moderate to high damping values.","title":"Quick tail setup"},{"location":"quick-tail-setup/#walkcycle","text":"Let's start with a walkcycle, and move towards interacting with the environment.","title":"Walkcycle"},{"location":"quick-tail-setup/#apply-simulation","text":"Select the hip followed by each tail control along the tail in order, and click Create Dynamic Control .","title":"Apply Simulation"},{"location":"quick-tail-setup/#reduce-gravity","text":"This particular rig is very small, about 1.6 cm tall, so we need to reduce the default Gravity to reflect this.","title":"Reduce Gravity"},{"location":"quick-tail-setup/#global-strength","text":"The first selected Dynamic Control contains a Guide Multiplier to influence the strength on all of the tail controls at the same time.","title":"Global Strength"},{"location":"quick-tail-setup/#local-strength","text":"You can also adjust the strength values individually for each joints, to taper their stiffness along the length of the tail.","title":"Local Strength"},{"location":"quick-tail-setup/#strength-falloff","text":"Let's taper the strength along the length of the tail.","title":"Strength Falloff"},{"location":"quick-tail-setup/#result","text":"Let's see how it looks.","title":"Result"},{"location":"quick-tail-setup/#sitting-down","text":"Now let's see how to steer our simulation with regular keyframes.","title":"Sitting Down"},{"location":"quick-tail-setup/#switch-to-animation","text":"The simulation will try to follow your keyframe animation. Just switch off the Simulated attribute on the root control while you're animating, then switch it back on to see how it looks.","title":"Switch to Animation"},{"location":"quick-tail-setup/#animation-vs-simulation","text":"You can see the animation input on the left and the resulting simulation on the right. With just 3 keyframed poses we end up with this result. Note that I had to overcompensate my animation poses to fight gravity when the tail swings around.","title":"Animation vs Simulation"},{"location":"quick-tail-setup/#advanced-control","text":"Gain even more fine-grained control with these advanced topics.","title":"Advanced Control"},{"location":"quick-tail-setup/#flex-and-relax-muscles","text":"By keyframing the root strength multiplier you can flex or relax the muscles in the tail. The higher the value the stiffer it gets and the lower the value the more relaxed it becomes, allowing gravity to drop it to the ground.","title":"Flex and Relax Muscles"},{"location":"quick-tail-setup/#damping","text":"Damping controls how fleshy and sluggish your simulation behaves. Low or zero damping preserves more energy in the system, making a simulation more elastic or rubbery. Creatures and humans tend to look best with moderate to high damping values.","title":"Damping"},{"location":"serialisation/","text":"Serialise all rigid bodies to JSON, for import into external software such as Unreal, Unity, Godot, CryEngine or any other engine able to read and parse JSON, including your own custom game engine. Units All linear units are in centimeters All angular units are in radians All quaternions are ordered XYZW Overview On playback, Ragdoll generates a physical representation of your Maya scene, suitable for simulation. You can gain access to that representation, independent of Maya, for use in your own software and for your own purposes. This enables you to use Maya as an authoring environment for general-purpose physics scenes, including full or partial ragdolls, for characters or props and even full environments. Target Audience Game programmers working on a custom engine Technical Directors working with e.g. Unreal Engine, Unity or CryEngine Roboticists exploring algorithms on humanoids with rigid bodies Scientists in Machine Learning in need of bespoke ragdolls for their work Usecases Once a ragdoll has been authored in Maya, it can be exported for later import into external software for a variety of purposes. Game Development where main or secondary characters need a physics representation Virtual Production where you need Motion Builder or Unreal Engine to reproduce physics happening in Maya for real-time feedback Robotics where you want interactive control over parameters that are also applied to a physical real-world equivalent, like Boston Dynamics's Atlas Reinforcement Learning where algorithm and articulation depend on each other and are iterated upon in parallel, like OpenAI's gym environments and algorithms Debugging in cases where odd things happen and you just require deep insight into what the solver sees Concepts Ragdoll internally stores data as \"entities\" and \"components\". Entity is a unique identifier for any \"thing\" in the solver, like a rigid body, a constraint or force. Component is a set of data, like the transformation or rigid body properties, associated to an entity The exported format reflects this relationship and looks something like this. { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } } Rigid Body A single translation/rotation pair. Components Component Description NameComponent Name and path in Maya ColorComponent Used in Maya viewport SceneComponent Reference to the scene entity this rigid belongs to RestComponent Initial transformation RigidComponent Physics attributes GeometryDescriptionComponent Shape attributes \"RigidComponent\" : { \"type\" : \"RigidComponent\" , \"members\" : { \"enabled\" : true , \"mass\" : 1.0 , \"friction\" : 0.80 , \"restitution\" : 0.10 , \"thickness\" : 0.0 , \"disableGravity\" : false , \"collide\" : true , \"kinematic\" : false , \"dynamic\" : true , \"sleeping\" : false , \"linearDamping\" : 0.5 , \"angularDamping\" : 1.0 , \"positionIterations\" : 8 , \"velocityIterations\" : 1 , \"maxContactImpulse\" : - 1.0 , \"maxDepenetrationVelocity\" : - 1.0 , \"sleepThreshold\" : 0.00 , \"enableCCD\" : false , # A value of -1 means \"automatically computed\" \"angularMass\" : { \"type\" : \"Vector3\" , \"values\" : [ - 1.0 , - 1.0 , - 1.0 ] }, # A value of 0 means \"automatically computed\" \"centerOfMass\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.0 , 0.0 , 0.0 ] } } } Shape Every rigid has exactly one collision shape. The transformation of this shape can be optionally offset, and that offset happens in the frame of the rigid. ________ ^ |\\ \\ | | \\_______\\ | | | | o--\\-|-> | \\ \\|______| \\ v In this example, the center of the box is offset from the center of the rigid along the X axis. Notice how the geometry is relative the axis of the rigid, so rotating the rigid along the Z axis would naturally take the geometry with it. \"GeometryDescriptionComponent\" : { \"type\" : \"GeometryDescriptionComponent\" , \"members\" : { \"type\" : \"Capsule\" , # Used by Capsule \"length\" : 0.123 , # Used by Sphere \"radius\" : 0.012 , # Used by Box \"extents\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.123 , 0.024 , 0.0247 ] }, # Translation relative the associated rigid \"offset\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.033 , - 0.05 , 0.00 ] }, # Rotation relative the associated rigid # Ordered as XYZW \"rotation\" : { \"type\" : \"Quaternion\" , \"values\" : [ 0.87 , - 0.47 , 0.00 , 0.00 ] } } } Constraint A relationship between two rigid bodies is referred to as a \"constraint\". A constraint constrains the way two rigid bodies move relative each other. For example, the position of the lower arm is typically associated with the tip of the upper arm. Wherever the upper arm goes, the lower arm must follow. It may also be further limited in how it is oriented, to e.g. prevent a lower arm from bending past the natural elbow limit; i.e. to rotate between 20-180 degrees along the Z axis, and 0-10 degrees around the X and Y axis (as that rotation would normally come from twisting the upper arm). All constraints are bi-directional Rigid A attaches to B, as B attaches to A The point on A where B attaches is referred to as the parentFrame The point on B where A attaches is referred to as the childFrame Despite the name, there is no notion of hierarchy or \"parent\" in Ragdoll; the naming reflects the hierarchy as represented in Maya, where constraints are parented to the rigid representing the childFrame . Components Component Description JointComponent References to associated rigids and frame matrices LimitComponent Optional limits on translation and/or rotation DriveComponent Optional target transformation, i.e. the animation \"JointComponent\" : { \"type\" : \"JointComponent\" , \"members\" : { # Reference to the associated rigid body entities \"parent\" : 1048586 , \"child\" : 1048584 , # The translate/rotate of the parent # rigid in the frame of child rigid \"parentFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.760 , - 0.594 , - 0.259 , 0.0 , - 0.648 , - 0.680 , - 0.340 , 0.0 , 0.0262 , 0.4274 , - 0.903 , 0.0 , 10.51 , - 0.646 , 0.0 , 1.0 ] }, # The translate/rotate of the child # rigid in the frame of parent rigid \"childFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.606 , - 0.751 , - 0.259 , 0.0 , - 0.785 , - 0.515 , - 0.340 , 0.0 , 0.122 , 0.4103 , - 0.903 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] }, # Allow intersections between connected rigids \"disableCollision\" : true } } Limit Constraints may optionally have a \"limit\", which means it can keep a rigid within a given angle (\"angular limit\") or position (\"linear limit\"). Min & Max Values represent a upper end of a range . With x=5 the minimum value of the linear X axis is -5 . \"LimitComponent\" : { \"type\" : \"LimitComponent\" , \"members\" : { \"enabled\" : true , \"x\" : - 1.0 , # Linear limit along the X-axis \"y\" : - 1.0 , \"z\" : - 1.0 , \"twist\" : 0.78 , # Angular limit along the X-axis \"swing1\" : 0.78 , # ..Y \"swing2\" : 0.78 , # ..Z \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } } Locked, Free or Limited A value of -1 means the axis is \"Locked\", i.e. the value along this axis cannot change. A Point Constraint is typically locked on all linear axes, but free on the angular axes. A value of 0 means the axis if \"Free\", meaning it has no effect. It is \"limitless\". A value above 0 indicates the range of a given limit. <0 means Locked =0 means Free >0 means Limited Drive A constraint may optionally have a \"drive\", which means having one rigid reach a target position and/or angle relative another rigid. The typical use case is having simulation match your input animation, where the animation provides the positions and angles. \"DriveComponent\" : { \"type\" : \"DriveComponent\" , \"members\" : { \"enabled\" : true , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"acceleration\" : true , \"target\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.973 , 0.2267 , 0.0 , 0.0 , - 0.226 , 0.973 , 0.0 , 0.0 , 0.0 , 0.0 , 0.999 , 0.0 , 0.1051 , - 0.006 , 0.0 , 1.0 ] } } } Data Types In addition to the plain-old-data types int , double and bool , these are all possible data types found in the exported JSON. { \"type\" : \"Color4\" , \"values\" : [ 0.4429999887943268 , # red 0.7049999833106995 , # green 0.9520000219345093 # blue 1.0 # alpha ] } { \"type\" : \"Vector3\" , \"values\" : [ 100.00001788139201 , # x 100.00001788139201 , # y 100.00000000000003 # z ] } { \"type\" : \"Quaternion\" , \"values\" : [ 0.8791841887437938 , # x - 0.47648206919348187 , # y - 2.7953360940182678e-8 , # z 1.191501461145112e-7 # w ] } { # Unscaled, unsheared matrix \"type\" : \"Matrix44\" , \"values\" : [ 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , 0.0 , # translateX 0.0 , # translateY 0.0 , # translateZ 1.0 ] } Reference Components These are all possible types of components found in the exported JSON. SolverComponent SceneComponent NameComponent ColorComponent RestComponent ScaleComponent RigidComponent GeometryDescriptionComponent JointComponent DriveComponent LimitComponent ConstraintUIComponent RigidUIComponent DriveUIComponent LimitUIComponent Output Example Here's an example of what a complete dump looks like. Ragdoll Dump Output Example Code Example Test your dump, by re-building the scene in Maya. from maya import cmds from ragdoll.vendor import cmdx class Component ( dict ): \"\"\"Simplified access to component members\"\"\" def __getattr__ ( self , key ): value = self [ \"members\" ][ key ] if not isinstance ( value , dict ): return value if value [ \"type\" ] == \"Vector3\" : return cmdx . Vector ( value [ \"values\" ]) elif value [ \"type\" ] == \"Color4\" : return cmdx . Color ( value [ \"values\" ]) elif value [ \"type\" ] == \"Matrix44\" : return cmdx . Matrix4 ( value [ \"values\" ]) elif value [ \"type\" ] == \"Quaternion\" : return cmdx . Quaternion ( * value [ \"values\" ]) else : raise TypeError ( \"Unsupported type: %s \" % value ) def dedump ( dump ): with cmdx . DagModifier () as mod : root = mod . createNode ( \"transform\" , name = \"dump\" ) for entity , data in dump [ \"entities\" ] . items (): comps = data [ \"components\" ] if \"RigidComponent\" not in comps : continue name = Component ( comps [ \"NameComponent\" ]) if not name . path : # Bad export continue joint = name . path . rsplit ( \"|\" , 3 )[ - 2 ] scale = Component ( comps [ \"ScaleComponent\" ]) rest = Component ( comps [ \"RestComponent\" ]) desc = Component ( comps [ \"GeometryDescriptionComponent\" ]) # Establish rigid transformation tm = cmdx . TransformationMatrix ( rest . matrix ) # Establish shape if desc . type in ( \"Cylinder\" , \"Capsule\" ): radius = desc . radius * scale . absolute . x length = desc . length * scale . absolute . y geo , _ = cmds . polyCylinder ( axis = ( 1 , 0 , 0 ), radius = radius , height = length , roundCap = True , subdivisionsCaps = 5 ) elif desc . type == \"Box\" : extents = desc . extents extents . x *= scale . absolute . x extents . y *= scale . absolute . y extents . z *= scale . absolute . z geo , _ = cmds . polyCube ( width = extents . x , height = extents . y , depth = extents . z ) elif desc . type == \"Sphere\" : radius = desc . radius * scale . absolute . x geo , _ = cmds . polySphere ( radius = radius ) else : print ( \"Unsupported shape type: %s .type= %s \" % ( name . path , desc . type )) continue with cmdx . DagModifier () as mod : transform = mod . createNode ( \"transform\" , name = joint , parent = root ) transform [ \"translate\" ] = tm . translation () transform [ \"rotate\" ] = tm . rotation () # Establish shape transformation offset = desc . offset offset . x *= scale . absolute . x offset . y *= scale . absolute . y offset . z *= scale . absolute . z geo = cmdx . encode ( geo ) geo [ \"translate\" ] = offset geo [ \"rotate\" ] = desc . rotation transform . addChild ( geo ) # Usage Example import json dump = cmds . ragdollDump () dump = json . loads ( dump ) dedump ( dump ) More Examples Tiger Courtesy of www.cgspectrum.com mytiger.rag Ragcar Model from https://mecabricks.com ragcar.rag Advanced Skeleton A generic human character, rigged with AS. mycharacter.rag","title":"Serialisation"},{"location":"serialisation/#overview","text":"On playback, Ragdoll generates a physical representation of your Maya scene, suitable for simulation. You can gain access to that representation, independent of Maya, for use in your own software and for your own purposes. This enables you to use Maya as an authoring environment for general-purpose physics scenes, including full or partial ragdolls, for characters or props and even full environments.","title":"Overview"},{"location":"serialisation/#target-audience","text":"Game programmers working on a custom engine Technical Directors working with e.g. Unreal Engine, Unity or CryEngine Roboticists exploring algorithms on humanoids with rigid bodies Scientists in Machine Learning in need of bespoke ragdolls for their work","title":"Target Audience"},{"location":"serialisation/#usecases","text":"Once a ragdoll has been authored in Maya, it can be exported for later import into external software for a variety of purposes. Game Development where main or secondary characters need a physics representation Virtual Production where you need Motion Builder or Unreal Engine to reproduce physics happening in Maya for real-time feedback Robotics where you want interactive control over parameters that are also applied to a physical real-world equivalent, like Boston Dynamics's Atlas Reinforcement Learning where algorithm and articulation depend on each other and are iterated upon in parallel, like OpenAI's gym environments and algorithms Debugging in cases where odd things happen and you just require deep insight into what the solver sees","title":"Usecases"},{"location":"serialisation/#concepts","text":"Ragdoll internally stores data as \"entities\" and \"components\". Entity is a unique identifier for any \"thing\" in the solver, like a rigid body, a constraint or force. Component is a set of data, like the transformation or rigid body properties, associated to an entity The exported format reflects this relationship and looks something like this. { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } }","title":"Concepts"},{"location":"serialisation/#rigid-body","text":"A single translation/rotation pair. Components Component Description NameComponent Name and path in Maya ColorComponent Used in Maya viewport SceneComponent Reference to the scene entity this rigid belongs to RestComponent Initial transformation RigidComponent Physics attributes GeometryDescriptionComponent Shape attributes \"RigidComponent\" : { \"type\" : \"RigidComponent\" , \"members\" : { \"enabled\" : true , \"mass\" : 1.0 , \"friction\" : 0.80 , \"restitution\" : 0.10 , \"thickness\" : 0.0 , \"disableGravity\" : false , \"collide\" : true , \"kinematic\" : false , \"dynamic\" : true , \"sleeping\" : false , \"linearDamping\" : 0.5 , \"angularDamping\" : 1.0 , \"positionIterations\" : 8 , \"velocityIterations\" : 1 , \"maxContactImpulse\" : - 1.0 , \"maxDepenetrationVelocity\" : - 1.0 , \"sleepThreshold\" : 0.00 , \"enableCCD\" : false , # A value of -1 means \"automatically computed\" \"angularMass\" : { \"type\" : \"Vector3\" , \"values\" : [ - 1.0 , - 1.0 , - 1.0 ] }, # A value of 0 means \"automatically computed\" \"centerOfMass\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.0 , 0.0 , 0.0 ] } } }","title":"Rigid Body"},{"location":"serialisation/#shape","text":"Every rigid has exactly one collision shape. The transformation of this shape can be optionally offset, and that offset happens in the frame of the rigid. ________ ^ |\\ \\ | | \\_______\\ | | | | o--\\-|-> | \\ \\|______| \\ v In this example, the center of the box is offset from the center of the rigid along the X axis. Notice how the geometry is relative the axis of the rigid, so rotating the rigid along the Z axis would naturally take the geometry with it. \"GeometryDescriptionComponent\" : { \"type\" : \"GeometryDescriptionComponent\" , \"members\" : { \"type\" : \"Capsule\" , # Used by Capsule \"length\" : 0.123 , # Used by Sphere \"radius\" : 0.012 , # Used by Box \"extents\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.123 , 0.024 , 0.0247 ] }, # Translation relative the associated rigid \"offset\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.033 , - 0.05 , 0.00 ] }, # Rotation relative the associated rigid # Ordered as XYZW \"rotation\" : { \"type\" : \"Quaternion\" , \"values\" : [ 0.87 , - 0.47 , 0.00 , 0.00 ] } } }","title":"Shape"},{"location":"serialisation/#constraint","text":"A relationship between two rigid bodies is referred to as a \"constraint\". A constraint constrains the way two rigid bodies move relative each other. For example, the position of the lower arm is typically associated with the tip of the upper arm. Wherever the upper arm goes, the lower arm must follow. It may also be further limited in how it is oriented, to e.g. prevent a lower arm from bending past the natural elbow limit; i.e. to rotate between 20-180 degrees along the Z axis, and 0-10 degrees around the X and Y axis (as that rotation would normally come from twisting the upper arm). All constraints are bi-directional Rigid A attaches to B, as B attaches to A The point on A where B attaches is referred to as the parentFrame The point on B where A attaches is referred to as the childFrame Despite the name, there is no notion of hierarchy or \"parent\" in Ragdoll; the naming reflects the hierarchy as represented in Maya, where constraints are parented to the rigid representing the childFrame . Components Component Description JointComponent References to associated rigids and frame matrices LimitComponent Optional limits on translation and/or rotation DriveComponent Optional target transformation, i.e. the animation \"JointComponent\" : { \"type\" : \"JointComponent\" , \"members\" : { # Reference to the associated rigid body entities \"parent\" : 1048586 , \"child\" : 1048584 , # The translate/rotate of the parent # rigid in the frame of child rigid \"parentFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.760 , - 0.594 , - 0.259 , 0.0 , - 0.648 , - 0.680 , - 0.340 , 0.0 , 0.0262 , 0.4274 , - 0.903 , 0.0 , 10.51 , - 0.646 , 0.0 , 1.0 ] }, # The translate/rotate of the child # rigid in the frame of parent rigid \"childFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.606 , - 0.751 , - 0.259 , 0.0 , - 0.785 , - 0.515 , - 0.340 , 0.0 , 0.122 , 0.4103 , - 0.903 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] }, # Allow intersections between connected rigids \"disableCollision\" : true } }","title":"Constraint"},{"location":"serialisation/#limit","text":"Constraints may optionally have a \"limit\", which means it can keep a rigid within a given angle (\"angular limit\") or position (\"linear limit\"). Min & Max Values represent a upper end of a range . With x=5 the minimum value of the linear X axis is -5 . \"LimitComponent\" : { \"type\" : \"LimitComponent\" , \"members\" : { \"enabled\" : true , \"x\" : - 1.0 , # Linear limit along the X-axis \"y\" : - 1.0 , \"z\" : - 1.0 , \"twist\" : 0.78 , # Angular limit along the X-axis \"swing1\" : 0.78 , # ..Y \"swing2\" : 0.78 , # ..Z \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } } Locked, Free or Limited A value of -1 means the axis is \"Locked\", i.e. the value along this axis cannot change. A Point Constraint is typically locked on all linear axes, but free on the angular axes. A value of 0 means the axis if \"Free\", meaning it has no effect. It is \"limitless\". A value above 0 indicates the range of a given limit. <0 means Locked =0 means Free >0 means Limited","title":"Limit"},{"location":"serialisation/#drive","text":"A constraint may optionally have a \"drive\", which means having one rigid reach a target position and/or angle relative another rigid. The typical use case is having simulation match your input animation, where the animation provides the positions and angles. \"DriveComponent\" : { \"type\" : \"DriveComponent\" , \"members\" : { \"enabled\" : true , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"acceleration\" : true , \"target\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.973 , 0.2267 , 0.0 , 0.0 , - 0.226 , 0.973 , 0.0 , 0.0 , 0.0 , 0.0 , 0.999 , 0.0 , 0.1051 , - 0.006 , 0.0 , 1.0 ] } } }","title":"Drive"},{"location":"serialisation/#data-types","text":"In addition to the plain-old-data types int , double and bool , these are all possible data types found in the exported JSON. { \"type\" : \"Color4\" , \"values\" : [ 0.4429999887943268 , # red 0.7049999833106995 , # green 0.9520000219345093 # blue 1.0 # alpha ] } { \"type\" : \"Vector3\" , \"values\" : [ 100.00001788139201 , # x 100.00001788139201 , # y 100.00000000000003 # z ] } { \"type\" : \"Quaternion\" , \"values\" : [ 0.8791841887437938 , # x - 0.47648206919348187 , # y - 2.7953360940182678e-8 , # z 1.191501461145112e-7 # w ] } { # Unscaled, unsheared matrix \"type\" : \"Matrix44\" , \"values\" : [ 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , 0.0 , # translateX 0.0 , # translateY 0.0 , # translateZ 1.0 ] }","title":"Data Types"},{"location":"serialisation/#reference","text":"","title":"Reference"},{"location":"serialisation/#components","text":"These are all possible types of components found in the exported JSON. SolverComponent SceneComponent NameComponent ColorComponent RestComponent ScaleComponent RigidComponent GeometryDescriptionComponent JointComponent DriveComponent LimitComponent ConstraintUIComponent RigidUIComponent DriveUIComponent LimitUIComponent","title":"Components"},{"location":"serialisation/#output-example","text":"Here's an example of what a complete dump looks like. Ragdoll Dump Output Example","title":"Output Example"},{"location":"serialisation/#code-example","text":"Test your dump, by re-building the scene in Maya. from maya import cmds from ragdoll.vendor import cmdx class Component ( dict ): \"\"\"Simplified access to component members\"\"\" def __getattr__ ( self , key ): value = self [ \"members\" ][ key ] if not isinstance ( value , dict ): return value if value [ \"type\" ] == \"Vector3\" : return cmdx . Vector ( value [ \"values\" ]) elif value [ \"type\" ] == \"Color4\" : return cmdx . Color ( value [ \"values\" ]) elif value [ \"type\" ] == \"Matrix44\" : return cmdx . Matrix4 ( value [ \"values\" ]) elif value [ \"type\" ] == \"Quaternion\" : return cmdx . Quaternion ( * value [ \"values\" ]) else : raise TypeError ( \"Unsupported type: %s \" % value ) def dedump ( dump ): with cmdx . DagModifier () as mod : root = mod . createNode ( \"transform\" , name = \"dump\" ) for entity , data in dump [ \"entities\" ] . items (): comps = data [ \"components\" ] if \"RigidComponent\" not in comps : continue name = Component ( comps [ \"NameComponent\" ]) if not name . path : # Bad export continue joint = name . path . rsplit ( \"|\" , 3 )[ - 2 ] scale = Component ( comps [ \"ScaleComponent\" ]) rest = Component ( comps [ \"RestComponent\" ]) desc = Component ( comps [ \"GeometryDescriptionComponent\" ]) # Establish rigid transformation tm = cmdx . TransformationMatrix ( rest . matrix ) # Establish shape if desc . type in ( \"Cylinder\" , \"Capsule\" ): radius = desc . radius * scale . absolute . x length = desc . length * scale . absolute . y geo , _ = cmds . polyCylinder ( axis = ( 1 , 0 , 0 ), radius = radius , height = length , roundCap = True , subdivisionsCaps = 5 ) elif desc . type == \"Box\" : extents = desc . extents extents . x *= scale . absolute . x extents . y *= scale . absolute . y extents . z *= scale . absolute . z geo , _ = cmds . polyCube ( width = extents . x , height = extents . y , depth = extents . z ) elif desc . type == \"Sphere\" : radius = desc . radius * scale . absolute . x geo , _ = cmds . polySphere ( radius = radius ) else : print ( \"Unsupported shape type: %s .type= %s \" % ( name . path , desc . type )) continue with cmdx . DagModifier () as mod : transform = mod . createNode ( \"transform\" , name = joint , parent = root ) transform [ \"translate\" ] = tm . translation () transform [ \"rotate\" ] = tm . rotation () # Establish shape transformation offset = desc . offset offset . x *= scale . absolute . x offset . y *= scale . absolute . y offset . z *= scale . absolute . z geo = cmdx . encode ( geo ) geo [ \"translate\" ] = offset geo [ \"rotate\" ] = desc . rotation transform . addChild ( geo ) # Usage Example import json dump = cmds . ragdollDump () dump = json . loads ( dump ) dedump ( dump )","title":"Code Example"},{"location":"serialisation/#more-examples","text":"","title":"More Examples"},{"location":"serialisation/#tiger","text":"Courtesy of www.cgspectrum.com mytiger.rag","title":"Tiger"},{"location":"serialisation/#ragcar","text":"Model from https://mecabricks.com ragcar.rag","title":"Ragcar"},{"location":"serialisation/#advanced-skeleton","text":"A generic human character, rigged with AS. mycharacter.rag","title":"Advanced Skeleton"},{"location":"tutorials/","text":"Learn about Ragdoll from the ground up with these short videos. Videos Manikin I Manikin II Manikin and IK Mocap Chap Rookie Wasp Self-Walking Rhino","title":"Tutorials"},{"location":"blog/20201215_cmdx/","text":"Talk about cmdx and why it's necessary.","title":"20201215 cmdx"},{"location":"blog/20201216_high_dpi_and_px/","text":"UI and Resolution Scaling Read about how Ragdoll implements resolution scaling, to support scalable UIs on modern high-resolution displays. TL;DR Here's a standalone version of the function I'll be walking you through, requires Maya 2017 (Qt 5) and above (due to QScreen ). def px ( value ): if not hasattr ( px , \"dpi\" ): any_widget = QtWidgets . QWidget () any_widget . setWindowFlags ( QtCore . Qt . ToolTip ) any_widget . show () window = any_widget . windowHandle () scale = window . screen () . logicalDotsPerInch () / 96.0 px . dpi = scale return value * px . dpi What is Resolution Scaling? Most displays have resolutions beyond the traditional 1080p, which makes text and graphics overly small. To account for this, operating systems have implemented \"resolution scaling\"; which is some factor to scale text and graphics by when drawing it on screen. Maya added (early and crude) support for resolution scaling in Maya 2016 with a usable and mostly transparent version landing in 2018 and beyond. Building UIs with Maya's native MEL-based UI tools account for scaling automatically, so you generally don't have to think about it. Unfortunately, for any non-trivial Qt project however you'll need to actively implement and maintain support for it. Ragdoll does this, and here's how. Implementation In short, any mention pixels run through a conversion function like this. # setFixedWidth(50) # Before setFixedWidth ( px ( 50 )) # After Where px() looks something like this. def px ( value ): return value * 1.5 That goes for stylesheets as well. style = \"\"\" QPushButton { width: 50px; } \"\"\" style = convert_px ( style ) setStyleSheet ( style ) Where convert_px() looks something like.. def convert_px ( style ): lines = [] for line in style . splitlines (); if \"px\" in line : # Find them and destroy them return \" \\n \" . join ( lines ) But where does this magical 1.5 value come from? The value depends on your display scale factor, or more precisely whichever scale factor Maya is currently working with. On Windows, the scale factor is set under your Display settings and Linux's various display managers have something like it. You can read this straight from the operating system, but the more cross-platform method would be to lean on Qt. Unfortunately, the Qt documentation for resolution scaling is a good representation of how confusing resolution scaling is amongst UI developers at large. https://doc.qt.io/qt-5/highdpi.html Because you have (1) an application scale, (2) an operating system scale and (3) a physical monitor scale; each of which combine in non-obvious ways to produce the final pixel coordinate on screen. What is the difference between \"Physical DPI\" and \"Logical DPI\"? Where does \"Device Pixel Ratio\" come into the picture? Here's what you need to know. scale = logicalDpi / 96.0 The value you'll end up with is 1.0 for a non-scaled display, such as your everyday 1080p monitor, and 1.5 or 2.0 for greater resolutions. If your OS allows, you could get values inbetween or greater, and although text scales somewhat well to any value, graphics shipped with Ragdoll is scaled at 2.0 which means it'll look best at 1.0 , 1.5 and 2.0 . Anything else will likely introduce blur. But wait, where does logicalDpi come from, and what's this magical 96.0 ? Qt can provide that for you, but not without a fight. window .","title":"20201216 high dpi and px"},{"location":"blog/20201216_high_dpi_and_px/#ui-and-resolution-scaling","text":"Read about how Ragdoll implements resolution scaling, to support scalable UIs on modern high-resolution displays.","title":"UI and Resolution Scaling"},{"location":"blog/20201216_high_dpi_and_px/#tldr","text":"Here's a standalone version of the function I'll be walking you through, requires Maya 2017 (Qt 5) and above (due to QScreen ). def px ( value ): if not hasattr ( px , \"dpi\" ): any_widget = QtWidgets . QWidget () any_widget . setWindowFlags ( QtCore . Qt . ToolTip ) any_widget . show () window = any_widget . windowHandle () scale = window . screen () . logicalDotsPerInch () / 96.0 px . dpi = scale return value * px . dpi","title":"TL;DR"},{"location":"blog/20201216_high_dpi_and_px/#what-is-resolution-scaling","text":"Most displays have resolutions beyond the traditional 1080p, which makes text and graphics overly small. To account for this, operating systems have implemented \"resolution scaling\"; which is some factor to scale text and graphics by when drawing it on screen. Maya added (early and crude) support for resolution scaling in Maya 2016 with a usable and mostly transparent version landing in 2018 and beyond. Building UIs with Maya's native MEL-based UI tools account for scaling automatically, so you generally don't have to think about it. Unfortunately, for any non-trivial Qt project however you'll need to actively implement and maintain support for it. Ragdoll does this, and here's how.","title":"What is Resolution Scaling?"},{"location":"blog/20201216_high_dpi_and_px/#implementation","text":"In short, any mention pixels run through a conversion function like this. # setFixedWidth(50) # Before setFixedWidth ( px ( 50 )) # After Where px() looks something like this. def px ( value ): return value * 1.5 That goes for stylesheets as well. style = \"\"\" QPushButton { width: 50px; } \"\"\" style = convert_px ( style ) setStyleSheet ( style ) Where convert_px() looks something like.. def convert_px ( style ): lines = [] for line in style . splitlines (); if \"px\" in line : # Find them and destroy them return \" \\n \" . join ( lines ) But where does this magical 1.5 value come from? The value depends on your display scale factor, or more precisely whichever scale factor Maya is currently working with. On Windows, the scale factor is set under your Display settings and Linux's various display managers have something like it. You can read this straight from the operating system, but the more cross-platform method would be to lean on Qt. Unfortunately, the Qt documentation for resolution scaling is a good representation of how confusing resolution scaling is amongst UI developers at large. https://doc.qt.io/qt-5/highdpi.html Because you have (1) an application scale, (2) an operating system scale and (3) a physical monitor scale; each of which combine in non-obvious ways to produce the final pixel coordinate on screen. What is the difference between \"Physical DPI\" and \"Logical DPI\"? Where does \"Device Pixel Ratio\" come into the picture? Here's what you need to know. scale = logicalDpi / 96.0 The value you'll end up with is 1.0 for a non-scaled display, such as your everyday 1080p monitor, and 1.5 or 2.0 for greater resolutions. If your OS allows, you could get values inbetween or greater, and although text scales somewhat well to any value, graphics shipped with Ragdoll is scaled at 2.0 which means it'll look best at 1.0 , 1.5 and 2.0 . Anything else will likely introduce blur. But wait, where does logicalDpi come from, and what's this magical 96.0 ? Qt can provide that for you, but not without a fight. window .","title":"Implementation"},{"location":"blog/20201217_option_dialogs/","text":"Talk about qargparse and why it's necessary.","title":"20201217 option dialogs"},{"location":"blog/20201218_optionvar/","text":"Maya's native persistent preferences, with support for access from C++.","title":"20201218 optionvar"},{"location":"blog/20201219_pythonreload/","text":"Talk about how you iterate in Maya, reloading all modules by namespace and what to look out for. Especially undo. And always having an uninstall.","title":"20201219 pythonreload"},{"location":"blog/20210325_view_to_pixmap/","text":"Write about this. def view_to_pixmap ( size = None ): \"\"\"Render currently active 3D viewport as a QPixmap\"\"\" # Python 2 backwards compatibility try : long except NameError : long = int image = om . MImage () view = omui . M3dView . active3dView () view . readColorBuffer ( image , True ) # Translate from Maya -> Qt jargon image . verticalFlip () osize = size or QtCore . QSize ( 512 , 256 ) isize = image . getSize () buf = ctypes . c_ubyte * isize [ 0 ] * isize [ 1 ] buf = buf . from_address ( long ( image . pixels ())) qimage = QtGui . QImage ( buf , isize [ 0 ], isize [ 1 ], QtGui . QImage . Format_RGB32 ) . rgbSwapped () return QtGui . QPixmap . fromImage ( qimage ) . scaled ( osize . width (), osize . height (), QtCore . Qt . KeepAspectRatio , QtCore . Qt . SmoothTransformation ) def pixmap_to_base64 ( pixmap ): array = QtCore . QByteArray () buffer = QtCore . QBuffer ( array ) buffer . open ( QtCore . QIODevice . WriteOnly ) pixmap . save ( buffer , \"png\" ) return bytes ( array . toBase64 ()) def base64_to_pixmap ( base64 ): data = QtCore . QByteArray . fromBase64 ( base64 ) pixmap = QtGui . QPixmap () pixmap . loadFromData ( data ) return pixmap","title":"20210325 view to pixmap"},{"location":"blog/20210409_littlebits_locatorshotkey/","text":"Write about the script for toggling locators in the viewport, alongside curves and meshes. A workflow tip. A short one. A \"Little Bits\". :D","title":"20210409 littlebits locatorshotkey"},{"location":"blog/20210420_bugfree/","text":"The bug-free software guarantee. Find a bug, get a free licence If you already have a licence, get the next one free (incentive to find bugs in the 2-4 week trial period) What if everyone finds a bug, and everyone gets a free licence? That's OK. If nobody is able to use Ragdoll without finding a bug, Ragdoll does not deserve payment. Requirements: Bug must be reproducible in the latest version Bug must not already have been reported, first-come first-served (tracked via GitHub issues) But must not already be known (tracked via GitHub)","title":"20210420 bugfree"},{"location":"blog/20210422_escapehatch/","text":"Always give users a way to circumvent protections and to workaround issues without waiting for a new update (which could be days or weeks).","title":"20210422 escapehatch"},{"location":"blog/20210531_backend/","text":"The month of May 2021 was spent authoring the frontend and backend of the ragdolldynamics.com website. Let's have a look at what makes it tick. Overview Here's life of the website in a nutshell. 1,500 lines of Markdown/HTML 2,000 lines of CSS 500 lines of JS 600 lines of Python Server via Hetzner Flask to communicate with Stripe WyDay to generate serials Mongo to store/match customers and serials Mongo to store logs mkdocs to generate most of the site Flask to generate a reproducible, persistent customer receipt Email via sendgrid That is, we want a user to put the versions and amount of seats for Ragdoll into a \"cart\" and for that \"cart\" to be passed on to Stripe for the transaction to take place. Once Stripe is done, we'll want to generate a serial to go with it. With a serial in hand, we'd then like to generate a web page specifically for this one purchase. Ideally something the user can revisit later if they forget their key(s). Because many things can go wrong in these few steps, we need to record each step of the way, including log messages, such that we can debug any such issue. And that's it. Let's have a look at practicalities. Static Website Because most of the site - namely the landing page and contact page - is static I opted to use the same static site generator I use for https://learn.ragdolldynamics.com . Namely mkdocs . Unlike the learn domain, this one wouldn't require a theme as we're laying everything out ourselves. One of the pages need purchase-specific information - namely your serial numbers - so that needs a \"dynamic site generator\", and for that I'll use flask because of my brief excursion many years ago for Pyblish Events .","title":"20210531 backend"},{"location":"blog/20210531_backend/#overview","text":"Here's life of the website in a nutshell. 1,500 lines of Markdown/HTML 2,000 lines of CSS 500 lines of JS 600 lines of Python Server via Hetzner Flask to communicate with Stripe WyDay to generate serials Mongo to store/match customers and serials Mongo to store logs mkdocs to generate most of the site Flask to generate a reproducible, persistent customer receipt Email via sendgrid That is, we want a user to put the versions and amount of seats for Ragdoll into a \"cart\" and for that \"cart\" to be passed on to Stripe for the transaction to take place. Once Stripe is done, we'll want to generate a serial to go with it. With a serial in hand, we'd then like to generate a web page specifically for this one purchase. Ideally something the user can revisit later if they forget their key(s). Because many things can go wrong in these few steps, we need to record each step of the way, including log messages, such that we can debug any such issue. And that's it. Let's have a look at practicalities.","title":"Overview"},{"location":"blog/20210531_backend/#static-website","text":"Because most of the site - namely the landing page and contact page - is static I opted to use the same static site generator I use for https://learn.ragdolldynamics.com . Namely mkdocs . Unlike the learn domain, this one wouldn't require a theme as we're laying everything out ourselves. One of the pages need purchase-specific information - namely your serial numbers - so that needs a \"dynamic site generator\", and for that I'll use flask because of my brief excursion many years ago for Pyblish Events .","title":"Static Website"},{"location":"blog/20210708_limitations/","text":"Document and offer alternatives to these. Active Rigid sandwiched between two Passive Rigids, jitters and possibly explodes Target outside of limits, causes jitters and invisible global forces","title":"20210708 limitations"},{"location":"blog/20210713_july28/","text":"On July 28 th 2021 , animators around the world will finally get something new . Something that isn't just your average incremental workflow improvement, but an entirely new way to animate . The Past 30 years ago there was innovation in character animation, much like the innovation we see today - modelers went from box modeling to sculpting, lighting artists nowadays reflect light and simulate the material properties in textures made with simulated wear-and-tear based on natural weather conditions and concept artists generate imagery through machine learning. But what are animators doing? https://youtu.be/6W_HL3nULMM?t=1208 That's right! The dopesheet, the graph editor, inverse kinematics, rigs that run at 5 fps. We're still animating like it's 1995! As a result, every part of the filmmaking process has seen a massively reduced cost, except animation . Animation of today is often the most expensive and time consuming part of the pipeline; and when it isn't it really ought to be because despite accurate models, realistic lighting and pixel perfect textures, motion is what makes a character truly come alive. The Present Ragdoll was made to address this need. The need for more believable characters with less effort. The need for animators to spend time where it matters - on telling story. Here is where and how I expect animators spend their time today in 2021. Story (10%) Performance (10%) Physics (80%) Message Body language Balance Delivery Timing Contacts Continuity Interactions Force Continuity Momentum Propagation See that 80%? Let's get rid of that. The Future Mark your calendars, spread the word. Roughly 2 weeks from now we will embark on a journey together to resume innovating. To ensure that 30 years from now we'll look back at today and not recognise a thing. Best, Marcus Ottosson CEO and Founder Ragdoll Dynamics","title":"Launch Date"},{"location":"blog/20210713_july28/#the-past","text":"30 years ago there was innovation in character animation, much like the innovation we see today - modelers went from box modeling to sculpting, lighting artists nowadays reflect light and simulate the material properties in textures made with simulated wear-and-tear based on natural weather conditions and concept artists generate imagery through machine learning. But what are animators doing? https://youtu.be/6W_HL3nULMM?t=1208 That's right! The dopesheet, the graph editor, inverse kinematics, rigs that run at 5 fps. We're still animating like it's 1995! As a result, every part of the filmmaking process has seen a massively reduced cost, except animation . Animation of today is often the most expensive and time consuming part of the pipeline; and when it isn't it really ought to be because despite accurate models, realistic lighting and pixel perfect textures, motion is what makes a character truly come alive.","title":"The Past"},{"location":"blog/20210713_july28/#the-present","text":"Ragdoll was made to address this need. The need for more believable characters with less effort. The need for animators to spend time where it matters - on telling story. Here is where and how I expect animators spend their time today in 2021. Story (10%) Performance (10%) Physics (80%) Message Body language Balance Delivery Timing Contacts Continuity Interactions Force Continuity Momentum Propagation See that 80%? Let's get rid of that.","title":"The Present"},{"location":"blog/20210713_july28/#the-future","text":"Mark your calendars, spread the word. Roughly 2 weeks from now we will embark on a journey together to resume innovating. To ensure that 30 years from now we'll look back at today and not recognise a thing. Best, Marcus Ottosson CEO and Founder Ragdoll Dynamics","title":"The Future"},{"location":"blog/20210727_debugging/","text":"Quick sanity check for overlapping shapes and an initial state residing within limits. Turn off gravity. Nothing should move when you play. If something does move.. Disable collisions on everything If something still does move.. Disable all limits and guides Enable limits one-by-one If something now does not move.. Everything is OK If something does not move.. Everything is OK","title":"20210727 debugging"},{"location":"blog/20210728_announce_1_0/","text":"Welcome to Ragdoll Dynamics , the real-time physics solver for Maya. Website Download July 28 th 2021 Today marks the launch of Ragdoll Dynamics and you are reading the announcement post for this moment. With Ragdoll, you'll be able to achieve faster and more realistic character animation with less work. Read on to find out what it's all about. Background In 2012 I had an idea for a physics system suitable for animators. The idea sprung from the mind of a Character Animator landing a job in Creature FX and being exposed to nCloth in Maya. The goal was simple; animate a piece of string in space. But, traditional tools failed us. The desired motion was too subtle and the level of control we had was too fine . Like laying bricks with a tweezer. So we turned to physics simulation as a means of automating subtlety and focusing on how we wanted the animation to feel and what we wanted it to do , rather than spending time making it look like it belonged in the real world. But now we had the opposite problem; although the results were subtle, they were hard to control . Like playing Jenga with a tractor. The process was highly technical , very few animators would endure that kind of process. If this was to become accessible to animators, something drastic needed to happen. Something to transform highly technical concepts into creative choices , something that could leverage the computational power of our workstations without overburdening the artist with nonsense. It is now July 28 th 2021 - the birthday of Ragdoll - and we may (finally) begin our journey towards exactly that. More What is Early Access? Ragdoll is now in \"Early Access\" for the next 1-3 months. During this time, we'll round off corners and improve the overall experience - including more tutorials, more documentation and generally being here for you as we both take our first steps into this together. Unlike most new technology, there has never been a physics solver for animators before; everything we do from here on out will be unexplored pastures, ripe with new discoveries. So, if you're happy to dive into the unknown and learn the old-fashioned-way of trial-and-error, Ragdoll is yours. Alternatively, sit back, relax and watch other people suffer through the growing pains of an early-stage startup for the next 1-3 months. We'll post updates both here and on LinkedIn during this time. Early Bird During these first 1-3 months, there's carrot. Ragdoll Unlimited is the unrestricted, full version of Ragdoll. The full price of which is \u00a31950 for a floating licence. But because it's early, the price is lowered to the price of Ragdoll Complete - \u00a3499 for a node-locked licence. This will be reflected in the total price during checkout. Once early access is over - about 1 to 3 months from now - the price will return to normal. Buy it Try it Immediate Roadmap The next 1-3 months will have a singular focus. Learning Material That means tutorials, documenation, interface tweaks, bug fixing, performance improvements and everything in between. If you find yourself struggling with something, it's not you, it's Ragdoll. Let us know via chat or forum here and we'll aim for same-day or same-week fixes. That's what Early Access is all about. Chat Forums Product Tiers Ragdoll comes in 5 flavours. Trial Personal Complete Unlimited Batch Each flavour is priced differently to enable access to everyone. For non-commercial users - namely anyone wanting to fool around with physics for their personal or student projects at home - there's a special version of Ragdoll. This version is identical to a node-locked version of Ragdoll Unlimited plus having free upgrades forever . Trial Personal Complete Unlimited Batch Commercial Use \u274c \u274c \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Interactive Tools \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Python API \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c Multi-Threading \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c JSON Import/Export \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c Per-process Licence \u274c \u274c \u274c \u274c \u2714\ufe0f Perpetual Pricing \u274c \u00a399 \u00a3499 \u00a31299 \u00a3199 Floating Licence \u274c \u274c \u00a3750 \u00a31950 \u00a3250 Monthly Pricing \u274c \u274c \u00a355 \u00a380 \u00a320 Annual Upgrade Plan \u274c \u00a30 \u00a3250 \u00a3650 \u00a399 Next Steps Ready? Click here to download and install Ragdoll for Windows and Linux, Maya versions 2018-2022. You'll have a whole month to experiment before having to make up your mind, so go nuts! Try it Buy it","title":"Launch"},{"location":"blog/20210728_announce_1_0/#july-28th-2021","text":"Today marks the launch of Ragdoll Dynamics and you are reading the announcement post for this moment. With Ragdoll, you'll be able to achieve faster and more realistic character animation with less work. Read on to find out what it's all about.","title":"July 28th 2021"},{"location":"blog/20210728_announce_1_0/#background","text":"In 2012 I had an idea for a physics system suitable for animators. The idea sprung from the mind of a Character Animator landing a job in Creature FX and being exposed to nCloth in Maya. The goal was simple; animate a piece of string in space. But, traditional tools failed us. The desired motion was too subtle and the level of control we had was too fine . Like laying bricks with a tweezer. So we turned to physics simulation as a means of automating subtlety and focusing on how we wanted the animation to feel and what we wanted it to do , rather than spending time making it look like it belonged in the real world. But now we had the opposite problem; although the results were subtle, they were hard to control . Like playing Jenga with a tractor. The process was highly technical , very few animators would endure that kind of process. If this was to become accessible to animators, something drastic needed to happen. Something to transform highly technical concepts into creative choices , something that could leverage the computational power of our workstations without overburdening the artist with nonsense. It is now July 28 th 2021 - the birthday of Ragdoll - and we may (finally) begin our journey towards exactly that. More","title":"Background"},{"location":"blog/20210728_announce_1_0/#what-is-early-access","text":"Ragdoll is now in \"Early Access\" for the next 1-3 months. During this time, we'll round off corners and improve the overall experience - including more tutorials, more documentation and generally being here for you as we both take our first steps into this together. Unlike most new technology, there has never been a physics solver for animators before; everything we do from here on out will be unexplored pastures, ripe with new discoveries. So, if you're happy to dive into the unknown and learn the old-fashioned-way of trial-and-error, Ragdoll is yours. Alternatively, sit back, relax and watch other people suffer through the growing pains of an early-stage startup for the next 1-3 months. We'll post updates both here and on LinkedIn during this time.","title":"What is Early Access?"},{"location":"blog/20210728_announce_1_0/#early-bird","text":"During these first 1-3 months, there's carrot. Ragdoll Unlimited is the unrestricted, full version of Ragdoll. The full price of which is \u00a31950 for a floating licence. But because it's early, the price is lowered to the price of Ragdoll Complete - \u00a3499 for a node-locked licence. This will be reflected in the total price during checkout. Once early access is over - about 1 to 3 months from now - the price will return to normal. Buy it Try it","title":"Early Bird"},{"location":"blog/20210728_announce_1_0/#immediate-roadmap","text":"The next 1-3 months will have a singular focus. Learning Material That means tutorials, documenation, interface tweaks, bug fixing, performance improvements and everything in between. If you find yourself struggling with something, it's not you, it's Ragdoll. Let us know via chat or forum here and we'll aim for same-day or same-week fixes. That's what Early Access is all about. Chat Forums","title":"Immediate Roadmap"},{"location":"blog/20210728_announce_1_0/#product-tiers","text":"Ragdoll comes in 5 flavours. Trial Personal Complete Unlimited Batch Each flavour is priced differently to enable access to everyone. For non-commercial users - namely anyone wanting to fool around with physics for their personal or student projects at home - there's a special version of Ragdoll. This version is identical to a node-locked version of Ragdoll Unlimited plus having free upgrades forever . Trial Personal Complete Unlimited Batch Commercial Use \u274c \u274c \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Interactive Tools \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Python API \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c Multi-Threading \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c JSON Import/Export \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c Per-process Licence \u274c \u274c \u274c \u274c \u2714\ufe0f Perpetual Pricing \u274c \u00a399 \u00a3499 \u00a31299 \u00a3199 Floating Licence \u274c \u274c \u00a3750 \u00a31950 \u00a3250 Monthly Pricing \u274c \u274c \u00a355 \u00a380 \u00a320 Annual Upgrade Plan \u274c \u00a30 \u00a3250 \u00a3650 \u00a399","title":"Product Tiers"},{"location":"blog/20210728_announce_1_0/#next-steps","text":"Ready? Click here to download and install Ragdoll for Windows and Linux, Maya versions 2018-2022. You'll have a whole month to experiment before having to make up your mind, so go nuts! Try it Buy it","title":"Next Steps"},{"location":"blog/20210730/","text":"Hey you! We launched our animation software Ragdoll Dynamics the other day and are on now the lookout for someone to author learning material on either a full-time or part-time basis. It would involve: Learning about Ragdoll Dynamics, enough to be dangerous Writing user documentation, primarily for animators, using primarily Markdown (Such as this very page! ) Recording 5-second gifs demonstrating workflow and new features, such as these! Recording 5-minute tutorials on making cool things with physics, such as this! Recording project-based learning material, breaking down a finished animation like what you see on the front page of our website Starting as soon as you're available Remote only, at least until we get an office at which point remote would remain an option With pay from \u00a340,000-60,000/year To qualify, you don't need experience with Autodesk Maya although it wouldn't hurt. What you would need however is: Examples of prior work; such as a tutorial series on Gnomon Workshop , CMIVFX, Digital Tutors or written documentation any equivalent source we can use to gauge your style. A pleasant voice; we can provide equipment like microphone and recording software. We could compensate you in various ways. Salary, from \u00a340-60,000/year Per topic, from \u00a3200-400 Per week, from \u00a3300-600 Pro-bono, get a licence for free Is this you? Do you know someone?","title":"Documentation Writers, Ahoy!"},{"location":"blog/20210821/","text":"Hello! We've recently launched our animation software Ragdoll Dynamics and are on now the lookout for a motivated Maya Developer , on either a full-time or part-time basis. About Us At the time of this writing, Ragdoll is me - Marcus - doing all things Maya along with handling just about every other aspect of running the business - like marketing, licencing, web development, design, animation, documentation.. too many things! And recently Kostas , doing secret things related to robotics in Maya. What I'd like to do is hand over my Maya-development role to you . It would involve all manner of challenges, from UI and UX to physics and low-level optimisations to workflow enhancements and tools development. The more you fancy the better. You will be given a great deal of agency and resonsibility that shape the future of Ragdoll in these early days. How should animators interact with physics? What parts of their workflow can be enhanced or even replaced with physics? These are questions you and I will explore, and the earlier you get involved the greater your influence. About You What I'd like to see from you is examples of your work along with some motivation for wanting to come on this journey. Startup-life is unlike corporate-life in a few key ways, primarily in being able to create and execute your own set of tasks, of not only implement a solution but also understanding the problem and finding a optimal solution to an otherwise muddy and unexplored problem. It also heavily relies on our pace and progress; if you and I don't make it, it's all over! Hah! On the upside it also means that our success is ours alone, and let me tell you that is incredibly rewarding! To cope with this, you should have some of these. \u2714\ufe0f 3+ years of experience with the Maya C++ API, enough to be dangerous \u2714\ufe0f Experience working in production on relevant tasks, like at ILM or Dneg or Framestore \u2753 (Optional) Some years of experience with Python, to either understand or evolve the artist tools \u2753 (Optional) Some experience at the other end of the spectrum, in rigging or animation \u2753 (Optional) Experience with continuous integration, such as GitLab CI or GitHub Actions Bonus Points If you have experience or interest in one or more of these, you're in. \ud83d\udd6f\ufe0f Data-oriented programming, specifically EnTT \ud83d\udd6f\ufe0f Graphics programming, ghosting and trajectories, tool UIs \ud83d\udd6f\ufe0f Maya Evaluation optimisation, about 90% of Ragdolls performance is on the table \ud83d\udd6f\ufe0f Black-box optimisation, specifically ES but also RL \ud83d\udd6f\ufe0f Parallel programming, performance is key and people have cores to spare The Offer Like the position, the offer is flexible. \u2714\ufe0f Part-time, full-time or contract work. Whichever works for you. \u2714\ufe0f Anywhere between \u00a350,000-80,000/year is fair game. \u2714\ufe0f For short-term work, \u00a3300-600/day is fair game. \u2714\ufe0f Remote, or in-office (once there is one). \u2714\ufe0f We're in Europe, so for the sake of timezone you should too. Next Step And that's it! If this tickles your curiosity, feel free to get in touch. We can setup a call and talk things through. Maybe all you do is low-level optimisations in x86 assembly, and none of that fancy-pants UX and Python stuff? Or maybe you've got the fanciest pants in town? As an early part of the Ragdoll Dynamics team there's plenty of space in all manner of pants. Email Contact Form Best, Marcus","title":"Maya Developers, ahoy!"},{"location":"blog/20210821/#about-us","text":"At the time of this writing, Ragdoll is me - Marcus - doing all things Maya along with handling just about every other aspect of running the business - like marketing, licencing, web development, design, animation, documentation.. too many things! And recently Kostas , doing secret things related to robotics in Maya. What I'd like to do is hand over my Maya-development role to you . It would involve all manner of challenges, from UI and UX to physics and low-level optimisations to workflow enhancements and tools development. The more you fancy the better. You will be given a great deal of agency and resonsibility that shape the future of Ragdoll in these early days. How should animators interact with physics? What parts of their workflow can be enhanced or even replaced with physics? These are questions you and I will explore, and the earlier you get involved the greater your influence.","title":"About Us"},{"location":"blog/20210821/#about-you","text":"What I'd like to see from you is examples of your work along with some motivation for wanting to come on this journey. Startup-life is unlike corporate-life in a few key ways, primarily in being able to create and execute your own set of tasks, of not only implement a solution but also understanding the problem and finding a optimal solution to an otherwise muddy and unexplored problem. It also heavily relies on our pace and progress; if you and I don't make it, it's all over! Hah! On the upside it also means that our success is ours alone, and let me tell you that is incredibly rewarding! To cope with this, you should have some of these. \u2714\ufe0f 3+ years of experience with the Maya C++ API, enough to be dangerous \u2714\ufe0f Experience working in production on relevant tasks, like at ILM or Dneg or Framestore \u2753 (Optional) Some years of experience with Python, to either understand or evolve the artist tools \u2753 (Optional) Some experience at the other end of the spectrum, in rigging or animation \u2753 (Optional) Experience with continuous integration, such as GitLab CI or GitHub Actions Bonus Points If you have experience or interest in one or more of these, you're in. \ud83d\udd6f\ufe0f Data-oriented programming, specifically EnTT \ud83d\udd6f\ufe0f Graphics programming, ghosting and trajectories, tool UIs \ud83d\udd6f\ufe0f Maya Evaluation optimisation, about 90% of Ragdolls performance is on the table \ud83d\udd6f\ufe0f Black-box optimisation, specifically ES but also RL \ud83d\udd6f\ufe0f Parallel programming, performance is key and people have cores to spare The Offer Like the position, the offer is flexible. \u2714\ufe0f Part-time, full-time or contract work. Whichever works for you. \u2714\ufe0f Anywhere between \u00a350,000-80,000/year is fair game. \u2714\ufe0f For short-term work, \u00a3300-600/day is fair game. \u2714\ufe0f Remote, or in-office (once there is one). \u2714\ufe0f We're in Europe, so for the sake of timezone you should too.","title":"About You"},{"location":"blog/20210821/#next-step","text":"And that's it! If this tickles your curiosity, feel free to get in touch. We can setup a call and talk things through. Maybe all you do is low-level optimisations in x86 assembly, and none of that fancy-pants UX and Python stuff? Or maybe you've got the fanciest pants in town? As an early part of the Ragdoll Dynamics team there's plenty of space in all manner of pants. Email Contact Form Best, Marcus","title":"Next Step"},{"location":"documentation/cache/","text":"The fundamental building block to Ragdoll, for \"reverse motion capture\" or Animation Capture. Caching Ragdoll runs alongside your character animation, but sometimes it can be useful to keep the results from a previous run and stop being so interactive. Meet Cache and Uncache . Caching is entirely non-destructive, and in fact leverages the very same cache you've been enjoying all this time whenever rewinding. The menu commands toggle an attribute on your solver node, called .cache and automatically plays the entire timeline for you. But the same result can be achieved by setting the attribute and playing it yourself. The minimal HUD will show you what's been cached, and like before once you resume playback from a cached to an uncached frame, Ragdoll will continue filling up the cache as one would expect. Look forward to a future release where caching happens in the background, as you work. Something that can also be handy from time to time (pun!).","title":"Cache"},{"location":"documentation/cache/#caching","text":"Ragdoll runs alongside your character animation, but sometimes it can be useful to keep the results from a previous run and stop being so interactive. Meet Cache and Uncache . Caching is entirely non-destructive, and in fact leverages the very same cache you've been enjoying all this time whenever rewinding. The menu commands toggle an attribute on your solver node, called .cache and automatically plays the entire timeline for you. But the same result can be achieved by setting the attribute and playing it yourself. The minimal HUD will show you what's been cached, and like before once you resume playback from a cached to an uncached frame, Ragdoll will continue filling up the cache as one would expect. Look forward to a future release where caching happens in the background, as you work. Something that can also be handy from time to time (pun!).","title":"Caching"},{"location":"documentation/constraints/","text":"Establish a relationship between two markers. Constraints You can constrain one marker to another! Constraint Type Description Weld Constraint Simplest of constraints, welds two markers together; no change to their distance or relative orientation is allowed. This is akin to the Maya Parent Constraint Distance Constraint Maintain a minimum, maximum or total distance between two markers. Pin Constraint Match a position and orientation in worldspace, similar to Drive Space = World . Weld Maintain the position and orientation of one marker relative another from the first frame onwards. Distance A simple but versatile constraint with animatable distance. Maintain Start Distance Whatever the distance between two markers, it will be maintained throughout a simulation. Minimum Distance Alternatively, only respond to when two controls get too close. Maximum Distance Conversely, keep markers from getting too far away from each other. Custom Distance Or go all-in, with both a minimum and maximum distance, for the most complex behavior. Offsets Control at which point on a control to measure the distance. Animated Distance Both min and max distance, along with stiffness and damping, can be animated for some pretty rad effects. Hard Distance A Stiffness = -1 means the constraint is \"hard\". It will not accept any slack or \"springiness\". In this example, the distance is animated whilst soft, and transitioned into a hard constraint. Notice how it snaps into place once hard. Limitation A limitation of a hard constraint is that the distance cannot be animated whilst hard. You can however animate it between values of -1 and above, to transition to and from hard to soft. Pin Pin the translation and/or rotation of a Marker in worldspace.","title":"Constraints"},{"location":"documentation/constraints/#constraints","text":"You can constrain one marker to another! Constraint Type Description Weld Constraint Simplest of constraints, welds two markers together; no change to their distance or relative orientation is allowed. This is akin to the Maya Parent Constraint Distance Constraint Maintain a minimum, maximum or total distance between two markers. Pin Constraint Match a position and orientation in worldspace, similar to Drive Space = World .","title":"Constraints"},{"location":"documentation/constraints/#weld","text":"Maintain the position and orientation of one marker relative another from the first frame onwards.","title":"Weld"},{"location":"documentation/constraints/#distance","text":"A simple but versatile constraint with animatable distance. Maintain Start Distance Whatever the distance between two markers, it will be maintained throughout a simulation. Minimum Distance Alternatively, only respond to when two controls get too close. Maximum Distance Conversely, keep markers from getting too far away from each other. Custom Distance Or go all-in, with both a minimum and maximum distance, for the most complex behavior. Offsets Control at which point on a control to measure the distance. Animated Distance Both min and max distance, along with stiffness and damping, can be animated for some pretty rad effects. Hard Distance A Stiffness = -1 means the constraint is \"hard\". It will not accept any slack or \"springiness\". In this example, the distance is animated whilst soft, and transitioned into a hard constraint. Notice how it snaps into place once hard. Limitation A limitation of a hard constraint is that the distance cannot be animated whilst hard. You can however animate it between values of -1 and above, to transition to and from hard to soft.","title":"Distance"},{"location":"documentation/constraints/#pin","text":"Pin the translation and/or rotation of a Marker in worldspace.","title":"Pin"},{"location":"documentation/export_physics/","text":"Export physics from one scene, for import into another scene. Coming Soon Scheduled for release in January 2022","title":"Export Physics"},{"location":"documentation/fields/","text":"Environmental effects like Wind and Turbulence for your Markers. Fields Ragdoll supports all of Maya's native \"fields\" What are fields? A field represents a set of forces applied to each Marker. Ranging from Gravity to Turbulence , each field carries unique properties you can use to emulate some environment or environmental effect, like wind and gravity fields along a curve. What is the difference from regular Maya fields? They are the very same! If you're already familiar with them, from e.g. nParticles of nCloth, then you can leverage your experience with Ragdoll, and vice versa if you ever venture into nCloth and friends. Overview Let's walk through these fields one-by-one. Turbulence The perhaps most interesting field. Apply forces in \"random\" directions, based on the worldspace positions of your Markers. The way to think of turbulence is as Perlin Noise you may have seen in images such as this. Where the amount of white determines the amount of force being applied. As a Marker travels across this field, both the magnitude and direction changes in interesting ways. Drag Apply an opposite force to any motion. The faster things move, the greater the force. Pro tip This field is similar to Ragdoll's Air Density . Not technically , but practically. Wind Apply a uniform force, at a given speed, in a given direction. Like wind, including a kitchen fan with some Spread . Gravity A familiar force, except this one can be also be animated! Newton Force Markers towards or away from a point in space. Radial A more curious field; with a force which increases as it gets farther from the source. Uniform Apply a constant force. That's all. Vortex Apply forces in a circular pattern. Volume Axis Field A field for when you don't know what field you want. A true Swiss Army Knife of fields, can do everything from Vortex, to Newton to Turbulence in one convenient node. Volume Curve Have some fun with this curve-based field. Perhaps to emulate an underwater current? In this example, I'm also using a Drag field to keep things from flying off into space. Pro tip The curve is a normal Maya NURBS curve. If you need more points, right click and add points as you normally would. Combined Fields Make two or more fields to combine their effect and create complex forces or series of forces! Centroids Where within each Marker should a field apply forces? Center of Mass Volumetric At the center, forces will be nice and predictable; except they won't be able to introduce rotations to your Marker, which may or may not be what you want. For the most realistic fields, use volumetric centroids. Here's another example using the Turbulence Field. Which is better? Up to you! There is a tiny performance penalty for volumetric origins, as the number of forces increase. But you shouldn't notice much if any impact on performance. Centroid Seed For complex meshes, centroids can end up in unwanted locations or gather in an area with dense vertices. That's when you can give the algorithm a little jolt to try and see whether there is a better alternative out there. Use Selected as Source Some forces act according to their position in the world. Attach a field to a Marker to create an interesting relationship between the two. Non-commercial Ragdoll This feature is limited to 100 frames in non-commercial versions of Ragdoll. Distance constrain two markers, and attach a field to the outer-most Marker for a doubly-interesting effect. That also wrecks your brain. \ud83d\ude43 Field Scale If forces start becoming large, you may find yourself in a situation where the visualisation needs to tone down just a bit. In the solver settings, you will find options to scale those lines (i.e. Field Scale ), as well as control how many steps into the future (i.e. Field Iterations ) it should draw for you. Ignore Field Fine-tune the effect of fields by having one or more Markers ignore the effect of fields. More Being native to Maya, Autodesk has some documentation of its own here. Maya's Fields Documentation . You may also search for fields on YouTube or ask your colleagues about them; any trick they've learnt may very well apply to Ragdoll as well!","title":"Fields"},{"location":"documentation/fields/#fields","text":"Ragdoll supports all of Maya's native \"fields\" What are fields? A field represents a set of forces applied to each Marker. Ranging from Gravity to Turbulence , each field carries unique properties you can use to emulate some environment or environmental effect, like wind and gravity fields along a curve. What is the difference from regular Maya fields? They are the very same! If you're already familiar with them, from e.g. nParticles of nCloth, then you can leverage your experience with Ragdoll, and vice versa if you ever venture into nCloth and friends.","title":"Fields"},{"location":"documentation/fields/#overview","text":"Let's walk through these fields one-by-one.","title":"Overview"},{"location":"documentation/fields/#turbulence","text":"The perhaps most interesting field. Apply forces in \"random\" directions, based on the worldspace positions of your Markers. The way to think of turbulence is as Perlin Noise you may have seen in images such as this. Where the amount of white determines the amount of force being applied. As a Marker travels across this field, both the magnitude and direction changes in interesting ways.","title":"Turbulence"},{"location":"documentation/fields/#drag","text":"Apply an opposite force to any motion. The faster things move, the greater the force. Pro tip This field is similar to Ragdoll's Air Density . Not technically , but practically.","title":"Drag"},{"location":"documentation/fields/#wind","text":"Apply a uniform force, at a given speed, in a given direction. Like wind, including a kitchen fan with some Spread .","title":"Wind"},{"location":"documentation/fields/#gravity","text":"A familiar force, except this one can be also be animated!","title":"Gravity"},{"location":"documentation/fields/#newton","text":"Force Markers towards or away from a point in space.","title":"Newton"},{"location":"documentation/fields/#radial","text":"A more curious field; with a force which increases as it gets farther from the source.","title":"Radial"},{"location":"documentation/fields/#uniform","text":"Apply a constant force. That's all.","title":"Uniform"},{"location":"documentation/fields/#vortex","text":"Apply forces in a circular pattern.","title":"Vortex"},{"location":"documentation/fields/#volume-axis-field","text":"A field for when you don't know what field you want. A true Swiss Army Knife of fields, can do everything from Vortex, to Newton to Turbulence in one convenient node.","title":"Volume Axis Field"},{"location":"documentation/fields/#volume-curve","text":"Have some fun with this curve-based field. Perhaps to emulate an underwater current? In this example, I'm also using a Drag field to keep things from flying off into space. Pro tip The curve is a normal Maya NURBS curve. If you need more points, right click and add points as you normally would.","title":"Volume Curve"},{"location":"documentation/fields/#combined-fields","text":"Make two or more fields to combine their effect and create complex forces or series of forces!","title":"Combined Fields"},{"location":"documentation/fields/#centroids","text":"Where within each Marker should a field apply forces? Center of Mass Volumetric At the center, forces will be nice and predictable; except they won't be able to introduce rotations to your Marker, which may or may not be what you want. For the most realistic fields, use volumetric centroids. Here's another example using the Turbulence Field. Which is better? Up to you! There is a tiny performance penalty for volumetric origins, as the number of forces increase. But you shouldn't notice much if any impact on performance.","title":"Centroids"},{"location":"documentation/fields/#centroid-seed","text":"For complex meshes, centroids can end up in unwanted locations or gather in an area with dense vertices. That's when you can give the algorithm a little jolt to try and see whether there is a better alternative out there.","title":"Centroid Seed"},{"location":"documentation/fields/#use-selected-as-source","text":"Some forces act according to their position in the world. Attach a field to a Marker to create an interesting relationship between the two. Non-commercial Ragdoll This feature is limited to 100 frames in non-commercial versions of Ragdoll. Distance constrain two markers, and attach a field to the outer-most Marker for a doubly-interesting effect. That also wrecks your brain. \ud83d\ude43","title":"Use Selected as Source"},{"location":"documentation/fields/#field-scale","text":"If forces start becoming large, you may find yourself in a situation where the visualisation needs to tone down just a bit. In the solver settings, you will find options to scale those lines (i.e. Field Scale ), as well as control how many steps into the future (i.e. Field Iterations ) it should draw for you.","title":"Field Scale"},{"location":"documentation/fields/#ignore-field","text":"Fine-tune the effect of fields by having one or more Markers ignore the effect of fields.","title":"Ignore Field"},{"location":"documentation/fields/#more","text":"Being native to Maya, Autodesk has some documentation of its own here. Maya's Fields Documentation . You may also search for fields on YouTube or ask your colleagues about them; any trick they've learnt may very well apply to Ragdoll as well!","title":"More"},{"location":"documentation/group/","text":"Ragdolls are combined into what's called a \"group\", with attributes to control the overall behavior of all contained Markers. Self Collision Previously, it was very important that your shapes did not overlap any shape other than it's immediate neighbour. If they did, chaos ensued. Before Clavicles intersect their parent spine, but also each other! After With the new Self Collision = Off , this is no longer a problem. This can be taken into the extreme! And here's a another example to fill out a large volume in the center of a character. Attention Notice how the spine is made up of many shapes, some of which cover the width of the body, others the depth. An overlapping mess that would never have simply not have been possible without self-collision support! Original asset created by Mehmet Tayfur T\u00fcrkmeno\u011fluwe and Dr. Reel, licensed by The Rookies.","title":"Group"},{"location":"documentation/group/#self-collision","text":"Previously, it was very important that your shapes did not overlap any shape other than it's immediate neighbour. If they did, chaos ensued. Before Clavicles intersect their parent spine, but also each other! After With the new Self Collision = Off , this is no longer a problem. This can be taken into the extreme! And here's a another example to fill out a large volume in the center of a character. Attention Notice how the spine is made up of many shapes, some of which cover the width of the body, others the depth. An overlapping mess that would never have simply not have been possible without self-collision support! Original asset created by Mehmet Tayfur T\u00fcrkmeno\u011fluwe and Dr. Reel, licensed by The Rookies.","title":"Self Collision"},{"location":"documentation/import_physics/","text":"Import physics onto existing controllers from disk. Import You can import a Ragdoll setup exported from Maya, back into Maya. It'll re-create everything just the way it was. What is included in the export? Just about everything. Solvers Groups Markers Constraints Colors Attribute changes Retargeting Reparenting Replaced meshes Thumbnail of your viewport What isn't included in the export? Very little. The mesh itself is not stored, the mesh is expected to come from your rig. Including any mesh you replace. This may be added in a future release. The cached simulation, although it will be soon. Will I get identical results when simulating an imported scene? Yes, anything else is a bug. More precisely, determinism depends on (1) the type and number of items in the solver along with (2) the order in which these are created. Both of these are part of the exported file format and is taken into account during import. Meaning you should get identical results so long as the content is the same. Example Here's an exported Ragdoll setup for the free CG Spectrum Tiger rig. Download Ragdoll file ( 2.8 mb ) Download Rig To use it, download the rig and import the Ragdoll file. It contains 2 levels of detail . Level Content Level 0 Body and feet Level 1 Everything on Level 0, plus toes Workflow Here's the rundown. Assign markers Tweak values Export Open a new scene, with the same character Import On import, Ragdoll will try and find the names of what you exported in your currently opened scene. If all names match, import should go smoothly. Preserving all of your hard work! If names do not match, if for example the namespace differs, there is an option to override the namespace from the file via the Namespace dropdown menu. If names don't match at all , if for example it was grouped differently on export or it is a different character altogether, then you can try using the Search and Replace fields to modify the names searched for by Ragdoll. Export Once you're happy with your character, it's time to export. Towards the bottom of the UI, you'll get a preview of what is about to be exported. This can help clarify that what ends up on disk is what you expect. Import In a new scene, with the same character, same names and everything, import as you'd expect. At the bottom of this UI, you'll get a preview of what's in the file on disk, along with how it will associate the node names found in the file with what you have on disk. Namespace from File Odds are, the character you're importing either has no namespace, or has a different namespace to what you've currently got in your scene. As in this example here, with 3 copies of the same character, each with its own namespace. Use the Namespace dropdown to select one of the current namespaces in your scene, or Custom to type one in yourself. Solver from File Per default, Ragdoll will import the file into the current solver in your scene, if any. Or, you can import the original solver from the source file. Known Limitations Here are a few things that will be addressed over time. Let us know if you encounter anything else! https://ragdolldynamics.com/chat Limitation Result Missing Replaced Mesh If you replace the mesh of a marker, but this mesh isn't present in the scene during import, you'll get a Capsule instead. The vertices of the geometry isn't stored in the exported file, only the name of the mesh you replaced with. Linked Solvers These turn into a single, unified solver on import.","title":"Import Physics"},{"location":"documentation/import_physics/#import","text":"You can import a Ragdoll setup exported from Maya, back into Maya. It'll re-create everything just the way it was. What is included in the export? Just about everything. Solvers Groups Markers Constraints Colors Attribute changes Retargeting Reparenting Replaced meshes Thumbnail of your viewport What isn't included in the export? Very little. The mesh itself is not stored, the mesh is expected to come from your rig. Including any mesh you replace. This may be added in a future release. The cached simulation, although it will be soon. Will I get identical results when simulating an imported scene? Yes, anything else is a bug. More precisely, determinism depends on (1) the type and number of items in the solver along with (2) the order in which these are created. Both of these are part of the exported file format and is taken into account during import. Meaning you should get identical results so long as the content is the same.","title":"Import"},{"location":"documentation/import_physics/#example","text":"Here's an exported Ragdoll setup for the free CG Spectrum Tiger rig. Download Ragdoll file ( 2.8 mb ) Download Rig To use it, download the rig and import the Ragdoll file. It contains 2 levels of detail . Level Content Level 0 Body and feet Level 1 Everything on Level 0, plus toes","title":"Example"},{"location":"documentation/import_physics/#workflow","text":"Here's the rundown. Assign markers Tweak values Export Open a new scene, with the same character Import On import, Ragdoll will try and find the names of what you exported in your currently opened scene. If all names match, import should go smoothly. Preserving all of your hard work! If names do not match, if for example the namespace differs, there is an option to override the namespace from the file via the Namespace dropdown menu. If names don't match at all , if for example it was grouped differently on export or it is a different character altogether, then you can try using the Search and Replace fields to modify the names searched for by Ragdoll. Export Once you're happy with your character, it's time to export. Towards the bottom of the UI, you'll get a preview of what is about to be exported. This can help clarify that what ends up on disk is what you expect. Import In a new scene, with the same character, same names and everything, import as you'd expect. At the bottom of this UI, you'll get a preview of what's in the file on disk, along with how it will associate the node names found in the file with what you have on disk.","title":"Workflow"},{"location":"documentation/import_physics/#namespace-from-file","text":"Odds are, the character you're importing either has no namespace, or has a different namespace to what you've currently got in your scene. As in this example here, with 3 copies of the same character, each with its own namespace. Use the Namespace dropdown to select one of the current namespaces in your scene, or Custom to type one in yourself.","title":"Namespace from File"},{"location":"documentation/import_physics/#solver-from-file","text":"Per default, Ragdoll will import the file into the current solver in your scene, if any. Or, you can import the original solver from the source file.","title":"Solver from File"},{"location":"documentation/import_physics/#known-limitations","text":"Here are a few things that will be addressed over time. Let us know if you encounter anything else! https://ragdolldynamics.com/chat Limitation Result Missing Replaced Mesh If you replace the mesh of a marker, but this mesh isn't present in the scene during import, you'll get a Capsule instead. The vertices of the geometry isn't stored in the exported file, only the name of the mesh you replaced with. Linked Solvers These turn into a single, unified solver on import.","title":"Known Limitations"},{"location":"documentation/level_of_detail/","text":"Light-weight or heavy-duty? How about both! Level of Detail Setup your character once with all bells-and-whistles, and interactively pick which level of detail to use for your simulation in a given situation. Usecases Body at Level 0 , fingers at Level 1 Props at Level 1 , muscles at Level 2 Major masses at Level 0 , extremities at Level 1 and Level 2 For example, here's a Wasp character with 3 levels of increasing detail. As you'd expect, it'll record only the currently active markers. Workflow Here's how it works. Give each marker a \"level\", such as 1 Tell solver which \"level\" to solve at, such as 1 And that's it! Any marker with a matching level is simulated and recorded. Operators What does each level mean? The answer lies in the \"operator\". Operator Description Less Than If the Marker Level is less than (or equal) to the Solver Level , simulate it. Greater Than If the Marker Level is greater than (or equal) to the Solver Level , simulate it. Equal If the Marker Level is equal to the Solver Level , simulate it. NotEqual If the Marker Level is not equal to the Solver Level , simulate it. With these, you can use each level for.. An increasing amount of detail An increasing amount of reduction Something completely custom With Equal and NotEqual operators, you can have some markers appear or disappear on particular levels, enabling endless combinations. Roadmap This should cover a majority of cases, but there are things you cannot yet do, but will be able to in the future. Capsule on one level, Mesh on another. For higher-resolution contacts. Dense hierarchy of controls at one level, sparse at another. For e.g. twist joints versus a simple 2-joint chain, or a densely packed spine versus just hip and torso controls. Algorithm For the geeks out there, here's what the underlying algorithm looks like in Python. # Membership types Minimum = 1 # Present at this level and higher Maximum = 3 # Present at this level and lower Only = 4 # Only present at this level Not = 5 # Present at all levels *except* this one markers = [ { \"name\" : \"hip\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"spine\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"neck\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"head\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_upper_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_lower_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"R_hand\" , \"level\" : 1 , \"membership\" : Minimum }, { \"name\" : \"L_foot_box\" , \"level\" : 1 , \"membership\" : Maximum }, { \"name\" : \"L_foot_convex\" , \"level\" : 2 , \"membership\" : Minimum }, { \"name\" : \"R_toe_capsule\" , \"level\" : 2 , \"membership\" : Not }, { \"name\" : \"R_toe_convex\" , \"level\" : 2 , \"membership\" : Only }, ] def resolve ( level ): print ( \"Level %d \" % level ) for marker in markers : if marker [ \"membership\" ] == Minimum and marker [ \"level\" ] <= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Maximum and marker [ \"level\" ] >= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Only and marker [ \"level\" ] == level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Not and marker [ \"level\" ] != level : print ( \" - {name} ( {level} )\" . format ( ** marker )) resolve ( 0 ) resolve ( 1 ) resolve ( 2 ) Run this, and this is what you'll find. Level 0 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 1 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 2 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_convex ( 2 ) - R_toe_convex ( 2 )","title":"Level Of Detail"},{"location":"documentation/level_of_detail/#level-of-detail","text":"Setup your character once with all bells-and-whistles, and interactively pick which level of detail to use for your simulation in a given situation. Usecases Body at Level 0 , fingers at Level 1 Props at Level 1 , muscles at Level 2 Major masses at Level 0 , extremities at Level 1 and Level 2 For example, here's a Wasp character with 3 levels of increasing detail. As you'd expect, it'll record only the currently active markers.","title":"Level of Detail"},{"location":"documentation/level_of_detail/#workflow","text":"Here's how it works. Give each marker a \"level\", such as 1 Tell solver which \"level\" to solve at, such as 1 And that's it! Any marker with a matching level is simulated and recorded.","title":"Workflow"},{"location":"documentation/level_of_detail/#operators","text":"What does each level mean? The answer lies in the \"operator\". Operator Description Less Than If the Marker Level is less than (or equal) to the Solver Level , simulate it. Greater Than If the Marker Level is greater than (or equal) to the Solver Level , simulate it. Equal If the Marker Level is equal to the Solver Level , simulate it. NotEqual If the Marker Level is not equal to the Solver Level , simulate it. With these, you can use each level for.. An increasing amount of detail An increasing amount of reduction Something completely custom With Equal and NotEqual operators, you can have some markers appear or disappear on particular levels, enabling endless combinations. Roadmap This should cover a majority of cases, but there are things you cannot yet do, but will be able to in the future. Capsule on one level, Mesh on another. For higher-resolution contacts. Dense hierarchy of controls at one level, sparse at another. For e.g. twist joints versus a simple 2-joint chain, or a densely packed spine versus just hip and torso controls.","title":"Operators"},{"location":"documentation/level_of_detail/#algorithm","text":"For the geeks out there, here's what the underlying algorithm looks like in Python. # Membership types Minimum = 1 # Present at this level and higher Maximum = 3 # Present at this level and lower Only = 4 # Only present at this level Not = 5 # Present at all levels *except* this one markers = [ { \"name\" : \"hip\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"spine\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"neck\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"head\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_upper_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_lower_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"R_hand\" , \"level\" : 1 , \"membership\" : Minimum }, { \"name\" : \"L_foot_box\" , \"level\" : 1 , \"membership\" : Maximum }, { \"name\" : \"L_foot_convex\" , \"level\" : 2 , \"membership\" : Minimum }, { \"name\" : \"R_toe_capsule\" , \"level\" : 2 , \"membership\" : Not }, { \"name\" : \"R_toe_convex\" , \"level\" : 2 , \"membership\" : Only }, ] def resolve ( level ): print ( \"Level %d \" % level ) for marker in markers : if marker [ \"membership\" ] == Minimum and marker [ \"level\" ] <= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Maximum and marker [ \"level\" ] >= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Only and marker [ \"level\" ] == level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Not and marker [ \"level\" ] != level : print ( \" - {name} ( {level} )\" . format ( ** marker )) resolve ( 0 ) resolve ( 1 ) resolve ( 2 ) Run this, and this is what you'll find. Level 0 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 1 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 2 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_convex ( 2 ) - R_toe_convex ( 2 )","title":"Algorithm"},{"location":"documentation/link/","text":"Combine, or \"merge\" multiple solvers together, to simulate them as one. Linking Reference two characters, link their solvers. Until now, you've been able to author physics using Active Chain and combine scenes using the Combine Scene menu item. That would transfer all connected rigids from one scene to another. But, that feature is destructive . There's no way to \"uncombine\" and even if you could, there's no record of what was originally combined. Let me introduce Solver Linking , a lightweight and non-destructive alternative. Linking This fellow is referenced twice, and get their solvers linked together. Unlinking Unlinking restores their previous behavior exactly. That's neat, but can you.. I know exactly what you're thinking, I was thinking the same thing. Can you link a solver to another solver that is also linked? So that I can build a network of simple solvers that all work together to form one complex solver? Yes. Yes, you can. \ud83e\udd2d See below. Example Here are 2 assets, a manikin and a backpack. Manikin Backback The backback and manikin has been combined into one, which is then referenced twice into the final scene for a total of 4 unique solvers. Non-destructively link solvers Notice the hierarchy of solvers formed here, enabling you to build complex solvers out of many small solvers. Non-destructively unlinking too Likewise, safely deconstruct a network of solvers by just removing the connection. Technically, a solver is added to another solver in the same manner a marker, group and constraint is added. One big happy family.","title":"Link"},{"location":"documentation/link/#linking","text":"Reference two characters, link their solvers. Until now, you've been able to author physics using Active Chain and combine scenes using the Combine Scene menu item. That would transfer all connected rigids from one scene to another. But, that feature is destructive . There's no way to \"uncombine\" and even if you could, there's no record of what was originally combined. Let me introduce Solver Linking , a lightweight and non-destructive alternative. Linking This fellow is referenced twice, and get their solvers linked together. Unlinking Unlinking restores their previous behavior exactly. That's neat, but can you.. I know exactly what you're thinking, I was thinking the same thing. Can you link a solver to another solver that is also linked? So that I can build a network of simple solvers that all work together to form one complex solver? Yes. Yes, you can. \ud83e\udd2d See below.","title":"Linking"},{"location":"documentation/link/#example","text":"Here are 2 assets, a manikin and a backpack. Manikin Backback The backback and manikin has been combined into one, which is then referenced twice into the final scene for a total of 4 unique solvers. Non-destructively link solvers Notice the hierarchy of solvers formed here, enabling you to build complex solvers out of many small solvers. Non-destructively unlinking too Likewise, safely deconstruct a network of solvers by just removing the connection. Technically, a solver is added to another solver in the same manner a marker, group and constraint is added. One big happy family.","title":"Example"},{"location":"documentation/manipulator/","text":"Interactively manipulate shapes and limits using the Manipulator. Manipulator One of the most challenging aspect of Ragdoll to date is editing shapes and limits. These have now been greatly simplified via the use of \"manipulators\", similar to your standard Translate/Rotate/Scale manipulators. Except on steroids. Here's a 21 second overview. Activate You have a few options for activating the manipulator. Run Ragdoll -> Manipulator Select a Ragdoll node and press T on your keyboard Select a Ragdoll node and click the Show Manipulator Tool in the Toolbar Any of the Ragdoll nodes can be selected in order to enable the manipulator via the T keyboard shortcut. rdSolver rdGroup rdMarker rdDistanceConstraint rdPinConstraint rdFixedConstraint Solver Shape At the time of this writing, the solver needs its shape selected, not the parent transform. This will be addressed in a future release. A comfortable workflow is.. Select any assigned control Select the marker DG node in the Channel Box Press T The selected Marker will be pre-selected in the manipulator. Alternatively, press the Show Manipulator Tool button in the Toolbar. Shape Modes This release introduces a manipulator with two \"modes\". Mode Description Shape Mode Edit shape properties, like Length , Radius , Position and Orientation Limit Mode Edit limit properties, like Twist and Swing along with their pivots. In Shape Mode, you currently have 5 manipulators. Manipulator Description Translate Affects the Shape Offset attribute Rotate Affects the Shape Rotation attribute Scale Affects the Shape Radius and Shape Extents attributes Length Affects the Shape Length attribute, for the Capsule shape HUD Individual control over primary attributes, like Shape Extents axes Translate Hold the middle-mouse button to translate. Rotate Hold Ctrl + middle-mouse button to rotate. Scale Hold Ctrl + left-mouse button to scale. Length The Capsule shape have additional in-view manipulators you can drag to affect each side independently. HUD Finally, attributes without a visual handle can be edited via the viewport HUD. Limit Mode In Limit Mode, you currently have 2 manipulators. Manipulator Description Limit Affects the Limit Range XYZ attributes HUD For locking and enabling of limits Enable and Disable Click the Axis button to limit the rotation about a particular axis. Lock and Unlock Click the Lock button to prevent all rotation about the axis. Asymmetrical Edits Hold Ctrl to make asymmetrical edits Some limbs start out at the center of their limit. Like your hip and neck. They are typically modeled to enable equal movement in each axis. Other limbs, like the elbow and knee, are typically modeled in the extreme of their limit. Able to only rotate in one direction. For these cases, they need an asymmetrical limit. With limits in multiple axes, keep an eye out for how asymmetrical edits to one axis affect the others. Why are they moving? Under the hood, each axis must be still be symmetrical; edits only appear to be asymmetrical for your convenience. What's really happening is the entire limit is both changing shape and also rotating and the rotation is causing all axes to move. This is an inherent limitation (pun!) of limits in Ragdoll and is unlikely to be addressed in the future, so we'll have to work with it. If you mess up and want to start from scratch, hit the Reset button, also found under.. Ragdoll -> Utilities -> Reset Constraint Frames Symmetry Enabled per default, symmetry will mirror your edits across an axis. There are 2 types of symmetry at the time of this writing. Type Description World Look for a marker across the current axis in worldspace Pose Based on the pose at the time of assigning markers, which is typically symmetrical. Each of which can be made symmetrical in either the X, Y or Z axes. The Pose axis means you can make changes even if a character has been posed after having been assigned. A feature particularly useful when assigning to the A- or T-pose of a character rig. Pose Based Symmetry Because these controls were assigned in the T-pose of the rig, you can use Pose-based symmetry to make changes even when the character is currently asymmetrical. Multiple Rigs If two or more characters are present in the scene, and they were all rigged in the same pose, at the center of the world, then Ragdoll will only look at markers in the same rdGroup as the selected Marker. Search Distance On the right-hand side of the Enable Symmetry button, there is a Search Distance gizmo. Drag to edit this value When you select a marker on one side, it will search for a marker at the opposite side of the axis you've chosen. Because positions are all approximate, it uses a maximum search distance to look for it. Matches Ideally, there should only be one match. But in a crowded hierarchy there may be several. Tune the Search Distance to control the number of matches, to ensure it doesn't pick the wrong one. Multi-select Disable Symmetry to enable multi-select Hold Shift to select and manipulate multiple markers at once. Drag Select? Not yet! But will be added in a future release. Undo & Redo No surprises here. Changes made using the manipulator is undoable as you would expect, with the exception that it currently does not let you undo the selection itself like normal Maya selection does; this will be addressed in a future release. Fit-to-view Tap the F key to fit any selected Marker(s) to the view, like you would expect from selected Maya nodes. Caveat This currently only applies if you've activated the manipulator using the Ragdoll -> Manipulator menu item, or have the rdSolver shape node selected. Select Node Click the Select Node button to select this node in Maya Per default, Ragdoll and Maya selection are separate. You can have Maya select the node(s) currently seleted in Ragdoll by pressing the Select Node button. You can automate this using the Synchronise button at the far-left of the HUD. Why is this not on per default? The solver is what is actually being fitted. If the selection is changed to a marker (which is not a DAG node, and therefore lacks a visual representation) then fit-to-view no longer works. This will be addressed in a future release and made into the default. With Multi-select or symmetry enabled, all selected markers will be selected in Maya, to make bulk edits via the Channel Box easier. Manipulator Help On the right-hand side is an overview of the hotkeys and mouse button combinations you can use, and what they do. It can be hidden via the HUD button on the upper right-hand side.","title":"Manipulator"},{"location":"documentation/manipulator/#manipulator","text":"One of the most challenging aspect of Ragdoll to date is editing shapes and limits. These have now been greatly simplified via the use of \"manipulators\", similar to your standard Translate/Rotate/Scale manipulators. Except on steroids. Here's a 21 second overview.","title":"Manipulator"},{"location":"documentation/manipulator/#activate","text":"You have a few options for activating the manipulator. Run Ragdoll -> Manipulator Select a Ragdoll node and press T on your keyboard Select a Ragdoll node and click the Show Manipulator Tool in the Toolbar Any of the Ragdoll nodes can be selected in order to enable the manipulator via the T keyboard shortcut. rdSolver rdGroup rdMarker rdDistanceConstraint rdPinConstraint rdFixedConstraint Solver Shape At the time of this writing, the solver needs its shape selected, not the parent transform. This will be addressed in a future release. A comfortable workflow is.. Select any assigned control Select the marker DG node in the Channel Box Press T The selected Marker will be pre-selected in the manipulator. Alternatively, press the Show Manipulator Tool button in the Toolbar.","title":"Activate"},{"location":"documentation/manipulator/#shape-modes","text":"This release introduces a manipulator with two \"modes\". Mode Description Shape Mode Edit shape properties, like Length , Radius , Position and Orientation Limit Mode Edit limit properties, like Twist and Swing along with their pivots. In Shape Mode, you currently have 5 manipulators. Manipulator Description Translate Affects the Shape Offset attribute Rotate Affects the Shape Rotation attribute Scale Affects the Shape Radius and Shape Extents attributes Length Affects the Shape Length attribute, for the Capsule shape HUD Individual control over primary attributes, like Shape Extents axes Translate Hold the middle-mouse button to translate. Rotate Hold Ctrl + middle-mouse button to rotate. Scale Hold Ctrl + left-mouse button to scale. Length The Capsule shape have additional in-view manipulators you can drag to affect each side independently. HUD Finally, attributes without a visual handle can be edited via the viewport HUD.","title":"Shape Modes"},{"location":"documentation/manipulator/#limit-mode","text":"In Limit Mode, you currently have 2 manipulators. Manipulator Description Limit Affects the Limit Range XYZ attributes HUD For locking and enabling of limits Enable and Disable Click the Axis button to limit the rotation about a particular axis. Lock and Unlock Click the Lock button to prevent all rotation about the axis. Asymmetrical Edits Hold Ctrl to make asymmetrical edits Some limbs start out at the center of their limit. Like your hip and neck. They are typically modeled to enable equal movement in each axis. Other limbs, like the elbow and knee, are typically modeled in the extreme of their limit. Able to only rotate in one direction. For these cases, they need an asymmetrical limit. With limits in multiple axes, keep an eye out for how asymmetrical edits to one axis affect the others. Why are they moving? Under the hood, each axis must be still be symmetrical; edits only appear to be asymmetrical for your convenience. What's really happening is the entire limit is both changing shape and also rotating and the rotation is causing all axes to move. This is an inherent limitation (pun!) of limits in Ragdoll and is unlikely to be addressed in the future, so we'll have to work with it. If you mess up and want to start from scratch, hit the Reset button, also found under.. Ragdoll -> Utilities -> Reset Constraint Frames","title":"Limit Mode"},{"location":"documentation/manipulator/#symmetry","text":"Enabled per default, symmetry will mirror your edits across an axis. There are 2 types of symmetry at the time of this writing. Type Description World Look for a marker across the current axis in worldspace Pose Based on the pose at the time of assigning markers, which is typically symmetrical. Each of which can be made symmetrical in either the X, Y or Z axes. The Pose axis means you can make changes even if a character has been posed after having been assigned. A feature particularly useful when assigning to the A- or T-pose of a character rig. Pose Based Symmetry Because these controls were assigned in the T-pose of the rig, you can use Pose-based symmetry to make changes even when the character is currently asymmetrical. Multiple Rigs If two or more characters are present in the scene, and they were all rigged in the same pose, at the center of the world, then Ragdoll will only look at markers in the same rdGroup as the selected Marker. Search Distance On the right-hand side of the Enable Symmetry button, there is a Search Distance gizmo. Drag to edit this value When you select a marker on one side, it will search for a marker at the opposite side of the axis you've chosen. Because positions are all approximate, it uses a maximum search distance to look for it. Matches Ideally, there should only be one match. But in a crowded hierarchy there may be several. Tune the Search Distance to control the number of matches, to ensure it doesn't pick the wrong one.","title":"Symmetry"},{"location":"documentation/manipulator/#multi-select","text":"Disable Symmetry to enable multi-select Hold Shift to select and manipulate multiple markers at once. Drag Select? Not yet! But will be added in a future release.","title":"Multi-select"},{"location":"documentation/manipulator/#undo-redo","text":"No surprises here. Changes made using the manipulator is undoable as you would expect, with the exception that it currently does not let you undo the selection itself like normal Maya selection does; this will be addressed in a future release.","title":"Undo &amp; Redo"},{"location":"documentation/manipulator/#fit-to-view","text":"Tap the F key to fit any selected Marker(s) to the view, like you would expect from selected Maya nodes. Caveat This currently only applies if you've activated the manipulator using the Ragdoll -> Manipulator menu item, or have the rdSolver shape node selected.","title":"Fit-to-view"},{"location":"documentation/manipulator/#select-node","text":"Click the Select Node button to select this node in Maya Per default, Ragdoll and Maya selection are separate. You can have Maya select the node(s) currently seleted in Ragdoll by pressing the Select Node button. You can automate this using the Synchronise button at the far-left of the HUD. Why is this not on per default? The solver is what is actually being fitted. If the selection is changed to a marker (which is not a DAG node, and therefore lacks a visual representation) then fit-to-view no longer works. This will be addressed in a future release and made into the default. With Multi-select or symmetry enabled, all selected markers will be selected in Maya, to make bulk edits via the Channel Box easier.","title":"Select Node"},{"location":"documentation/manipulator/#manipulator-help","text":"On the right-hand side is an overview of the hotkeys and mouse button combinations you can use, and what they do. It can be hidden via the HUD button on the upper right-hand side.","title":"Manipulator Help"},{"location":"documentation/marker/","text":"Markers form the fundamental building block of Ragdoll, to achieve Animation Capture a.k.a. \"reverse motion capture\". Animation Capture Capture your character rig, as though it was a live action actor. Inspired by Motion Capture - Animation Capture is a new way to think about and work with physics in Maya. To learn about it, let's first understand how Motion Capture generally works. Here is a typical data pipeline for motion capture, from real-life actor to final character animation. # Description 1 Markers are attached to an actor 2 Markers are \"captured\" 3 A pointcloud is generated 4 A hierarchy of joints is generated 5 Joints drive a typical character rig 6 Rig drives final geometry for render Each \"Marker\" is a dud. Nothing of any complexity. Something for the camera(s) to recognise and track as it moves through space. Once tracked, it's able to translate this Marker from a 2D image into a 3D position, and continues to do so for each Marker. The real processing to take place inside software. Once the capture is complete, the human actor can remove the markers and go enjoy the rest of their day. The rest is up to the computer. With 3D positions generated, software takes over to translate these points into a hierarchy; the FK joint hierarchy you may be familiar with if you've ever worked with mocap. The joint hierarchy can then be used to either drive the final geometry, or to drive a more complex character rig which in turn drives the final geometry. Animation Capture is just like that, but in reverse . Instead of capturing a person, it captures your character rig . # Description 1 Markers are attached to a character rig 2 Markers are \"captured\" 3 A rigid body is generated for each Marker 4 A hierarchy of constraints is generated to connect them 5 Simulation is recorded back onto the original character rig Unlike motion capture, we'd like the result mapped back onto our character rig again, which is how animators iterate with physics. Example 1 - Basics Here's how to simulate a box. Select box Run Assign Once you're happy with what you see.. Run Record Simulation Example 2 - Ragdoll Here's how to setup a full Ragdoll. 1. Setup hierarchy Select controls in the order you'd like them attached. 2. Edit shapes Fit the shapes to your character model. 3. Record Once your happy with the way the simulation looks, record it back onto your rig. Behaviour In the above examples, I mentioned Kinematic and you probably spotted a few other options too, like Inherit and Pose Match . What are those? The Behaviour is how Ragdoll should interpret the controls you assign. Did you mean for them remain animated, i.e. Kinematic ? Or should they follow the control around, i.e. Pose ? Or should they just fall with gravity, ignoring the original control altogether, i.e. Initial State ? The Behaviour can be set either for a whole group of markers, or each Marker individually. Type Description Inherit Do whatever the group is doing, or Kinematic if there is no group Initial State Do nothing, just fall under gravity Kinematic Follow the input exactly , physics need not apply Pose Match Follow the input approximately, with some Stiffness and Damping Kinematic Follow the input exactly, no exceptions. Not even collisions. Dynamic Follow the local pose of your animation. Pose Space Pose matching happens in either Local or World space. Look, it's Ragdoll Blaine! This is an example of Worldspace Pose Matching . Ragdoll will try and reach the worldspace position and orientation of your rig, rather than only looking at the relative angles between each limb. Here's another example of the difference between Local and World space. Notice how in Local space, the controls arms remain relative the torso. And with World space they instead follow the worldspace orientation of the controls. This attribute is also animatable , and is how you can transition from animation into simulation and back again. Here's a more complete example: Frame Transition 100 Starts as a regular animated character 125 Transitions into physics as he jumps, for a physically-correct trajectory 155 Transitions back to animation once he rolls over on that cabinet 160 Transitions back to physics until he stands up 170 Transitions back into animation to match an exact pose 200 Partially transitions into physics, for secondary motion in the upper body as his arm is raised. Overlap Group Specify which markers may overlap rather than collide. This can be useful to enable dense areas of a character, like the clavicles, where there is natural overlap amongst large shapes like with the neck and spine. Value Meaning -1 No overlap allowed 0 Default, respects self-collision on the group (if any) 1-255 Overlap everything with the same number An rdMarker part of a rdGroup can get an overlap group assigned procedurally, based on other members of that group. For example, in a complete ragdoll, all markers are part of the same group. So a Self Collide = On means these will all be given the same overlap group. If it isn't in a group, then 0 is the same as -1 , in that it will collide with everything. Let's have a look at a few scenarios. Collide with Everything In this example, every Marker is part of the same group. The group has Self Collide = Off , which is fine for just about every Marker except the fingers . In that case, we do want self-collision, so they are given the group -1 . Respect Self Collision In this case, we're happy with a default group of 0 since we don't need anything to self collide. Especially these clavicles that overlap significantly! Surgical Control Finally, for the very specific cases of wanting two or more markers to overlap. Notice how we give both the ground and 3 of the boxes an Overlap Group = 5 . Material Each Marker has a \"material\" to control how it interacts with other markers. Mass How much influence one Marker should have over another during contact. Pro tip 1 - Misconception about Mass A common misconception in physics is that Mass affects how quickly something falls to the ground. But in Ragdoll - like in real-life - mass is only relevant during interaction with another Marker and when forces are applied, like Guide Strength . Have a look at this video of a bowling ball falling in a vacuum alongside a feather. Pro tip 2 - Making something fall faster So how do you make something fall faster? Decrease Scene Scale under the solver node Increase Gravity , also under the solver node To make something \"bend\" faster, like an arm flexing, that would be controlled via the Guide Strength and typically what causes it to reach a given speed and then stay there is governed by the Rotate Damping . That's how much of any motion should be cancelled out, to stabilise the motion. A very fast motion would have very little damping, but then also run the risk of \"overshooting\". That is, of passing the point at which you wanted it to reach. Density Ragdoll can automatically compute a suitable mass for each Marker, based on the volume of your shape and a density of your choosing. In other words, big objects become heavy, small objects become light. Before After Presets Provide a custom density, or choose from one of the provided ones. Density Value Off Do not compute, use the Mass attribute Cotton Very sparse, 0.05 grams per cubic centimeter Wood Sparse, 0.2 grams per cubic centimeter Flesh Default, 1.0g/cm3 Uranium Dense, 19.0g/cm3 Black Hole Very, very dense Custom You pick Mass is computed based on the volume of your shape, along with a density of your choosing. Options Choose between various densities either at creation-time or after creation. Visualise The computed mass updates interactively as you change the size and type of your shape, including convex hulls! In the Manipulator, you'll be able to not only only edit the density, but preview the computed mass given the current shape volume and density you provide. Friction Control how much resistance should be added between two rigids rubbing against each other. Bounciness Control how much rigids should repel each other when coming into contact. Values beyond 1.0 Here's a tip! Bounciness can be greater than 1.0, which means they will gain energy during contact. In practice, energy will always dissipate in some way. The most-bouncy character in the gif above has a bounciness of 2.0 , which in theory means that for every contact it should fly 200% faster away than it did coming in, and keep doing this forever. Center of Mass If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You now override this point using the attribute Center of Mass found under the Advanced tab. Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it Angular Mass In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\", also known as \"moment of inertia\" . It's like mass, but in terms of rotation rather than position. The broom has a low angular mass along its length axis. It takes more force to affect a \"heavier\" axis than a lighter one which is why a broom spins more easily along its length. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, it will act like a broom. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to act like one Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it","title":"Marker"},{"location":"documentation/marker/#animation-capture","text":"Capture your character rig, as though it was a live action actor. Inspired by Motion Capture - Animation Capture is a new way to think about and work with physics in Maya. To learn about it, let's first understand how Motion Capture generally works. Here is a typical data pipeline for motion capture, from real-life actor to final character animation. # Description 1 Markers are attached to an actor 2 Markers are \"captured\" 3 A pointcloud is generated 4 A hierarchy of joints is generated 5 Joints drive a typical character rig 6 Rig drives final geometry for render Each \"Marker\" is a dud. Nothing of any complexity. Something for the camera(s) to recognise and track as it moves through space. Once tracked, it's able to translate this Marker from a 2D image into a 3D position, and continues to do so for each Marker. The real processing to take place inside software. Once the capture is complete, the human actor can remove the markers and go enjoy the rest of their day. The rest is up to the computer. With 3D positions generated, software takes over to translate these points into a hierarchy; the FK joint hierarchy you may be familiar with if you've ever worked with mocap. The joint hierarchy can then be used to either drive the final geometry, or to drive a more complex character rig which in turn drives the final geometry. Animation Capture is just like that, but in reverse . Instead of capturing a person, it captures your character rig . # Description 1 Markers are attached to a character rig 2 Markers are \"captured\" 3 A rigid body is generated for each Marker 4 A hierarchy of constraints is generated to connect them 5 Simulation is recorded back onto the original character rig Unlike motion capture, we'd like the result mapped back onto our character rig again, which is how animators iterate with physics.","title":"Animation Capture"},{"location":"documentation/marker/#example-1-basics","text":"Here's how to simulate a box. Select box Run Assign Once you're happy with what you see.. Run Record Simulation","title":"Example 1 - Basics"},{"location":"documentation/marker/#example-2-ragdoll","text":"Here's how to setup a full Ragdoll. 1. Setup hierarchy Select controls in the order you'd like them attached. 2. Edit shapes Fit the shapes to your character model. 3. Record Once your happy with the way the simulation looks, record it back onto your rig.","title":"Example 2 - Ragdoll"},{"location":"documentation/marker/#behaviour","text":"In the above examples, I mentioned Kinematic and you probably spotted a few other options too, like Inherit and Pose Match . What are those? The Behaviour is how Ragdoll should interpret the controls you assign. Did you mean for them remain animated, i.e. Kinematic ? Or should they follow the control around, i.e. Pose ? Or should they just fall with gravity, ignoring the original control altogether, i.e. Initial State ? The Behaviour can be set either for a whole group of markers, or each Marker individually. Type Description Inherit Do whatever the group is doing, or Kinematic if there is no group Initial State Do nothing, just fall under gravity Kinematic Follow the input exactly , physics need not apply Pose Match Follow the input approximately, with some Stiffness and Damping","title":"Behaviour"},{"location":"documentation/marker/#kinematic","text":"Follow the input exactly, no exceptions. Not even collisions.","title":"Kinematic"},{"location":"documentation/marker/#dynamic","text":"Follow the local pose of your animation.","title":"Dynamic"},{"location":"documentation/marker/#pose-space","text":"Pose matching happens in either Local or World space. Look, it's Ragdoll Blaine! This is an example of Worldspace Pose Matching . Ragdoll will try and reach the worldspace position and orientation of your rig, rather than only looking at the relative angles between each limb. Here's another example of the difference between Local and World space. Notice how in Local space, the controls arms remain relative the torso. And with World space they instead follow the worldspace orientation of the controls. This attribute is also animatable , and is how you can transition from animation into simulation and back again. Here's a more complete example: Frame Transition 100 Starts as a regular animated character 125 Transitions into physics as he jumps, for a physically-correct trajectory 155 Transitions back to animation once he rolls over on that cabinet 160 Transitions back to physics until he stands up 170 Transitions back into animation to match an exact pose 200 Partially transitions into physics, for secondary motion in the upper body as his arm is raised.","title":"Pose Space"},{"location":"documentation/marker/#overlap-group","text":"Specify which markers may overlap rather than collide. This can be useful to enable dense areas of a character, like the clavicles, where there is natural overlap amongst large shapes like with the neck and spine. Value Meaning -1 No overlap allowed 0 Default, respects self-collision on the group (if any) 1-255 Overlap everything with the same number An rdMarker part of a rdGroup can get an overlap group assigned procedurally, based on other members of that group. For example, in a complete ragdoll, all markers are part of the same group. So a Self Collide = On means these will all be given the same overlap group. If it isn't in a group, then 0 is the same as -1 , in that it will collide with everything. Let's have a look at a few scenarios.","title":"Overlap Group"},{"location":"documentation/marker/#collide-with-everything","text":"In this example, every Marker is part of the same group. The group has Self Collide = Off , which is fine for just about every Marker except the fingers . In that case, we do want self-collision, so they are given the group -1 .","title":"Collide with Everything"},{"location":"documentation/marker/#respect-self-collision","text":"In this case, we're happy with a default group of 0 since we don't need anything to self collide. Especially these clavicles that overlap significantly!","title":"Respect Self Collision"},{"location":"documentation/marker/#surgical-control","text":"Finally, for the very specific cases of wanting two or more markers to overlap. Notice how we give both the ground and 3 of the boxes an Overlap Group = 5 .","title":"Surgical Control"},{"location":"documentation/marker/#material","text":"Each Marker has a \"material\" to control how it interacts with other markers.","title":"Material"},{"location":"documentation/marker/#mass","text":"How much influence one Marker should have over another during contact. Pro tip 1 - Misconception about Mass A common misconception in physics is that Mass affects how quickly something falls to the ground. But in Ragdoll - like in real-life - mass is only relevant during interaction with another Marker and when forces are applied, like Guide Strength . Have a look at this video of a bowling ball falling in a vacuum alongside a feather. Pro tip 2 - Making something fall faster So how do you make something fall faster? Decrease Scene Scale under the solver node Increase Gravity , also under the solver node To make something \"bend\" faster, like an arm flexing, that would be controlled via the Guide Strength and typically what causes it to reach a given speed and then stay there is governed by the Rotate Damping . That's how much of any motion should be cancelled out, to stabilise the motion. A very fast motion would have very little damping, but then also run the risk of \"overshooting\". That is, of passing the point at which you wanted it to reach.","title":"Mass"},{"location":"documentation/marker/#density","text":"Ragdoll can automatically compute a suitable mass for each Marker, based on the volume of your shape and a density of your choosing. In other words, big objects become heavy, small objects become light. Before After","title":"Density"},{"location":"documentation/marker/#presets","text":"Provide a custom density, or choose from one of the provided ones. Density Value Off Do not compute, use the Mass attribute Cotton Very sparse, 0.05 grams per cubic centimeter Wood Sparse, 0.2 grams per cubic centimeter Flesh Default, 1.0g/cm3 Uranium Dense, 19.0g/cm3 Black Hole Very, very dense Custom You pick Mass is computed based on the volume of your shape, along with a density of your choosing.","title":"Presets"},{"location":"documentation/marker/#options","text":"Choose between various densities either at creation-time or after creation.","title":"Options"},{"location":"documentation/marker/#visualise","text":"The computed mass updates interactively as you change the size and type of your shape, including convex hulls! In the Manipulator, you'll be able to not only only edit the density, but preview the computed mass given the current shape volume and density you provide.","title":"Visualise"},{"location":"documentation/marker/#friction","text":"Control how much resistance should be added between two rigids rubbing against each other.","title":"Friction"},{"location":"documentation/marker/#bounciness","text":"Control how much rigids should repel each other when coming into contact. Values beyond 1.0 Here's a tip! Bounciness can be greater than 1.0, which means they will gain energy during contact. In practice, energy will always dissipate in some way. The most-bouncy character in the gif above has a bounciness of 2.0 , which in theory means that for every contact it should fly 200% faster away than it did coming in, and keep doing this forever.","title":"Bounciness"},{"location":"documentation/marker/#center-of-mass","text":"If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You now override this point using the attribute Center of Mass found under the Advanced tab. Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it","title":"Center of Mass"},{"location":"documentation/marker/#angular-mass","text":"In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\", also known as \"moment of inertia\" . It's like mass, but in terms of rotation rather than position. The broom has a low angular mass along its length axis. It takes more force to affect a \"heavier\" axis than a lighter one which is why a broom spins more easily along its length. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, it will act like a broom. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to act like one Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it","title":"Angular Mass"},{"location":"documentation/record_simulation/","text":"Convert a simulation into keyframes using Record Simulation . Record Simulation Markers can be recorded all together, or independently. For example, say you wanted animation from frame 1-100, simulate 101-150 and return to animation from 151-200. You can do that. Furthermore, say you liked what the simulation was doing, but only on one half of the body. Or only on the hip, driving the main trajectory in a physically-plausible way. Keeping the rest of your animation intact. Record All With nothing selected, Ragdoll will record all marked controls to the current Maya playback range. Record Selected Markers Select a few controls to control what gets recorded. Record Range Limit the Maya playback range for control over when recording takes place. Record Selected Range Or, select an explicit range interactively. Record to Animation Layer Ragdoll will record to a layer per default. Transitions Let's have a look at how you would use markers to transition between simulation and animation. Notice how we're animated up until the jump, and then Ragdoll takes over. Once he approaches that box, we turn our Pose Space from Local to World and have him reach the target pose in worldspace . Once he's close, we switch Behaviour to Kinematic and kinematically move him. Until we once again transition to Guide , this time with Pose Space = Local . Record to Custom Attributes Sometimes, rotation isn't coming from Rotate X but rather a custom Ball Roll attribute on a different IK control. As Ragdoll only understands Translate and Rotate , how would you go about recording onto this attribute!? Here's what you can do. Create a new Locator Retarget the foot to this Locator Connect Locator.rotateX -> R_foot_CTL.ballRoll Now Ragdoll will record onto a familiar channel, and Maya will handle the conversion back onto the rig. Extract Simulation Get data out of the solver and into a baked joint hierarchy. You can use this to build a library of animations, or to handle the retargeting from simulation to animation manually by just constraining to the resulting joint hierarchy. Performance Notice how fast this is! A Debugging Companion It can also be used for situations where Record Simulation doesn't do what you need it to. The extracted skeleton will be a plain joint hierarchy, with no scale, and guaranteed to match the simulation exactly. So you can extract it, and constrain your rig to it.","title":"Record Simulation"},{"location":"documentation/record_simulation/#record-simulation","text":"Markers can be recorded all together, or independently. For example, say you wanted animation from frame 1-100, simulate 101-150 and return to animation from 151-200. You can do that. Furthermore, say you liked what the simulation was doing, but only on one half of the body. Or only on the hip, driving the main trajectory in a physically-plausible way. Keeping the rest of your animation intact. Record All With nothing selected, Ragdoll will record all marked controls to the current Maya playback range. Record Selected Markers Select a few controls to control what gets recorded. Record Range Limit the Maya playback range for control over when recording takes place. Record Selected Range Or, select an explicit range interactively. Record to Animation Layer Ragdoll will record to a layer per default.","title":"Record Simulation"},{"location":"documentation/record_simulation/#transitions","text":"Let's have a look at how you would use markers to transition between simulation and animation. Notice how we're animated up until the jump, and then Ragdoll takes over. Once he approaches that box, we turn our Pose Space from Local to World and have him reach the target pose in worldspace . Once he's close, we switch Behaviour to Kinematic and kinematically move him. Until we once again transition to Guide , this time with Pose Space = Local .","title":"Transitions"},{"location":"documentation/record_simulation/#record-to-custom-attributes","text":"Sometimes, rotation isn't coming from Rotate X but rather a custom Ball Roll attribute on a different IK control. As Ragdoll only understands Translate and Rotate , how would you go about recording onto this attribute!? Here's what you can do. Create a new Locator Retarget the foot to this Locator Connect Locator.rotateX -> R_foot_CTL.ballRoll Now Ragdoll will record onto a familiar channel, and Maya will handle the conversion back onto the rig.","title":"Record to Custom Attributes"},{"location":"documentation/record_simulation/#extract-simulation","text":"Get data out of the solver and into a baked joint hierarchy. You can use this to build a library of animations, or to handle the retargeting from simulation to animation manually by just constraining to the resulting joint hierarchy. Performance Notice how fast this is! A Debugging Companion It can also be used for situations where Record Simulation doesn't do what you need it to. The extracted skeleton will be a plain joint hierarchy, with no scale, and guaranteed to match the simulation exactly. So you can extract it, and constrain your rig to it.","title":"Extract Simulation"},{"location":"documentation/retargeting/","text":"Assign to joints, record to controls. Retarget Any moderately complex character will have parts better suited for capturing and others for recording onto. For example, in order to control a simulation with IK controls, we must first assign Markers onto the underlying joints driven by those IK controls. Then, we retarget those joints back onto the IK controls. In this example, markers are assigned to the upper body controls, but then to the joints of the lower body. We don't want keyframes on these joints, so we retarget these keyframes onto the IK controls. Reassign The opposite of Retarget. Rather than assigning to joints and retargeting to IK controls, we assign to IK controls and reassign to joints. Same coin, different side; which one do you prefer? Reparent Use Reparent when you selected things in the wrong order and want a do-over. Success! Untarget For when you don't want anything recorded for this Marker. Useful for utility Markers, like twist joints or extra spine controls or just Markers without a corresponding control.","title":"Retargeting"},{"location":"documentation/retargeting/#retarget","text":"Any moderately complex character will have parts better suited for capturing and others for recording onto. For example, in order to control a simulation with IK controls, we must first assign Markers onto the underlying joints driven by those IK controls. Then, we retarget those joints back onto the IK controls. In this example, markers are assigned to the upper body controls, but then to the joints of the lower body. We don't want keyframes on these joints, so we retarget these keyframes onto the IK controls.","title":"Retarget"},{"location":"documentation/retargeting/#reassign","text":"The opposite of Retarget. Rather than assigning to joints and retargeting to IK controls, we assign to IK controls and reassign to joints. Same coin, different side; which one do you prefer?","title":"Reassign"},{"location":"documentation/retargeting/#reparent","text":"Use Reparent when you selected things in the wrong order and want a do-over. Success!","title":"Reparent"},{"location":"documentation/retargeting/#untarget","text":"For when you don't want anything recorded for this Marker. Useful for utility Markers, like twist joints or extra spine controls or just Markers without a corresponding control.","title":"Untarget"},{"location":"documentation/snap_to_simulation/","text":"Snap a character to wherever the simulation is currently at. Snap to Simulation Yet another way to work with physics, by transferring individual poses from the solver into your animation. You can use it to pose or layout a scene. Coming Up An upcoming release will enable you to advance time in the simulation, without affecting time in Maya. Such that you can \"relax\" a pose, for example. \ud83d\ude01","title":"Snap to Simulation"},{"location":"documentation/snap_to_simulation/#snap-to-simulation","text":"Yet another way to work with physics, by transferring individual poses from the solver into your animation. You can use it to pose or layout a scene. Coming Up An upcoming release will enable you to advance time in the simulation, without affecting time in Maya. Such that you can \"relax\" a pose, for example. \ud83d\ude01","title":"Snap to Simulation"},{"location":"documentation/solver/","text":"Markers connect to a solver, and anything connected to one solver is able to interact. Solver Where the magic happens. The rdSolver node is akin to the motion capture camera(s). It'll monitor any markers in your Maya scene and show you what their physical equivalent version looks like. \u2714\ufe0f Real-time \u2714\ufe0f Deterministic \u2714\ufe0f Rewind and Resume \u2714\ufe0f Caching \u2714\ufe0f Support for scale \u2714\ufe0f Support for non-uniform scale \u2714\ufe0f Support for negative scale \u2714\ufe0f Support for overlapping shapes \u2714\ufe0f Support for IK/FK \u2714\ufe0f Support for space switching \u2714\ufe0f Support for follicles \u2714\ufe0f Support for native Maya constraints \u2714\ufe0f And more Frameskip Method Ragdoll needs a consistent progression of time to provide reliable results. So per default, if it notices a frame being skipped , it kindly pauses and waits until you revisit the last simulated frame. Alternatively, you can let it look the other way and pretend time has progressed linearly, like nCloth and countless other solvers do. Pause The default. It's safe, predictable, but requires Play Every Frame to work. Ignore The nCloth and nHair default, of trying its best to simulate even though it wasn't given the frames inbetween. Unpredictable, unreliable but may handle playing along with sound. Aside from not giving you the same result each time you play, if too many frames are skipped your simulation can completely explode. You can semi-work around this by increasing the number of substeps, forcing more simulation frames to fill for the missing frames. Non-deterministic Bear in mind that the Ignore method cannot give you the same results each playthrough. The Pause method is guaranteed to give you the same results, and are identical to what you get when you use the Record Simulation or Cache commands. Auto Time Rather than having to specify which frame to start simulating at, Ragdoll can keep track of your animation start frame. Either the start of the range , or the full timeline. Or, you can still set a Custom start time for when you do care about specifics. Pee-gees and Tee-gees Two sides of the same coin.","title":"Solver"},{"location":"documentation/solver/#solver","text":"Where the magic happens. The rdSolver node is akin to the motion capture camera(s). It'll monitor any markers in your Maya scene and show you what their physical equivalent version looks like. \u2714\ufe0f Real-time \u2714\ufe0f Deterministic \u2714\ufe0f Rewind and Resume \u2714\ufe0f Caching \u2714\ufe0f Support for scale \u2714\ufe0f Support for non-uniform scale \u2714\ufe0f Support for negative scale \u2714\ufe0f Support for overlapping shapes \u2714\ufe0f Support for IK/FK \u2714\ufe0f Support for space switching \u2714\ufe0f Support for follicles \u2714\ufe0f Support for native Maya constraints \u2714\ufe0f And more","title":"Solver"},{"location":"documentation/solver/#frameskip-method","text":"Ragdoll needs a consistent progression of time to provide reliable results. So per default, if it notices a frame being skipped , it kindly pauses and waits until you revisit the last simulated frame. Alternatively, you can let it look the other way and pretend time has progressed linearly, like nCloth and countless other solvers do.","title":"Frameskip Method"},{"location":"documentation/solver/#pause","text":"The default. It's safe, predictable, but requires Play Every Frame to work.","title":"Pause"},{"location":"documentation/solver/#ignore","text":"The nCloth and nHair default, of trying its best to simulate even though it wasn't given the frames inbetween. Unpredictable, unreliable but may handle playing along with sound. Aside from not giving you the same result each time you play, if too many frames are skipped your simulation can completely explode. You can semi-work around this by increasing the number of substeps, forcing more simulation frames to fill for the missing frames. Non-deterministic Bear in mind that the Ignore method cannot give you the same results each playthrough. The Pause method is guaranteed to give you the same results, and are identical to what you get when you use the Record Simulation or Cache commands.","title":"Ignore"},{"location":"documentation/solver/#auto-time","text":"Rather than having to specify which frame to start simulating at, Ragdoll can keep track of your animation start frame. Either the start of the range , or the full timeline. Or, you can still set a Custom start time for when you do care about specifics.","title":"Auto Time"},{"location":"documentation/solver/#pee-gees-and-tee-gees","text":"Two sides of the same coin.","title":"Pee-gees and Tee-gees"},{"location":"documentation/utilities/","text":"The fundamental building block to Ragdoll, for \"reverse motion capture\" or Animation Capture. Replace Mesh You can now replace the original geometry assigned to your marker, just like you could with Rigids. Auto Limits Markers are now able to infer which axes to lock in the simulation, based on the locked channels of your control or joint. Notice in this example how some of the channels are locked. With the Auto Limit option checked, the corresponding limit axes will be locked too, such as to prevent the simulation from rotating around those axes. If you forget or want to detect locked axes on an existing marker, you can use the Utility option too.","title":"Utilities"},{"location":"documentation/utilities/#replace-mesh","text":"You can now replace the original geometry assigned to your marker, just like you could with Rigids.","title":"Replace Mesh"},{"location":"documentation/utilities/#auto-limits","text":"Markers are now able to infer which axes to lock in the simulation, based on the locked channels of your control or joint. Notice in this example how some of the channels are locked. With the Auto Limit option checked, the corresponding limit axes will be locked too, such as to prevent the simulation from rotating around those axes. If you forget or want to detect locked axes on an existing marker, you can use the Utility option too.","title":"Auto Limits"},{"location":"nodes/rdConstraint/","text":"Reference sheet for the rdConstraint node type. from maya import cmds cmds . createNode ( \"rdConstraint\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdConstraint"},{"location":"nodes/rdConstraint/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdConstraintMultiplier/","text":"Reference sheet for the rdConstraintMultiplier node type. from maya import cmds cmds . createNode ( \"rdConstraintMultiplier\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping \u2714\ufe0f float 1.0 .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness \u2714\ufe0f float 1.0 .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping \u2714\ufe0f float 1.0 .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness \u2714\ufe0f float 1.0 .driveStrength Multiplier for rdConstraint.driveStrength \u2714\ufe0f float 1.0 .limitStrength Multiplier for rdConstraint.limitStrength \u2714\ufe0f float 1.0 .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping \u2714\ufe0f float 1.0 .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness \u2714\ufe0f float 1.0 .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping \u2714\ufe0f float 1.0 .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdConstraintMultiplier"},{"location":"nodes/rdConstraintMultiplier/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping \u2714\ufe0f float 1.0 .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness \u2714\ufe0f float 1.0 .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping \u2714\ufe0f float 1.0 .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness \u2714\ufe0f float 1.0 .driveStrength Multiplier for rdConstraint.driveStrength \u2714\ufe0f float 1.0 .limitStrength Multiplier for rdConstraint.limitStrength \u2714\ufe0f float 1.0 .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping \u2714\ufe0f float 1.0 .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness \u2714\ufe0f float 1.0 .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping \u2714\ufe0f float 1.0 .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdControl/","text":"Reference sheet for the rdControl node type. from maya import cmds cmds . createNode ( \"rdControl\" ) Attributes Attribute Description Keyable Type Default .color Color of the surface and wireframe. float3 0.443 0.705 0.952 .drawShaded Whether or not to draw wireframe or shaded. bool False .outputMesh Polygonal output, for rendering, shadows and export. mesh .rigid Reference to rigid this control represents. int -1 .version Version of Ragdoll used to create this node. int 0","title":"rdControl"},{"location":"nodes/rdControl/#attributes","text":"Attribute Description Keyable Type Default .color Color of the surface and wireframe. float3 0.443 0.705 0.952 .drawShaded Whether or not to draw wireframe or shaded. bool False .outputMesh Polygonal output, for rendering, shadows and export. mesh .rigid Reference to rigid this control represents. int -1 .version Version of Ragdoll used to create this node. int 0","title":"Attributes"},{"location":"nodes/rdRigid/","text":"Reference sheet for the rdRigid node type. from maya import cmds cmds . createNode ( \"rdRigid\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float 1.0 .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced. Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .creationMatrix Matrix at the time of creation. This attribute is copied into the .restMatrix upon calling Clear Initial State. matrix identity .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .exclusiveNodes Nodes created for this and only this rigid. Exclusive nodes are deleted alongside this rigid. If you want to keep a node initially created as an exclusive node, disconnect it from this array. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .inputSurface NURBS input to the Mesh shape type. nurbsSurface .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float 0.5 .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum 1 .sleepThreshold How strong does a force have to be to keep the wakeCounter from incrementing? Ragdoll optimises performance by putting inactive rigids to 'sleep'. It is a temporary state to conserve computational resources. 100 sleeping rigids are quicker to solve than 100 active ones. A rigid 'wakes up' whenever a force is applied or contact occurres. float 5e-06 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .userAttributes References to attributes created for this rigid but on another node. Such as proxy attributes created on an original animation control, used to drive the attribute on this rigid. bool True .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0 .wakeCounter How many frames of not moving does it take to put this rigid to sleep? A value of 0 = insomnia, meaning it never goes to sleep. int 0","title":"rdRigid"},{"location":"nodes/rdRigid/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float 1.0 .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced. Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .creationMatrix Matrix at the time of creation. This attribute is copied into the .restMatrix upon calling Clear Initial State. matrix identity .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .exclusiveNodes Nodes created for this and only this rigid. Exclusive nodes are deleted alongside this rigid. If you want to keep a node initially created as an exclusive node, disconnect it from this array. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .inputSurface NURBS input to the Mesh shape type. nurbsSurface .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float 0.5 .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum 1 .sleepThreshold How strong does a force have to be to keep the wakeCounter from incrementing? Ragdoll optimises performance by putting inactive rigids to 'sleep'. It is a temporary state to conserve computational resources. 100 sleeping rigids are quicker to solve than 100 active ones. A rigid 'wakes up' whenever a force is applied or contact occurres. float 5e-06 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .userAttributes References to attributes created for this rigid but on another node. Such as proxy attributes created on an original animation control, used to drive the attribute on this rigid. bool True .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0 .wakeCounter How many frames of not moving does it take to put this rigid to sleep? A value of 0 = insomnia, meaning it never goes to sleep. int 0","title":"Attributes"},{"location":"nodes/rdRigidMultiplier/","text":"Reference sheet for the rdRigidMultiplier node type. from maya import cmds cmds . createNode ( \"rdRigidMultiplier\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier for rdRigid.airDensity \u2714\ufe0f float 1.0 .angularDamping Multiplier for rdRigid.angularDamping \u2714\ufe0f float 1.0 .linearDamping Multiplier for rdRigid.linearDamping \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdRigidMultiplier"},{"location":"nodes/rdRigidMultiplier/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier for rdRigid.airDensity \u2714\ufe0f float 1.0 .angularDamping Multiplier for rdRigid.angularDamping \u2714\ufe0f float 1.0 .linearDamping Multiplier for rdRigid.linearDamping \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdScene/","text":"Reference sheet for the rdScene node type. from maya import cmds cmds . createNode ( \"rdScene\" ) Attributes Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .positionIterations Spend this many iterations on each rigid. Amount of iterations given to solve all constraints. This attribute is a multiplier of the rdRigid.positionIterations attribute, to affect the overall behavior of the scene. int 4 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdScene"},{"location":"nodes/rdScene/#attributes","text":"Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .positionIterations Spend this many iterations on each rigid. Amount of iterations given to solve all constraints. This attribute is a multiplier of the rdRigid.positionIterations attribute, to affect the overall behavior of the scene. int 4 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"releases/0/","text":"FIXED Inches and other Units Manipulator now understands units other than centimeters [ ADDED Following Pin Constraint] ADDED Manipulator & Ordered Selection Manipulator & Ordered Selection The Manipulator now remembers the order in which you select, meaning you can use it for ordinary tasks like reparenting and constraining markers! Following Pin Constraint The Pin Constraint can now automatically follow your animation on creation, opening up the gates for some pretty nifty workflow tricks. Mesh Protection Under rare circumstances, Maya could provide Ragdoll with meshes that have no volume. And that's fine; Ragdoll will generate a flat surface with some volume to it, to try and interpret what you want. Under even more rare circumstances, those volume-less meshes could cause trouble for Ragdoll. New attributes have been added to try and protect you from these. Inches Using the manipulator in a Maya configured for inches, or any other unit than millimeters.. ..could result in funky behaviour. This has now been fixed!","title":"..."},{"location":"releases/0/#manipulator-ordered-selection","text":"The Manipulator now remembers the order in which you select, meaning you can use it for ordinary tasks like reparenting and constraining markers!","title":"Manipulator &amp; Ordered Selection"},{"location":"releases/0/#following-pin-constraint","text":"The Pin Constraint can now automatically follow your animation on creation, opening up the gates for some pretty nifty workflow tricks.","title":"Following Pin Constraint"},{"location":"releases/0/#mesh-protection","text":"Under rare circumstances, Maya could provide Ragdoll with meshes that have no volume. And that's fine; Ragdoll will generate a flat surface with some volume to it, to try and interpret what you want. Under even more rare circumstances, those volume-less meshes could cause trouble for Ragdoll. New attributes have been added to try and protect you from these.","title":"Mesh Protection"},{"location":"releases/0/#inches","text":"Using the manipulator in a Maya configured for inches, or any other unit than millimeters.. ..could result in funky behaviour. This has now been fixed!","title":"Inches"},{"location":"releases/2020.11.10/","text":"Performance! NEW Multi-threading Ragdoll now supports multiple solvers in the same Maya scene, each of which run in parallel offering a 2-3x increase in FPS NEW UI Menu items now have additional customisation with a new UI interface. NEW Animation Influence Dynamic Controls can now respond to animation input, either kinematically or as a guided influence to your simulation. This means you can turn your controllers dynamic, and add additional animation to steer the simulation! NEW Exploratory Menu The menu is now fully unlocked, with user-friendly messages letting you know how to use it if you are unfamiliar. The goal is facilitating exploration and curiosity in a safe environment with reliable undo. FIXED Hinge Constraint A constraint being converted to/from a hinge constraint no longer breaks the constraint. FIXED Set Initial State Modify the position and orientation of your rigid bodies after creation with this feature. Multi-Threading Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead. Option Dialogs Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches. Animation Influence The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"2020.11.10"},{"location":"releases/2020.11.10/#multi-threading","text":"Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead.","title":"Multi-Threading"},{"location":"releases/2020.11.10/#option-dialogs","text":"Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches.","title":"Option Dialogs"},{"location":"releases/2020.11.10/#animation-influence","text":"The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"Animation Influence"},{"location":"releases/2020.11.16/","text":"The highlight for this release is Cached Playback! NEW Cached Playback You can now leverage Maya 2020's native cached playback for your simulations, speeding up playback performance and lowering iteration times. NEW Help Videos Ragdoll commands now come with how-to videos built directly into the UI. NEW Shape orientation and joints Shapes relied on the jointOrient being proper for joints, gone are the days. FIXED Wireframe Bug The wireframe for the Box shape does now draw correctly with a custom rdRigid.shapeRotation FIXED Outliner Icon Support on Linux Linux now benefits from the same pretty icons as Windows FIXED Logging Warnings These now emit a yellow color in your Command Line FIXED Boxes and Joints Joints converted to Rigids can now be set to Box shape with proper orientation Cached Playback Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor Known Limitations with Cached Playback There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! rdRigid.ouputGeometry Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why. Help Videos Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll. Shape Orientation Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"2020.11.16"},{"location":"releases/2020.11.16/#cached-playback","text":"Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor","title":"Cached Playback"},{"location":"releases/2020.11.16/#known-limitations-with-cached-playback","text":"There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! rdRigid.ouputGeometry Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why.","title":"Known Limitations with Cached Playback"},{"location":"releases/2020.11.16/#help-videos","text":"Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll.","title":"Help Videos"},{"location":"releases/2020.11.16/#shape-orientation","text":"Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"Shape Orientation"},{"location":"releases/2020.11.17/","text":"Minor release. NEW Installation confirmation Ragdoll now lets you know whether the install went successful or not. This appears on first launch, and can be revisited via the Ragdoll menu. This is also where updates will be found, along with future new-user material like links to docs and tutorials. FIXED The Ragdoll | Character menu item has been fixed and is operating at 100% Install Confirmation It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"2020.11.17"},{"location":"releases/2020.11.17/#install-confirmation","text":"It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"Install Confirmation"},{"location":"releases/2020.11.22/","text":"Minor release, no breaking changes. FIXED Capsule orientation used to face the wrong direction with some joints FIXED Creating a new collider is now undoable like you would expect FIXED Message printed when converting a rigid is now accurate FIXED Kinematic/Dynamic option from Convert Options does no longer bleeds into the Create Rigid Options ADDED Auto option to Convert Rigid , to toggle a rigid between dynamic and kinematic CHANGED The rdRigid.kinematic attribute is now up-top, better indicating its importance CHANGED The Ragdoll | Convert menu item is now split into Convert Rigid and Convert Constraint CHANGED Renamed Convex Hull -> Mesh , should make more sense now Capsule Orientation Fixed a bug where the capsule of a joint would face the wrong way. What is Rigid Body Dynamics? Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body Performance Tips Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"2020.11.22"},{"location":"releases/2020.11.22/#capsule-orientation","text":"Fixed a bug where the capsule of a joint would face the wrong way.","title":"Capsule Orientation"},{"location":"releases/2020.11.22/#what-is-rigid-body-dynamics","text":"Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body","title":"What is Rigid Body Dynamics?"},{"location":"releases/2020.11.22/#performance-tips","text":"Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"Performance Tips"},{"location":"releases/2020.11.23/","text":"The headline of this release is Dynamic Control 2.0 CHANGED Dynamic Control Removed fuss and simplified the interface. CHANGED \"Delete All Physics\" Now deletes all physics, regardless of the current selection CHANGED Rigid versus Collider Learn about what these mean and how to convert between the two. ADDED Center of mass (Advanced) Now you can change the point at which a rigid body is balanced ADDED Angular mass (Advanced) Typically computed automatically from the shape and size of your rigid, now you can manually define this. ADDED Auto Connect More clarity, and also usable with things other than joints Dynamic Control 2.0 Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos Limitations Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment. Center of Mass If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it Angular Mass In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\", also known as \"moment of inertia\" . It's like mass, but in terms of rotation rather than position. The broom has a low angular mass along its length axis. It takes more force to affect a \"heavier\" axis than a lighter one which is why a broom spins more easily along its length. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, it will act like a broom. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to act like one Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it Auto Connect The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"2020.11.23"},{"location":"releases/2020.11.23/#dynamic-control-20","text":"Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos","title":"Dynamic Control 2.0"},{"location":"releases/2020.11.23/#limitations","text":"Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment.","title":"Limitations"},{"location":"releases/2020.11.23/#center-of-mass","text":"If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it","title":"Center of Mass"},{"location":"releases/2020.11.23/#angular-mass","text":"In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\", also known as \"moment of inertia\" . It's like mass, but in terms of rotation rather than position. The broom has a low angular mass along its length axis. It takes more force to affect a \"heavier\" axis than a lighter one which is why a broom spins more easily along its length. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, it will act like a broom. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to act like one Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it","title":"Angular Mass"},{"location":"releases/2020.11.23/#auto-connect","text":"The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"Auto Connect"},{"location":"releases/2020.11.24/","text":"Hotfix, the last release broke a few things. FIXED You can now save the Maya scene. Imagine that! FIXED You can now enable the Ragdoll solver after having disabled it That's all, have mercy.","title":"2020.11.24"},{"location":"releases/2020.12.01/","text":"Lots of good stuff! CHANGED Active & Passive Rigid More intuitive jargon for these suckers CHANGED Character 2.0 New and improved, now with cup-holders! ADDED Dynamic Control Capsules For those flat controls ADDED Time Multiplier Speed up or slow down your simulation, can be animated! ADDED Normalise Shapes Evenly distribute shapes across a hierarchy ADDED Auto Orient Don't bother orienting your joints with this nifty automation, now the X-axis always means \"length\" CHANGED Delete all Physics now also deletes Ragdoll's attributes on your animation controls, for that squeaky clean feeling ADDED Support for custom Rotate Order means more character controls now work out-of-the-box. FIXED Undo bug and rdRigid The rigids should now clean up after themselves better FIXED Simulation start time now uses the start range rather than start time, which is what you would expect NOTES Stick figures Learn about how thickness affects your simulation NOTES Animation in 1995 Witness how little our industry has changed since then, let's fix that! Active & Passive Rigid Body The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\"). Character 2.0 - \"Auto-Ragger\" This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page Dynamic Control Capsules Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page Normalise Shapes An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up Time Multiplier Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene Rotate Order Now rigids play well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one! Auto Orient Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons. Undo Bug There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed! Stick Figures In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head? Animation in 1995 Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"2020.12.01"},{"location":"releases/2020.12.01/#active-passive-rigid-body","text":"The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\").","title":"Active &amp; Passive Rigid Body"},{"location":"releases/2020.12.01/#character-20-auto-ragger","text":"This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page","title":"Character 2.0 - \"Auto-Ragger\""},{"location":"releases/2020.12.01/#dynamic-control-capsules","text":"Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.01/#normalise-shapes","text":"An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up","title":"Normalise Shapes"},{"location":"releases/2020.12.01/#time-multiplier","text":"Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene","title":"Time Multiplier"},{"location":"releases/2020.12.01/#rotate-order","text":"Now rigids play well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one!","title":"Rotate Order"},{"location":"releases/2020.12.01/#auto-orient","text":"Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons.","title":"Auto Orient"},{"location":"releases/2020.12.01/#undo-bug","text":"There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed!","title":"Undo Bug"},{"location":"releases/2020.12.01/#stick-figures","text":"In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head?","title":"Stick Figures"},{"location":"releases/2020.12.01/#animation-in-1995","text":"Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"Animation in 1995"},{"location":"releases/2020.12.07/","text":"Small release with important changes if you use Dynamic Controls on complex rigs with pre-existing animation. ADDED Blend Rigid Now rigids can do some of what Dynamic Controls can do. :) FIXED Dynamic Control switch Shape You can now switch to capsules after having created them as meshes. FIXED Dynamic Control and Undo If your controls have pre-existing animation, undo will now work properly FIXED Dynamic Control and Auto Orient If you controls have intermediate groups between themselves, auto axis will now work properly Blend Rigid Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box. Dynamic Control Capsules Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around. Dynamic Control and Undo You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo. Dynamic Control and Orient Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"2020.12.07"},{"location":"releases/2020.12.07/#blend-rigid","text":"Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box.","title":"Blend Rigid"},{"location":"releases/2020.12.07/#dynamic-control-capsules","text":"Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around.","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.07/#dynamic-control-and-undo","text":"You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo.","title":"Dynamic Control and Undo"},{"location":"releases/2020.12.07/#dynamic-control-and-orient","text":"Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"Dynamic Control and Orient"},{"location":"releases/2020.12.18/","text":"Documentation documentation documentation! ADDED Documentation You heard it here first! ADDED Help Page All menu items now offer a dedicated help page for details about how it works. ADDED Timeline More videos more easily accessible via the new Timeline feature of UIs CHANGED API \ud83d\udc96 cmds The API now integrates with maya.cmds ADDED Shelf Support Menu items can now be added to your own custom shelf with Ctrl + Shift + Click ADDED Helper warnings Ragdoll now warns when doing something unsupported This version expires January 10 2021 Documentation Since the last release I've added a boatload of documentation to Ragdoll, including the very website you are visiting now! https://learn.ragdolldynamics.com This is where I'll aggregate anything there is to know about Ragdoll, including links to the upcoming forums and chat rooms, YouTube series and more. More more more! Documentation is generated dynamically from the same source used to generate the in-Maya menu and graphical dialogs, so whenever you want quick help from within Maya without breaking your flow, you can! And when you're on the train without access to Maya wanting to know more about a particular button or feature, you can! Overview Help Page Every menu item now comes with the Help sub-menu active. The page can also be accessed by clicking on the top description. I also added hints to the labels of attributes, rather than just the widgets themselves. All of the information is generated from the same source as the website, so they'll tell you the same thing except closer to where you are. For example, the Active Rigid menu item: https://learn.ragdolldynamics.com/menu/#active-rigid Timeline Multiple videos are now visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about. Real-time scrubbing I've added real-time scrubbing too! The caveat however is that it consumes a lot of RAM, this dialog of about 1,000 frames takes 1.5 GB of RAM, and a hefty delay to showing the option dialog. API and cmds The API used to take and return instances of cmdx , the high-performance alternative to PyMEL. The API now integrates seamlessly with maya.cmds , both taking and returning node paths (i.e. strings) rather than instances, which means you can now do this! from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) The performance advantage of cmdx is still intact, and can be accessed via commands.py which contains identical members and argument signatures, except returning instanced of cmdx instead. This is what's used internally for both performance and readability. In addition, there is now support for interactive.py for quick-and-dirty one-off scripts. This module contains all of what is provided by the Ragdoll menu and work similarly to api.py except they take (1) user selection and (2) user preferences into account. API Reference Add to Shelf Menu items can now be added to the shelf by holding Ctrl + Shift + Click. Menu items also reveal the equivalent Python command to use for your scripts! Helper Warnings If nodes have custom pivots or if your Maya scene is set to DG evaluation mode, Ragdoll will tell you about why that's a bad idea.","title":"2020.12.18"},{"location":"releases/2020.12.18/#documentation","text":"Since the last release I've added a boatload of documentation to Ragdoll, including the very website you are visiting now! https://learn.ragdolldynamics.com This is where I'll aggregate anything there is to know about Ragdoll, including links to the upcoming forums and chat rooms, YouTube series and more. More more more! Documentation is generated dynamically from the same source used to generate the in-Maya menu and graphical dialogs, so whenever you want quick help from within Maya without breaking your flow, you can! And when you're on the train without access to Maya wanting to know more about a particular button or feature, you can! Overview","title":"Documentation"},{"location":"releases/2020.12.18/#help-page","text":"Every menu item now comes with the Help sub-menu active. The page can also be accessed by clicking on the top description. I also added hints to the labels of attributes, rather than just the widgets themselves. All of the information is generated from the same source as the website, so they'll tell you the same thing except closer to where you are. For example, the Active Rigid menu item: https://learn.ragdolldynamics.com/menu/#active-rigid","title":"Help Page"},{"location":"releases/2020.12.18/#timeline","text":"Multiple videos are now visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about. Real-time scrubbing I've added real-time scrubbing too! The caveat however is that it consumes a lot of RAM, this dialog of about 1,000 frames takes 1.5 GB of RAM, and a hefty delay to showing the option dialog.","title":"Timeline"},{"location":"releases/2020.12.18/#api-and-cmds","text":"The API used to take and return instances of cmdx , the high-performance alternative to PyMEL. The API now integrates seamlessly with maya.cmds , both taking and returning node paths (i.e. strings) rather than instances, which means you can now do this! from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) The performance advantage of cmdx is still intact, and can be accessed via commands.py which contains identical members and argument signatures, except returning instanced of cmdx instead. This is what's used internally for both performance and readability. In addition, there is now support for interactive.py for quick-and-dirty one-off scripts. This module contains all of what is provided by the Ragdoll menu and work similarly to api.py except they take (1) user selection and (2) user preferences into account. API Reference","title":"API and cmds"},{"location":"releases/2020.12.18/#add-to-shelf","text":"Menu items can now be added to the shelf by holding Ctrl + Shift + Click. Menu items also reveal the equivalent Python command to use for your scripts!","title":"Add to Shelf"},{"location":"releases/2020.12.18/#helper-warnings","text":"If nodes have custom pivots or if your Maya scene is set to DG evaluation mode, Ragdoll will tell you about why that's a bad idea.","title":"Helper Warnings"},{"location":"releases/2021.01.04/","text":"This release introduces proper licencing to Ragdoll. ADDED Official Website Tell your friends! ADDED Licencing Read all about it! FIXED Locked rotatePivot Minor bug patched up and ready to go FIXED Centered Option Window - On Linux, the option window would sometimes appear in the top-left corner of the screen. No more! Website Happy New Year, the year of Ragdoll. :) I've launched the next generation of Ragdoll's website. Something a little more flashy and intended to wet people's appetite for what lies ahead. Feel free to tell people about it, I've added a note about when it'll become a reality. https://ragdolldynamics.com Also see this news coverage happening in Japan! :D https://3dnchu.com/archives/ragdoll-dynamics-maya/ The old website can still be accessed, although it is a little crippled. https://alanjfs.github.io/ragdoll-web/ If any link fails, just make sure it's prefixed with ragdoll-web/ as the landing page, e.g. https://alanjfs.github.io/ragdoll-web/howto Licencing Ragdoll is growing up and now understands the \"product key\" which means users can now purchase a copy and register it to themselves. Here's the short version, with a longer version below. Can I use it on more than one machine? Yes Can I move a licence between two machines? Yes Do I need an internet connection to use Ragdoll? Yes and no What if someone steals my licence key? Bummer Can I have a floating licence? Soon Can I activate offline? Soon When exactly is internet required? See long answer Can I manage my licence via Python? Yes Now let's cover the nitty gritty details, at the time of this writing. See licencing for current up-to-date information if you are reading this from the future. What's changed? You won't notice a change, other than a new UI. Rather than Ragdoll expiring on a fixed date, it'll now expire 30 days after first launch, unless you activate. Activation requires a product key which you get by either purchasing a licence or being really awesome. How does it work? On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Click Activate Enter your product key Or if you prefer: from ragdoll import licence licence . activate ( key ) Can I use it on more than one machine? Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence. Can I move a licence between two machines? Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released. Do I need an internet connection to use Ragdoll? Yes and no. Yes: To activate either the trial of purchased version of Ragdoll, the machine needs a connection to the internet. No: Once activated, you won't need internet for 90 days No: For special cases, get in touch. What if someone steals my licence key? That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one. Can I have a floating licence? Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All I need is you. Can I activate offline? Yes. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch. When exactly is internet required? A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain. Can I manage my licence via Python? Sure can, see below. Licence API As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" # Is the current licence activated? \"isActivated\" # Is the current licence a trial licence? \"isTrial\" # Has the licence not been tampered with? \"isGenuine\" # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" # How many days until this trial expires? \"trialDays\" } Locked Rotate Pivot Ragdoll doesn't support a custom rotatePivot attribute and would zero this out whenever a transform is turned dynamic. It'll provide a warning to the end user that this would happen. But, it wasn't taking into account the rotatePivot being connected or locked. If that happened, Ragdoll would flat out refuse and print something cryptic in the Script Editor. This has now been fixed. If the attribute is zero, nothing changes If the attribute is modified, it'll be zeroed out If the attribute is locked or connected, a warning is printed, but nothing changes. Ragdoll still doesn't actually support a custom rotate pivot. So this fixes only the situation where.. The rotatePivot is zero (default), and.. The rotatePivot is locked","title":"2021.01.04"},{"location":"releases/2021.01.04/#website","text":"Happy New Year, the year of Ragdoll. :) I've launched the next generation of Ragdoll's website. Something a little more flashy and intended to wet people's appetite for what lies ahead. Feel free to tell people about it, I've added a note about when it'll become a reality. https://ragdolldynamics.com Also see this news coverage happening in Japan! :D https://3dnchu.com/archives/ragdoll-dynamics-maya/ The old website can still be accessed, although it is a little crippled. https://alanjfs.github.io/ragdoll-web/ If any link fails, just make sure it's prefixed with ragdoll-web/ as the landing page, e.g. https://alanjfs.github.io/ragdoll-web/howto","title":"Website"},{"location":"releases/2021.01.04/#licencing","text":"Ragdoll is growing up and now understands the \"product key\" which means users can now purchase a copy and register it to themselves. Here's the short version, with a longer version below. Can I use it on more than one machine? Yes Can I move a licence between two machines? Yes Do I need an internet connection to use Ragdoll? Yes and no What if someone steals my licence key? Bummer Can I have a floating licence? Soon Can I activate offline? Soon When exactly is internet required? See long answer Can I manage my licence via Python? Yes Now let's cover the nitty gritty details, at the time of this writing. See licencing for current up-to-date information if you are reading this from the future.","title":"Licencing"},{"location":"releases/2021.01.04/#whats-changed","text":"You won't notice a change, other than a new UI. Rather than Ragdoll expiring on a fixed date, it'll now expire 30 days after first launch, unless you activate. Activation requires a product key which you get by either purchasing a licence or being really awesome.","title":"What's changed?"},{"location":"releases/2021.01.04/#how-does-it-work","text":"On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Click Activate Enter your product key Or if you prefer: from ragdoll import licence licence . activate ( key )","title":"How does it work?"},{"location":"releases/2021.01.04/#can-i-use-it-on-more-than-one-machine","text":"Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence.","title":"Can I use it on more than one machine?"},{"location":"releases/2021.01.04/#can-i-move-a-licence-between-two-machines","text":"Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released.","title":"Can I move a licence between two machines?"},{"location":"releases/2021.01.04/#do-i-need-an-internet-connection-to-use-ragdoll","text":"Yes and no. Yes: To activate either the trial of purchased version of Ragdoll, the machine needs a connection to the internet. No: Once activated, you won't need internet for 90 days No: For special cases, get in touch.","title":"Do I need an internet connection to use Ragdoll?"},{"location":"releases/2021.01.04/#what-if-someone-steals-my-licence-key","text":"That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one.","title":"What if someone steals my licence key?"},{"location":"releases/2021.01.04/#can-i-have-a-floating-licence","text":"Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All I need is you.","title":"Can I have a floating licence?"},{"location":"releases/2021.01.04/#can-i-activate-offline","text":"Yes. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch.","title":"Can I activate offline?"},{"location":"releases/2021.01.04/#when-exactly-is-internet-required","text":"A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain.","title":"When exactly is internet required?"},{"location":"releases/2021.01.04/#can-i-manage-my-licence-via-python","text":"Sure can, see below.","title":"Can I manage my licence via Python?"},{"location":"releases/2021.01.04/#licence-api","text":"As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" # Is the current licence activated? \"isActivated\" # Is the current licence a trial licence? \"isTrial\" # Has the licence not been tampered with? \"isGenuine\" # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" # How many days until this trial expires? \"trialDays\" }","title":"Licence API"},{"location":"releases/2021.01.04/#locked-rotate-pivot","text":"Ragdoll doesn't support a custom rotatePivot attribute and would zero this out whenever a transform is turned dynamic. It'll provide a warning to the end user that this would happen. But, it wasn't taking into account the rotatePivot being connected or locked. If that happened, Ragdoll would flat out refuse and print something cryptic in the Script Editor. This has now been fixed. If the attribute is zero, nothing changes If the attribute is modified, it'll be zeroed out If the attribute is locked or connected, a warning is printed, but nothing changes. Ragdoll still doesn't actually support a custom rotate pivot. So this fixes only the situation where.. The rotatePivot is zero (default), and.. The rotatePivot is locked","title":"Locked Rotate Pivot"},{"location":"releases/2021.01.14/","text":"Highlight for this release are the new Multiplier Nodes ! ADDED Multiplier Nodes Animate in bulk with this nifty utility node! ADDED Environment variables Gain more control over the integration of Ragdoll into your pipeline ADDED Dynamic Shape Type Attributes Cleaner channel box means happier animators FIXED NaN and Dynamic Control Got bogus values on the Rotate Limit of Dynamic Controls? No longer! FIXED Cycle warnings on create In rare occasions, Maya would complain that there's a cycle just as you turn a control dynamic. No more. FIXED Zero limit strength Used to be interpreted as \"inifinitely strong\", but now is \"off\" as one would expect. PUBLICITY EnTT We got mentioned in this great project :) OPTIMISATION Bounding Box Minor performance and stability improvements with native bounding box support Multiplier Nodes Work procedurally, with this centralised place to edit any number of rigids or constraints simultaneously. The idea is to facilitate a top-level node which govern the overall look of your simulation; withouth having to find and select each control individually. Workflow Select any number of rigids or constraints Click Multiply Selected Constraints (or Rigids ) The order in which you select matters, the first selection gets the node. The recommended workflow is to start with the root and work your way out. But your selection can span multiple hierarchies or even the whole character. A quick \"Select Hierarchy\" across an entire character is possible also. A constraint and rigid can only have 1 multiplier connected at any one time. Demo The most common attributes are made available currently, let me know if you find something missing! YouTube Wolf Rig Example Multiply Constraint Attributes Multiply Rigid Attributes Environment Variables Added these suckers for you to play around with. Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset For up to date information, see here. https://learn.ragdolldynamics.com/api/#environment-variables EnTT Getting some more recognition on the interwebs from EnTT, the library used to keep Ragdoll fast and clean! https://github.com/skypjack/entt Dynamic Shape Type Attributes Now only relevant attributes are visible in the Channel Box, dynamically based on the current type. I've added an option to disable this in the Global Preferences. Bounding Box Maya uses bounding box information to avoid drawing things that aren't visible in camera. The previous version of Ragdoll didn't provide Maya with any bounding box, which left Maya with no choice but to draw these always; even when behind the camera. Now this isn't so. You shouldn't notice much for smaller scenes, but drawing typically consumes 20-30% of the total CPU impact Ragdoll has on your character rigs. So for larger scenes this should reap a significant performance boost. Pro tip: You can also disable drawing of all Ragdoll primitives by disabling Locators in your viewport; that's how Maya classifies any and all Ragdoll nodes. Cycle Warnings TLDR; you should now experience fewer cycle warnings. https://forums.ragdolldynamics.com/t/how-to-cause-a-cycle-warning/33 Whenever you create a rigid from any Maya node, like an animation control, Ragdoll makes a note of the position and orientation of that control. It takes into account that you may not be on the start frame when you create the control, which is what you most likely intended to do. When that happens, Maya will silently roll back time in the background to query an attribute at the start frame. This silent roll-back has a tendency to trigger evaluation of unrelated nodes, like IK handles, which in turn trigger other nodes, ultimately leading back to where it came from, and thus cause a cycle. These were somewhat harmless, but could mask a real cycle from happening. In this release, this silent roll back only happens when you actually aren't on the start frame. So you should see less of it. There's still room for improvement however, so if you still find warnings or any odd behaviors being due to cycles, do reach out! NaN If you've ever gotten these, you can now rest easy. They are gone. They could happen on occasion, especially after repeated undo. It had to do with memory access violation by Maya being naughty, something it really shouldn't be able to do in the first place. We now guard against this , so all is well.","title":"2021.01.14"},{"location":"releases/2021.01.14/#multiplier-nodes","text":"Work procedurally, with this centralised place to edit any number of rigids or constraints simultaneously. The idea is to facilitate a top-level node which govern the overall look of your simulation; withouth having to find and select each control individually. Workflow Select any number of rigids or constraints Click Multiply Selected Constraints (or Rigids ) The order in which you select matters, the first selection gets the node. The recommended workflow is to start with the root and work your way out. But your selection can span multiple hierarchies or even the whole character. A quick \"Select Hierarchy\" across an entire character is possible also. A constraint and rigid can only have 1 multiplier connected at any one time. Demo The most common attributes are made available currently, let me know if you find something missing! YouTube Wolf Rig Example Multiply Constraint Attributes Multiply Rigid Attributes","title":"Multiplier Nodes"},{"location":"releases/2021.01.14/#environment-variables","text":"Added these suckers for you to play around with. Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset For up to date information, see here. https://learn.ragdolldynamics.com/api/#environment-variables","title":"Environment Variables"},{"location":"releases/2021.01.14/#entt","text":"Getting some more recognition on the interwebs from EnTT, the library used to keep Ragdoll fast and clean! https://github.com/skypjack/entt","title":"EnTT"},{"location":"releases/2021.01.14/#dynamic-shape-type-attributes","text":"Now only relevant attributes are visible in the Channel Box, dynamically based on the current type. I've added an option to disable this in the Global Preferences.","title":"Dynamic Shape Type Attributes"},{"location":"releases/2021.01.14/#bounding-box","text":"Maya uses bounding box information to avoid drawing things that aren't visible in camera. The previous version of Ragdoll didn't provide Maya with any bounding box, which left Maya with no choice but to draw these always; even when behind the camera. Now this isn't so. You shouldn't notice much for smaller scenes, but drawing typically consumes 20-30% of the total CPU impact Ragdoll has on your character rigs. So for larger scenes this should reap a significant performance boost. Pro tip: You can also disable drawing of all Ragdoll primitives by disabling Locators in your viewport; that's how Maya classifies any and all Ragdoll nodes.","title":"Bounding Box"},{"location":"releases/2021.01.14/#cycle-warnings","text":"TLDR; you should now experience fewer cycle warnings. https://forums.ragdolldynamics.com/t/how-to-cause-a-cycle-warning/33 Whenever you create a rigid from any Maya node, like an animation control, Ragdoll makes a note of the position and orientation of that control. It takes into account that you may not be on the start frame when you create the control, which is what you most likely intended to do. When that happens, Maya will silently roll back time in the background to query an attribute at the start frame. This silent roll-back has a tendency to trigger evaluation of unrelated nodes, like IK handles, which in turn trigger other nodes, ultimately leading back to where it came from, and thus cause a cycle. These were somewhat harmless, but could mask a real cycle from happening. In this release, this silent roll back only happens when you actually aren't on the start frame. So you should see less of it. There's still room for improvement however, so if you still find warnings or any odd behaviors being due to cycles, do reach out!","title":"Cycle Warnings"},{"location":"releases/2021.01.14/#nan","text":"If you've ever gotten these, you can now rest easy. They are gone. They could happen on occasion, especially after repeated undo. It had to do with memory access violation by Maya being naughty, something it really shouldn't be able to do in the first place. We now guard against this , so all is well.","title":"NaN"},{"location":"releases/2021.01.15/","text":"The gift that keeps on giving, the highlight for this release is Dynamic Control 3.0 ! UX Dynamic Control 3.0 More intuitive, more smart UX Convert & Restore Slimmer and more intuitive UI Passive Grayscale Passive rigids are now distinguished by grayscale colors ADDED Select All Quickly select all rigids and constraints with this handy menu or shelf item. Dynamic Control 3.0 Another step forward for Dynamic Controls. Default Capsule Ragdoll now defaults to the newer Capsule shape type for dynamic controls. It's faster and applies more generally to most rigs; even those that do have NURBS curves wrapping around the underlying character geometry. Before After Automatic Multiplier The previous release introduced Multiplier Nodes . This release add a multiplier to each new dynamic control chain per default, on the root control, which means you can now do stuff like this! Centralised Blend Simulation Previously, to blend between animation and simulation you needed to select the controls to blend and edit each individually. But it's rather uncommon (and probably not very useful) to want independent control over each blend. In this release, there is 1 central Blend Simulation attribute on the root dynamic control. This can be changed in the Options, but will probably disappear unless someone says they like it and wants to keep it! Smart Tip Length Previously, Ragdoll wasn't able to figure out how long to make the last control. Now it borrows length, radius and orientation from the parent capsule, which should be what you expect for the majority of cases. Meaning you can now expect this. Before After You can change the shape type after creation, and modify the default value in the options dialog. Transparent Root The first selection of a dynamic control chain is passive, and it used to also collide with the first child. But, most of the time, that root isn't useful as a collider. It would be a global hip control or some particular shoulder/clavicle gizmo. So the root is now set to Collide = False , meaning this is now ok. You can still enable it afterwards if you'd like. Convert and Restore I've merge the Convert Rigid and Convert Constraint buttons into the rigid and constraint creation buttons. Convert Rigid Turn a passive into an active rigid, or vice versa. Select active rigid in viewport Click Passive to convert it into a passive rigid If it's already passive, nothing happens. If you wanted to make a passive rigid active, you know what to do. Convert Constraint Turn a Socket Constraint into a Hinge Constraint, or any other type, on-the-fly. Select any constraint Click Socket to turn it into a socket constraint, regardless of what it was Restore Constraint Sometimes you just want to start from scratch. And using the same convert feature you can also restore a constraint to its original settings. Select any constraint Click any constraint type Passive Grayscale Spot passive rigids by their colors, now all passive rigids are gray. That means.. Active rigids are multi-colored Passive rigids are gray Controls are blue Select All Sometimes you want to make bulk changes to all rigids or all constraints at once. You could select each of them, or you could turn to Python and say.. cmds . select ( cmds . ls ( type = \"rdRigid\" )) Now there's a menu item for it too! With nothing selected, it'll select all rigids or constraints With something selected, it'll filter that selection for just rigids or constraints That means you can either find everything all at once and make great big changes, or you can zone in on a particular hierarchy or character and affect all rigids or constraints in just that hierarchy! Fire Wolf rig courtesy of Truong CG Artist","title":"2021.01.15"},{"location":"releases/2021.01.15/#dynamic-control-30","text":"Another step forward for Dynamic Controls.","title":"Dynamic Control 3.0"},{"location":"releases/2021.01.15/#default-capsule","text":"Ragdoll now defaults to the newer Capsule shape type for dynamic controls. It's faster and applies more generally to most rigs; even those that do have NURBS curves wrapping around the underlying character geometry. Before After","title":"Default Capsule"},{"location":"releases/2021.01.15/#automatic-multiplier","text":"The previous release introduced Multiplier Nodes . This release add a multiplier to each new dynamic control chain per default, on the root control, which means you can now do stuff like this!","title":"Automatic Multiplier"},{"location":"releases/2021.01.15/#centralised-blend-simulation","text":"Previously, to blend between animation and simulation you needed to select the controls to blend and edit each individually. But it's rather uncommon (and probably not very useful) to want independent control over each blend. In this release, there is 1 central Blend Simulation attribute on the root dynamic control. This can be changed in the Options, but will probably disappear unless someone says they like it and wants to keep it!","title":"Centralised Blend Simulation"},{"location":"releases/2021.01.15/#smart-tip-length","text":"Previously, Ragdoll wasn't able to figure out how long to make the last control. Now it borrows length, radius and orientation from the parent capsule, which should be what you expect for the majority of cases. Meaning you can now expect this. Before After You can change the shape type after creation, and modify the default value in the options dialog.","title":"Smart Tip Length"},{"location":"releases/2021.01.15/#transparent-root","text":"The first selection of a dynamic control chain is passive, and it used to also collide with the first child. But, most of the time, that root isn't useful as a collider. It would be a global hip control or some particular shoulder/clavicle gizmo. So the root is now set to Collide = False , meaning this is now ok. You can still enable it afterwards if you'd like.","title":"Transparent Root"},{"location":"releases/2021.01.15/#convert-and-restore","text":"I've merge the Convert Rigid and Convert Constraint buttons into the rigid and constraint creation buttons.","title":"Convert and Restore"},{"location":"releases/2021.01.15/#convert-rigid","text":"Turn a passive into an active rigid, or vice versa. Select active rigid in viewport Click Passive to convert it into a passive rigid If it's already passive, nothing happens. If you wanted to make a passive rigid active, you know what to do.","title":"Convert Rigid"},{"location":"releases/2021.01.15/#convert-constraint","text":"Turn a Socket Constraint into a Hinge Constraint, or any other type, on-the-fly. Select any constraint Click Socket to turn it into a socket constraint, regardless of what it was","title":"Convert Constraint"},{"location":"releases/2021.01.15/#restore-constraint","text":"Sometimes you just want to start from scratch. And using the same convert feature you can also restore a constraint to its original settings. Select any constraint Click any constraint type","title":"Restore Constraint"},{"location":"releases/2021.01.15/#passive-grayscale","text":"Spot passive rigids by their colors, now all passive rigids are gray. That means.. Active rigids are multi-colored Passive rigids are gray Controls are blue","title":"Passive Grayscale"},{"location":"releases/2021.01.15/#select-all","text":"Sometimes you want to make bulk changes to all rigids or all constraints at once. You could select each of them, or you could turn to Python and say.. cmds . select ( cmds . ls ( type = \"rdRigid\" )) Now there's a menu item for it too! With nothing selected, it'll select all rigids or constraints With something selected, it'll filter that selection for just rigids or constraints That means you can either find everything all at once and make great big changes, or you can zone in on a particular hierarchy or character and affect all rigids or constraints in just that hierarchy! Fire Wolf rig courtesy of Truong CG Artist","title":"Select All"},{"location":"releases/2021.01.17/","text":"Minor maintenance release. FIXED userSetup.py More robust integration with some pipelines FIXED Two-chain Dynamic Control More able to deal with edge-cases userSetup The startup code for Ragdoll since 2021.01.14 didn't play well with other userSetup.py files, like the ones you might have in a major production pipeline. If you were having any issues with the os module, then this is the fix for you. Two-chain Dynamic Control The previous release made it possible for the last selected Dynamic Control to inherit its size and orientation from the previously selected control. This only worked if you have 3 controls selected. This release makes it work on just 2 controls!","title":"2021.01.17"},{"location":"releases/2021.01.17/#usersetup","text":"The startup code for Ragdoll since 2021.01.14 didn't play well with other userSetup.py files, like the ones you might have in a major production pipeline. If you were having any issues with the os module, then this is the fix for you.","title":"userSetup"},{"location":"releases/2021.01.17/#two-chain-dynamic-control","text":"The previous release made it possible for the last selected Dynamic Control to inherit its size and orientation from the previously selected control. This only worked if you have 3 controls selected. This release makes it work on just 2 controls!","title":"Two-chain Dynamic Control"},{"location":"releases/2021.01.27/","text":"Focus of this release is Solver Iterations , and some UI additions too! ADDED Message Board Greater visibility of warnings and errors ADDED Solver Iterations Trade performance for precision ADDED Help Line The Help Line now displays a summary of what menu items do ADDED Delete from Selection Trim your setup more accurately with this new addition FIXED Locked Channels Now able to simulate even the most locked channel! FIXED Multiple cmdx You're now able to have Ragdoll running in conjunction with cmdx and vendors of cmdx. ADDED Animated Initial State A more adaptive initial state ADDED Worldspace Dynamic Control Dynamic Controls.. now in wordspace! Message Board Ever opened the Script Editor to find Ragdoll screaming for help? I've added a new Message Board to help Ragdoll stand out from the overall messy or hidden messages from rigs and Maya and all else. Your goal then is to never have any messages appear in the Message Board. A silent Message Board means a happy simulation. :) Solver Iterations Anything called strength in Ragdoll is a multipler for stiffness and damping . And currently there's a ceiling to how high stiffness and damping values can go, after which point they just stop having an effect. The values are limited by how many \"iterations\" you let the solver perform. Per default, they are set to 8 and can be found at rdRigid.positionIterations . This release sheds some more light on this somewhat obscure attribute by exposing it directly on the solver, right next to Substeps . This value multiplies each rdRigid.positionIterations attribute, meaning a value of 2 yields a total iteration count for every rigid in the solver of 16 (i.e. 2 * 8 ). Which means you can now do this! You can further customise iteration counts per rigid, under the Advanced tab. There's no limit to how many iterations you can allow; more iterations means greater accuracy. However, I have found that values beyond 128 tend to get funky. Iteration Count Strength Range Description 8 (default) 0-5 Default, sensible for most uses 16 0-10 High 32 0-500 Really, really high 64 0-1000 Ultra Nightmare For completeness, here's how Iterations differ from Substeps . Substep Divide each frame into smaller time steps Iterations Number of times a constraint is \"resolved\" They both provide accuracy in slightly different ways. With a greater amount of substeps, the solver is effectively working in slow-motion. Everything is easier in slow-motion. Resolving constraints is independent of time and a little more technical to describe, so you can instead kind of think of it a little bit like rubbing dirt of a silver platter. The first rub, you'll get most of it off. But the more you rub, the shinier it gets. There's no limit to how much you can rub, but eventually rubbing will stop having a visible effect. Help Line Hovering over any menu item now reveals a short description of what it does in the native Maya Help Line (typically at the bottom of the Maya window). This is the same information as can be found in the Menu Reference . Delete From Selection The Delete All Physics menu-item has gotten an option box, now it can be used to limit deletion to currently selected nodes! Locked Channels The previous release would bark at you whenever trying to turn any transform dynamic if it had any of its translate or rotate channels locked. This was a problem when you didn't necessarily care for some of them. For example, with a dynamic control, you really only cared for the rotate channels but would be prevented from simulating them if the sibling translate channels were locked. No longer! That said, the simulation does still produce both translate and rotate values. There's no way around it. And locked channels cannot be connected or edited. Even though you might want to. If the transform is referenced, then there's nothing you can do. Warnings will be emitted (and made visible in the new Message Board!) if this happens, so it's still true that if your Message Board is silent, all is well. Multiple cmdx This should only really affect users of WeightShift, which also uses cmdx . The previous release was adamant on being the one and only physics solver for Maya. But it has now become more lenient and accepting of other lifestyle choices. :D Animated Initial State Heads up! This got removed. Stay tuned for a re-appearance in a later release In the previous release, you could animate your dynamic controls, but you couldn't change the initial pose unless you explicitly called Set Initial Pose from the Ragdoll | Rigging menu. With this release, you can! Limitations This currently only works reliably with strict FK control hierarchies. The animation is translated into an initial state, but in doing so we are effectively recreating the parent/child relationship between controls. And sometimes - perhaps a lot of times - this isn't a direct FK hierarchy. Here you can see how the physics and animation controls disagree on what the pose should be. The animation controls aren't in a hierarchy, they are constrained in a complex manner. It isn't accurately reproduced in the initial state. So if you notice your the simulated initial state to differ from the first pose of your animation, it's the best you can get at the moment. Worldspace Dynamic Control Heads up! This got removed. Stay tuned for a re-appearance in a later release Guide forces in dynamic controls are all local . Which means it'll maintain a pose, even if that pose is upside down or sideways. And since many versions ago, you've been able to append these \"Guide\" controls, that are in worldspace (per default). These look at the worldspace position and rotation of the control, and use that to line up the simulation. Much like IK! Now these are built-in to each Dynamic Control (toggle in the option dialog). These can help keep a character closer to an animated pose. But they are \"cheats\". Forces that appear out of nowhere, as opposed to the local forces which behave like muscles. Muscles can tense and relax whilst still appearing natural, but these are not natural. You can however use them to fake natural. One more thing; world spaces have strength in either translation or rotation, or both. A worldspace rotation could for example keep a head facing a certain direction, not unlike how IK works. Except physical! Limitations This feature uses the same \"virtual hierarchy\" as the animated initial state and suffers from the same limitations.","title":"2021.01.27"},{"location":"releases/2021.01.27/#message-board","text":"Ever opened the Script Editor to find Ragdoll screaming for help? I've added a new Message Board to help Ragdoll stand out from the overall messy or hidden messages from rigs and Maya and all else. Your goal then is to never have any messages appear in the Message Board. A silent Message Board means a happy simulation. :)","title":"Message Board"},{"location":"releases/2021.01.27/#solver-iterations","text":"Anything called strength in Ragdoll is a multipler for stiffness and damping . And currently there's a ceiling to how high stiffness and damping values can go, after which point they just stop having an effect. The values are limited by how many \"iterations\" you let the solver perform. Per default, they are set to 8 and can be found at rdRigid.positionIterations . This release sheds some more light on this somewhat obscure attribute by exposing it directly on the solver, right next to Substeps . This value multiplies each rdRigid.positionIterations attribute, meaning a value of 2 yields a total iteration count for every rigid in the solver of 16 (i.e. 2 * 8 ). Which means you can now do this! You can further customise iteration counts per rigid, under the Advanced tab. There's no limit to how many iterations you can allow; more iterations means greater accuracy. However, I have found that values beyond 128 tend to get funky. Iteration Count Strength Range Description 8 (default) 0-5 Default, sensible for most uses 16 0-10 High 32 0-500 Really, really high 64 0-1000 Ultra Nightmare For completeness, here's how Iterations differ from Substeps . Substep Divide each frame into smaller time steps Iterations Number of times a constraint is \"resolved\" They both provide accuracy in slightly different ways. With a greater amount of substeps, the solver is effectively working in slow-motion. Everything is easier in slow-motion. Resolving constraints is independent of time and a little more technical to describe, so you can instead kind of think of it a little bit like rubbing dirt of a silver platter. The first rub, you'll get most of it off. But the more you rub, the shinier it gets. There's no limit to how much you can rub, but eventually rubbing will stop having a visible effect.","title":"Solver Iterations"},{"location":"releases/2021.01.27/#help-line","text":"Hovering over any menu item now reveals a short description of what it does in the native Maya Help Line (typically at the bottom of the Maya window). This is the same information as can be found in the Menu Reference .","title":"Help Line"},{"location":"releases/2021.01.27/#delete-from-selection","text":"The Delete All Physics menu-item has gotten an option box, now it can be used to limit deletion to currently selected nodes!","title":"Delete From Selection"},{"location":"releases/2021.01.27/#locked-channels","text":"The previous release would bark at you whenever trying to turn any transform dynamic if it had any of its translate or rotate channels locked. This was a problem when you didn't necessarily care for some of them. For example, with a dynamic control, you really only cared for the rotate channels but would be prevented from simulating them if the sibling translate channels were locked. No longer! That said, the simulation does still produce both translate and rotate values. There's no way around it. And locked channels cannot be connected or edited. Even though you might want to. If the transform is referenced, then there's nothing you can do. Warnings will be emitted (and made visible in the new Message Board!) if this happens, so it's still true that if your Message Board is silent, all is well.","title":"Locked Channels"},{"location":"releases/2021.01.27/#multiple-cmdx","text":"This should only really affect users of WeightShift, which also uses cmdx . The previous release was adamant on being the one and only physics solver for Maya. But it has now become more lenient and accepting of other lifestyle choices. :D","title":"Multiple cmdx"},{"location":"releases/2021.01.27/#animated-initial-state","text":"Heads up! This got removed. Stay tuned for a re-appearance in a later release In the previous release, you could animate your dynamic controls, but you couldn't change the initial pose unless you explicitly called Set Initial Pose from the Ragdoll | Rigging menu. With this release, you can! Limitations This currently only works reliably with strict FK control hierarchies. The animation is translated into an initial state, but in doing so we are effectively recreating the parent/child relationship between controls. And sometimes - perhaps a lot of times - this isn't a direct FK hierarchy. Here you can see how the physics and animation controls disagree on what the pose should be. The animation controls aren't in a hierarchy, they are constrained in a complex manner. It isn't accurately reproduced in the initial state. So if you notice your the simulated initial state to differ from the first pose of your animation, it's the best you can get at the moment.","title":"Animated Initial State"},{"location":"releases/2021.01.27/#worldspace-dynamic-control","text":"Heads up! This got removed. Stay tuned for a re-appearance in a later release Guide forces in dynamic controls are all local . Which means it'll maintain a pose, even if that pose is upside down or sideways. And since many versions ago, you've been able to append these \"Guide\" controls, that are in worldspace (per default). These look at the worldspace position and rotation of the control, and use that to line up the simulation. Much like IK! Now these are built-in to each Dynamic Control (toggle in the option dialog). These can help keep a character closer to an animated pose. But they are \"cheats\". Forces that appear out of nowhere, as opposed to the local forces which behave like muscles. Muscles can tense and relax whilst still appearing natural, but these are not natural. You can however use them to fake natural. One more thing; world spaces have strength in either translation or rotation, or both. A worldspace rotation could for example keep a head facing a certain direction, not unlike how IK works. Except physical! Limitations This feature uses the same \"virtual hierarchy\" as the animated initial state and suffers from the same limitations.","title":"Worldspace Dynamic Control"},{"location":"releases/2021.02.07/","text":"Highlight of this release is Support for Scale ! ADDED Support for Scale Ragdoll now works on scaled geometry and controls ADDED Support for NURBS Surfaces This hip new thing popularised in the 90s is now yours to reap! ADDED Visualise Output Attributes Gain insight into what comes out of the solver FIXED Zombie Attributes Delete All Physics didn't quite catch'em all Scale This has been an epic challenge , but it finally happened! Up till now, any scale other than (1, 1, 1) at any level of a hierarchy would have either broken a simulation or refused to work outright. Not anymore! Now you can simulate scaled transforms , including scaled rigs and all of what it entails. Here's a brief on what works and what doesn't. Feature Example \u2714\ufe0f Uniform Scale 1.5, 1.5, 1.5 \u2714\ufe0f Non-uniform Scale 0.5, 0.6, 0.12 \u2714\ufe0f Scaled parent(s) Scaled root control \u2714\ufe0f Mixed Scale & Constraints Scaled box to differently-scaled capsule \u2796 Zero Scale 0.0, 0.0, 0.0 \u2796 Mixed Zero Scale 1.0, 0.0, 1.0 \u2796 Negative Scale -1.5, -1.5, -1.5 \u2796 Mixed Positive/Negative Scale 0.9, -1.5, -1.1 \u2796 Non-uniform Negative Scale -1.0, 1.0, -2.0 \u274c Non Object-Space Scale Scale in World mode There are a few caveats. Avoid negative scale if possible, it works but can surprise you Negative non-uniform scale is more common, e.g. to mirror something across the X-axis, and may work but may surprise you Non object-space scale flat-out doesn't work, not even Maya can do that; it's here for completeness. Scale cannot be animated Scale is set on the start frame, and is part of the Initial State. It is also updated alongside the translate/rotate initial state. Negative Scale Commonly found in parent hierarchies that attempt to mirror the behavior of a control or hierarchy of controls. I'd like to better support this, but it is currently limited by math. More specifically, in that a transformation matrix simply cannot distinguish between negative and positive scale. So this one is semi-supported . The problem is for Ragdoll to distinguish between scale and rotation. It's a bit mathy, but you know how you can achieve the same pose by either scaling something negatively or rotate it 180 degrees along one or more axes? Ragdoll currently cannot know which of the possible outcomes you wanted. Here's a visual to help illustrate this point. ( Reference ) Here's what can happen in practice. Notice how both the scale and rotation values changed, even though the object in the viewport remains in the same orientation. That's because these values are both correct scale and orientation for this particular transform. You might think.. Well, whatever. So long as it's oriented right, why should I care? Well, what if you had animated a realistically looking horse locomotion, rotating around the X-axis ? Did you spot it? Both X and Z got their scale neutralised and X got 180 degrees steeper, compensating for the neutralised scale values. Also Z got flipped too! You can work around it, by accepting the new Z and offsetting your animation by 180 degrees. There's also the issue with it flying off for the first few frames. It's unclear why this happens, this may be a bug in the solver itself, trying to reconcile an orientation that is 180 degrees wrong. So, negative scale works, but it's painful. Avoid if possible. Zero Scale This is \"supported\" in that it doesn't fatal crash your Maya session. Ragdoll is a 3D solver, it cannot operate on anything without volume and mass. Here's an example of what to expect should you find the need for zero scale. Scaled Rotation TLDR; if you animate something from 0-45 degrees, it will rotate 45 degrees, regardless of scale. This should be what you expect and won't need remembering, but for completeness here's what happening under the hood. Ragdoll strips scale from most internal computations. It's kept mostly so that it can be outputted again, as well as for rendering. See, custom Maya nodes render in the space of the transform. So rendering a point at coordinate (0, 0, 0) ends up in the middle of the transform node. Even as you move that transform around with the translate tool. That's problematic if you need to draw something uniformly, like the limits and drive visualisations. Even more so when you attempt to draw a line from one transform to another.. at different scales! But stripping it early is beneficial for both readability of code, but also usability for you. Uniform scale normally doesn't affect rotation, but non-uniform scale could. Consider this. Here, we've got a single angle of 45 degrees. If you were to scale this horizontally, you can see how the angle now changes! At a scale of 0, the angle has gone from 45 degrees to 90 degrees. This complicates things a lot, and Ragdoll saves you from that by not taking non-uniform scale into consideration for its rotations. A 45 degree angle will remain 45 degree regardless of scale; with the exception of negative scales which still flip the angle as you'd expect. Non Object-Space Scale You probably don't do this, but for completeness here's what doesn't work. NURBS Surfaces Ragdoll could translate polygon meshes and NURBS curves into collision meshes, and today I'm happy to announce that it now also supports the latest trend in computer graphics, heavily used in the 90s at Dreamworks for critically acclaimed feature animation films Antz and Shark Tale. Join the future! Output Attributes The Attribute Editor now displays the output translate, rotate and scale attributes from each rigid body. In both local and world space coordinates. These are the values that feed into your animation control, or any transform you're simulating. Zombie Attributes Minor bug fix. The Delete All Physics menu item didn't catch the last remaining Local Strength attribute created by Create Dynamic Control . This is all patched up!","title":"2021.02.07"},{"location":"releases/2021.02.07/#scale","text":"This has been an epic challenge , but it finally happened! Up till now, any scale other than (1, 1, 1) at any level of a hierarchy would have either broken a simulation or refused to work outright. Not anymore! Now you can simulate scaled transforms , including scaled rigs and all of what it entails. Here's a brief on what works and what doesn't. Feature Example \u2714\ufe0f Uniform Scale 1.5, 1.5, 1.5 \u2714\ufe0f Non-uniform Scale 0.5, 0.6, 0.12 \u2714\ufe0f Scaled parent(s) Scaled root control \u2714\ufe0f Mixed Scale & Constraints Scaled box to differently-scaled capsule \u2796 Zero Scale 0.0, 0.0, 0.0 \u2796 Mixed Zero Scale 1.0, 0.0, 1.0 \u2796 Negative Scale -1.5, -1.5, -1.5 \u2796 Mixed Positive/Negative Scale 0.9, -1.5, -1.1 \u2796 Non-uniform Negative Scale -1.0, 1.0, -2.0 \u274c Non Object-Space Scale Scale in World mode There are a few caveats. Avoid negative scale if possible, it works but can surprise you Negative non-uniform scale is more common, e.g. to mirror something across the X-axis, and may work but may surprise you Non object-space scale flat-out doesn't work, not even Maya can do that; it's here for completeness. Scale cannot be animated Scale is set on the start frame, and is part of the Initial State. It is also updated alongside the translate/rotate initial state.","title":"Scale"},{"location":"releases/2021.02.07/#negative-scale","text":"Commonly found in parent hierarchies that attempt to mirror the behavior of a control or hierarchy of controls. I'd like to better support this, but it is currently limited by math. More specifically, in that a transformation matrix simply cannot distinguish between negative and positive scale. So this one is semi-supported . The problem is for Ragdoll to distinguish between scale and rotation. It's a bit mathy, but you know how you can achieve the same pose by either scaling something negatively or rotate it 180 degrees along one or more axes? Ragdoll currently cannot know which of the possible outcomes you wanted. Here's a visual to help illustrate this point. ( Reference ) Here's what can happen in practice. Notice how both the scale and rotation values changed, even though the object in the viewport remains in the same orientation. That's because these values are both correct scale and orientation for this particular transform. You might think.. Well, whatever. So long as it's oriented right, why should I care? Well, what if you had animated a realistically looking horse locomotion, rotating around the X-axis ? Did you spot it? Both X and Z got their scale neutralised and X got 180 degrees steeper, compensating for the neutralised scale values. Also Z got flipped too! You can work around it, by accepting the new Z and offsetting your animation by 180 degrees. There's also the issue with it flying off for the first few frames. It's unclear why this happens, this may be a bug in the solver itself, trying to reconcile an orientation that is 180 degrees wrong. So, negative scale works, but it's painful. Avoid if possible.","title":"Negative Scale"},{"location":"releases/2021.02.07/#zero-scale","text":"This is \"supported\" in that it doesn't fatal crash your Maya session. Ragdoll is a 3D solver, it cannot operate on anything without volume and mass. Here's an example of what to expect should you find the need for zero scale.","title":"Zero Scale"},{"location":"releases/2021.02.07/#scaled-rotation","text":"TLDR; if you animate something from 0-45 degrees, it will rotate 45 degrees, regardless of scale. This should be what you expect and won't need remembering, but for completeness here's what happening under the hood. Ragdoll strips scale from most internal computations. It's kept mostly so that it can be outputted again, as well as for rendering. See, custom Maya nodes render in the space of the transform. So rendering a point at coordinate (0, 0, 0) ends up in the middle of the transform node. Even as you move that transform around with the translate tool. That's problematic if you need to draw something uniformly, like the limits and drive visualisations. Even more so when you attempt to draw a line from one transform to another.. at different scales! But stripping it early is beneficial for both readability of code, but also usability for you. Uniform scale normally doesn't affect rotation, but non-uniform scale could. Consider this. Here, we've got a single angle of 45 degrees. If you were to scale this horizontally, you can see how the angle now changes! At a scale of 0, the angle has gone from 45 degrees to 90 degrees. This complicates things a lot, and Ragdoll saves you from that by not taking non-uniform scale into consideration for its rotations. A 45 degree angle will remain 45 degree regardless of scale; with the exception of negative scales which still flip the angle as you'd expect.","title":"Scaled Rotation"},{"location":"releases/2021.02.07/#non-object-space-scale","text":"You probably don't do this, but for completeness here's what doesn't work.","title":"Non Object-Space Scale"},{"location":"releases/2021.02.07/#nurbs-surfaces","text":"Ragdoll could translate polygon meshes and NURBS curves into collision meshes, and today I'm happy to announce that it now also supports the latest trend in computer graphics, heavily used in the 90s at Dreamworks for critically acclaimed feature animation films Antz and Shark Tale. Join the future!","title":"NURBS Surfaces"},{"location":"releases/2021.02.07/#output-attributes","text":"The Attribute Editor now displays the output translate, rotate and scale attributes from each rigid body. In both local and world space coordinates. These are the values that feed into your animation control, or any transform you're simulating.","title":"Output Attributes"},{"location":"releases/2021.02.07/#zombie-attributes","text":"Minor bug fix. The Delete All Physics menu item didn't catch the last remaining Local Strength attribute created by Create Dynamic Control . This is all patched up!","title":"Zombie Attributes"},{"location":"releases/2021.03.01/","text":"It's been an epic month of problem-solving, but it finally happened. :D Highlight for this release is.. drumroll.. Automatic Initial State ! ADDED Auto Initial State Start simulating in whatever pose your character is in ADDED Hierarchy Preservation Moving parents around now correctly moves children ADDED Worldspace Constraints Animate in both local- and world-space FIXED DG Viewport Bug Fix for rare cases of viewport going out of sync FIXED Unload plug-in The Ragdoll plug-in can now be loaded and unloaded using the native Maya plug-in manager ADDED New Commands Developer candy, return a JSON of physics for export and import into another application, like Unreal, Motion Builder or Blender! Tiger Rig courtesy of www.cgspectrum.com Auto Initial State Have you ever used the Set Initial State button? It's useful, isn't it? It's what enables you to turn something dynamic but then change your mind about where it should start simulating. With this release, that process is automatic! It's more or less what you expected would happen anyway. I mean, obviously the box should drop from where you left it, rather than where it was originally turned dynamic? Disable Feature If you would rather have none of it, or if it gives you trouble, you can switch it off like this. NOTE: Changes take effect on next scene open and newly created rigids. Parallel Only That's right, automatic initial state will only work in Maya's Parallel Evaluation mode. It may end up getting support for DG later on, the trouble lies in the callback we use to read an edited initial state is not reliable in DG. It's possible we'll find another means of achieving the same goal in the future, although DG really is part of the past. Ragdoll works best under Parallel for other reasons too; primarily performance but also stability and robustness. Constraints Stay Behind Constraints currently show you the true position of rigid bodies. They stay behind because hierarchy preservation is \"artificial\". It's just for you and Maya. In a later release, I'll make rigids also stay behind, and only have your controls move with hierarchy, so that you get to visualise where rigid bodies really are (even when your controls have locked channels, like translate) whilst at the same time letting you move and see your controls and how they reflect that true position. Caveat There's one known \"gotcha\" with the automated initial state. Namely, the initial state is \"recorded\" whenever you transition from the start time to the next frame. Evaluation on the next frame will automatically read whatever was evaluated previously, and store that as the initial state. However! It is possible to trigger evaluation without actually changing time. Maya loves doing that. You can do it by either scrubbing the timeline, or holding K and dragging (effectively scrubbing) the viewport. As you scrub, even if time isn't actually changing, Maya will go ahead and re-evaluated the time. When that happens, it won't actually record a new initial state, but instead restore the original value. Something to be aware of. Journey For the technically inclined, here you can witness last month's struggle first hand and all the kinks uncovered in Maya's API and evaluation graph. Hierarchy Preservation Like in the real world, physics happens in worldspace. There are no \"children\" and no \"parents\". As a result, as soon as you turn any of your controls dynamic, they start acting that way. But we don't want that. With this release, you'll now get realism along with that familiar feeling of having children and being a parent! Before After Caveat There is one known case to be aware of when it comes to children. Passive Rigids Hierarchy is currently preserved only if a rigid is active . The reason being.. well, I'll just show you. In this case, the passive rigid bodies are driven by an external transform, those blue \"controls\". Hierarchy is coming from the blue rigids, so we wouldn't want the passive rigids to mess with that. But now when we move the rigids themselves (gray, in this example) we aren't getting our hierarchy preservation.. :( At the other extreme, if we do account for hierarchy then the problem pops up at the other end instead. I trust experience and feedback will light the way here for a more intuitive experience working with external controls. Worldspace Constraints If you thought automatic initial state was enough, think again! If your controls have animation already applied, Ragdoll will now translate it into physics in world- and local-space. Default Behavior Local animation, like a rotated arm, are imbued with a \"local constraint\" to preserve the relative angle between it and its parent. World animation, like in this case where there is no parent, get imbued with a \"world constraint\". World Only Here's what you get when constraining the child to its worldspace pose. Notice how it assumes the angle you give it regardless of whatever the parent is doing. Local Only Conversely, with just the local constraint, it'll assume the relative angle and respects its parent. World + Local Things get interesting when you combine the two! World + World + Local ..or combine the three! Here's the lower arm trying to adhere to both its worldspace and local orientation. Notice the constraint coming out of alignment at the root; the constraints are of equal strength per default so it'll end up averaging the desired poses. There's one more thing happening here that I'll touch on in an upcoming release, which is the concept of world space forces. Notice how the joint chain follows animation DG Viewport Bug If you've ever had the viewport \"remember\" old frames as you scrub the timeline, this fix is for you. Unload Plug-in In the previous release, licencing was implemented as a Python binding. The trouble with compiled Python bindings in Maya is that they cannot be unloaded. As a result, Ragdoll could not be unloaded. Licencing is now implemented as a native Maya command, accessible as ragdollLicence from MEL and cmds.ragdollLicence() from Python. See ragdollLicence below New Commands Three new commands was added in this release, they are primarily intended for TDs and technically minded folk. cmds.ragdollLicence() cmds.ragdollPeek() cmds.ragdollDump() cmds.ragdollLicence Synopsis : ragdollLicence [ flags ] Flags : - q - query - a - activate String - d - deactivate - h - help - i - init - ia - isActivated - ig - isGenuine - it - isTrial - iv - isVerified - md - magicDays - r - reverify - s - serial - td - trialDays You still typically interact with ragdoll.licence , as documented here . But under the hood, this is now the native Maya command being called. from maya import cmds cmds . ragdollLicence ( serial = True , query = True ) # Your-Serial-Number-Here cmds.ragdollPeek Synopsis : ragdollPeek [ flags ] Flags : - e - entity UnsignedInt - h - help - ps - physicsStatistics - ss - sceneStatistics Gain insight into what Maya sees in Ragdoll. cmds . ragdollPeek ( sceneStatistics = True ) # Ragdoll Peek Scene ____________ ___________________________ _______________ | Id | Scene | Name | |------------|---------------------------|---------------| | 71 | rSceneShape | rSceneShape | | 70 | rSceneShape | rRigid18 | | 69 | rSceneShape | rRigid17 | | 67 | rSceneShape | rRigid | | 65 | rSceneShape | rRigid7 | | 63 | rSceneShape | rRigid8 | | 61 | rSceneShape | rRigid14 | | 59 | rSceneShape | rRigid15 | | 57 | rSceneShape | rRigid16 | | 55 | rSceneShape | rRigid11 | | 53 | rSceneShape | rRigid12 | | 51 | rSceneShape | rRigid13 | | 49 | rSceneShape | rRigid9 | | 46 | rSceneShape | rRigid10 | | 44 | rSceneShape | rRigid4 | | 42 | rSceneShape | rRigid5 | | 40 | rSceneShape | rRigid6 | | 38 | rSceneShape | rRigid1 | | 36 | rSceneShape | rRigid2 | | 34 | rSceneShape | rRigid3 | | 15 | rSceneShape | rRigid27 | | 14 | rSceneShape | rRigid28 | | 13 | rSceneShape | rRigid29 | | 12 | rSceneShape | rRigid30 | | 11 | rSceneShape | rRigid31 | | 10 | rSceneShape | rRigid32 | | 9 | rSceneShape | rRigid33 | | 8 | rSceneShape | rRigid34 | | 7 | rSceneShape | rRigid19 | | 6 | rSceneShape | rRigid20 | | 5 | rSceneShape | rRigid21 | | 4 | rSceneShape | rRigid22 | | 3 | rSceneShape | rRigid23 | | 1048576 | rSceneShape | rRigid24 | | 1048578 | rSceneShape | rRigid25 | | 1048577 | rSceneShape | rRigid26 | | ____________ | ___________________________ | _______________ | cmds . ragdollPeek ( physicsStatistics = True ) # Ragdoll Peek Solver - Number of scenes : 1 - Number of shapes : 36 - Number of materials : 36 - Number of convex meshes : 0 - scene [ 71 ] - Number of dynamic actors : 35 - Number of static actors : 1 - Number of constraints : 18 # cmds.ragdollDump Synopsis : ragdollDump - h - help This is more of a teaser of what's to come, but let me tell you about it for completeness of these release notes. ragdollDumps is the start of an integration effort of Ragdoll into any and all external software, like Unreal and Blender. Anything able to parse JSON. Including web-applications. What if you could rig and/or animate in Maya, but then export the physics setup into e.g. Unreal? I'm not talking about baking your animation and playing it back somewhere else. But of exporting the internal physics objects from Ragdoll, translating them to whatever the third-party software uses for physics, and re-using it there! With that, you could bypass all of the horrible authoring tools of those applications and transfer a physics scene or setup across applications. Later, you'll be able to load these into a standalone Ragdoll desktop and web-based application. Useful for sharing your creations and animations with others, and for debugging too! import json from maya import cmds cmds . ragdollDump () # { # \"scenes\": { # \"0\": { # \"id\": 0, # \"name\": \"rSceneShape\", # \"entities\": { # \"0\": { # \"id\": 0, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rSceneShape\" # } # } # } # }, # \"1\": { # \"id\": 1, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rRigid\" # } # } # } # }, # \"2\": { # \"id\": 2, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rGuideConstraint\" # } # } # } # } # } # } # } # } Turn this string into json, with the native Python json module. import json from maya import cmds dump = cmds . ragdollDump () dump = json . loads ( dump ) # From string to dictionary # The format is internal and yet to be documented, stay tuned scene = dump [ \"scenes\" ][ \"0\" ] rigid = scene [ \"entities\" ][ \"1\" ] name = rigid [ \"components\" ][ \"NameComponent\" ][ \"members\" ][ \"value\" ] print ( name ) # rRigid Expect the output to grow throughout later releases as more internals get serialised to JSON.","title":"2021.03.01"},{"location":"releases/2021.03.01/#auto-initial-state","text":"Have you ever used the Set Initial State button? It's useful, isn't it? It's what enables you to turn something dynamic but then change your mind about where it should start simulating. With this release, that process is automatic! It's more or less what you expected would happen anyway. I mean, obviously the box should drop from where you left it, rather than where it was originally turned dynamic?","title":"Auto Initial State"},{"location":"releases/2021.03.01/#disable-feature","text":"If you would rather have none of it, or if it gives you trouble, you can switch it off like this. NOTE: Changes take effect on next scene open and newly created rigids.","title":"Disable Feature"},{"location":"releases/2021.03.01/#parallel-only","text":"That's right, automatic initial state will only work in Maya's Parallel Evaluation mode. It may end up getting support for DG later on, the trouble lies in the callback we use to read an edited initial state is not reliable in DG. It's possible we'll find another means of achieving the same goal in the future, although DG really is part of the past. Ragdoll works best under Parallel for other reasons too; primarily performance but also stability and robustness.","title":"Parallel Only"},{"location":"releases/2021.03.01/#constraints-stay-behind","text":"Constraints currently show you the true position of rigid bodies. They stay behind because hierarchy preservation is \"artificial\". It's just for you and Maya. In a later release, I'll make rigids also stay behind, and only have your controls move with hierarchy, so that you get to visualise where rigid bodies really are (even when your controls have locked channels, like translate) whilst at the same time letting you move and see your controls and how they reflect that true position.","title":"Constraints Stay Behind"},{"location":"releases/2021.03.01/#caveat","text":"There's one known \"gotcha\" with the automated initial state. Namely, the initial state is \"recorded\" whenever you transition from the start time to the next frame. Evaluation on the next frame will automatically read whatever was evaluated previously, and store that as the initial state. However! It is possible to trigger evaluation without actually changing time. Maya loves doing that. You can do it by either scrubbing the timeline, or holding K and dragging (effectively scrubbing) the viewport. As you scrub, even if time isn't actually changing, Maya will go ahead and re-evaluated the time. When that happens, it won't actually record a new initial state, but instead restore the original value. Something to be aware of.","title":"Caveat"},{"location":"releases/2021.03.01/#journey","text":"For the technically inclined, here you can witness last month's struggle first hand and all the kinks uncovered in Maya's API and evaluation graph.","title":"Journey"},{"location":"releases/2021.03.01/#hierarchy-preservation","text":"Like in the real world, physics happens in worldspace. There are no \"children\" and no \"parents\". As a result, as soon as you turn any of your controls dynamic, they start acting that way. But we don't want that. With this release, you'll now get realism along with that familiar feeling of having children and being a parent! Before After","title":"Hierarchy Preservation"},{"location":"releases/2021.03.01/#caveat_1","text":"There is one known case to be aware of when it comes to children. Passive Rigids Hierarchy is currently preserved only if a rigid is active . The reason being.. well, I'll just show you. In this case, the passive rigid bodies are driven by an external transform, those blue \"controls\". Hierarchy is coming from the blue rigids, so we wouldn't want the passive rigids to mess with that. But now when we move the rigids themselves (gray, in this example) we aren't getting our hierarchy preservation.. :( At the other extreme, if we do account for hierarchy then the problem pops up at the other end instead. I trust experience and feedback will light the way here for a more intuitive experience working with external controls.","title":"Caveat"},{"location":"releases/2021.03.01/#worldspace-constraints","text":"If you thought automatic initial state was enough, think again! If your controls have animation already applied, Ragdoll will now translate it into physics in world- and local-space.","title":"Worldspace Constraints"},{"location":"releases/2021.03.01/#default-behavior","text":"Local animation, like a rotated arm, are imbued with a \"local constraint\" to preserve the relative angle between it and its parent. World animation, like in this case where there is no parent, get imbued with a \"world constraint\".","title":"Default Behavior"},{"location":"releases/2021.03.01/#world-only","text":"Here's what you get when constraining the child to its worldspace pose. Notice how it assumes the angle you give it regardless of whatever the parent is doing.","title":"World Only"},{"location":"releases/2021.03.01/#local-only","text":"Conversely, with just the local constraint, it'll assume the relative angle and respects its parent.","title":"Local Only"},{"location":"releases/2021.03.01/#world-local","text":"Things get interesting when you combine the two!","title":"World + Local"},{"location":"releases/2021.03.01/#world-world-local","text":"..or combine the three! Here's the lower arm trying to adhere to both its worldspace and local orientation. Notice the constraint coming out of alignment at the root; the constraints are of equal strength per default so it'll end up averaging the desired poses. There's one more thing happening here that I'll touch on in an upcoming release, which is the concept of world space forces. Notice how the joint chain follows animation","title":"World + World + Local"},{"location":"releases/2021.03.01/#dg-viewport-bug","text":"If you've ever had the viewport \"remember\" old frames as you scrub the timeline, this fix is for you.","title":"DG Viewport Bug"},{"location":"releases/2021.03.01/#unload-plug-in","text":"In the previous release, licencing was implemented as a Python binding. The trouble with compiled Python bindings in Maya is that they cannot be unloaded. As a result, Ragdoll could not be unloaded. Licencing is now implemented as a native Maya command, accessible as ragdollLicence from MEL and cmds.ragdollLicence() from Python. See ragdollLicence below","title":"Unload Plug-in"},{"location":"releases/2021.03.01/#new-commands","text":"Three new commands was added in this release, they are primarily intended for TDs and technically minded folk. cmds.ragdollLicence() cmds.ragdollPeek() cmds.ragdollDump()","title":"New Commands"},{"location":"releases/2021.03.01/#cmdsragdolllicence","text":"Synopsis : ragdollLicence [ flags ] Flags : - q - query - a - activate String - d - deactivate - h - help - i - init - ia - isActivated - ig - isGenuine - it - isTrial - iv - isVerified - md - magicDays - r - reverify - s - serial - td - trialDays You still typically interact with ragdoll.licence , as documented here . But under the hood, this is now the native Maya command being called. from maya import cmds cmds . ragdollLicence ( serial = True , query = True ) # Your-Serial-Number-Here","title":"cmds.ragdollLicence"},{"location":"releases/2021.03.01/#cmdsragdollpeek","text":"Synopsis : ragdollPeek [ flags ] Flags : - e - entity UnsignedInt - h - help - ps - physicsStatistics - ss - sceneStatistics Gain insight into what Maya sees in Ragdoll. cmds . ragdollPeek ( sceneStatistics = True ) # Ragdoll Peek Scene ____________ ___________________________ _______________ | Id | Scene | Name | |------------|---------------------------|---------------| | 71 | rSceneShape | rSceneShape | | 70 | rSceneShape | rRigid18 | | 69 | rSceneShape | rRigid17 | | 67 | rSceneShape | rRigid | | 65 | rSceneShape | rRigid7 | | 63 | rSceneShape | rRigid8 | | 61 | rSceneShape | rRigid14 | | 59 | rSceneShape | rRigid15 | | 57 | rSceneShape | rRigid16 | | 55 | rSceneShape | rRigid11 | | 53 | rSceneShape | rRigid12 | | 51 | rSceneShape | rRigid13 | | 49 | rSceneShape | rRigid9 | | 46 | rSceneShape | rRigid10 | | 44 | rSceneShape | rRigid4 | | 42 | rSceneShape | rRigid5 | | 40 | rSceneShape | rRigid6 | | 38 | rSceneShape | rRigid1 | | 36 | rSceneShape | rRigid2 | | 34 | rSceneShape | rRigid3 | | 15 | rSceneShape | rRigid27 | | 14 | rSceneShape | rRigid28 | | 13 | rSceneShape | rRigid29 | | 12 | rSceneShape | rRigid30 | | 11 | rSceneShape | rRigid31 | | 10 | rSceneShape | rRigid32 | | 9 | rSceneShape | rRigid33 | | 8 | rSceneShape | rRigid34 | | 7 | rSceneShape | rRigid19 | | 6 | rSceneShape | rRigid20 | | 5 | rSceneShape | rRigid21 | | 4 | rSceneShape | rRigid22 | | 3 | rSceneShape | rRigid23 | | 1048576 | rSceneShape | rRigid24 | | 1048578 | rSceneShape | rRigid25 | | 1048577 | rSceneShape | rRigid26 | | ____________ | ___________________________ | _______________ | cmds . ragdollPeek ( physicsStatistics = True ) # Ragdoll Peek Solver - Number of scenes : 1 - Number of shapes : 36 - Number of materials : 36 - Number of convex meshes : 0 - scene [ 71 ] - Number of dynamic actors : 35 - Number of static actors : 1 - Number of constraints : 18 #","title":"cmds.ragdollPeek"},{"location":"releases/2021.03.01/#cmdsragdolldump","text":"Synopsis : ragdollDump - h - help This is more of a teaser of what's to come, but let me tell you about it for completeness of these release notes. ragdollDumps is the start of an integration effort of Ragdoll into any and all external software, like Unreal and Blender. Anything able to parse JSON. Including web-applications. What if you could rig and/or animate in Maya, but then export the physics setup into e.g. Unreal? I'm not talking about baking your animation and playing it back somewhere else. But of exporting the internal physics objects from Ragdoll, translating them to whatever the third-party software uses for physics, and re-using it there! With that, you could bypass all of the horrible authoring tools of those applications and transfer a physics scene or setup across applications. Later, you'll be able to load these into a standalone Ragdoll desktop and web-based application. Useful for sharing your creations and animations with others, and for debugging too! import json from maya import cmds cmds . ragdollDump () # { # \"scenes\": { # \"0\": { # \"id\": 0, # \"name\": \"rSceneShape\", # \"entities\": { # \"0\": { # \"id\": 0, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rSceneShape\" # } # } # } # }, # \"1\": { # \"id\": 1, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rRigid\" # } # } # } # }, # \"2\": { # \"id\": 2, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rGuideConstraint\" # } # } # } # } # } # } # } # } Turn this string into json, with the native Python json module. import json from maya import cmds dump = cmds . ragdollDump () dump = json . loads ( dump ) # From string to dictionary # The format is internal and yet to be documented, stay tuned scene = dump [ \"scenes\" ][ \"0\" ] rigid = scene [ \"entities\" ][ \"1\" ] name = rigid [ \"components\" ][ \"NameComponent\" ][ \"members\" ][ \"value\" ] print ( name ) # rRigid Expect the output to grow throughout later releases as more internals get serialised to JSON.","title":"cmds.ragdollDump"},{"location":"releases/2021.03.04/","text":"Small fixes and tweaks, with one pretty cool new feature - the ability to animate the transition between active and passive mode for any rigid! ADDED Animated Transition Between Passive and Active It's now possible! ADDED More Scene Visualisation You can now visualise the internal rigid bodies at the scene level FIXED More Robust Passive Rigids The start frame now does a better job representing passive rigids FIXED Better Scaled Shape Rendering Shading on scaled shapes now render correctly FIXED Consistent X-axis for Sphere Radius Rather than the average of X and Y Transition Between Passive and Active Active rigid bodies can now be made passive interactively, and continue to be animated as passive, and then - here's the cool part! - once they transition from passive to active, they inherit the animated velocity you gave it! Pay special attention to the fact that we can key the simulated values, such that we can continue animating from exactly where they left off. Making for a clean transition both to and from physics! More Scene Visualisation The rdScene node has been able to draw velocities, trajectories and constraints to help you track down problems or gain better insight into the inner workings of the solver. Now it can also draw the current position and orientation of rigids, regardless of where your animation controls are. This can be especially helpful if your controls have locked channels, such as translate, as they would be unable to show you the translation of the physical version of the control. Here's how it works. See how the box as-seen from the scene falls down, whereas the original box doesn't? Because the translate channels were locked, they weren't able to fully represent the simulation. Here's a more practical example of a tail. Notice that because the translate channels of the tail are locked, they remain positioned according to the rig. And the rig has some clever mechanics going on to keep the tail attached to the body even when the hip control moves away. Here's a close-up of that mechanic. The solver shows you what is actually going on physically and can help track down controls that misbehave. Better Scaled Shape Rendering Small, but important. When you scale things, rendering needs to keep up and descale the normals of the geometry.","title":"2021.03.04"},{"location":"releases/2021.03.04/#transition-between-passive-and-active","text":"Active rigid bodies can now be made passive interactively, and continue to be animated as passive, and then - here's the cool part! - once they transition from passive to active, they inherit the animated velocity you gave it! Pay special attention to the fact that we can key the simulated values, such that we can continue animating from exactly where they left off. Making for a clean transition both to and from physics!","title":"Transition Between Passive and Active"},{"location":"releases/2021.03.04/#more-scene-visualisation","text":"The rdScene node has been able to draw velocities, trajectories and constraints to help you track down problems or gain better insight into the inner workings of the solver. Now it can also draw the current position and orientation of rigids, regardless of where your animation controls are. This can be especially helpful if your controls have locked channels, such as translate, as they would be unable to show you the translation of the physical version of the control. Here's how it works. See how the box as-seen from the scene falls down, whereas the original box doesn't? Because the translate channels were locked, they weren't able to fully represent the simulation. Here's a more practical example of a tail. Notice that because the translate channels of the tail are locked, they remain positioned according to the rig. And the rig has some clever mechanics going on to keep the tail attached to the body even when the hip control moves away. Here's a close-up of that mechanic. The solver shows you what is actually going on physically and can help track down controls that misbehave.","title":"More Scene Visualisation"},{"location":"releases/2021.03.04/#better-scaled-shape-rendering","text":"Small, but important. When you scale things, rendering needs to keep up and descale the normals of the geometry.","title":"Better Scaled Shape Rendering"},{"location":"releases/2021.03.11/","text":"Highlight for this release is Local Space Simulation ! ADDED Ragdog Tutorial Learn how to setup a \"ragdog\" from scratch ADDED Big Fish Showcase of the benefit of automated overlapping animation for a fish ADDED Local Space Simulation Robust simulated hierarchy whilst animating FIXED Rotate Order Warning More safeguards against unsupported aspects of Ragdoll FIXED Animated Rigid Attributes Minor bugfix FIXED Pre-Start Frame Pose is now reset prior to hitting the solver start frame FIXED Explosion on Initial State More robust detection of when to actually update the initial state Sunny Side Up Just a wolf, for breakfast. Waterproof Fire Fox If you squint, it almost looks like he's underwater! Collision Volumes The automatically-generated colliders you get when turning animation NURBS controls dynamic. Ragdog Tutorial That's no typo, this is a Ragdoll-dog! :D Learn about how to achieve the above simulation in this 2-part series on using Dynamic Control. Fire Wolf Rig Big Fish Spotted an animation on LinkedIn the other day by Radovan Zivkovic, and wanted to see whether it would work with Ragdoll. Here's about 15 minutes of work from launch of Maya to final playblast. Reference Sea Beast Maya Rig Local Space Simulation TLDR; This will keep simulation of children intact whilst manipulating parents. Up until this release, simulation has taken place in worldspace. The last few releases has tried translating worldspace into localspace to try and mimic that familiar feeling of moving the parent and having children follow. This release moves simulation altogether into local space which means a seamless integration with he parent/child hierarchy that your animation controls are normally in! Before Pay special attention to how you can edit the master control mid-way through a simulation, but then have that change completely ignored as you return to frame 1. After Now, with simulation resting in the local space, it behaves as you would expect. Rotate Order Warning A while back , support was implemented for a custom rotateOrder , such as ZYX or YXZ . As it turns out, this support was rather incomplete. Solving for a custom rotate order is much more involved than I'd hoped it would be, so for the time being you are advised not to use them. If you do, you may run into issues such as this. Animated Rigid Attributes The previous release broke your ability to animate anything on a rigid, e.g. rdRigid.linearDamping . That's been all patched up! Pre-Start Frame A bug in a prior version caused frames ahead of the start frame to not reset correctly, unless you explicitly visited the start frame. E.g. skipping from frame 100 directly to 1 rather than from 2 to 1 wouldn't look right. Coupled with the next auto-initial-state feature, this could break a pose. This has now been patched up! Explosion on Initial State Ragdoll could mistakenly treat a broken simulated first frame as the new and correct initial state. Detecting that stuff is hard! Now it's doing a better job, but keep an eye out for when your start pose breaks, that should never happen. Also don't forget that this fancy new shiny feature can be disabled under Ragdoll -> System -> Ragdoll Preferences. Shear The enemy of any animation, shear is scale's ugly brother. Ragdoll now accounts for shear, even though you are strongly advised never to introduce it willingly.","title":"2021.03.11"},{"location":"releases/2021.03.11/#ragdog-tutorial","text":"That's no typo, this is a Ragdoll-dog! :D Learn about how to achieve the above simulation in this 2-part series on using Dynamic Control. Fire Wolf Rig","title":"Ragdog Tutorial"},{"location":"releases/2021.03.11/#big-fish","text":"Spotted an animation on LinkedIn the other day by Radovan Zivkovic, and wanted to see whether it would work with Ragdoll. Here's about 15 minutes of work from launch of Maya to final playblast. Reference Sea Beast Maya Rig","title":"Big Fish"},{"location":"releases/2021.03.11/#local-space-simulation","text":"TLDR; This will keep simulation of children intact whilst manipulating parents. Up until this release, simulation has taken place in worldspace. The last few releases has tried translating worldspace into localspace to try and mimic that familiar feeling of moving the parent and having children follow. This release moves simulation altogether into local space which means a seamless integration with he parent/child hierarchy that your animation controls are normally in!","title":"Local Space Simulation"},{"location":"releases/2021.03.11/#before","text":"Pay special attention to how you can edit the master control mid-way through a simulation, but then have that change completely ignored as you return to frame 1.","title":"Before"},{"location":"releases/2021.03.11/#after","text":"Now, with simulation resting in the local space, it behaves as you would expect.","title":"After"},{"location":"releases/2021.03.11/#rotate-order-warning","text":"A while back , support was implemented for a custom rotateOrder , such as ZYX or YXZ . As it turns out, this support was rather incomplete. Solving for a custom rotate order is much more involved than I'd hoped it would be, so for the time being you are advised not to use them. If you do, you may run into issues such as this.","title":"Rotate Order Warning"},{"location":"releases/2021.03.11/#animated-rigid-attributes","text":"The previous release broke your ability to animate anything on a rigid, e.g. rdRigid.linearDamping . That's been all patched up!","title":"Animated Rigid Attributes"},{"location":"releases/2021.03.11/#pre-start-frame","text":"A bug in a prior version caused frames ahead of the start frame to not reset correctly, unless you explicitly visited the start frame. E.g. skipping from frame 100 directly to 1 rather than from 2 to 1 wouldn't look right. Coupled with the next auto-initial-state feature, this could break a pose. This has now been patched up!","title":"Pre-Start Frame"},{"location":"releases/2021.03.11/#explosion-on-initial-state","text":"Ragdoll could mistakenly treat a broken simulated first frame as the new and correct initial state. Detecting that stuff is hard! Now it's doing a better job, but keep an eye out for when your start pose breaks, that should never happen. Also don't forget that this fancy new shiny feature can be disabled under Ragdoll -> System -> Ragdoll Preferences.","title":"Explosion on Initial State"},{"location":"releases/2021.03.11/#shear","text":"The enemy of any animation, shear is scale's ugly brother. Ragdoll now accounts for shear, even though you are strongly advised never to introduce it willingly.","title":"Shear"},{"location":"releases/2021.03.23/","text":"Highlight for this release is JSON Export, this one's for you game developers out there! ADDED JSON Export Run your ragdolls in Unreal, Unity or your own custom game engine ADDED Active Chain Next generation \"Dynamic Control\" with \"chain\" ADDED Dynamic Constraint Attributes Stay focused on attributes that matter ADDED What'Z-Up? Is your up axis-Z? Ragdoll is now down with that. CHANGED Simplified Menu Less noisy, more focused menu CHANGED Dynamic Install Tighter integration into Maya's native Plug-in Manager CHANGED Greater Guide Strength Have simulation follow animation even closelier FIXED Less Crashes Kids, say no to crashes FIXED Custom Rotate Order Now works as expected FIXED Bad Initial State on Load Loading saved physics now works as expected Important! This version won't self-install like the past releases, see Dynamic Install on how you need to load the plug-in via Maya's Plug-in Manager from now on. Ragcar It's a ragcar allright. You can tell by how bouncy it is! Knocking things around No obstacle is too tall for ragcar. A look underneath The parts are all there, it's how it would work in real life if you put an engine in it. :D Vehicle model from Mecabricks . JSON Export In 2021.03.01 we introduced cmds.ragdollDump to get a copy of all rigids in the form of a JSON dictionary. This release includes all initial state for the simulation, such that you can reproduce the results you see in Maya in a game engine, like Unreal, Unity, CryEngine or your own custom game engine. Or why not Houdini, Blender or 3dsMax? This enables you to use Maya as an authoring platform for physics anywhere. from maya import cmds dump = cmds . ragdollDump () # Convert big string to structured dictionary import json dump = json . loads ( dump ) for entity , data in dump . items (): components = data [ \"components\" ] name = components [ \"NameComponents\" ][ \"members\" ][ \"path\" ] print ( name ) # |root|pelvis|rRigid1 # |root|pelvis|spine|rRigid2 # |root|pelvis|spine2|rRigid3 # ... Here's an example of what to expect from the output. output_example.json { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } } See the new Serialisation documentation for an overview, examples and data reference. https://learn.ragdolldynamics.com/serialisation Dynamic Install Previous releases shipped with a userSetup.py that triggered on launch of Maya. This made it easy to get setup, but made it challenging to uninstall without physically removing files off of the file system (hint: ~/Documents/maya/modules/Ragdoll.mod ). This release associates install with plug-in load. Install Uninstall Active Chain Dynamic Control has been renamed Active Chain . Turns out, what Dynamic Control was really all about was a generic chain that can also be turned into hierarchies of chains - or \"branches\" - to form a tree. Even a literal one! Dynamic Constraint Attributes Now whatever attributes are relevant show up in the Channel Box, and stay relevant as you make changes. Similar to how the rdRigid.shapeType attribute updates the shapeExtents and shapeOffset attributes! What'Z-up? Ragdoll now understands when the up-axis is Z rather than the default Y. Simplified Menu Items have been re-arranged and grouped together to be easier to find and less cluttered. Greater Guide Strength The solver Iterations determines how high your Guide Strength attribute can go. Per default, Iterations was set to 1 which enabled strengths between 0-5 or so until their effect dimished. This release increases this default value to 4 for ranges between 0-100 , which means \"incredibly high!\". The change comes at a minor performance impact - estimated between 1-5% - so if you find the need to optimise, lower this value back to 2 or 1. Hint Bear in mind that the number of iterations are spread across all rigid in your scene. Meaning twice the number of rigids would half the amount of iterations dedicated to each one. Before After Crash on Cleanup In rare cases, Ragdoll could crash Maya due to accessing memory it had no business accessing. Those have now been patched up and refactored for a more stable, crash-free experience! Bad Initial State on Load In rare cases, opening a scene could lead to some controls being badly positioned. This could happen if the control you made dynamic was parented to a group with no values. That made the parent and local matrices cancel out, producing an identity matrix. Maya doesn't normally save attributes that are equal to their default values, and this includes matrices whose defaults are the identity matrix. This has now been fixed. Rotate Order Improvement In previous releases, any rotation order other than XYZ (the default) would make your rotations all whack. Ragdoll didn't know how to translate physics into any order other than XYZ, so it would put them in the wrong place. In the last release, I added a warning for that and in this release I've lifted that warning somewhat. Most rotation orders works well, but I have spotted rare instances of one axis flipping. Here's the problem. See how arms and torso flips? It tends to happen around the 90 and 180 degree values, values below that normally look fine. This will be fixed in a future release, one way or another!","title":"2021.03.23"},{"location":"releases/2021.03.23/#json-export","text":"In 2021.03.01 we introduced cmds.ragdollDump to get a copy of all rigids in the form of a JSON dictionary. This release includes all initial state for the simulation, such that you can reproduce the results you see in Maya in a game engine, like Unreal, Unity, CryEngine or your own custom game engine. Or why not Houdini, Blender or 3dsMax? This enables you to use Maya as an authoring platform for physics anywhere. from maya import cmds dump = cmds . ragdollDump () # Convert big string to structured dictionary import json dump = json . loads ( dump ) for entity , data in dump . items (): components = data [ \"components\" ] name = components [ \"NameComponents\" ][ \"members\" ][ \"path\" ] print ( name ) # |root|pelvis|rRigid1 # |root|pelvis|spine|rRigid2 # |root|pelvis|spine2|rRigid3 # ... Here's an example of what to expect from the output. output_example.json { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } } See the new Serialisation documentation for an overview, examples and data reference. https://learn.ragdolldynamics.com/serialisation","title":"JSON Export"},{"location":"releases/2021.03.23/#dynamic-install","text":"Previous releases shipped with a userSetup.py that triggered on launch of Maya. This made it easy to get setup, but made it challenging to uninstall without physically removing files off of the file system (hint: ~/Documents/maya/modules/Ragdoll.mod ). This release associates install with plug-in load. Install Uninstall","title":"Dynamic Install"},{"location":"releases/2021.03.23/#active-chain","text":"Dynamic Control has been renamed Active Chain . Turns out, what Dynamic Control was really all about was a generic chain that can also be turned into hierarchies of chains - or \"branches\" - to form a tree. Even a literal one!","title":"Active Chain"},{"location":"releases/2021.03.23/#dynamic-constraint-attributes","text":"Now whatever attributes are relevant show up in the Channel Box, and stay relevant as you make changes. Similar to how the rdRigid.shapeType attribute updates the shapeExtents and shapeOffset attributes!","title":"Dynamic Constraint Attributes"},{"location":"releases/2021.03.23/#whatz-up","text":"Ragdoll now understands when the up-axis is Z rather than the default Y.","title":"What'Z-up?"},{"location":"releases/2021.03.23/#simplified-menu","text":"Items have been re-arranged and grouped together to be easier to find and less cluttered.","title":"Simplified Menu"},{"location":"releases/2021.03.23/#greater-guide-strength","text":"The solver Iterations determines how high your Guide Strength attribute can go. Per default, Iterations was set to 1 which enabled strengths between 0-5 or so until their effect dimished. This release increases this default value to 4 for ranges between 0-100 , which means \"incredibly high!\". The change comes at a minor performance impact - estimated between 1-5% - so if you find the need to optimise, lower this value back to 2 or 1. Hint Bear in mind that the number of iterations are spread across all rigid in your scene. Meaning twice the number of rigids would half the amount of iterations dedicated to each one.","title":"Greater Guide Strength"},{"location":"releases/2021.03.23/#before","text":"","title":"Before"},{"location":"releases/2021.03.23/#after","text":"","title":"After"},{"location":"releases/2021.03.23/#crash-on-cleanup","text":"In rare cases, Ragdoll could crash Maya due to accessing memory it had no business accessing. Those have now been patched up and refactored for a more stable, crash-free experience!","title":"Crash on Cleanup"},{"location":"releases/2021.03.23/#bad-initial-state-on-load","text":"In rare cases, opening a scene could lead to some controls being badly positioned. This could happen if the control you made dynamic was parented to a group with no values. That made the parent and local matrices cancel out, producing an identity matrix. Maya doesn't normally save attributes that are equal to their default values, and this includes matrices whose defaults are the identity matrix. This has now been fixed.","title":"Bad Initial State on Load"},{"location":"releases/2021.03.23/#rotate-order-improvement","text":"In previous releases, any rotation order other than XYZ (the default) would make your rotations all whack. Ragdoll didn't know how to translate physics into any order other than XYZ, so it would put them in the wrong place. In the last release, I added a warning for that and in this release I've lifted that warning somewhat. Most rotation orders works well, but I have spotted rare instances of one axis flipping. Here's the problem. See how arms and torso flips? It tends to happen around the 90 and 180 degree values, values below that normally look fine. This will be fixed in a future release, one way or another!","title":"Rotate Order Improvement"},{"location":"releases/2021.03.25/","text":"Highlight for this release is support for Maya 2022 ! ADDED Support for Maya 2022 It's out, and Ragdoll is game ADDED Ragdoll on GitHub Browse the source, contribute your own feaures and fixes FIXED Backwards Compatibility Last release broke our precious example scenes! FIXED Accurate Gravity The gravity indicator on the scene is now always truthful FIXED Ragdoll Explorer Visually browse the output of cmds.ragdollDump() Support for Maya 2022 Ready when you are, Python 3 and all! Ragdoll on GitHub Ragdoll is a high-performance C++ plug-in with a flexible Python API. The API is what powers all user interfaces and all menu items, including the tools themselves. It's what generates Ragdoll nodes and hooks them up to other nodes, translating your selection into physics. This API is now available on GitHub and will soon open for contributions too! https://github.com/mottosso/ragdoll Backwards Compatibility What does breaking backwards compatibility of a dynamics solver look like? Original Last Release He's the same person! Only the circumstances have changed. :D This has now been fixed, and all previous examples now open and run as expected! Still pretty cool though I thought, that even though it's broken it still gives you an interesting result. Look at how he initially falls over, it looks like he's attempting to hold onto the seat for balance, and also takes a step back before landing on his butt. :D Accurate Gravity The indicator used to face in the Y-axis of wherever the node was facing. That wasn't true. It's now accurate no matter how you spin it around, including a potential Z-up axis! Before After Ragdoll Explorer Added an early version of a visual interface for the cmds.ragdollDump() command, something to inspect the internals of the solver. Mostly intended for game developers but also advanced users and techincal directors. Expect an Outliner-like appearance and use for this explorer, more to come!","title":"2021.03.25"},{"location":"releases/2021.03.25/#support-for-maya-2022","text":"Ready when you are, Python 3 and all!","title":"Support for Maya 2022"},{"location":"releases/2021.03.25/#ragdoll-on-github","text":"Ragdoll is a high-performance C++ plug-in with a flexible Python API. The API is what powers all user interfaces and all menu items, including the tools themselves. It's what generates Ragdoll nodes and hooks them up to other nodes, translating your selection into physics. This API is now available on GitHub and will soon open for contributions too! https://github.com/mottosso/ragdoll","title":"Ragdoll on GitHub"},{"location":"releases/2021.03.25/#backwards-compatibility","text":"What does breaking backwards compatibility of a dynamics solver look like? Original Last Release He's the same person! Only the circumstances have changed. :D This has now been fixed, and all previous examples now open and run as expected! Still pretty cool though I thought, that even though it's broken it still gives you an interesting result. Look at how he initially falls over, it looks like he's attempting to hold onto the seat for balance, and also takes a step back before landing on his butt. :D","title":"Backwards Compatibility"},{"location":"releases/2021.03.25/#accurate-gravity","text":"The indicator used to face in the Y-axis of wherever the node was facing. That wasn't true. It's now accurate no matter how you spin it around, including a potential Z-up axis! Before After","title":"Accurate Gravity"},{"location":"releases/2021.03.25/#ragdoll-explorer","text":"Added an early version of a visual interface for the cmds.ragdollDump() command, something to inspect the internals of the solver. Mostly intended for game developers but also advanced users and techincal directors. Expect an Outliner-like appearance and use for this explorer, more to come!","title":"Ragdoll Explorer"},{"location":"releases/2021.04.11/","text":"Highlight for this release is import of physics from one character to another! ADDED Import Animator-friendly export/import workflow for physics ADDED Edit Shape Edit shapes using normal Maya manipulators ADDED Logging Level Tune how chatty Ragdoll is IMPROVED Ragdoll Stability Rock-solid undo support, go nuts! IMPROVED Maya 2022 Stability Steer clear IMPROVED Explorer Next iteration of the Ragdoll Explorer CHANGED Proxy Attributes A small sacrifice for stability CHANGED Python API Consistency More to come Head's up Game Developers NameComponent was changed, and entity values are now a fully-fledged type. See Backwards Incompatibility for details. Import onto Selected Character Import onto the Ragcar Import limbs of Tiger Import Animators can now setup physics one character, export it, and then import onto another. The usecase is having spent time setting up a perfect ragdoll and then wanting to reuse this setup across multiple scenes, on multiple instances of the same referenced character, or on characters with similar naming scheme and anatomy. It can also be used to import parts of a character or individual objects. Demo Here's an 18 second run-down of the complete workflow, from authoring to import. Features Anything you can apply physics to can be exported. The nodes onto which physics is imported .. \u2714\ufe0f Can have a different namespace \u2714\ufe0f Can have a different naming convention \u2714\ufe0f Can have a different pose \u2714\ufe0f Can have a different scale \u2714\ufe0f Can be animated \u2714\ufe0f Can be referenced \u2714\ufe0f Can be imported in pieces, based on what is currently selected It will remember.. \u2714\ufe0f All edited attributes, like Guide Strength \u2714\ufe0f All edited constraints, like their limits and frames It will not remember.. \u274c The convex hulls \u274c The original root of your chains About those 'Convex Hulls'.. Convex hulls, those triangulated versions of your Maya shapes - the Mesh shape type - are re-generated onto whatever character you import onto. This is probably what you want, and enables you to apply physics onto characters with different geometry from when you originally authored the physics. Although sometimes it's not, which is why this we be augmented in a future release. About the 'Original Root'.. The root in any chain is the first in your selection when creating the chain. If you build a network of chains - a \"tree\" - which is common for any character of more than 1 limb, the exported file will not remember which the original root was. It will figure out new roots procedurally based on their parent/child relationship which may or may not be the same as your original. For importing a full character, this makes no difference. Only for the advanced case of exporting a full character but then wanting to apply only the arm or leg of that character onto another character makes this problematic. This will be addressed in a future release. And that's about it! It doesn't even have to be a \"character\", any combination of Maya nodes you can apply physics to can have their physics exported. Like a (rag)car, or just a (rag)box. User Interface In addition to import everything found in an exported file, there's a UI for more control. The UI resembles native Maya and Ragdoll option dialogs, with two interesting bits. 1. File Browser The top part displays other Ragdoll scene ( .rag ) files in the same directory as the selected file, along with the thumbnail stored during the time of export. The thumbnail currently isn't visible during export, it is captured from the currently active viewport. An Export UI with thumbnail preview (and more!) will be added in a future release. 2. Content Preview This sections shows you the contents of the physics scene, ahead of actually importing it. It will visualise a number of things. Which Maya nodes will be \"physicalised\"? Which nodes present during export are not present in the currently opened scene? What was the original path of a node during export? What is the destination path of the node being imported? Is there a destination node? Is the destination already physicalised? What was the original node icon , e.g. nurbsCurve or mesh ? What is the Shape Type of the exported rigid, e.g Capsule ? Introduction Did you see Snyder's Justice League? In it, they introduce and explain the \"mother box\" and how it is capable of turning the dust of a burnt house back into a house. This Import feature is the Mother Box of Ragdoll. The export format is identical to what game developers use to author physics in Maya and import it into their game engine. It contains all data managed by Ragdoll in full detail. Enough detail to reverse-engineer it back into a Maya scene, which is exactly what's going on here. Example Files mytiger.rag mycharacter.rag ragcar.rag Thumbnail Each export captures the currently active 3d viewport for use as a thumbnail. So, whenever you export, remember to smile and wave! :D Context Sensitive The visualisations will update as you select different nodes and edit the various options in the UI. To illustrate this, let's import onto the same scene we exported. Export Only one character is physicalised and exported. Import Notice that importing is not possible, since the character is already physicalised. Unless we replace the namespace, by selecting another character. Use Selection Import onto selected nodes with Use Selection toggled (it's the default). Search and Replace Every node is stored along with its full path, such as.. |root_grp|spine_grp|spine_ctrl And in most cases can get quite long, with one or more namespaces and tens to hundreds of levels deep in hierarchy. |_:Group|_:Main|_:DeformationSystem|_:Root_M|_:RootPart1_M|_:RootPart2_M|_:Spine1_M|_:Spine1Part1_M|_:Spine1Part2_M|_:Chest_M|_:Scapula_L|_:Shoulder_L|_:ShoulderPart1_L|_:ShoulderPart2_L|_:Elbow_L|_:ElbowPart1_L|_:ElbowPart2_L|_:Wrist_L|_:IndexFinger1_L Here, the namespace is simply _: The Search and Replace boxes of the UI can be used to replace parts of each path, to try and map the original path to whatever path is currently available in the scene. Auto Namespace One challenge with export/import it remapping names from the original scene onto your new scene. Ragdoll solves the typical case of only the namespace being different with \"Auto Namespace\". \"Auto Namespace\" will replace any namespace in the original file with whatever namespace is currently selected. Neat! If there are multiple namespaces, it'll use the last namespace. Let me know how you find that, there's room left to explore here. Most often, you only ever have a single namespace, but Maya does allow you to tie yourself into a knot if you really wanted to. Auto Scene Locate and use the original physics scene from the original file, so as to preserve your multi-scene setups. For example, if your one character has 3 physics scenes - one for the right arm, one for the left and a single one for both legs - then \"Auto Scene\" will preserve these scenes for you. Performance Tip Using more than one scene can improve performance significantly, as Ragdoll will parallelise each invidual scene. The caveat is that rigids in different scenes cannot interact with each other. Ragdoll Clean Here's a quick way you can use this feature to \"clean\" a physics scene. Export Delete All Import The resulting scene will be \"clean\" in that it will have been broken down into its componens and reassembled again, not taking into account anything Ragdoll doesn't know about. (I may just add a menu item for this, called Clean to do this in one go :) Roadmap A few things became apparent as I rounded off this feature Export UI - You'll want control over what that thumbnail looks like, currently it'll take a snapshot but not show you what that snapshot looks like until you look at it from the importer Remember \"root\" of each chain - The importer will recognise what is a Rigid and what is a Chain, but it's having trouble distinguishing the root of each chain. For example, if you made the spine into a chain, followed by the two arms, odds are it'll think the hip leading out to the hand is one chain, and torso to head being another chain, and so on. This isn't an issue when importing a full character, but it'll keep you from being able to import only one of those chains. E.g. just the arm. Import Python API Anything the UI can do can be done via Python, using the new dump.Loader object. from ragdoll import dump loader = dump . Loader () loader . read ( r \"c:\\path\\to\\myRagdoll.rag\" ) # Search and replace these terms from the full node path # E.g. |root_grp|arm_left -> |root_grp|arm_right loader . set_replace (( ( \"_left\" , \"_right\" ), ( \"_ik\" , \"_fk\" ), )) # An automatic method of search-and-replace, that replaces # any namespaces found in the file with this. # E.g. |char1:root_grp -> |char2:root_grp loader . set_namespace ( \"char2:\" ) # Limit imported nodes to those with an absolute path # starting with *any* of these loader . set_roots (( \"|char1:root_grp\" , \"|char2:root_grp\" )) # Deconstruct the provided `.rag` file # (This is what is visualised in the UI) # (The exact layout of this data may change) analysis = loader . analyse () assert isinstance ( analysis , dict ) # Print a brief human-readable summary of the current analysis loader . report () Heads up Consider this a version 0.1 of the API, it will likely change in the future. Ragdoll Stability Implementing import put a lot of strain on Ragdoll. Whereas before, authoring physics was a matter of calling one command at a time, playing around with the result, calling another. Maybe undoing every so often. Import on the other hand calls tens to hundreds of commands at once, undoing them en masse, redoing them en masse. It exposed a ton of flaws in the system that had gone unnoticed in all but the rarest of occasions. Crashes, a ton of them. The worst kind, the kind that doesn't tell you anyhing about why it crashes. The above an example of: Authoring lots of physics in different ways Undoing all of it Redoing all of it With no problem! I'm happy to say these have all been resolved, and the automated test-suite has grown 10x since the last release. Every command is tested, and tested again with undo, and again with redoing an undone redo. It is rock solid, and fast. You can now undo any command as-one, any number of times, redo it any number of times, undo your redo any number of times. Ragdoll will not be the cause of any crashes. Maya 2022 Stability Maya 2022 in its current state has proven incapable of reliably supporting Ragdoll. https://forums.autodesk.com/t5/maya-programming/maya-2022-dagitem-was-nullptr/td-p/10217589 Maya 2022 may crash with Ragdoll That's right. Maya 2022 isn't quite baked yet, and needs a Service Pack. Until then, Ragdoll will run reliably so long as you don't delete anything, or try and open a new scene. In addition to that, the multiplier nodes didn't quite work with Maya 2022, or more specifically with Python 3. from ragdoll import interactive as ri ri.multiply_rigids () # Error: 'filter' object is not subscriptable # Traceback (most recent call last): # File \"<maya console>\", line 2, in <module> # File \"C:\\Users\\marcus\\Documents\\maya\\modules\\Ragdoll\\python\\ragdoll\\interactive.py\", line 2112, in multiply_rigids # root = rigids[0].parent() # TypeError: 'filter' object is not subscriptable # There were also crashes happening on deleting rigid bodies from your scene, these got swept away alongside a number of other fixes to the handling of nodes. So one step forward, one step back. :) Edit Shape A new menu item got added for manipulating shapes with a native Maya transform, as an alternative to fiddling with numbers in the Channel Box. Proxy Attributes In Maya 2018 and 2020, the attributes added to your original animation controls that mirror those of Ragdoll were \"proxy attributes\". That is, they could be edited from either their original attribute, or the one connected to by your control. That's really convenient. Turns out, it is also really unstable. Most of the crashes happening so far, especially on deleting physics or starting a new scene, has come from proxy attributes messing everything up. It should't be surprising, even Maya struggles with them. node = cmds . createNode ( \"transform\" ) shape = cmds . createNode ( \"nurbsCurve\" , parent = node ) cmds . addAttr ( node , ln = \"proxyVisibility\" , proxy = shape + \".visibility\" ) assert cmds . objExists ( node + \".proxyVisibility\" ) assert cmds . getAttr ( node + \".proxyVisibility\" ) == 1 # What should happen to the proxy attribute? :O cmds . delete ( shape ) cmds . getAttr ( node + \".proxyVisibility\" ) # RuntimeError: The value for the attribute could not be retrieved. # The same thing applies with access from the API. It just doesn't know what's going on. If we're lucky - which we have been so far - it'll just fail and tell you about it. Other times it'll fail and take Maya down with it. That's just bad. In Maya 2019, the problem was so severe that proxy attributes were simply not used. With this release, no proxy attributes are used. I hope to reintroduce them at a later date, once I discover is a safe method (read: workaround) to using them. Python API Consistency The good news is, the Python API is maturing. The bad news is, this release introduces backwards incompatible changes. from maya import cmds from ragdoll import api cube , _ = cmds . polyCube () cmds . move ( 0 , 5 , 0 ) cmds . rotate ( 0 , 45 , 45 ) scene = api . createScene () rigid = api . createRigid ( cube ) So far so good. # Before api . socketConstraint ( parent , child , maintain_offset = False ) # After api . socketConstraint ( parent , child , opts = { \"maintainOffset\" : False }) Here's the change. These behavior-like arguments have been moved into an opts={} argument, and is now consistent across any commands that take \"options\". It's to faciliate a large number of options, both from the UI and scripting and enhance compatibility over time; with a dictionary, you can test for availability of arguments at run-time, as opposed to suffer the consequences of not being able to call an update function. I'm still exploring ways of getting more options into commands, without polluting the argument signature, without changing their order when an argument is deprecated, or changing an argument name when jargon inevitably changes. Using a dictionary for options-like arguments enables us to pass arbitrary sized options to functions, they can also be passed to functions that don't necessarily need all contained options, meaning you can establish a single options dictionary up-front and pass that to all relevant functions. It's too soon to tell whether the cons of this approach outweighs the pros. This is one reason for the API still going through changes. The non-optional arguments are those that are never intended to change, like the createRigid(node) argument. Every rigid needs something to make rigid. (Or so you'd think, as you can now also create a rigid from a new empty transform). So, the API has changed and will continue changing for a while longer. Node/Attribute format The Ragdoll scene format is stable and has been for months. It will remain compatible with future versions of Ragdoll, which means anything you build today (or months ago) will continue to work identically. The Python API on the other hand is not yet refined and is still changing. So when you build tools ontop of Ragdoll, keep in mind that nodes, their attributes and their connections are stable , but the means of creating those connections are not. So if you need stability today , look at what nodes and connections are made by the API, and do it yourself. Ragdoll Explorer For developers Explorer has gotten an update, inching its way towards Outliner-like behavior and feel. Eventually maybe even an integration with the Outliner, similar to how USD slots into Maya 2022. That's quite neat! Logging Level You can now tune the way Ragdoll communicates with you. Off means it won't tell you anything, not even warnings Default is what you've gotten used to so far Less only shows you important messages that require you to take action More is the full monty, performance metrics, detailed messages, you name it Programmer Jargon These are animator-friendly jargon for the native logging.INFO and logging.WARNING levels. \"Off\" means logging.CRITICAL since Ragdoll does not emit any critical messages. Developer Updates A few things has been improved for those using Ragdoll as an authoring platform for other software like Unreal and general game engines. New Components The export format has been graced with new components to accommodate for the import feature. As the name suggests, these are stricly related to UI and aren't required for reproducing the physics in another application or engine. They are meant to cover user elements in Maya such that they can be accurately reproduced on re-import back into Maya. New Components RigidUIComponent ConstraintUIComponent LimitUIComponent DriveUIComponent RigidMultiplierUIComponent ConstraintMultiplierUIComponent Here's what the new components may look like in your exported file. { \"type\" : \"RigidUIComponent\" , \"members\" : { \"shaded\" : false , \"airDensity\" : 1.0 , \"shapeIcon\" : \"transform\" , \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 } } }, { \"type\" : \"ConstraintUIComponent\" , \"members\" : { \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 }, \"childIndex\" : 2 } }, \"type\" : \"LimitUIComponent\" , \"members\" : { \"strength\" : 1.0 , \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } }, \"type\" : \"DriveUIComponent\" , \"members\" : { \"strength\" : 0.5 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 } } There's also an added section for \"ui\" related data, most interestingly a base64-encoded QPixmap of a thumbnail . \"ui\" : { \"description\" : \"\" , \"filename\" : \"C:/scenes/demo/advancedskeleton5.rag\" , \"thumbnail\" : \"iVBORw0KGgoAAAAN ... lots more characters ...\" } That can be converted like this. from ragdoll import ui qpixmap = ui . base64_to_pixmap ( data [ \"ui\" ][ \"thumbnail\" ]) Backwards Incompatibility The export format has changed slightly, here's what you need to know. NameComponent.path was changed from the full path + Ragdoll node to just full path. Entity values are now types instead of plain integers Example # Before | root_grp | spine1_ctrl | upperArm_ctrl | rRigid3 # After | root_grp | spine1_ctrl | upperArm_ctrl Some values were entities themselves, but there wasn't any way of knowing unless you explicitly new that JointComponent.parent is in fact an entity. This has now been addressed, and all entities now carry a [\"type\"] signature. # Before { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : true , \"parent\" : 16 \"child\" : 15 } } # After { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : True , \"parent\" : { \"type\" : \"Entity\" , \"value\" : 16 }, \"child\" : { \"type\" : \"Entity\" , \"value\" : 15 } } }","title":"2021.04.11"},{"location":"releases/2021.04.11/#import","text":"Animators can now setup physics one character, export it, and then import onto another. The usecase is having spent time setting up a perfect ragdoll and then wanting to reuse this setup across multiple scenes, on multiple instances of the same referenced character, or on characters with similar naming scheme and anatomy. It can also be used to import parts of a character or individual objects. Demo Here's an 18 second run-down of the complete workflow, from authoring to import.","title":"Import"},{"location":"releases/2021.04.11/#features","text":"Anything you can apply physics to can be exported. The nodes onto which physics is imported .. \u2714\ufe0f Can have a different namespace \u2714\ufe0f Can have a different naming convention \u2714\ufe0f Can have a different pose \u2714\ufe0f Can have a different scale \u2714\ufe0f Can be animated \u2714\ufe0f Can be referenced \u2714\ufe0f Can be imported in pieces, based on what is currently selected It will remember.. \u2714\ufe0f All edited attributes, like Guide Strength \u2714\ufe0f All edited constraints, like their limits and frames It will not remember.. \u274c The convex hulls \u274c The original root of your chains About those 'Convex Hulls'.. Convex hulls, those triangulated versions of your Maya shapes - the Mesh shape type - are re-generated onto whatever character you import onto. This is probably what you want, and enables you to apply physics onto characters with different geometry from when you originally authored the physics. Although sometimes it's not, which is why this we be augmented in a future release. About the 'Original Root'.. The root in any chain is the first in your selection when creating the chain. If you build a network of chains - a \"tree\" - which is common for any character of more than 1 limb, the exported file will not remember which the original root was. It will figure out new roots procedurally based on their parent/child relationship which may or may not be the same as your original. For importing a full character, this makes no difference. Only for the advanced case of exporting a full character but then wanting to apply only the arm or leg of that character onto another character makes this problematic. This will be addressed in a future release. And that's about it! It doesn't even have to be a \"character\", any combination of Maya nodes you can apply physics to can have their physics exported. Like a (rag)car, or just a (rag)box.","title":"Features"},{"location":"releases/2021.04.11/#user-interface","text":"In addition to import everything found in an exported file, there's a UI for more control. The UI resembles native Maya and Ragdoll option dialogs, with two interesting bits.","title":"User Interface"},{"location":"releases/2021.04.11/#1-file-browser","text":"The top part displays other Ragdoll scene ( .rag ) files in the same directory as the selected file, along with the thumbnail stored during the time of export. The thumbnail currently isn't visible during export, it is captured from the currently active viewport. An Export UI with thumbnail preview (and more!) will be added in a future release.","title":"1. File Browser"},{"location":"releases/2021.04.11/#2-content-preview","text":"This sections shows you the contents of the physics scene, ahead of actually importing it. It will visualise a number of things. Which Maya nodes will be \"physicalised\"? Which nodes present during export are not present in the currently opened scene? What was the original path of a node during export? What is the destination path of the node being imported? Is there a destination node? Is the destination already physicalised? What was the original node icon , e.g. nurbsCurve or mesh ? What is the Shape Type of the exported rigid, e.g Capsule ?","title":"2. Content Preview"},{"location":"releases/2021.04.11/#introduction","text":"Did you see Snyder's Justice League? In it, they introduce and explain the \"mother box\" and how it is capable of turning the dust of a burnt house back into a house. This Import feature is the Mother Box of Ragdoll. The export format is identical to what game developers use to author physics in Maya and import it into their game engine. It contains all data managed by Ragdoll in full detail. Enough detail to reverse-engineer it back into a Maya scene, which is exactly what's going on here. Example Files mytiger.rag mycharacter.rag ragcar.rag","title":"Introduction"},{"location":"releases/2021.04.11/#thumbnail","text":"Each export captures the currently active 3d viewport for use as a thumbnail. So, whenever you export, remember to smile and wave! :D","title":"Thumbnail"},{"location":"releases/2021.04.11/#context-sensitive","text":"The visualisations will update as you select different nodes and edit the various options in the UI. To illustrate this, let's import onto the same scene we exported. Export Only one character is physicalised and exported. Import Notice that importing is not possible, since the character is already physicalised. Unless we replace the namespace, by selecting another character.","title":"Context Sensitive"},{"location":"releases/2021.04.11/#use-selection","text":"Import onto selected nodes with Use Selection toggled (it's the default).","title":"Use Selection"},{"location":"releases/2021.04.11/#search-and-replace","text":"Every node is stored along with its full path, such as.. |root_grp|spine_grp|spine_ctrl And in most cases can get quite long, with one or more namespaces and tens to hundreds of levels deep in hierarchy. |_:Group|_:Main|_:DeformationSystem|_:Root_M|_:RootPart1_M|_:RootPart2_M|_:Spine1_M|_:Spine1Part1_M|_:Spine1Part2_M|_:Chest_M|_:Scapula_L|_:Shoulder_L|_:ShoulderPart1_L|_:ShoulderPart2_L|_:Elbow_L|_:ElbowPart1_L|_:ElbowPart2_L|_:Wrist_L|_:IndexFinger1_L Here, the namespace is simply _: The Search and Replace boxes of the UI can be used to replace parts of each path, to try and map the original path to whatever path is currently available in the scene.","title":"Search and Replace"},{"location":"releases/2021.04.11/#auto-namespace","text":"One challenge with export/import it remapping names from the original scene onto your new scene. Ragdoll solves the typical case of only the namespace being different with \"Auto Namespace\". \"Auto Namespace\" will replace any namespace in the original file with whatever namespace is currently selected. Neat! If there are multiple namespaces, it'll use the last namespace. Let me know how you find that, there's room left to explore here. Most often, you only ever have a single namespace, but Maya does allow you to tie yourself into a knot if you really wanted to.","title":"Auto Namespace"},{"location":"releases/2021.04.11/#auto-scene","text":"Locate and use the original physics scene from the original file, so as to preserve your multi-scene setups. For example, if your one character has 3 physics scenes - one for the right arm, one for the left and a single one for both legs - then \"Auto Scene\" will preserve these scenes for you. Performance Tip Using more than one scene can improve performance significantly, as Ragdoll will parallelise each invidual scene. The caveat is that rigids in different scenes cannot interact with each other.","title":"Auto Scene"},{"location":"releases/2021.04.11/#ragdoll-clean","text":"Here's a quick way you can use this feature to \"clean\" a physics scene. Export Delete All Import The resulting scene will be \"clean\" in that it will have been broken down into its componens and reassembled again, not taking into account anything Ragdoll doesn't know about. (I may just add a menu item for this, called Clean to do this in one go :)","title":"Ragdoll Clean"},{"location":"releases/2021.04.11/#roadmap","text":"A few things became apparent as I rounded off this feature Export UI - You'll want control over what that thumbnail looks like, currently it'll take a snapshot but not show you what that snapshot looks like until you look at it from the importer Remember \"root\" of each chain - The importer will recognise what is a Rigid and what is a Chain, but it's having trouble distinguishing the root of each chain. For example, if you made the spine into a chain, followed by the two arms, odds are it'll think the hip leading out to the hand is one chain, and torso to head being another chain, and so on. This isn't an issue when importing a full character, but it'll keep you from being able to import only one of those chains. E.g. just the arm.","title":"Roadmap"},{"location":"releases/2021.04.11/#import-python-api","text":"Anything the UI can do can be done via Python, using the new dump.Loader object. from ragdoll import dump loader = dump . Loader () loader . read ( r \"c:\\path\\to\\myRagdoll.rag\" ) # Search and replace these terms from the full node path # E.g. |root_grp|arm_left -> |root_grp|arm_right loader . set_replace (( ( \"_left\" , \"_right\" ), ( \"_ik\" , \"_fk\" ), )) # An automatic method of search-and-replace, that replaces # any namespaces found in the file with this. # E.g. |char1:root_grp -> |char2:root_grp loader . set_namespace ( \"char2:\" ) # Limit imported nodes to those with an absolute path # starting with *any* of these loader . set_roots (( \"|char1:root_grp\" , \"|char2:root_grp\" )) # Deconstruct the provided `.rag` file # (This is what is visualised in the UI) # (The exact layout of this data may change) analysis = loader . analyse () assert isinstance ( analysis , dict ) # Print a brief human-readable summary of the current analysis loader . report () Heads up Consider this a version 0.1 of the API, it will likely change in the future.","title":"Import Python API"},{"location":"releases/2021.04.11/#ragdoll-stability","text":"Implementing import put a lot of strain on Ragdoll. Whereas before, authoring physics was a matter of calling one command at a time, playing around with the result, calling another. Maybe undoing every so often. Import on the other hand calls tens to hundreds of commands at once, undoing them en masse, redoing them en masse. It exposed a ton of flaws in the system that had gone unnoticed in all but the rarest of occasions. Crashes, a ton of them. The worst kind, the kind that doesn't tell you anyhing about why it crashes. The above an example of: Authoring lots of physics in different ways Undoing all of it Redoing all of it With no problem! I'm happy to say these have all been resolved, and the automated test-suite has grown 10x since the last release. Every command is tested, and tested again with undo, and again with redoing an undone redo. It is rock solid, and fast. You can now undo any command as-one, any number of times, redo it any number of times, undo your redo any number of times. Ragdoll will not be the cause of any crashes.","title":"Ragdoll Stability"},{"location":"releases/2021.04.11/#maya-2022-stability","text":"Maya 2022 in its current state has proven incapable of reliably supporting Ragdoll. https://forums.autodesk.com/t5/maya-programming/maya-2022-dagitem-was-nullptr/td-p/10217589 Maya 2022 may crash with Ragdoll That's right. Maya 2022 isn't quite baked yet, and needs a Service Pack. Until then, Ragdoll will run reliably so long as you don't delete anything, or try and open a new scene. In addition to that, the multiplier nodes didn't quite work with Maya 2022, or more specifically with Python 3. from ragdoll import interactive as ri ri.multiply_rigids () # Error: 'filter' object is not subscriptable # Traceback (most recent call last): # File \"<maya console>\", line 2, in <module> # File \"C:\\Users\\marcus\\Documents\\maya\\modules\\Ragdoll\\python\\ragdoll\\interactive.py\", line 2112, in multiply_rigids # root = rigids[0].parent() # TypeError: 'filter' object is not subscriptable # There were also crashes happening on deleting rigid bodies from your scene, these got swept away alongside a number of other fixes to the handling of nodes. So one step forward, one step back. :)","title":"Maya 2022 Stability"},{"location":"releases/2021.04.11/#edit-shape","text":"A new menu item got added for manipulating shapes with a native Maya transform, as an alternative to fiddling with numbers in the Channel Box.","title":"Edit Shape"},{"location":"releases/2021.04.11/#proxy-attributes","text":"In Maya 2018 and 2020, the attributes added to your original animation controls that mirror those of Ragdoll were \"proxy attributes\". That is, they could be edited from either their original attribute, or the one connected to by your control. That's really convenient. Turns out, it is also really unstable. Most of the crashes happening so far, especially on deleting physics or starting a new scene, has come from proxy attributes messing everything up. It should't be surprising, even Maya struggles with them. node = cmds . createNode ( \"transform\" ) shape = cmds . createNode ( \"nurbsCurve\" , parent = node ) cmds . addAttr ( node , ln = \"proxyVisibility\" , proxy = shape + \".visibility\" ) assert cmds . objExists ( node + \".proxyVisibility\" ) assert cmds . getAttr ( node + \".proxyVisibility\" ) == 1 # What should happen to the proxy attribute? :O cmds . delete ( shape ) cmds . getAttr ( node + \".proxyVisibility\" ) # RuntimeError: The value for the attribute could not be retrieved. # The same thing applies with access from the API. It just doesn't know what's going on. If we're lucky - which we have been so far - it'll just fail and tell you about it. Other times it'll fail and take Maya down with it. That's just bad. In Maya 2019, the problem was so severe that proxy attributes were simply not used. With this release, no proxy attributes are used. I hope to reintroduce them at a later date, once I discover is a safe method (read: workaround) to using them.","title":"Proxy Attributes"},{"location":"releases/2021.04.11/#python-api-consistency","text":"The good news is, the Python API is maturing. The bad news is, this release introduces backwards incompatible changes. from maya import cmds from ragdoll import api cube , _ = cmds . polyCube () cmds . move ( 0 , 5 , 0 ) cmds . rotate ( 0 , 45 , 45 ) scene = api . createScene () rigid = api . createRigid ( cube ) So far so good. # Before api . socketConstraint ( parent , child , maintain_offset = False ) # After api . socketConstraint ( parent , child , opts = { \"maintainOffset\" : False }) Here's the change. These behavior-like arguments have been moved into an opts={} argument, and is now consistent across any commands that take \"options\". It's to faciliate a large number of options, both from the UI and scripting and enhance compatibility over time; with a dictionary, you can test for availability of arguments at run-time, as opposed to suffer the consequences of not being able to call an update function. I'm still exploring ways of getting more options into commands, without polluting the argument signature, without changing their order when an argument is deprecated, or changing an argument name when jargon inevitably changes. Using a dictionary for options-like arguments enables us to pass arbitrary sized options to functions, they can also be passed to functions that don't necessarily need all contained options, meaning you can establish a single options dictionary up-front and pass that to all relevant functions. It's too soon to tell whether the cons of this approach outweighs the pros. This is one reason for the API still going through changes. The non-optional arguments are those that are never intended to change, like the createRigid(node) argument. Every rigid needs something to make rigid. (Or so you'd think, as you can now also create a rigid from a new empty transform). So, the API has changed and will continue changing for a while longer. Node/Attribute format The Ragdoll scene format is stable and has been for months. It will remain compatible with future versions of Ragdoll, which means anything you build today (or months ago) will continue to work identically. The Python API on the other hand is not yet refined and is still changing. So when you build tools ontop of Ragdoll, keep in mind that nodes, their attributes and their connections are stable , but the means of creating those connections are not. So if you need stability today , look at what nodes and connections are made by the API, and do it yourself.","title":"Python API Consistency"},{"location":"releases/2021.04.11/#ragdoll-explorer","text":"For developers Explorer has gotten an update, inching its way towards Outliner-like behavior and feel. Eventually maybe even an integration with the Outliner, similar to how USD slots into Maya 2022. That's quite neat!","title":"Ragdoll Explorer"},{"location":"releases/2021.04.11/#logging-level","text":"You can now tune the way Ragdoll communicates with you. Off means it won't tell you anything, not even warnings Default is what you've gotten used to so far Less only shows you important messages that require you to take action More is the full monty, performance metrics, detailed messages, you name it Programmer Jargon These are animator-friendly jargon for the native logging.INFO and logging.WARNING levels. \"Off\" means logging.CRITICAL since Ragdoll does not emit any critical messages.","title":"Logging Level"},{"location":"releases/2021.04.11/#developer-updates","text":"A few things has been improved for those using Ragdoll as an authoring platform for other software like Unreal and general game engines.","title":"Developer Updates"},{"location":"releases/2021.04.11/#new-components","text":"The export format has been graced with new components to accommodate for the import feature. As the name suggests, these are stricly related to UI and aren't required for reproducing the physics in another application or engine. They are meant to cover user elements in Maya such that they can be accurately reproduced on re-import back into Maya. New Components RigidUIComponent ConstraintUIComponent LimitUIComponent DriveUIComponent RigidMultiplierUIComponent ConstraintMultiplierUIComponent Here's what the new components may look like in your exported file. { \"type\" : \"RigidUIComponent\" , \"members\" : { \"shaded\" : false , \"airDensity\" : 1.0 , \"shapeIcon\" : \"transform\" , \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 } } }, { \"type\" : \"ConstraintUIComponent\" , \"members\" : { \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 }, \"childIndex\" : 2 } }, \"type\" : \"LimitUIComponent\" , \"members\" : { \"strength\" : 1.0 , \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } }, \"type\" : \"DriveUIComponent\" , \"members\" : { \"strength\" : 0.5 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 } } There's also an added section for \"ui\" related data, most interestingly a base64-encoded QPixmap of a thumbnail . \"ui\" : { \"description\" : \"\" , \"filename\" : \"C:/scenes/demo/advancedskeleton5.rag\" , \"thumbnail\" : \"iVBORw0KGgoAAAAN ... lots more characters ...\" } That can be converted like this. from ragdoll import ui qpixmap = ui . base64_to_pixmap ( data [ \"ui\" ][ \"thumbnail\" ])","title":"New Components"},{"location":"releases/2021.04.11/#backwards-incompatibility","text":"The export format has changed slightly, here's what you need to know. NameComponent.path was changed from the full path + Ragdoll node to just full path. Entity values are now types instead of plain integers Example # Before | root_grp | spine1_ctrl | upperArm_ctrl | rRigid3 # After | root_grp | spine1_ctrl | upperArm_ctrl Some values were entities themselves, but there wasn't any way of knowing unless you explicitly new that JointComponent.parent is in fact an entity. This has now been addressed, and all entities now carry a [\"type\"] signature. # Before { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : true , \"parent\" : 16 \"child\" : 15 } } # After { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : True , \"parent\" : { \"type\" : \"Entity\" , \"value\" : 16 }, \"child\" : { \"type\" : \"Entity\" , \"value\" : 15 } } }","title":"Backwards Incompatibility"},{"location":"releases/2021.04.23/","text":"Highlight for this release is No Limits and Greater Performance ! ADDED No Limits No rig is now too complex for Ragdoll! ADDED 30% Greater Performance You're welcome! ADDED Offline Activation For the poor souls without an internet connection ADDED Auto-cleanup Shape and Constraint editors now vanish alongside the rest of physics ADDED Return To Start More intuitive creation of new rigid bodies ADDED Cycle Protection Avoid running into cycle warnings with this early-warning mechanism ADDED Hard Pin Tell a rigid body exactly where to be in worldspace, no exceptions ADDED Soft Pin Guide a rigid body towards a worldspace position and orientation ADDED Animation Constraint Convert translate/rotate to a guide constraint ADDED Character Multiplier Characters now get a default multiplier IMPROVED Simulated Attribute Active Chains and Trees are now more animator-friendly FIXED Import Bugs Ironed out a few quirks with the new import feature FIXED User Attributes Names and default values of user attributes wasn't quite up to the task FIXED Looped Playback Bug This could under rare circumstances look off FIXED Qt Bug In rare cases this could pollute your Script Editor whenever selection changed FIXED Low-DPI Cosmetics More eye-candy for those still using a low resolution display FIXED Z-up Worldspace Guides Worldspace guides now play nice with a re-oriented world FIXED Tree Multipliers Complex active chains weren't multiplied correctly 10 Second Ragdoll Here's the absolute quickest way to turn a fresh mesh into a full ragdoll. And here's a more practical example of using this feature to clean up a bad mocap clip. It'll endure changes to the environment too, with little to no modification of the physics settings or the original animation. No More Limits! That's right! It used to be the case that if your character had a non-default Rotate Order , or a tweaked Rotate Pivot or maybe made use of the handy Rotate Axis or the joints you were using had a non-zero Joint Orient , then you were out of luck ! Ragdoll just couldn't handle those. It would aggressively reset those to their defaults, or flat-out refuse to work. This release adds support for these missing members, which just so happens to be the very last major limitations of Ragdoll when used with your everyday character rigs! \u2714\ufe0f Rotate Pivot \u2714\ufe0f Rotate Axis \u2714\ufe0f Rotate Order \u2714\ufe0f Joint Orient From now on, if it doesn't work with your rig, that's a bug (let me know!). Rotate Pivot This release introduces support for both the .rotatePivot and rotatePivotTranslate attributes, letting you do things like.. I've also added an option to actually use the rotate pivot (for greater good?) such that you can do this. Rotate Axis The advanced rigger will know of his lesser-known feature of Maya transform nodes, with the ability to modify the axis around which the Rotate XYZ channels operate. Rotate Order Finally cracked this one, it has been far too long and is a far-too used feature of Maya transform nodes to not support. But it's done! You should now be able to pick any rotate order and experience no flipping or issue of any kind. Don't even bother getting in touch if you do, because I will not believe you. xD This tiger (courtesy of www.cgspectrum.com ) has a different rotate order on nearly every control. Before After Hold on a second! That final flip of the spine is coming from the rig itself, the joints driven by the controllers we're simulating. Ragdoll isn't the only one having issues with flipping. :) Joint Orient When simulating joints, it can be important to retain the original jointOrient values. Especially if those joints are later used for IK or if you want or need to zero out those rotate values. But it is perhaps most important for an already-animated skeleton, like what you get out of motion capture. Some motion capture libraries, like Rokoku, do a good job not having any jointOrient in which case they would already work well with Ragdoll. But for animated skeletons with a non-default jointOrient you would have been out of luck.. Until now! 30% Greater Performance Ragdoll used to be really really fast, and is now really really really fast! Rendering is one of two areas where Ragdoll spends time computing (the other being simulating), and rendering performance has been improved by 400%, making Ragdoll 30% faster overall! Here you can see the improvement up-close, notice how much time was spent simulating versus rendering each frame in the previous version; almost half the time was spent just rendering! And if you're wondering... Ok, but what features did you remove ? On the contrary! Rendering now includes .. \u2714\ufe0f Specular \u2714\ufe0f Shadows \u2714\ufe0f Ambient Occlusion \u2714\ufe0f Depth of Field \u2714\ufe0f With more to come! Even More Performance? You'll notice that the rendering square isn't entirely gone. If 4 ms just to render is too much to ask, you'll get even more of a performance jolt by simply hiding anything Ragdoll related, in particular the rdRigid and rdConstraint nodes. The simulated result is independent of whether or not it is visible in the viewport. If you are a rigger , this can be handy for your animators once you've finished setting things up, as they may not benefit from seeing these things anyway and could use all of the performance you can give. Simulated Attribute Whenever you make a new chain, an attribute is created on the root of that chain to control whether or not the chain should be Simulated or animated. With this release, Simulated = Off means: \u2714\ufe0f Disabled Solver - meaning no more warnings on skipping frames! \u2714\ufe0f Hidden Drawing of Physics - For a less distracting animation experience Return To Start Additions to the physics solver can only happen on the start frame, and if you in previous version created anything on any other frame Ragdoll would yell at you. This release aids in this process, in that rather then telling you you are wrong, it helps you make it right by automatically returning to the start frame when necessary. Cycle Protection Cycle warnings are generally bad but especially bad for Ragdoll. Understanding when they happen and where they come from can be difficult, especially in complex setups. Ragdoll now includes Cycle Protection to help you spot potential cycles before they happen ! Notice how making a passive rigid here would have resulted in it becoming a child of an otherwise active hierarchy. That would have been bad! Protected Commands These commands will try and protect your from cycles. \u2714\ufe0f Active Rigid \u2714\ufe0f Active Chain \u2714\ufe0f Convert Rigid All other commands is already safe to use and shouldn't cause any cycles. FAQ These are some of the things you might want to learn more about. How does it work? Whenever a new Passive Rigid or Active Chain (with passive root) is being created, Ragdoll is asked to evaluate the world transformation of the node you are attempting to make dynamic. The solver should not be bothered to simulate anything during this encounter, because if it did then that would mean a cycle is about to happen. Why? Because passive rigids pass data into the solver. Namely, the position and orientation of the node you are attempting to turn into a passive rigid. It cannot both pass and receive data. If it is to receive translate/rotate from the solver, then that's an active rigid. Is it accurate? Very. Character rigs can get very complex; how can Ragdoll distinguish between an actual parent being active, and a node acting like a parent via something like Maya's Parent Constraints (i.e. a \"broken rig\")? The answer is that the feature builds on Maya's own evaluation mechanism to figure out whether a node is dependent on the solver or not. The mechanism is surprisingly simple. def is_dynamic ( transform , scene ): \"\"\"Does `transform` in any way affect `scene`?\"\"\" scene [ \"clean\" ] = True # Pull, but do not bother actually serialising it transform [ \"worldMatrix\" ] . pull () return not scene [ \"clean\" ] . read () By pulling on worldMatrix we ensure all hierarchy and constraints is taken into account, and by not actually retrieving value we limit the computational cost to dirty propagation only - as opposed to actually reading and serialising the 16 values that make up the matrix. Can it be disabled? Yes. The protection is only happening when interacting with Ragdoll via the UI menu items. The API remains unaffected and there is an option in the Preferences to disable it in the UI as well. New Constraints Have more fun with more control. \ud83d\ude18 These were previously available under a different names and less intuitive usage Hard Pin When you want a rigid to be at an exact place at an exact time, use Hard Pin . Limitations A rigid can currently have 1 Hard Pin each. This will be addressed in a future release. These cannot currently be exported, they are primarily intended for use interactively by the animator Previously called Passive Control . Soft Pin When you want a rigid to be at an approximate place at an approximate time, whilst still respecting the laws of physics including contacts and gravity, use Soft Pin . Soft pins are nothing more than a constraint with a guide position towards the newly created transform. Limitations These cannot currently be exported, see Hard Pin for rationale Previously called Guide Control . Animation Constraint In the the previous releases I've been experimenting with the idea of turning the Maya translate/rotate channels directly into a guide constraint. There are three possible scenarios with subtle differences. \u2714\ufe0f Non-dynamic Parent E.g. the first rigid in a new scene with an animated character \u2714\ufe0f Passive Parent E.g. a prop attached to a passive body \u2714\ufe0f Active Parent E.g. what you normally get out of chains \u2796 Dynamic Grandparent A less-supported special case, see below In the above, the parent of the newly created rigid with an animation constraint is non-dynamic, it's got nothing to do with Ragdoll. Just your everyday (boring) Maya transform. In this case, the channel is successfully converted to a worldspace position and orientation from your translate/rotate channels. Here on the other hand, the immediate parent is a Passive Rigid which is a little more flexible, and gives you an option to actually collide with the parent. Finally, the parent is active. This is also OK and quite fun. Now the new rigid will affect the parent, since it adds weight onto it. Like a backback. Dynamic Grandparent Here's where things get less predictable. If the parent of the control you want physics to follow along with your translate/rotate channels is non-dynamic, but one or more of its parent are active rigids, then the channel box values no longer align. This will be addressed in a future release. Character Multiplier Making a new character now includes a default multiplier for all constraints (just like chains do!), meaning you can more easily create effects like this! Import Bugs Two issues were found with the importer introduced in the last version. It wasn't able to distinguish between a passive and active rigid It wasn't able to correctly identify a chain with only 2 links Passive versus Rigid When importing a passive rigid, odds are it got imported as a active rigid instead. This could get very messy, as it could end up creating passive rigids as children of active ones, which could reak all kinds of havoc, including cycle warnings. 2-link chains Any \"chain\" with more than one child (head) is a special case of each chain only having 1 rigid each, as opposed to longer chains like arms and legs. Now these can be imported too! Export is Unchanged This and the above import fix were only related to importing of physics, both your existing Maya scenes and exported .rag files are unchanged and were already in good condition. Yay! User Attributes Whenever you make a rigid or chain, some attributes are forwarded onto your animation controls. These attributes are called \"User Attributes\" and the previous release changed these from Maya proxy-attributes to plain-attributes. In doing so, they lost their nice names and default values. :( This has now been fixed! Looped Playback Bug If you've ever had both passive and active rigids and let playback run on a loop, you might have encountered something like this. Whereas if you rewound and playback without looping, everything would be allright. This bug got squashed in this release, letting you loop things to your hearts content! Auto-cleanup Whenever you Delete All Physics anything created by Ragdoll disappears, including User Attributes. What wasn't included however was the handles that appears when you Edit Constraint Pivot and Edit Shape . These now also vanish with delete-all, making your life just a little bit better! Thanks to Remi Comtois for pointing this out! Offline Activation Activation is streamlined by happening inside of Maya at the paste of a serial and press of a button. Unless you are one of those without access to the internet, in which case we'll need to do a little dance. :) Step 1 - Generate Request from ragdoll import licence key = \"YOUR-VERY-LONG-KEY-HERE\" fname = r \"c:\\ragdoll_activation_request.xml\" licence . activation_request_to_file ( key , fname ) Step 2 - Email Request Send this file to licencing@ragdolldynamics.com . We'll abrakadabra this file before you can say Taumatawhakatangi\u00adhangakoauauotamatea\u00adturipukakapikimaunga\u00adhoronukupokaiwhen\u00aduakitanatahu . Step 3 - Activate Once you've got a response, activate your licence like this. from ragdoll import licence fname = r \"c:\\ragdoll_activation_response.xml\" licence . activate_from_file ( fname ) Linux users, you'll know what to do about that Windows-like path. Full documentation https://learn.ragdolldynamics.com/licencing/#offline-activation Qt Bug The last release included a callback for synchronising the Import Options UI with the Maya selection. As a result, a bug slipped in which could - in rare cases - produce the following error messages in your Script Editor whenever you changed selection. ../ragdoll/vendor/qargparse.py line 654: Internal C++ object (WidgetHoverFactory) already deleted. // This has now been patched up, but do shout out if this or anything like it happens to you! Thanks to Rafael Villar for finding this bug! Low-DPI Cosmetics The Import Options UI didn't quite live up to the hype at 720p and 1080p, now it does! Preview properly resizes to fit content Thumbnail properly fits the square Thumbnail and file listing lines up nicely Spacing between widgets are consistent across high and low DPI settings Before After Z-up Worldspace Guides Whenever you make a Guide control (now called Soft Pin ) you are technically creating a constraint between a rigid and the world . That's what makes it worldspace. Until now, constraints assumed the world didn't move. But you z-up folks out there know that, sometimes, it does! Ragdoll is now OK with that. Before After Thanks to Jason Snyman for finding this bug! Tree Multipliers There was a minor bug with multipliers for any chain branching off of another chain (e.g. an arm from a spine) which caused the default multiplier to not correctly affect every link in those chains. This has now been fixed! Known Issues At the time of this release, these are the known issues that will be addressed in a future release. Evaluation Graph Controllers If you use \"controllers\" in your rig, there is a possibility Ragdoll will be drawing things incorrectly. This can be addressed by either not (1) using controllers, (2) disabling controllers in the evaluation or (3) awaiting a future update. The problem appears visual-only and should have no effect on the simulation itself. Scale Pivot When you hold the D key and move the pivot, there are 4 attributes being edited. Rotate Pivot Rotate Pivot Translate Scale Pivot Scale Pivot Translate If scalePivot and scalePivotTranslate result in zero change to a nodes position (the default) then all is well. But, if you edit these independently then that will in turn affect the final position of the node, in which case Ragdoll will struggle to simulate it. Auto Key I've narrowed down a particularly annoying behavior (likely a bug) in Maya that can affect users of auto-key and Ragdoll. https://forums.autodesk.com/t5/maya-animation-and-rigging/bug-with-pairblend-and-auto-key/td-p/10258735 This will be fixed in a future release, and if anyone knows of any workaround please let me know! Joint Orient & Non-linear Hierarchy When joints do not immediately follow each other, the rotate channel isn't entirely accurate. Notice how there is a joint inbetween the two rigids? Avoid this edge case for now, or zero out the jointOrient . Soft Passive Guides Solved Solved in 2021.04.28 Guiding the translation of an Active Rigid with a Passive Rigid is currently problematic and creates an unrealistic increase of acceleration. The current workaround is to swap solvers under the Advanced tab of the scene.","title":"2021.04.23"},{"location":"releases/2021.04.23/#no-more-limits","text":"That's right! It used to be the case that if your character had a non-default Rotate Order , or a tweaked Rotate Pivot or maybe made use of the handy Rotate Axis or the joints you were using had a non-zero Joint Orient , then you were out of luck ! Ragdoll just couldn't handle those. It would aggressively reset those to their defaults, or flat-out refuse to work. This release adds support for these missing members, which just so happens to be the very last major limitations of Ragdoll when used with your everyday character rigs! \u2714\ufe0f Rotate Pivot \u2714\ufe0f Rotate Axis \u2714\ufe0f Rotate Order \u2714\ufe0f Joint Orient From now on, if it doesn't work with your rig, that's a bug (let me know!).","title":"No More Limits!"},{"location":"releases/2021.04.23/#rotate-pivot","text":"This release introduces support for both the .rotatePivot and rotatePivotTranslate attributes, letting you do things like.. I've also added an option to actually use the rotate pivot (for greater good?) such that you can do this.","title":"Rotate Pivot"},{"location":"releases/2021.04.23/#rotate-axis","text":"The advanced rigger will know of his lesser-known feature of Maya transform nodes, with the ability to modify the axis around which the Rotate XYZ channels operate.","title":"Rotate Axis"},{"location":"releases/2021.04.23/#rotate-order","text":"Finally cracked this one, it has been far too long and is a far-too used feature of Maya transform nodes to not support. But it's done! You should now be able to pick any rotate order and experience no flipping or issue of any kind. Don't even bother getting in touch if you do, because I will not believe you. xD This tiger (courtesy of www.cgspectrum.com ) has a different rotate order on nearly every control. Before After Hold on a second! That final flip of the spine is coming from the rig itself, the joints driven by the controllers we're simulating. Ragdoll isn't the only one having issues with flipping. :)","title":"Rotate Order"},{"location":"releases/2021.04.23/#joint-orient","text":"When simulating joints, it can be important to retain the original jointOrient values. Especially if those joints are later used for IK or if you want or need to zero out those rotate values. But it is perhaps most important for an already-animated skeleton, like what you get out of motion capture. Some motion capture libraries, like Rokoku, do a good job not having any jointOrient in which case they would already work well with Ragdoll. But for animated skeletons with a non-default jointOrient you would have been out of luck.. Until now!","title":"Joint Orient"},{"location":"releases/2021.04.23/#30-greater-performance","text":"Ragdoll used to be really really fast, and is now really really really fast! Rendering is one of two areas where Ragdoll spends time computing (the other being simulating), and rendering performance has been improved by 400%, making Ragdoll 30% faster overall! Here you can see the improvement up-close, notice how much time was spent simulating versus rendering each frame in the previous version; almost half the time was spent just rendering! And if you're wondering... Ok, but what features did you remove ? On the contrary! Rendering now includes .. \u2714\ufe0f Specular \u2714\ufe0f Shadows \u2714\ufe0f Ambient Occlusion \u2714\ufe0f Depth of Field \u2714\ufe0f With more to come! Even More Performance? You'll notice that the rendering square isn't entirely gone. If 4 ms just to render is too much to ask, you'll get even more of a performance jolt by simply hiding anything Ragdoll related, in particular the rdRigid and rdConstraint nodes. The simulated result is independent of whether or not it is visible in the viewport. If you are a rigger , this can be handy for your animators once you've finished setting things up, as they may not benefit from seeing these things anyway and could use all of the performance you can give.","title":"30% Greater Performance"},{"location":"releases/2021.04.23/#simulated-attribute","text":"Whenever you make a new chain, an attribute is created on the root of that chain to control whether or not the chain should be Simulated or animated. With this release, Simulated = Off means: \u2714\ufe0f Disabled Solver - meaning no more warnings on skipping frames! \u2714\ufe0f Hidden Drawing of Physics - For a less distracting animation experience","title":"Simulated Attribute"},{"location":"releases/2021.04.23/#return-to-start","text":"Additions to the physics solver can only happen on the start frame, and if you in previous version created anything on any other frame Ragdoll would yell at you. This release aids in this process, in that rather then telling you you are wrong, it helps you make it right by automatically returning to the start frame when necessary.","title":"Return To Start"},{"location":"releases/2021.04.23/#cycle-protection","text":"Cycle warnings are generally bad but especially bad for Ragdoll. Understanding when they happen and where they come from can be difficult, especially in complex setups. Ragdoll now includes Cycle Protection to help you spot potential cycles before they happen ! Notice how making a passive rigid here would have resulted in it becoming a child of an otherwise active hierarchy. That would have been bad!","title":"Cycle Protection"},{"location":"releases/2021.04.23/#protected-commands","text":"These commands will try and protect your from cycles. \u2714\ufe0f Active Rigid \u2714\ufe0f Active Chain \u2714\ufe0f Convert Rigid All other commands is already safe to use and shouldn't cause any cycles.","title":"Protected Commands"},{"location":"releases/2021.04.23/#faq","text":"These are some of the things you might want to learn more about. How does it work? Whenever a new Passive Rigid or Active Chain (with passive root) is being created, Ragdoll is asked to evaluate the world transformation of the node you are attempting to make dynamic. The solver should not be bothered to simulate anything during this encounter, because if it did then that would mean a cycle is about to happen. Why? Because passive rigids pass data into the solver. Namely, the position and orientation of the node you are attempting to turn into a passive rigid. It cannot both pass and receive data. If it is to receive translate/rotate from the solver, then that's an active rigid. Is it accurate? Very. Character rigs can get very complex; how can Ragdoll distinguish between an actual parent being active, and a node acting like a parent via something like Maya's Parent Constraints (i.e. a \"broken rig\")? The answer is that the feature builds on Maya's own evaluation mechanism to figure out whether a node is dependent on the solver or not. The mechanism is surprisingly simple. def is_dynamic ( transform , scene ): \"\"\"Does `transform` in any way affect `scene`?\"\"\" scene [ \"clean\" ] = True # Pull, but do not bother actually serialising it transform [ \"worldMatrix\" ] . pull () return not scene [ \"clean\" ] . read () By pulling on worldMatrix we ensure all hierarchy and constraints is taken into account, and by not actually retrieving value we limit the computational cost to dirty propagation only - as opposed to actually reading and serialising the 16 values that make up the matrix. Can it be disabled? Yes. The protection is only happening when interacting with Ragdoll via the UI menu items. The API remains unaffected and there is an option in the Preferences to disable it in the UI as well.","title":"FAQ"},{"location":"releases/2021.04.23/#new-constraints","text":"Have more fun with more control. \ud83d\ude18 These were previously available under a different names and less intuitive usage","title":"New Constraints"},{"location":"releases/2021.04.23/#hard-pin","text":"When you want a rigid to be at an exact place at an exact time, use Hard Pin . Limitations A rigid can currently have 1 Hard Pin each. This will be addressed in a future release. These cannot currently be exported, they are primarily intended for use interactively by the animator Previously called Passive Control .","title":"Hard Pin"},{"location":"releases/2021.04.23/#soft-pin","text":"When you want a rigid to be at an approximate place at an approximate time, whilst still respecting the laws of physics including contacts and gravity, use Soft Pin . Soft pins are nothing more than a constraint with a guide position towards the newly created transform. Limitations These cannot currently be exported, see Hard Pin for rationale Previously called Guide Control .","title":"Soft Pin"},{"location":"releases/2021.04.23/#animation-constraint","text":"In the the previous releases I've been experimenting with the idea of turning the Maya translate/rotate channels directly into a guide constraint. There are three possible scenarios with subtle differences. \u2714\ufe0f Non-dynamic Parent E.g. the first rigid in a new scene with an animated character \u2714\ufe0f Passive Parent E.g. a prop attached to a passive body \u2714\ufe0f Active Parent E.g. what you normally get out of chains \u2796 Dynamic Grandparent A less-supported special case, see below In the above, the parent of the newly created rigid with an animation constraint is non-dynamic, it's got nothing to do with Ragdoll. Just your everyday (boring) Maya transform. In this case, the channel is successfully converted to a worldspace position and orientation from your translate/rotate channels. Here on the other hand, the immediate parent is a Passive Rigid which is a little more flexible, and gives you an option to actually collide with the parent. Finally, the parent is active. This is also OK and quite fun. Now the new rigid will affect the parent, since it adds weight onto it. Like a backback. Dynamic Grandparent Here's where things get less predictable. If the parent of the control you want physics to follow along with your translate/rotate channels is non-dynamic, but one or more of its parent are active rigids, then the channel box values no longer align. This will be addressed in a future release.","title":"Animation Constraint"},{"location":"releases/2021.04.23/#character-multiplier","text":"Making a new character now includes a default multiplier for all constraints (just like chains do!), meaning you can more easily create effects like this!","title":"Character Multiplier"},{"location":"releases/2021.04.23/#import-bugs","text":"Two issues were found with the importer introduced in the last version. It wasn't able to distinguish between a passive and active rigid It wasn't able to correctly identify a chain with only 2 links Passive versus Rigid When importing a passive rigid, odds are it got imported as a active rigid instead. This could get very messy, as it could end up creating passive rigids as children of active ones, which could reak all kinds of havoc, including cycle warnings. 2-link chains Any \"chain\" with more than one child (head) is a special case of each chain only having 1 rigid each, as opposed to longer chains like arms and legs. Now these can be imported too! Export is Unchanged This and the above import fix were only related to importing of physics, both your existing Maya scenes and exported .rag files are unchanged and were already in good condition. Yay!","title":"Import Bugs"},{"location":"releases/2021.04.23/#user-attributes","text":"Whenever you make a rigid or chain, some attributes are forwarded onto your animation controls. These attributes are called \"User Attributes\" and the previous release changed these from Maya proxy-attributes to plain-attributes. In doing so, they lost their nice names and default values. :( This has now been fixed!","title":"User Attributes"},{"location":"releases/2021.04.23/#looped-playback-bug","text":"If you've ever had both passive and active rigids and let playback run on a loop, you might have encountered something like this. Whereas if you rewound and playback without looping, everything would be allright. This bug got squashed in this release, letting you loop things to your hearts content!","title":"Looped Playback Bug"},{"location":"releases/2021.04.23/#auto-cleanup","text":"Whenever you Delete All Physics anything created by Ragdoll disappears, including User Attributes. What wasn't included however was the handles that appears when you Edit Constraint Pivot and Edit Shape . These now also vanish with delete-all, making your life just a little bit better! Thanks to Remi Comtois for pointing this out!","title":"Auto-cleanup"},{"location":"releases/2021.04.23/#offline-activation","text":"Activation is streamlined by happening inside of Maya at the paste of a serial and press of a button. Unless you are one of those without access to the internet, in which case we'll need to do a little dance. :) Step 1 - Generate Request from ragdoll import licence key = \"YOUR-VERY-LONG-KEY-HERE\" fname = r \"c:\\ragdoll_activation_request.xml\" licence . activation_request_to_file ( key , fname ) Step 2 - Email Request Send this file to licencing@ragdolldynamics.com . We'll abrakadabra this file before you can say Taumatawhakatangi\u00adhangakoauauotamatea\u00adturipukakapikimaunga\u00adhoronukupokaiwhen\u00aduakitanatahu . Step 3 - Activate Once you've got a response, activate your licence like this. from ragdoll import licence fname = r \"c:\\ragdoll_activation_response.xml\" licence . activate_from_file ( fname ) Linux users, you'll know what to do about that Windows-like path. Full documentation https://learn.ragdolldynamics.com/licencing/#offline-activation","title":"Offline Activation"},{"location":"releases/2021.04.23/#qt-bug","text":"The last release included a callback for synchronising the Import Options UI with the Maya selection. As a result, a bug slipped in which could - in rare cases - produce the following error messages in your Script Editor whenever you changed selection. ../ragdoll/vendor/qargparse.py line 654: Internal C++ object (WidgetHoverFactory) already deleted. // This has now been patched up, but do shout out if this or anything like it happens to you! Thanks to Rafael Villar for finding this bug!","title":"Qt Bug"},{"location":"releases/2021.04.23/#low-dpi-cosmetics","text":"The Import Options UI didn't quite live up to the hype at 720p and 1080p, now it does! Preview properly resizes to fit content Thumbnail properly fits the square Thumbnail and file listing lines up nicely Spacing between widgets are consistent across high and low DPI settings Before After","title":"Low-DPI Cosmetics"},{"location":"releases/2021.04.23/#z-up-worldspace-guides","text":"Whenever you make a Guide control (now called Soft Pin ) you are technically creating a constraint between a rigid and the world . That's what makes it worldspace. Until now, constraints assumed the world didn't move. But you z-up folks out there know that, sometimes, it does! Ragdoll is now OK with that. Before After Thanks to Jason Snyman for finding this bug!","title":"Z-up Worldspace Guides"},{"location":"releases/2021.04.23/#tree-multipliers","text":"There was a minor bug with multipliers for any chain branching off of another chain (e.g. an arm from a spine) which caused the default multiplier to not correctly affect every link in those chains. This has now been fixed!","title":"Tree Multipliers"},{"location":"releases/2021.04.23/#known-issues","text":"At the time of this release, these are the known issues that will be addressed in a future release.","title":"Known Issues"},{"location":"releases/2021.04.23/#evaluation-graph-controllers","text":"If you use \"controllers\" in your rig, there is a possibility Ragdoll will be drawing things incorrectly. This can be addressed by either not (1) using controllers, (2) disabling controllers in the evaluation or (3) awaiting a future update. The problem appears visual-only and should have no effect on the simulation itself.","title":"Evaluation Graph Controllers"},{"location":"releases/2021.04.23/#scale-pivot","text":"When you hold the D key and move the pivot, there are 4 attributes being edited. Rotate Pivot Rotate Pivot Translate Scale Pivot Scale Pivot Translate If scalePivot and scalePivotTranslate result in zero change to a nodes position (the default) then all is well. But, if you edit these independently then that will in turn affect the final position of the node, in which case Ragdoll will struggle to simulate it.","title":"Scale Pivot"},{"location":"releases/2021.04.23/#auto-key","text":"I've narrowed down a particularly annoying behavior (likely a bug) in Maya that can affect users of auto-key and Ragdoll. https://forums.autodesk.com/t5/maya-animation-and-rigging/bug-with-pairblend-and-auto-key/td-p/10258735 This will be fixed in a future release, and if anyone knows of any workaround please let me know!","title":"Auto Key"},{"location":"releases/2021.04.23/#joint-orient-non-linear-hierarchy","text":"When joints do not immediately follow each other, the rotate channel isn't entirely accurate. Notice how there is a joint inbetween the two rigids? Avoid this edge case for now, or zero out the jointOrient .","title":"Joint Orient &amp; Non-linear Hierarchy"},{"location":"releases/2021.04.23/#soft-passive-guides","text":"Solved Solved in 2021.04.28 Guiding the translation of an Active Rigid with a Passive Rigid is currently problematic and creates an unrealistic increase of acceleration. The current workaround is to swap solvers under the Advanced tab of the scene.","title":"Soft Passive Guides"},{"location":"releases/2021.04.28/","text":"This release introduces more robustness, in exchange for changes to the default values for any Stiffness and Damping parameters. ADDED Solver Upgrade More realistic guides, at the expense of new default values ADDED Frameskip Protection Does what it says on the tin! ADDED Clear Initial State Return to a better time ADDED Passive Visualisation Understand which and when rigids are passive FIXED Start Frame Explosion Fixed a rare case overly eager passive rigids FIXED Negative Scale 2.0 Greater support for negative scale FIXED Rotate Order 3.0 Greater support for custom Rotate Order. FIXED Draw Shaded Rigids can now once again be wireframed, for less clutter whilst animating Solver Upgrade The solver has been upgraded for more accuracy and stability. Unfortunately, this changes the default values Stiffness and Damping attributes, which may require changes in your scene. ATTENTION: Backwards Incompatibility Ragdoll takes backwards compatibility very seriously. At no point should a scene you have created break because of an update. This however is an exception to that rule, one that I expect never to happen again. What has changed? Stiffness and Damping need higher values. So far, we've used the Iterations value on the solver to control how strong our constraints could be. As it happens, this isn't right. Iterations shouldn't control strength, it should only control how close the solution is to the true analytical solution. In the previous release, increasing this value produced an entirely different result based on how many iterations you used. At no point would it \"converge\" onto a true solution. In this and future releases, only stiffness and damping will affect the behavior of physics, with Iterations optionally bringing it closer to the true solution. In practice, not much has changed. You should still increase stiffness/damping when relevant, and still increase Iterations if you find the values aren't being respected. What can I do? \ud83d\udc49 Increase Stiffness by 3-10x \ud83d\udc49 Increase Damping by 3-10x That is, if Stiffness was previously 1'000, make it 10'000. Exceptions For anything created with this version, no action is needed. Projected Gauss-Seidel (Advanced) remains unchanged. It's not an exact science, in some cases you only need 3x, like in this case here. Where the Yellow line is from the previous version at 1'000 stiffness and 100 damping, the Blue line has 3'000 stiffnes and 300 damping. Why did this change? The previous version was subtly faulty, so this was inevitable. In practice however, under a very particular - but useful - circumstance the solver would struggle to obey. Circumstance An Active Rigid Constrained to a Passive Rigid Limits turned off Translate Guide turned On Use Cases Dynamic muscles attached to an animated skeleton Dynamic props attached to an animated character Dynamic cloth attached to a passive collider Basically anything that isn't a fully-dynamic character Here was the result. Notice how the active rigid does what the active rigid does, but is a little too excited? One workaround was to use \"Projected Gauss-Seidel\" in place of the default \"Temporal Gauss-Seidel\", however that solver isn't as accurate or fast. You might be thinking.. Well that's an awefully specific case, when would I even hit that? Which is when you realise.. This was previously only possible with Projected Gauss-Seidel which is less performant and less able to handle large networks of constraints like a full ragdoll. Result This behavior was due to a subtle bug in how constraints were solved, a deeply rooted bug that once sorted out was what caused this change to the overall behavior of Stiffness and Damping values. In this release, the bug has been squashed and muscles and props now follow their passive counterpart much more accurately and without surprises. Frameskip Protection The simulation is like a train running on a train track. It absolute must not miss a stop, else it can't realistically figure how how to get to the subsequent stop. Allow me to demonstrate. Notice how everything falls apart when skipping just a handful of frames? It's trying to catch up, but the time difference is just too great to produce accurate values. This release adds support for pausing the solver whenever a frame is skipped, meaning you either get a (A) good solve or (B) a patient solver, awaiting your return. The behavior can be disabled in the Preferences. Why should I care? Consider your everyday situation of adding dynamics to a tail. Whenever a frame is skipped, the result is garbage. This can get even more extreme during more extreme movements. But, what's worse, this garbage is expensive! It's still simulating, and trying to solve these skipped frames is more expensive than non-skipped frames. That's a bad deal. Here what happens with frameskip protection. See how it just stays put? It'll remember the last simulated frame, awaiting your return. Clear Initial State Setting the initial state can be used to relax a physics character or scene. But once relaxed, you had no way to returning to its original creation state, until now! The set and cleared state are both saved with the scene This can rescue the initial state from breaking due to Automatic Initial State Thanks to Jason Snyman for this suggestion! Passive Visualisation Rigids will now turn gray when made passive, making it easier to understand what's going on visually. Start Frame Explosion In a specific and rare circumstance, a passive rigid body could appear to have velocity on the start frame. Notice here how animation starts immediately from the start frame, giving it an upwards velocity? The active rigids connected to the root on the other hand gets an even stronger velocity, for some reason. If we move the animation to just one frame after the start frame, all is well. A subtle bug, having to do with the rigid body being created on the second frame of the simulation, which in this case had a position the was different from the start frame. However! The animation started at the start frame, so the velocity got inherited from there instead. Yes, it's complicated. :) And is now fixed! Negative Scale Ragdoll has supported scale, but negative scale has been unreliable. This release extends this support to negative scale used to mirror controls and behavior across a rig. Before This whole arm has a negative scale in the X-axis, from when it was mirrored across from the other side. Notice here how it look like the arm is about to move forwards, and instead move backwards. After This has now been fixed. It also means you can flip entire performances with a little more ease. :) Caveat Avoid negative scale on the control you are animating. \u2714\ufe0f Global negative scale \u274c Local negative scale You are still better off not having any negative scales in your rig, as there is still at least one special case I found that might jump up and bite you. And that is if the animated control itself has negative local scale. Typically, one or more of the parents have negative scale, so as to mirror a whole hierarchy of controls. And that is \u2714\ufe0f. But if the control you are animating also have negative scale, you might experience this. Notice how on rewind, it twitches at the start of playback every other time? That's because it cannot tell the whether the control has negative scale or whether it is rotated 180 degrees. This will be addressed in a future release. Rotate Order The animation constraint is what translates your keyframes into physics and with the introduction of support for Rotate Order in the previous few releases it has been possible for Ragdoll to output rotations onto any control with a custom rotate order. This release now includes support for input of custom rotate order into the simulation. Before Notice how changing the rotate order should have changed the axis around which the Y-animation was happening, but didn't? After Now it does! Draw Shaded The previous release revamped the rendering system in Ragdoll, but left out a the convenience attribute to disable shading when rigid bodies were used alongside animation controls. Before After Manual Override The behavior can be manually adjusted to taste via the Attribute Editor.","title":"2021.04.28"},{"location":"releases/2021.04.28/#solver-upgrade","text":"The solver has been upgraded for more accuracy and stability. Unfortunately, this changes the default values Stiffness and Damping attributes, which may require changes in your scene. ATTENTION: Backwards Incompatibility Ragdoll takes backwards compatibility very seriously. At no point should a scene you have created break because of an update. This however is an exception to that rule, one that I expect never to happen again.","title":"Solver Upgrade"},{"location":"releases/2021.04.28/#what-has-changed","text":"Stiffness and Damping need higher values. So far, we've used the Iterations value on the solver to control how strong our constraints could be. As it happens, this isn't right. Iterations shouldn't control strength, it should only control how close the solution is to the true analytical solution. In the previous release, increasing this value produced an entirely different result based on how many iterations you used. At no point would it \"converge\" onto a true solution. In this and future releases, only stiffness and damping will affect the behavior of physics, with Iterations optionally bringing it closer to the true solution. In practice, not much has changed. You should still increase stiffness/damping when relevant, and still increase Iterations if you find the values aren't being respected.","title":"What has changed?"},{"location":"releases/2021.04.28/#what-can-i-do","text":"\ud83d\udc49 Increase Stiffness by 3-10x \ud83d\udc49 Increase Damping by 3-10x That is, if Stiffness was previously 1'000, make it 10'000. Exceptions For anything created with this version, no action is needed. Projected Gauss-Seidel (Advanced) remains unchanged. It's not an exact science, in some cases you only need 3x, like in this case here. Where the Yellow line is from the previous version at 1'000 stiffness and 100 damping, the Blue line has 3'000 stiffnes and 300 damping.","title":"What can I do?"},{"location":"releases/2021.04.28/#why-did-this-change","text":"The previous version was subtly faulty, so this was inevitable. In practice however, under a very particular - but useful - circumstance the solver would struggle to obey. Circumstance An Active Rigid Constrained to a Passive Rigid Limits turned off Translate Guide turned On Use Cases Dynamic muscles attached to an animated skeleton Dynamic props attached to an animated character Dynamic cloth attached to a passive collider Basically anything that isn't a fully-dynamic character Here was the result. Notice how the active rigid does what the active rigid does, but is a little too excited? One workaround was to use \"Projected Gauss-Seidel\" in place of the default \"Temporal Gauss-Seidel\", however that solver isn't as accurate or fast. You might be thinking.. Well that's an awefully specific case, when would I even hit that? Which is when you realise.. This was previously only possible with Projected Gauss-Seidel which is less performant and less able to handle large networks of constraints like a full ragdoll. Result This behavior was due to a subtle bug in how constraints were solved, a deeply rooted bug that once sorted out was what caused this change to the overall behavior of Stiffness and Damping values. In this release, the bug has been squashed and muscles and props now follow their passive counterpart much more accurately and without surprises.","title":"Why did this change?"},{"location":"releases/2021.04.28/#frameskip-protection","text":"The simulation is like a train running on a train track. It absolute must not miss a stop, else it can't realistically figure how how to get to the subsequent stop. Allow me to demonstrate. Notice how everything falls apart when skipping just a handful of frames? It's trying to catch up, but the time difference is just too great to produce accurate values. This release adds support for pausing the solver whenever a frame is skipped, meaning you either get a (A) good solve or (B) a patient solver, awaiting your return. The behavior can be disabled in the Preferences.","title":"Frameskip Protection"},{"location":"releases/2021.04.28/#why-should-i-care","text":"Consider your everyday situation of adding dynamics to a tail. Whenever a frame is skipped, the result is garbage. This can get even more extreme during more extreme movements. But, what's worse, this garbage is expensive! It's still simulating, and trying to solve these skipped frames is more expensive than non-skipped frames. That's a bad deal. Here what happens with frameskip protection. See how it just stays put? It'll remember the last simulated frame, awaiting your return.","title":"Why should I care?"},{"location":"releases/2021.04.28/#clear-initial-state","text":"Setting the initial state can be used to relax a physics character or scene. But once relaxed, you had no way to returning to its original creation state, until now! The set and cleared state are both saved with the scene This can rescue the initial state from breaking due to Automatic Initial State Thanks to Jason Snyman for this suggestion!","title":"Clear Initial State"},{"location":"releases/2021.04.28/#passive-visualisation","text":"Rigids will now turn gray when made passive, making it easier to understand what's going on visually.","title":"Passive Visualisation"},{"location":"releases/2021.04.28/#start-frame-explosion","text":"In a specific and rare circumstance, a passive rigid body could appear to have velocity on the start frame. Notice here how animation starts immediately from the start frame, giving it an upwards velocity? The active rigids connected to the root on the other hand gets an even stronger velocity, for some reason. If we move the animation to just one frame after the start frame, all is well. A subtle bug, having to do with the rigid body being created on the second frame of the simulation, which in this case had a position the was different from the start frame. However! The animation started at the start frame, so the velocity got inherited from there instead. Yes, it's complicated. :) And is now fixed!","title":"Start Frame Explosion"},{"location":"releases/2021.04.28/#negative-scale","text":"Ragdoll has supported scale, but negative scale has been unreliable. This release extends this support to negative scale used to mirror controls and behavior across a rig. Before This whole arm has a negative scale in the X-axis, from when it was mirrored across from the other side. Notice here how it look like the arm is about to move forwards, and instead move backwards. After This has now been fixed. It also means you can flip entire performances with a little more ease. :)","title":"Negative Scale"},{"location":"releases/2021.04.28/#caveat","text":"Avoid negative scale on the control you are animating. \u2714\ufe0f Global negative scale \u274c Local negative scale You are still better off not having any negative scales in your rig, as there is still at least one special case I found that might jump up and bite you. And that is if the animated control itself has negative local scale. Typically, one or more of the parents have negative scale, so as to mirror a whole hierarchy of controls. And that is \u2714\ufe0f. But if the control you are animating also have negative scale, you might experience this. Notice how on rewind, it twitches at the start of playback every other time? That's because it cannot tell the whether the control has negative scale or whether it is rotated 180 degrees. This will be addressed in a future release.","title":"Caveat"},{"location":"releases/2021.04.28/#rotate-order","text":"The animation constraint is what translates your keyframes into physics and with the introduction of support for Rotate Order in the previous few releases it has been possible for Ragdoll to output rotations onto any control with a custom rotate order. This release now includes support for input of custom rotate order into the simulation. Before Notice how changing the rotate order should have changed the axis around which the Y-animation was happening, but didn't? After Now it does!","title":"Rotate Order"},{"location":"releases/2021.04.28/#draw-shaded","text":"The previous release revamped the rendering system in Ragdoll, but left out a the convenience attribute to disable shading when rigid bodies were used alongside animation controls. Before After Manual Override The behavior can be manually adjusted to taste via the Attribute Editor.","title":"Draw Shaded"},{"location":"releases/2021.05.10/","text":"Highlight for this release is Mimic ! ADDED Mimic Clean separation between simulation and animation ADDED Bake Simulation Fresh out the oven! ADDED Import Additions More control over the import process ADDED Sleep Greater performance by putting rigids to sleep ADDED Textures Visualise mass, friction and restitution ADDED Vertex Limit Less vertices, more performance IMPROVED Collide Off Improved handling of disabled collisions IMPROVED Quality of Life Can never have too much of these FIXED Startup Crash Were you one of the 2% of users having Maya crash on startup? FIXED Scene Drawing in 2018 Maya 2018 and 2019 were acting up, no more! FIXED Initial State One less thing to worry about FIXED Qt Another less to worry about Some awesome simulations, courtesy of Jason Snyman, a.k.a. The Wizard. xD Facial Rigging Move lips, pull muscles. Collides with the teeth too! Ragdolls have feelings too Zilla is nothing with Kong, Kong is nothing without Zilla. Wreck-it Zilla Old recovered footage from the 60s! Wreck-it Warm-up Ever wondered how Zilla prepares for world domination? Mimic Transition in and out of physics, in both pose-space and world-space, with the newly added Mimic . Options In-Depth A step-by-step guide on what each option mean, there's quite a few of them! Production Rig Example A closer look at the Fire Wolf. Courtesy of Truong CG Artist Multiple Mimic Mimic is a replica of your control hierarchy, and there's no limit to the number of replicas you can make. The final force applied to your rigid bodies is the sum of constraints applied. Order Independent The controls in character rigs typically don't form a linear hierarchy. They're in some offset group, or in a different part altogether hanging together with constraints. That are animated, for space switching and what not. Mimics don't mind. Partial Chain Sometimes you only want a little bit of control. Bake Simulation You can now convert physics into keyframes with Bake Simulation . I did not edit this GIF, it really was that fast! :D Tutorial Bake Duration It'll tell you how much time was spent baking too. Bake Options There are a few more options to choose from, with more to come. Import Additions The import mechanic got an upgrade, you're now able to choose whether or not to re-apply changes to attributes and more finely import onto part of a larger chain hierarchy. Preserve Attributes You now have the option to preserve attributes when importing, for when you'd rather stick with the default values. Preserve Roots Exported files now remember what their original roots were. The original root of chains aren't important to Ragdoll. Whether the spine was a chain followed by the left and right arm, or whether the spine and left arm were part of one chain followed by the neck and right arm makes no difference. Consider these two characters. Notice how in the front character, one chain starts at the hip and goes out into the arm, whereas in the back character the spine is a single chain as you may expect? Regardless of how you authored it, to Ragdoll these characters are identical. Ragdoll doesn't bother with hierarchies, everything happens in worldspace. The hierarchy is between you and Maya. However What if you wanted to import just one of the roots? You can import only onto the selected controls, but you can't import part of a network of chains like a full ragdoll. It's either a complete character, or no character at all. In the case of the foreground character, you could import the screen-left arm, but not the screen-right. Not without importing the whole spine. This release preserves the original root, such that you can isolate an import onto the same chain you originally authored. Sleep It is now possible to reap additional performance benefits in situations where one or more rigids remain immobile for a given number of frames. The behavior can be tuned via two attributes on each rdRigid node. Attribute Description Wake Counter How many frames of inactivity before I fall asleep? Sleep Threshold How low of a force should be applied before I start counting? In practice, you'll likely only want to tweak the Wake Counter to some reasonable value like 5 or 20 frames of immobility. The default value of 0 means they'll never fall asleep. Like a proper insomniac or new parent. Caveat Currently, the wake counter is not reset when you rewind , so it's possible to have them fall asleep on frame 20, rewind to frame 19 and have the counter reset and keep them awake past frame 20. It's unlikely to affect you, and will be addressed in a later release. Textures As you author your ragdolls, the distribution of mass can play a big role. But it can be tricky to balance something you cannot see, smell or touch. With this release, you're able to see (but not smell, I promise) the masses in each rigid using the handy new Texture attribute and when your viewport is set to Textured mode (the 6 key on your keyboard). Thanks to Jason Snyman for the idea! Normalised Distribution Notice how the colors even out to always give you pure white for the maximum weight in any of the rigids in the scene they are part of, and approaching black for anything less. No need to manually specify min/max values! Friction and Restitution These can be visualised too. Maya 2018 Caveat In Maya 2018, consolidation is disabled to facilitate this shader. It shouldn't affect anything of value, you probably don't even know what it is. But if you'd rather it didn't do that, untick the \"Maya 2018 Consolidate World Fix\" in the Ragdoll Preferences and reload the plug-in or restart Maya. Vertex Limit Meshes are the slowest to compute and have an upper-limit of 256 vertices. You can now lower this limit for meshes that would normally result in 256 for greater performance. Collide Off Rigids have always been able to ignore contacts with Collide: Off The problem here is subtle, but has been present since the beginning of Ragdoll. It mostly makes itself known once there is a constraint between a rigid with Collide: On and a rigid with Collide: Off . Notice how with Collide: Off the upper part of the \"creature\" is more wobbly? As if the effect of the constraint has somehow dimished? That's not right. Unless there are contacts involved, disabling them shouldn't have an effect on the simulation. With this release, it behaves as you would expect. Quality of Life A number of improvements were made to make working with Ragdoll more pleasant! Translate Limit Rendering The translate limit is making an appearance! This should make it just a tiny bit easier to work with, now that it's clear which axes are actually free. Letting you see whether they are constrained in 3D, 2D or 1D . All the D's! Edit Limit Using the same method as editing rotate limits, they can be rotated (and moved!). Soft Limit Like rotate limits, these can also be made soft! Constraint Rendering Have you ever noticed constraints looking real nervous? You now needn't lose any more sleep over it, as they now render flicker-free. :D Before After Constraint Interactivity You may also have noticed how when you edit one of two constrained rigids, how things get all whack? Before Best case you'd at least get constraints to stick together as you make changes. After And oh golly how ugly it was. No more! Yay! \ud83e\udd29 Constraint Colors When rigids have multiple constraints, it can be hard to tell them apart visually given they all share the same red/green colors. And if you're amongst the colorblinds things are even more challenging. This release enables you to give some extra flare to your constriants, by editing the Twist (X-axis) and Swing (YZ-axes). Trajectory on Selected There's now an option to isolate trajectories to selected rigids only. Less Explosive Overlaps are resolved by moving one or both rigids away from each other. The force with which that resolution happens could be infinite , resulting in what looks like explosions. This release addresses this, by compromising between realism and aesthetics. Before After Editable The behavior can be restored or tweaked further by adjusting the Max Depenetration Velocity attribute of the rigid. Load on File Open There are 3 ways to load Ragdoll. Maya's Plug-in Manager Python's cmds.loadPlugin(\"ragdoll\") Opening a file with Ragdoll in it When Ragdoll is loaded, it appends to a special environment variable Maya uses to look for icons in the Outliner called XBMLANGPATH . Because of course that's what it is called, why do you have that look on your face? Anyway, as it happens, if the Outliner was given a chance to draw icons before Ragdoll added this variable then it'd go ahead and draw a generic, non-pleasant-looking icon like this. This release fixes that. \ud83e\udd70 Before After Upgrade on File Open Like above, there was another issue when loading the plug-in alonside opening of scenes, which had to do with upgrades. Normally, what happens is this. Scene is opened Ragdoll checks to see if any nodes are older than the version you use If they are, it then checks to see whether any of them need upgrading If any are, it upgrades those Scene open complete But since the plug-in is loaded during scene open, Ragdoll wasn't given a chance to check it first. This has now been fixed. Install on Idle This changes the initialisation mechanism somewhat, if this causes any issues for you, set the RAGDOLL_INSTALL_ON_IDLE environment variable to revert to the old behavior. It won't be able to upgrade on scene open unless you load the plug-in first, but that's the only thing you're missing out on. Node Editor Icons Our precious icons now appear in the node editor too! Before After Passive Initial State Here's a subtle one. In previous releases, the initial state is automatically updated on the 2 nd frame of the simulation to wherever a rigid was on the 1 st frame. Even if you modified the position interactively with manipulators, or via curves in the Graph Editor, or the channel box, and so on. It even updated when a rigid was affected by passive input, like a Hard Pin, which meant you lost track of the original initial state whenever you disabled the hard pin. This release addresses that by only automatically updating the initial state if a rigid is active on the start frame. Notice how I can disable Hard Pin and have the rigids return to where they were before they got pinnned? It's what you would expect. Passive to Active and Back Again Ragdoll tries to clean up after itself by removing constraints no longer in use. When a rigid is passive, it can no longer be affected by constraints, so those constraints are deleted. However, active rigids can still be influenced by a passive rigid, and Ragdoll was a little too aggressive in removing those constraints too. This release fixes that. Undo and Attribute Order Whenever you delete physics and undo , the order in which proxy attributes would appear on your controllers would go all whack. This is basic-Maya, it loves doing this. But now love goes both ways, and we are much happier. \ud83e\udd70 Before After Control Rendering Controls give you a preview of what the rigid they control look like. These are special in that Maya doesn't actually need them. Ragdoll doesn't actually need them either. They are exclusively for-your-eyes-only. And due to Maya only updating things it absolutely needs to whenever rendering anything, these won't get updated unless Ragdoll explicitly tells them to. So far, they've been told to update whenever the selection changed, which can end up looking bad. This has now been improved! Before After Fixed Startup Crash On plug-in load, Ragdoll would check your licence. Under rare circumstances (2 out of 100 users reported it happening) this would be enough to put Maya under, instantly and without warning. This has now been fixed. Fixed Initial State An error was introduced between 2021.04.23 and 2021.04.28 leading to an issue with updating the initial pose via the Channel Box or Graph Editor. This got addressed on the same day and released unofficially as 2021.04.30, and is now officially part of the latest version. Thanks to Niels Dervieux for reporting this bug! Before After Fixed Qt Whenever you clicked Import Physics in the Import Physics Option Window, it would needlessly shout at you. # RuntimeError: Internal C++ object (WidgetHoverFactory) already deleted. No more! Scene Drawing in 2019 Maya was misbehaving in 2018-2019, refused to draw the scene visualisation correctly. No longer! Before After","title":"2021.05.10"},{"location":"releases/2021.05.10/#mimic","text":"Transition in and out of physics, in both pose-space and world-space, with the newly added Mimic . Options In-Depth A step-by-step guide on what each option mean, there's quite a few of them! Production Rig Example A closer look at the Fire Wolf. Courtesy of Truong CG Artist","title":"Mimic"},{"location":"releases/2021.05.10/#multiple-mimic","text":"Mimic is a replica of your control hierarchy, and there's no limit to the number of replicas you can make. The final force applied to your rigid bodies is the sum of constraints applied.","title":"Multiple Mimic"},{"location":"releases/2021.05.10/#order-independent","text":"The controls in character rigs typically don't form a linear hierarchy. They're in some offset group, or in a different part altogether hanging together with constraints. That are animated, for space switching and what not. Mimics don't mind.","title":"Order Independent"},{"location":"releases/2021.05.10/#partial-chain","text":"Sometimes you only want a little bit of control.","title":"Partial Chain"},{"location":"releases/2021.05.10/#bake-simulation","text":"You can now convert physics into keyframes with Bake Simulation . I did not edit this GIF, it really was that fast! :D Tutorial Bake Duration It'll tell you how much time was spent baking too. Bake Options There are a few more options to choose from, with more to come.","title":"Bake Simulation"},{"location":"releases/2021.05.10/#import-additions","text":"The import mechanic got an upgrade, you're now able to choose whether or not to re-apply changes to attributes and more finely import onto part of a larger chain hierarchy.","title":"Import Additions"},{"location":"releases/2021.05.10/#preserve-attributes","text":"You now have the option to preserve attributes when importing, for when you'd rather stick with the default values.","title":"Preserve Attributes"},{"location":"releases/2021.05.10/#preserve-roots","text":"Exported files now remember what their original roots were. The original root of chains aren't important to Ragdoll. Whether the spine was a chain followed by the left and right arm, or whether the spine and left arm were part of one chain followed by the neck and right arm makes no difference. Consider these two characters. Notice how in the front character, one chain starts at the hip and goes out into the arm, whereas in the back character the spine is a single chain as you may expect? Regardless of how you authored it, to Ragdoll these characters are identical. Ragdoll doesn't bother with hierarchies, everything happens in worldspace. The hierarchy is between you and Maya. However What if you wanted to import just one of the roots? You can import only onto the selected controls, but you can't import part of a network of chains like a full ragdoll. It's either a complete character, or no character at all. In the case of the foreground character, you could import the screen-left arm, but not the screen-right. Not without importing the whole spine. This release preserves the original root, such that you can isolate an import onto the same chain you originally authored.","title":"Preserve Roots"},{"location":"releases/2021.05.10/#sleep","text":"It is now possible to reap additional performance benefits in situations where one or more rigids remain immobile for a given number of frames. The behavior can be tuned via two attributes on each rdRigid node. Attribute Description Wake Counter How many frames of inactivity before I fall asleep? Sleep Threshold How low of a force should be applied before I start counting? In practice, you'll likely only want to tweak the Wake Counter to some reasonable value like 5 or 20 frames of immobility. The default value of 0 means they'll never fall asleep. Like a proper insomniac or new parent. Caveat Currently, the wake counter is not reset when you rewind , so it's possible to have them fall asleep on frame 20, rewind to frame 19 and have the counter reset and keep them awake past frame 20. It's unlikely to affect you, and will be addressed in a later release.","title":"Sleep"},{"location":"releases/2021.05.10/#textures","text":"As you author your ragdolls, the distribution of mass can play a big role. But it can be tricky to balance something you cannot see, smell or touch. With this release, you're able to see (but not smell, I promise) the masses in each rigid using the handy new Texture attribute and when your viewport is set to Textured mode (the 6 key on your keyboard). Thanks to Jason Snyman for the idea! Normalised Distribution Notice how the colors even out to always give you pure white for the maximum weight in any of the rigids in the scene they are part of, and approaching black for anything less. No need to manually specify min/max values! Friction and Restitution These can be visualised too. Maya 2018 Caveat In Maya 2018, consolidation is disabled to facilitate this shader. It shouldn't affect anything of value, you probably don't even know what it is. But if you'd rather it didn't do that, untick the \"Maya 2018 Consolidate World Fix\" in the Ragdoll Preferences and reload the plug-in or restart Maya.","title":"Textures"},{"location":"releases/2021.05.10/#vertex-limit","text":"Meshes are the slowest to compute and have an upper-limit of 256 vertices. You can now lower this limit for meshes that would normally result in 256 for greater performance.","title":"Vertex Limit"},{"location":"releases/2021.05.10/#collide-off","text":"Rigids have always been able to ignore contacts with Collide: Off The problem here is subtle, but has been present since the beginning of Ragdoll. It mostly makes itself known once there is a constraint between a rigid with Collide: On and a rigid with Collide: Off . Notice how with Collide: Off the upper part of the \"creature\" is more wobbly? As if the effect of the constraint has somehow dimished? That's not right. Unless there are contacts involved, disabling them shouldn't have an effect on the simulation. With this release, it behaves as you would expect.","title":"Collide Off"},{"location":"releases/2021.05.10/#quality-of-life","text":"A number of improvements were made to make working with Ragdoll more pleasant!","title":"Quality of Life"},{"location":"releases/2021.05.10/#translate-limit-rendering","text":"The translate limit is making an appearance! This should make it just a tiny bit easier to work with, now that it's clear which axes are actually free. Letting you see whether they are constrained in 3D, 2D or 1D . All the D's! Edit Limit Using the same method as editing rotate limits, they can be rotated (and moved!). Soft Limit Like rotate limits, these can also be made soft!","title":"Translate Limit Rendering"},{"location":"releases/2021.05.10/#constraint-rendering","text":"Have you ever noticed constraints looking real nervous? You now needn't lose any more sleep over it, as they now render flicker-free. :D Before After","title":"Constraint Rendering"},{"location":"releases/2021.05.10/#constraint-interactivity","text":"You may also have noticed how when you edit one of two constrained rigids, how things get all whack? Before Best case you'd at least get constraints to stick together as you make changes. After And oh golly how ugly it was. No more! Yay! \ud83e\udd29","title":"Constraint Interactivity"},{"location":"releases/2021.05.10/#constraint-colors","text":"When rigids have multiple constraints, it can be hard to tell them apart visually given they all share the same red/green colors. And if you're amongst the colorblinds things are even more challenging. This release enables you to give some extra flare to your constriants, by editing the Twist (X-axis) and Swing (YZ-axes).","title":"Constraint Colors"},{"location":"releases/2021.05.10/#trajectory-on-selected","text":"There's now an option to isolate trajectories to selected rigids only.","title":"Trajectory on Selected"},{"location":"releases/2021.05.10/#less-explosive","text":"Overlaps are resolved by moving one or both rigids away from each other. The force with which that resolution happens could be infinite , resulting in what looks like explosions. This release addresses this, by compromising between realism and aesthetics. Before After Editable The behavior can be restored or tweaked further by adjusting the Max Depenetration Velocity attribute of the rigid.","title":"Less Explosive"},{"location":"releases/2021.05.10/#load-on-file-open","text":"There are 3 ways to load Ragdoll. Maya's Plug-in Manager Python's cmds.loadPlugin(\"ragdoll\") Opening a file with Ragdoll in it When Ragdoll is loaded, it appends to a special environment variable Maya uses to look for icons in the Outliner called XBMLANGPATH . Because of course that's what it is called, why do you have that look on your face? Anyway, as it happens, if the Outliner was given a chance to draw icons before Ragdoll added this variable then it'd go ahead and draw a generic, non-pleasant-looking icon like this. This release fixes that. \ud83e\udd70 Before After","title":"Load on File Open"},{"location":"releases/2021.05.10/#upgrade-on-file-open","text":"Like above, there was another issue when loading the plug-in alonside opening of scenes, which had to do with upgrades. Normally, what happens is this. Scene is opened Ragdoll checks to see if any nodes are older than the version you use If they are, it then checks to see whether any of them need upgrading If any are, it upgrades those Scene open complete But since the plug-in is loaded during scene open, Ragdoll wasn't given a chance to check it first. This has now been fixed. Install on Idle This changes the initialisation mechanism somewhat, if this causes any issues for you, set the RAGDOLL_INSTALL_ON_IDLE environment variable to revert to the old behavior. It won't be able to upgrade on scene open unless you load the plug-in first, but that's the only thing you're missing out on.","title":"Upgrade on File Open"},{"location":"releases/2021.05.10/#node-editor-icons","text":"Our precious icons now appear in the node editor too! Before After","title":"Node Editor Icons"},{"location":"releases/2021.05.10/#passive-initial-state","text":"Here's a subtle one. In previous releases, the initial state is automatically updated on the 2 nd frame of the simulation to wherever a rigid was on the 1 st frame. Even if you modified the position interactively with manipulators, or via curves in the Graph Editor, or the channel box, and so on. It even updated when a rigid was affected by passive input, like a Hard Pin, which meant you lost track of the original initial state whenever you disabled the hard pin. This release addresses that by only automatically updating the initial state if a rigid is active on the start frame. Notice how I can disable Hard Pin and have the rigids return to where they were before they got pinnned? It's what you would expect.","title":"Passive Initial State"},{"location":"releases/2021.05.10/#passive-to-active-and-back-again","text":"Ragdoll tries to clean up after itself by removing constraints no longer in use. When a rigid is passive, it can no longer be affected by constraints, so those constraints are deleted. However, active rigids can still be influenced by a passive rigid, and Ragdoll was a little too aggressive in removing those constraints too. This release fixes that.","title":"Passive to Active and Back Again"},{"location":"releases/2021.05.10/#undo-and-attribute-order","text":"Whenever you delete physics and undo , the order in which proxy attributes would appear on your controllers would go all whack. This is basic-Maya, it loves doing this. But now love goes both ways, and we are much happier. \ud83e\udd70 Before After","title":"Undo and Attribute Order"},{"location":"releases/2021.05.10/#control-rendering","text":"Controls give you a preview of what the rigid they control look like. These are special in that Maya doesn't actually need them. Ragdoll doesn't actually need them either. They are exclusively for-your-eyes-only. And due to Maya only updating things it absolutely needs to whenever rendering anything, these won't get updated unless Ragdoll explicitly tells them to. So far, they've been told to update whenever the selection changed, which can end up looking bad. This has now been improved! Before After","title":"Control Rendering"},{"location":"releases/2021.05.10/#fixed-startup-crash","text":"On plug-in load, Ragdoll would check your licence. Under rare circumstances (2 out of 100 users reported it happening) this would be enough to put Maya under, instantly and without warning. This has now been fixed.","title":"Fixed Startup Crash"},{"location":"releases/2021.05.10/#fixed-initial-state","text":"An error was introduced between 2021.04.23 and 2021.04.28 leading to an issue with updating the initial pose via the Channel Box or Graph Editor. This got addressed on the same day and released unofficially as 2021.04.30, and is now officially part of the latest version. Thanks to Niels Dervieux for reporting this bug! Before After","title":"Fixed Initial State"},{"location":"releases/2021.05.10/#fixed-qt","text":"Whenever you clicked Import Physics in the Import Physics Option Window, it would needlessly shout at you. # RuntimeError: Internal C++ object (WidgetHoverFactory) already deleted. No more!","title":"Fixed Qt"},{"location":"releases/2021.05.10/#scene-drawing-in-2019","text":"Maya was misbehaving in 2018-2019, refused to draw the scene visualisation correctly. No longer! Before After","title":"Scene Drawing in 2019"},{"location":"releases/2021.05.17/","text":"Highlight for this release is support for Floating Licences ! ADDED Floating Licence Server Convenient big-studio licencing ADDED Mimic IK Turn mimic into a joint hierarchy, for IK and such IMPROVED Quality of Life More joy for you TIP Bulk Edits Some tips for a happier life Floating Licence Server So far, Ragdoll has been activated on a per-machine basis. It's been node-locked. But in many cases, you are a studio with a team of artists using Ragdoll. That's when it becomes impractical for each artist to manage their own licences, or for licences to become associated with a single machine. Floating licences solve this problem. With it, you register a fixed amount of licences with a server somewhere on your network, and then have Maya \"lease\" licences off of it. For example, with 10 floating licences, 10 artists can use Ragdoll in parallel. On Maya shutdown or plug-in unload, the lease is \"dropped\" meaning it can be picked up by another artist, on some other machine. Heads-up SysAdmins On Windows, the floating licence mechanism is currently a dedicated DLL. This will be merged into the plug-in like on Linux in a future release. See also Floating Licence Documentation Mimic IK The Mimic introduced in the last release generated a clean hierarchy of transforms. This release introduced \"mimik\", which is a joint hierarchy suitable for skinning and IK. It's got a proper Joint Orient too, irregardless of what the original animation controls looked like. They're great if IK is what you want, but they do make the overall hierarchy more complex and introduce an additional jointOrient offset onto the joints themselves. For that reason, Transform is the default node type and is currently the most simple mimic to work with. Room for Improvement There's still room for improvement, the user attributes remain on the blue control nodes rather than the joints themselves for now. This will be addressed in a future release. Quality of Life More quality, less problems. Hacuna matata! Constraint Outliner Style You can now choose how constraints appear in the outliner. Style Result nConstraint At the root of the outliner, as its own transform Maya Constraint As a child transform Ragdoll As a shape The rRigid node appears as a shape of any node you apply physics to, and normally constraints appear alongside them. But normal Maya constraints do not, and neither does the constraints you get with nCloth and nHair. So which do you prefer? Ragdoll Style As a shape, alongside the rRigid node. Maya Constraint Style As a child, similar to native Maya constraints. nConstraint Style As a new transform at the root of the scene, similar to nCloth and nHair constraints. Group them, hide them; if you can imagine it, you can achieve it! Subjective Whichever you prefer, it has no effect on the simulation and is strictly related to the Outliner only. They can also be re-parented after being created, it really doesn't matter where they are. So organise away! Constraint Scale Rendering The last release made constraints render poorly if the node they were parented to was scaled . The simulation was still fine, but you couldn't see what you were doing. Before After Constraint Maintain Offset Constraints typically maintain their offset on creation, such that rigids do not abruptly snap together on simulation start. But it's optional, and if you don't maintain offset then they would snap together. With this release, the default behavior is now soft as opposed to infinitely strong. Installer Improvements On Windows, the MSI installer can now be used to install multiple versions of Ragdoll simultaneously, with a dedicated uninstall option each. This should also help clear out issues with upgrading using the MSI, which has been problematic in the past since the installer really didn't like overwriting files. On all platforms, multiple Maya module files now co-exist, which means that if you want to disable or switch versions you can do that by removing the offending version - rather than editing the text file itself like in previous versions of Ragdoll. Rigid Scale Rendering Rendering of non-uniformly scaled rigid bodies has been improved and now respond interactively to scale changes. Notice in particular how scale is translated into sphere radius only along the X-axis. For non-uniform scale of a sphere, switch to Shape Type = Mesh . Before After Scene Scale The default distance unit in Maya is centimeters. Meaning Translate X=5.0 means \"5 centimeters along the X axis\". And in some cases, characters get modeled by this unit too, to an average height of 160-190cm. But often this unit is ignored and now Ragdoll can too. Default Value Ragdoll has assumed a scene scale of 0.1 so far, meaning 10 centimeters meant 1 meter. That's the typical scale of most rigs, some having smaller - like the Fire Wolf at 0.01 - and some larger - like a real-world scale of 1.0. This value used to be reflected in Gravity Y as 98.2 meaning 98.2 cm/s2 . Which means that an object falling for 1 second would reach a velocity of 98.2 cm/s and keep increasing by the amount each second until reaching terminal velocity. It is now reflected in Scene Scale instead as 0.1. For a real-world scale, simply set this value to 1.0 and leave gravity unchanged. Quick Select The quick-select commands now feature an option to ignore whatever is currently selected. Either select all of a certain type, like rdRigid Or filter current selection by type, like rdRigid Filtering grows more useful as your scenes grow large. When you have e.g. 2 characters and want to edit all constraints in one of them, then filtering is what you're looking for. Bulk Edits The Maya Channel Box is great for editing multiple nodes at once. Select two or more nodes, change an attribute in the Channel Box, and the change is applied to each of the selected nodes at once. Win! But what about attributes that aren't in the Channel Box? Here are 3 ways in which you can bulk-edit a class of Ragdoll nodes in one-go. In each case, I'm using the Ragdoll -> Select menu item to bulk-select all rigid bodies in the scene. 1. Attribute Editor Also known as \"the slow way\". Simply edit each attribute, one at a time. Like watching paint dry. It's slow. 2. Channel Editor All attributes found in the Attribute Editor are also available in the Channel Editor. The most-commonly used ones are already exposed, but you can expose more. 3. Attribute Spreadsheet For total control, irregardless of the Channel Box and with searchability amongst attributes, you can also try the lesser-known Attribute Spreadsheet.","title":"2021.05.17"},{"location":"releases/2021.05.17/#floating-licence-server","text":"So far, Ragdoll has been activated on a per-machine basis. It's been node-locked. But in many cases, you are a studio with a team of artists using Ragdoll. That's when it becomes impractical for each artist to manage their own licences, or for licences to become associated with a single machine. Floating licences solve this problem. With it, you register a fixed amount of licences with a server somewhere on your network, and then have Maya \"lease\" licences off of it. For example, with 10 floating licences, 10 artists can use Ragdoll in parallel. On Maya shutdown or plug-in unload, the lease is \"dropped\" meaning it can be picked up by another artist, on some other machine. Heads-up SysAdmins On Windows, the floating licence mechanism is currently a dedicated DLL. This will be merged into the plug-in like on Linux in a future release. See also Floating Licence Documentation","title":"Floating Licence Server"},{"location":"releases/2021.05.17/#mimic-ik","text":"The Mimic introduced in the last release generated a clean hierarchy of transforms. This release introduced \"mimik\", which is a joint hierarchy suitable for skinning and IK. It's got a proper Joint Orient too, irregardless of what the original animation controls looked like. They're great if IK is what you want, but they do make the overall hierarchy more complex and introduce an additional jointOrient offset onto the joints themselves. For that reason, Transform is the default node type and is currently the most simple mimic to work with. Room for Improvement There's still room for improvement, the user attributes remain on the blue control nodes rather than the joints themselves for now. This will be addressed in a future release.","title":"Mimic IK"},{"location":"releases/2021.05.17/#quality-of-life","text":"More quality, less problems. Hacuna matata!","title":"Quality of Life"},{"location":"releases/2021.05.17/#constraint-outliner-style","text":"You can now choose how constraints appear in the outliner. Style Result nConstraint At the root of the outliner, as its own transform Maya Constraint As a child transform Ragdoll As a shape The rRigid node appears as a shape of any node you apply physics to, and normally constraints appear alongside them. But normal Maya constraints do not, and neither does the constraints you get with nCloth and nHair. So which do you prefer? Ragdoll Style As a shape, alongside the rRigid node. Maya Constraint Style As a child, similar to native Maya constraints. nConstraint Style As a new transform at the root of the scene, similar to nCloth and nHair constraints. Group them, hide them; if you can imagine it, you can achieve it! Subjective Whichever you prefer, it has no effect on the simulation and is strictly related to the Outliner only. They can also be re-parented after being created, it really doesn't matter where they are. So organise away!","title":"Constraint Outliner Style"},{"location":"releases/2021.05.17/#constraint-scale-rendering","text":"The last release made constraints render poorly if the node they were parented to was scaled . The simulation was still fine, but you couldn't see what you were doing. Before After","title":"Constraint Scale Rendering"},{"location":"releases/2021.05.17/#constraint-maintain-offset","text":"Constraints typically maintain their offset on creation, such that rigids do not abruptly snap together on simulation start. But it's optional, and if you don't maintain offset then they would snap together. With this release, the default behavior is now soft as opposed to infinitely strong.","title":"Constraint Maintain Offset"},{"location":"releases/2021.05.17/#installer-improvements","text":"On Windows, the MSI installer can now be used to install multiple versions of Ragdoll simultaneously, with a dedicated uninstall option each. This should also help clear out issues with upgrading using the MSI, which has been problematic in the past since the installer really didn't like overwriting files. On all platforms, multiple Maya module files now co-exist, which means that if you want to disable or switch versions you can do that by removing the offending version - rather than editing the text file itself like in previous versions of Ragdoll.","title":"Installer Improvements"},{"location":"releases/2021.05.17/#rigid-scale-rendering","text":"Rendering of non-uniformly scaled rigid bodies has been improved and now respond interactively to scale changes. Notice in particular how scale is translated into sphere radius only along the X-axis. For non-uniform scale of a sphere, switch to Shape Type = Mesh . Before After","title":"Rigid Scale Rendering"},{"location":"releases/2021.05.17/#scene-scale","text":"The default distance unit in Maya is centimeters. Meaning Translate X=5.0 means \"5 centimeters along the X axis\". And in some cases, characters get modeled by this unit too, to an average height of 160-190cm. But often this unit is ignored and now Ragdoll can too. Default Value Ragdoll has assumed a scene scale of 0.1 so far, meaning 10 centimeters meant 1 meter. That's the typical scale of most rigs, some having smaller - like the Fire Wolf at 0.01 - and some larger - like a real-world scale of 1.0. This value used to be reflected in Gravity Y as 98.2 meaning 98.2 cm/s2 . Which means that an object falling for 1 second would reach a velocity of 98.2 cm/s and keep increasing by the amount each second until reaching terminal velocity. It is now reflected in Scene Scale instead as 0.1. For a real-world scale, simply set this value to 1.0 and leave gravity unchanged.","title":"Scene Scale"},{"location":"releases/2021.05.17/#quick-select","text":"The quick-select commands now feature an option to ignore whatever is currently selected. Either select all of a certain type, like rdRigid Or filter current selection by type, like rdRigid Filtering grows more useful as your scenes grow large. When you have e.g. 2 characters and want to edit all constraints in one of them, then filtering is what you're looking for.","title":"Quick Select"},{"location":"releases/2021.05.17/#bulk-edits","text":"The Maya Channel Box is great for editing multiple nodes at once. Select two or more nodes, change an attribute in the Channel Box, and the change is applied to each of the selected nodes at once. Win! But what about attributes that aren't in the Channel Box? Here are 3 ways in which you can bulk-edit a class of Ragdoll nodes in one-go. In each case, I'm using the Ragdoll -> Select menu item to bulk-select all rigid bodies in the scene.","title":"Bulk Edits"},{"location":"releases/2021.05.17/#1-attribute-editor","text":"Also known as \"the slow way\". Simply edit each attribute, one at a time. Like watching paint dry. It's slow.","title":"1. Attribute Editor"},{"location":"releases/2021.05.17/#2-channel-editor","text":"All attributes found in the Attribute Editor are also available in the Channel Editor. The most-commonly used ones are already exposed, but you can expose more.","title":"2. Channel Editor"},{"location":"releases/2021.05.17/#3-attribute-spreadsheet","text":"For total control, irregardless of the Channel Box and with searchability amongst attributes, you can also try the lesser-known Attribute Spreadsheet.","title":"3. Attribute Spreadsheet"},{"location":"releases/2021.06.07/","text":"Highlight for this release is minor bugfixes , in preparation for launch. FIXED Broken Scale The arch-nemesis has been slain once again FIXED Zero Length Spheres On rare occasions could your chain tips end up with a zero size FIXED Crash on Playback No more of these, be gone! IMPROVED Referenced Dynamics More visual aids when working with referenced physics Development Status It's been almost a month, and this is all you have to show for it? Yes! The past few weeks has been \"Less C++, more HTML\". The website is getting an overhaul, along with documentation and tutorials. Stay tuned, and for early access users: keep on reporting any issues you encounter! Broken Scale Sometimes, when animation controls has been scaled the default values and drawing of rigids and constraints did not look right. This has now been fixed. Before As you can see, the rigids are far away from their control, and the constraint visualisation is all whack. These are exactly 10x wrong, which is how scaled the top-level group is. After Thanks to @mariia for reporting this issue! Zero Length Spheres When making a chain for a tail, there was a specific circumstance that could trip-up Ragdoll when trying to figure out how large to make the tip of that tail, resulting in a rigid body of zero length and width. These don't simulate well and didn't communicate that it had happened. This has now been fixed! Thanks to Amedeo Beretta for reporting this issue! Crash on Playback The previous release intoduced interactive re-generation of rigid body meshes when scaling. It was really neat! Unfortunately, the Maya feature used to support this feature had a critical fault in Maya 2020. Leaving mention of the culprit here should anyone surf the interwebs and arrive to at similar fate. MDagMessage::addWorldMatrixModifiedCallback() As such, in order to scale a rigid body of Shape Type = Mesh you must trigger a rebuild. The simplest way of doing that at the time of this writing is to jiggle the vertex limit. Other options include: Edit the geometry, e.g. move a vertex Edit the topology, e.g. subdivide and undo Disconnect/reconnect mesh from the rdRigid node Delete the rigid and undo Re-open the scene Referenced Physics When referencing another file, the nodes are \"locked\". Meaning they have some restrictions on what you can do with them, like not being able to delete them. Ragdoll would happily attempt to delete these but not tell you that it had failed. It simply isn't allowed to do it. This release communicates this to you. It also applies to deletion happening indirectly , such that when you want physics removed after baking.","title":"2021.06.07"},{"location":"releases/2021.06.07/#development-status","text":"It's been almost a month, and this is all you have to show for it? Yes! The past few weeks has been \"Less C++, more HTML\". The website is getting an overhaul, along with documentation and tutorials. Stay tuned, and for early access users: keep on reporting any issues you encounter!","title":"Development Status"},{"location":"releases/2021.06.07/#broken-scale","text":"Sometimes, when animation controls has been scaled the default values and drawing of rigids and constraints did not look right. This has now been fixed. Before As you can see, the rigids are far away from their control, and the constraint visualisation is all whack. These are exactly 10x wrong, which is how scaled the top-level group is. After Thanks to @mariia for reporting this issue!","title":"Broken Scale"},{"location":"releases/2021.06.07/#zero-length-spheres","text":"When making a chain for a tail, there was a specific circumstance that could trip-up Ragdoll when trying to figure out how large to make the tip of that tail, resulting in a rigid body of zero length and width. These don't simulate well and didn't communicate that it had happened. This has now been fixed! Thanks to Amedeo Beretta for reporting this issue!","title":"Zero Length Spheres"},{"location":"releases/2021.06.07/#crash-on-playback","text":"The previous release intoduced interactive re-generation of rigid body meshes when scaling. It was really neat! Unfortunately, the Maya feature used to support this feature had a critical fault in Maya 2020. Leaving mention of the culprit here should anyone surf the interwebs and arrive to at similar fate. MDagMessage::addWorldMatrixModifiedCallback() As such, in order to scale a rigid body of Shape Type = Mesh you must trigger a rebuild. The simplest way of doing that at the time of this writing is to jiggle the vertex limit. Other options include: Edit the geometry, e.g. move a vertex Edit the topology, e.g. subdivide and undo Disconnect/reconnect mesh from the rdRigid node Delete the rigid and undo Re-open the scene","title":"Crash on Playback"},{"location":"releases/2021.06.07/#referenced-physics","text":"When referencing another file, the nodes are \"locked\". Meaning they have some restrictions on what you can do with them, like not being able to delete them. Ragdoll would happily attempt to delete these but not tell you that it had failed. It simply isn't allowed to do it. This release communicates this to you. It also applies to deletion happening indirectly , such that when you want physics removed after baking.","title":"Referenced Physics"},{"location":"releases/2021.06.10/","text":"Highlight for this release is telemetry . ADDED Telemetry Anonymous usage statistics for focused development FIXED Fractional Start Time This could cause a nasty crash FIXED Suspend on Bake Faster baking now that this works! FIXED More Resilient Constraint Rendering Optimised and less noisy Telemetry Ragdoll is now able to gather usage statistics so that I can strip menu items that aren't used, pay more attention to the ones that are and get an overall understanding of how Ragdoll performs out in the wild. FAQ What is telemetry? It's the term coined for gathering anonymous usage statistics and send it to a product vendor for a greater understanding of how their product is used. Do I need it? No, this won't help you. Not directly. But it will help you and others indirectly, in that it allows me to spend more time on features you use, and less time on those you don't. What does it collect? Mostly performance numbers, nothing personal. See Data below. How is it collected? Mostly through C++, but some of it through Python. You can read about exactly what it does in telemetry.py What if I'm offline? Then the file will still be written to your home directory, and you'd be welcome to email it at your own leisure to telemetry@ragdolldynamics.com Opt-in It is currently opt-in while I work out the kinks, so if you're interested in helping out put this in your maya.env or type it into your script editor before loading the plug-in. Maya.env RAGDOLL_TELEMETRY = Yes Script Editor os . environ [ \"RAGDOLL_TELEMETRY\" ] = \"Yes\" Data Data is gathered and stored in 2 places. Locally at ~/.ragdoll/telemetry_10-06-2021-100402.json Remotely at the Ragdoll database It is gathered and stored when Maya closes. Or more precisely, when the plug-in is unloaded. Here's what the complete data currently looks like. ~/.ragdoll/telemetry_10-06-2021-100402 { \"maya\" : { \"crashed\" : false , \"version\" : 20200200 , \"errors\" : 0 , \"warnings\" : 0 }, \"system\" : { \"time\" : \"10-06-2021, 10:04:39\" , \"memory_cpu\" : \"31010.8 MB\" , \"machine\" : \"AMD64\" , \"memory_gpu\" : \"24576 MB\" , \"gpu\" : \"GeForce RTX 3090/PCIe/SSE2\" , \"os\" : \"win32\" , \"processor\" : \"AMD64 Family 23 Model 49 Stepping 0, AuthenticAMD\" , \"render_api\" : \"OpenGL V.4.6\" }, \"ragdoll\" : { \"simulationTimeMax\" : 1.2327 , \"computeTimeMax\" : 1.6763 , \"setupTimeMin\" : 0.301 , \"computeTimeMin\" : 0.7595 , \"setupTimeMax\" : 0.4756 , \"simulationTimeMin\" : 0.4697 , \"rigidCountMax\" : 15 , \"constraintCountMax\" : 16 , \"version\" : 20210606 , \"computeTimeAvg\" : 0.949111823737213 , \"simulationTimeAvg\" : 0.597494786145304 , \"setupTimeAvg\" : 0.25006875 , \"rigidCountMin\" : 15 , \"constraintCountMin\" : 16 } } This was generated from that throbbing heart simulation above. There are currently 3 categories of data gathered. \"maya\" As you can see, it'll capture how many errors and warnings were emitted from the plug-in whilst the plug-in was loaded. It'll also include whether Maya crashed the last time Ragdoll was loaded. Ragdoll's goal is to keep crashes at 0. \"system\" It'll also include system information such that I know how restrained to keep Ragdoll, both in terms of memory and CPU power. If everyone's running on an integrated Intel chip, then Ragdoll simply wouldn't try to benefit from the GPU that much. These numbers also help put the next category into perspective. \"ragdoll\" The ragdoll category is perhaps the most interesting, as it sheds light on how much you are willing to suffer haha! Ragdoll is a real-time solver and is designed to be operated without waiting. So if I see these numbers climb too high, I'll crank up the number of optimisations to bring them back down again. Simple! Roadmap There will be a publicly available website for this information - with graphs and charts - such that we can all witness just how fast Ragdoll is and get some perspective on the kind of workload it typically deals with. From this overview, development can then focus on exactly those. Fractional Start Time You wouldn't normally set your start time to 0.8 or 16.351 , but it can happen whether you like it or not if e.g. physics was made in one scene and later referenced into another with differing frame rates. Such as 24 fps in one, and 30 fps in another. If that happened, then best case your simulation flickers on the first frame, worst case you're looking at a fatal crash. Why? In this illustration, you can see how the simulation ( blue ) progresses alongside time ( red ). As we reach just beyond a whole frame, such as 1.1, you'll notice how the simulation immediately fills in that whole frame; even though we haven't actually reached the end yet! The result is a simulation that operates on incomplete information. Your animation at frame 1.1 is not where it is at frame 2 . In this release, here's what happens instead. Now we're only simulating once we've actually reached a whole frame step. Your animation has reached the full pose at that frame and that's what will be used to compute the simulation. As you would expect. Does this mean I can playback in fractional frames? Not yet, simulation happens on whole frames and won't output anything until the next whole frame. At a later date, fractional frames will be automatically interpolated, similar to when you bake a simulation and set keys to linear . This isn't typically useful for animation, but can help with motion blur during the rendering of fast-moving objects; especially spinning objects like propellers and wheels. That said, you can achieve some pretty surreal effects with this. :D Stay tuned for real-time interpolation, and do let me know if this is something you're interested in. Thanks to Amedeo Beretta for spotting this issue! Suspend on Bake Baking is fast and light with the default option for disabling the viewport as it runs, but should you also opt to delete physics once baking is complete you would find suspension to have no effect. :( This was due to deletion of physics also suspending the viewport as it deletes things and - wanting to be helpful - went ahead and resumed rendering of the viewport before baking got a chance to get started. This has now been fixed. Speed! 0.51 seconds versus 0.13 seconds, a 4x speedup! More Resilient Constraint Rendering You are unlikely to end up with zero scaled things, but if you do you could also run into visual flicker like this. Before After Not only is this gone, it's fast too. It is as fast as though the constraints were never visible to begin with, giving you another option for hiding them. Scaling them down. Hah!","title":"2021.06.10"},{"location":"releases/2021.06.10/#telemetry","text":"Ragdoll is now able to gather usage statistics so that I can strip menu items that aren't used, pay more attention to the ones that are and get an overall understanding of how Ragdoll performs out in the wild.","title":"Telemetry"},{"location":"releases/2021.06.10/#faq","text":"What is telemetry? It's the term coined for gathering anonymous usage statistics and send it to a product vendor for a greater understanding of how their product is used. Do I need it? No, this won't help you. Not directly. But it will help you and others indirectly, in that it allows me to spend more time on features you use, and less time on those you don't. What does it collect? Mostly performance numbers, nothing personal. See Data below. How is it collected? Mostly through C++, but some of it through Python. You can read about exactly what it does in telemetry.py What if I'm offline? Then the file will still be written to your home directory, and you'd be welcome to email it at your own leisure to telemetry@ragdolldynamics.com","title":"FAQ"},{"location":"releases/2021.06.10/#opt-in","text":"It is currently opt-in while I work out the kinks, so if you're interested in helping out put this in your maya.env or type it into your script editor before loading the plug-in. Maya.env RAGDOLL_TELEMETRY = Yes Script Editor os . environ [ \"RAGDOLL_TELEMETRY\" ] = \"Yes\"","title":"Opt-in"},{"location":"releases/2021.06.10/#data","text":"Data is gathered and stored in 2 places. Locally at ~/.ragdoll/telemetry_10-06-2021-100402.json Remotely at the Ragdoll database It is gathered and stored when Maya closes. Or more precisely, when the plug-in is unloaded. Here's what the complete data currently looks like. ~/.ragdoll/telemetry_10-06-2021-100402 { \"maya\" : { \"crashed\" : false , \"version\" : 20200200 , \"errors\" : 0 , \"warnings\" : 0 }, \"system\" : { \"time\" : \"10-06-2021, 10:04:39\" , \"memory_cpu\" : \"31010.8 MB\" , \"machine\" : \"AMD64\" , \"memory_gpu\" : \"24576 MB\" , \"gpu\" : \"GeForce RTX 3090/PCIe/SSE2\" , \"os\" : \"win32\" , \"processor\" : \"AMD64 Family 23 Model 49 Stepping 0, AuthenticAMD\" , \"render_api\" : \"OpenGL V.4.6\" }, \"ragdoll\" : { \"simulationTimeMax\" : 1.2327 , \"computeTimeMax\" : 1.6763 , \"setupTimeMin\" : 0.301 , \"computeTimeMin\" : 0.7595 , \"setupTimeMax\" : 0.4756 , \"simulationTimeMin\" : 0.4697 , \"rigidCountMax\" : 15 , \"constraintCountMax\" : 16 , \"version\" : 20210606 , \"computeTimeAvg\" : 0.949111823737213 , \"simulationTimeAvg\" : 0.597494786145304 , \"setupTimeAvg\" : 0.25006875 , \"rigidCountMin\" : 15 , \"constraintCountMin\" : 16 } } This was generated from that throbbing heart simulation above. There are currently 3 categories of data gathered. \"maya\" As you can see, it'll capture how many errors and warnings were emitted from the plug-in whilst the plug-in was loaded. It'll also include whether Maya crashed the last time Ragdoll was loaded. Ragdoll's goal is to keep crashes at 0. \"system\" It'll also include system information such that I know how restrained to keep Ragdoll, both in terms of memory and CPU power. If everyone's running on an integrated Intel chip, then Ragdoll simply wouldn't try to benefit from the GPU that much. These numbers also help put the next category into perspective. \"ragdoll\" The ragdoll category is perhaps the most interesting, as it sheds light on how much you are willing to suffer haha! Ragdoll is a real-time solver and is designed to be operated without waiting. So if I see these numbers climb too high, I'll crank up the number of optimisations to bring them back down again. Simple!","title":"Data"},{"location":"releases/2021.06.10/#roadmap","text":"There will be a publicly available website for this information - with graphs and charts - such that we can all witness just how fast Ragdoll is and get some perspective on the kind of workload it typically deals with. From this overview, development can then focus on exactly those.","title":"Roadmap"},{"location":"releases/2021.06.10/#fractional-start-time","text":"You wouldn't normally set your start time to 0.8 or 16.351 , but it can happen whether you like it or not if e.g. physics was made in one scene and later referenced into another with differing frame rates. Such as 24 fps in one, and 30 fps in another. If that happened, then best case your simulation flickers on the first frame, worst case you're looking at a fatal crash. Why? In this illustration, you can see how the simulation ( blue ) progresses alongside time ( red ). As we reach just beyond a whole frame, such as 1.1, you'll notice how the simulation immediately fills in that whole frame; even though we haven't actually reached the end yet! The result is a simulation that operates on incomplete information. Your animation at frame 1.1 is not where it is at frame 2 . In this release, here's what happens instead. Now we're only simulating once we've actually reached a whole frame step. Your animation has reached the full pose at that frame and that's what will be used to compute the simulation. As you would expect. Does this mean I can playback in fractional frames? Not yet, simulation happens on whole frames and won't output anything until the next whole frame. At a later date, fractional frames will be automatically interpolated, similar to when you bake a simulation and set keys to linear . This isn't typically useful for animation, but can help with motion blur during the rendering of fast-moving objects; especially spinning objects like propellers and wheels. That said, you can achieve some pretty surreal effects with this. :D Stay tuned for real-time interpolation, and do let me know if this is something you're interested in. Thanks to Amedeo Beretta for spotting this issue!","title":"Fractional Start Time"},{"location":"releases/2021.06.10/#suspend-on-bake","text":"Baking is fast and light with the default option for disabling the viewport as it runs, but should you also opt to delete physics once baking is complete you would find suspension to have no effect. :( This was due to deletion of physics also suspending the viewport as it deletes things and - wanting to be helpful - went ahead and resumed rendering of the viewport before baking got a chance to get started. This has now been fixed. Speed! 0.51 seconds versus 0.13 seconds, a 4x speedup!","title":"Suspend on Bake"},{"location":"releases/2021.06.10/#more-resilient-constraint-rendering","text":"You are unlikely to end up with zero scaled things, but if you do you could also run into visual flicker like this. Before After Not only is this gone, it's fast too. It is as fast as though the constraints were never visible to begin with, giving you another option for hiding them. Scaling them down. Hah!","title":"More Resilient Constraint Rendering"},{"location":"releases/2021.07.02/","text":"Highlight for this release is quality of life . ADDED Replace Mesh Swap one mesh for another ADDED Freeze Evaluation Optimise performance by excluding nodes from evaluation ADDED Scene Management Extract, move and merge rigids across scenes ADDED Ignore Contact Constraint Surgical control over which rigid two interacts with each other ADDED Bake Selected Scenes Limit bake to one or more scenes ADDED Multi-mesh Shapes Mesh, Curve and Surface, as one? FIXED Edit Constraint and Chain Connection to Pose Strength is now preserved FIXED Constraints and Focus F-key no longer blows you away FIXED Skinweight Painting No long an issue! FIXED Referenced Physics Can now be mixed with new physics FIXED Two Users, One Machine More capable of rare production occurrences FIXED Export Initialisation You can now export without first playing back FIXED Center Of Mass Visualisation This vanished, and is now back! FIXED Something Went Wrong Less of these pesky errors FIXED More Accurate Auto Mass 1x1x1m = 1,000kg, as god intended Showcase In preparation for the upcoming website, there are 4 new animations in progress. Here's just a taste. :) Replace Mesh When you turn a mesh dynamic, the vertices are plugged into the rigid node. mesh nodes plug into rdRigid.inputMesh nurbsCurve nodes plug into rdRigid.inputCurve nurbsSurface nodes plug into rdRigid.inputSurface But what if you wanted a different mesh? What if there was no mesh, such as for a joint or empty transform? I give you, Replace Mesh . \ud83d\udc4f Here's a more practical example, of a dynamic joint being replaced with the mesh of a car wheel. Freeze Evaluation Rigid bodies have an Enabled state to exclude it from a simulation, but it will still partake in most evaluation and still cost precious CPU cycles. In Maya 2016, an attribute was introduced for exclude nodes from Parallel Evaluation called .frozen . Ragdoll now supports this attribute to a limited extent. This operation is completely non-destructive and affects nothing but the nodes you select. Important The more you freeze, the more performance you gain, and that includes Maya's native nodes . So go ahead and freeze the controls as well. Caveat The optimisations are coming from deep within Maya and is mostly outside of our control. And it isn't perfect. How Maya chooses to evaluate nodes is sometimes a mystery, and sometimes even frozen nodes get included in evaluation. For the technically minded, you can read more about the attribute and behavior here. https://download.autodesk.com/us/company/files/UsingParallelMaya/2020/UsingParallelMaya.html#frozen-evaluator Scene Management Sometimes, you find yourself with rigid bodies that could run separately, in parallel. Either for performance, or because they could benefit from independent solver settings like iterations and substeps, or time scale and more. Now you can extract rigid bodies from one scene into a new scene, akin to extracting polygons from one mesh into another. Extract Move one or more rigids out of one scene, and into another. Move Move one rigid between two scenes. Merge Collapse two or more scenes into the first-selected scene. Constraints For constraints to work, both rigids must be in the same scene and currently extracting only one rigid from a constrained pair would break the constraint. In a later version, the rigid will automatically become a Passive rigid in the extracted scene, such that it can still be constrained albeit indirectly. This will enable you to extract parts of a simulation, like muscle and cloth, from an overall dynamic character without breaking anything. Ignore Contact Constraint You can now select two rigids and say \"Hey, ignore each other, ok?\" Technically, this is just a constraint but with both the Limit and Guide disabled, and Allow Overlap kept enabled. Bake Selected Scenes The Bake Simulation tool now allows you to bake either all or selected scenes. Multi-mesh Shapes The rdRigid node has an attribute called .inputMesh which takes a normal Maya mesh, like a polyCube, and turns it into a volume suitable for simulation. It's also got a .inputCurve and .inputSurface attribute, to treat NURBS curves and surfaces in the same way. Until now, only one of these could be connected at a time. Connecting to one when another was already connected would lead to undefined behavior. In this release, the behavior is defined! If you want two meshes, you can have'm! Edit Constraint and Chain When you make a chain, attributes from rigids and constraints are mapped to the original animation control as attributes. When you then want to edit the constraint pivot of any of those constraints, it would overwrite that connection so as to make it easier/possible to edit values directly from the locators that appear representing the pivots. This no longer breaks your connections, at the expense of having to edit values on the original constraints instead. This will be addressed in a future release, once we get a proper manipulator in place instead of the makeshift Maya transform. Constraints and Focus The F-key zooms and centers and object in the viewport. But trying that on constraints would have you flying through the cosmos until NaN appears in your channel box. Before After Skinweight Painting Any joint with a shape causes the right-click menu to stop working. It's typical Maya, and has been the case for years. Ragdoll nodes are mostly shapes of the control they drive, including joints. As a result, you weren't able to right-click on a dynamic joint to select its skinweights.. Before After Referenced Physics The previous releases tried adding any new physics added to a referenced physics scene, but was unable to! This release fixes that. Two Users, One Machine When Ragdoll starts for the first time, a file is written into your temp-directory. The undo plug-in for cmdx . The file is written using the permissions of the currently logged on user and cannot be touched by anyone else. When another user logs in to the same machine, Ragdoll will attempt to overwrite this file but cannot! It doesn't have permission! The result is a limit of 1 user able to leverage Ragdoll per machine. And that's no good. This release fixes that! Export Initialisation If you author physics and immediately export, without playing back, the results could be incomplete. \ud83e\udd14 The reason is that Maya only evaluates what it has to, and until you actually run the simulation a lot of things are left unevaluated. To Ragdoll, it's as if they never existed in the first place. This has now been fixed. Center Of Mass Visualisation With the recent upgrade and performance improvements to rendering, a small but necessary visualisation feature of the rigid bodies was the COM or center of mass. This has now been restored! Something Went Wrong The order in which Maya evaluates Ragdoll nodes is important, and whenever it tries doing that in some unexpected way it'll tell you. # Warning: ragdoll._on_cycle() - Something is not right! The reason it happens is difficult to say. The evaluation order is something Maya dynamically generates on the first frame of your animation, and it's based on the way nodes are connected. Cycles are the most common culprit. Ragdoll cannot stand cycles. But another reason was discovered in this release which was that when you constrain A to B but then delete B, A is left constrained to a broken constraint. This could throw off evaluation, and break the scene. This particular situation has now been fixed! More Accurate Auto Mass Rigid bodies have an option to have their masses automatically computed from their initial shape. This value was 10,000x wrong, and is now roughly 1-2x wrong. It is 100% accurate for boxes, but diverges from there as it does not take into account the negative volume within its bounding box. Choose Density Be like water, my friend. Responds to Scale The computed mass will respect the size of the object, and the overall scene scale. Important Remember that large mass differences between two rigids that interact can result in instabilities. In the real world, an object with the density of air under a much heavier object with the density of water would crumble . However, it cannot do that here. Instead, it will bounce around and act unnaturally. The recommended max difference is 10x . E.g. one rigid can weigh 10 kg, whereas the other can weigh 100 kg. That's at the edge of what the solver (and the real-world) considers manageable.","title":"2021.07.02"},{"location":"releases/2021.07.02/#showcase","text":"In preparation for the upcoming website, there are 4 new animations in progress. Here's just a taste. :)","title":"Showcase"},{"location":"releases/2021.07.02/#replace-mesh","text":"When you turn a mesh dynamic, the vertices are plugged into the rigid node. mesh nodes plug into rdRigid.inputMesh nurbsCurve nodes plug into rdRigid.inputCurve nurbsSurface nodes plug into rdRigid.inputSurface But what if you wanted a different mesh? What if there was no mesh, such as for a joint or empty transform? I give you, Replace Mesh . \ud83d\udc4f Here's a more practical example, of a dynamic joint being replaced with the mesh of a car wheel.","title":"Replace Mesh"},{"location":"releases/2021.07.02/#freeze-evaluation","text":"Rigid bodies have an Enabled state to exclude it from a simulation, but it will still partake in most evaluation and still cost precious CPU cycles. In Maya 2016, an attribute was introduced for exclude nodes from Parallel Evaluation called .frozen . Ragdoll now supports this attribute to a limited extent. This operation is completely non-destructive and affects nothing but the nodes you select. Important The more you freeze, the more performance you gain, and that includes Maya's native nodes . So go ahead and freeze the controls as well. Caveat The optimisations are coming from deep within Maya and is mostly outside of our control. And it isn't perfect. How Maya chooses to evaluate nodes is sometimes a mystery, and sometimes even frozen nodes get included in evaluation. For the technically minded, you can read more about the attribute and behavior here. https://download.autodesk.com/us/company/files/UsingParallelMaya/2020/UsingParallelMaya.html#frozen-evaluator","title":"Freeze Evaluation"},{"location":"releases/2021.07.02/#scene-management","text":"Sometimes, you find yourself with rigid bodies that could run separately, in parallel. Either for performance, or because they could benefit from independent solver settings like iterations and substeps, or time scale and more. Now you can extract rigid bodies from one scene into a new scene, akin to extracting polygons from one mesh into another. Extract Move one or more rigids out of one scene, and into another. Move Move one rigid between two scenes. Merge Collapse two or more scenes into the first-selected scene. Constraints For constraints to work, both rigids must be in the same scene and currently extracting only one rigid from a constrained pair would break the constraint. In a later version, the rigid will automatically become a Passive rigid in the extracted scene, such that it can still be constrained albeit indirectly. This will enable you to extract parts of a simulation, like muscle and cloth, from an overall dynamic character without breaking anything.","title":"Scene Management"},{"location":"releases/2021.07.02/#ignore-contact-constraint","text":"You can now select two rigids and say \"Hey, ignore each other, ok?\" Technically, this is just a constraint but with both the Limit and Guide disabled, and Allow Overlap kept enabled.","title":"Ignore Contact Constraint"},{"location":"releases/2021.07.02/#bake-selected-scenes","text":"The Bake Simulation tool now allows you to bake either all or selected scenes.","title":"Bake Selected Scenes"},{"location":"releases/2021.07.02/#multi-mesh-shapes","text":"The rdRigid node has an attribute called .inputMesh which takes a normal Maya mesh, like a polyCube, and turns it into a volume suitable for simulation. It's also got a .inputCurve and .inputSurface attribute, to treat NURBS curves and surfaces in the same way. Until now, only one of these could be connected at a time. Connecting to one when another was already connected would lead to undefined behavior. In this release, the behavior is defined! If you want two meshes, you can have'm!","title":"Multi-mesh Shapes"},{"location":"releases/2021.07.02/#edit-constraint-and-chain","text":"When you make a chain, attributes from rigids and constraints are mapped to the original animation control as attributes. When you then want to edit the constraint pivot of any of those constraints, it would overwrite that connection so as to make it easier/possible to edit values directly from the locators that appear representing the pivots. This no longer breaks your connections, at the expense of having to edit values on the original constraints instead. This will be addressed in a future release, once we get a proper manipulator in place instead of the makeshift Maya transform.","title":"Edit Constraint and Chain"},{"location":"releases/2021.07.02/#constraints-and-focus","text":"The F-key zooms and centers and object in the viewport. But trying that on constraints would have you flying through the cosmos until NaN appears in your channel box. Before After","title":"Constraints and Focus"},{"location":"releases/2021.07.02/#skinweight-painting","text":"Any joint with a shape causes the right-click menu to stop working. It's typical Maya, and has been the case for years. Ragdoll nodes are mostly shapes of the control they drive, including joints. As a result, you weren't able to right-click on a dynamic joint to select its skinweights.. Before After","title":"Skinweight Painting"},{"location":"releases/2021.07.02/#referenced-physics","text":"The previous releases tried adding any new physics added to a referenced physics scene, but was unable to! This release fixes that.","title":"Referenced Physics"},{"location":"releases/2021.07.02/#two-users-one-machine","text":"When Ragdoll starts for the first time, a file is written into your temp-directory. The undo plug-in for cmdx . The file is written using the permissions of the currently logged on user and cannot be touched by anyone else. When another user logs in to the same machine, Ragdoll will attempt to overwrite this file but cannot! It doesn't have permission! The result is a limit of 1 user able to leverage Ragdoll per machine. And that's no good. This release fixes that!","title":"Two Users, One Machine"},{"location":"releases/2021.07.02/#export-initialisation","text":"If you author physics and immediately export, without playing back, the results could be incomplete. \ud83e\udd14 The reason is that Maya only evaluates what it has to, and until you actually run the simulation a lot of things are left unevaluated. To Ragdoll, it's as if they never existed in the first place. This has now been fixed.","title":"Export Initialisation"},{"location":"releases/2021.07.02/#center-of-mass-visualisation","text":"With the recent upgrade and performance improvements to rendering, a small but necessary visualisation feature of the rigid bodies was the COM or center of mass. This has now been restored!","title":"Center Of Mass Visualisation"},{"location":"releases/2021.07.02/#something-went-wrong","text":"The order in which Maya evaluates Ragdoll nodes is important, and whenever it tries doing that in some unexpected way it'll tell you. # Warning: ragdoll._on_cycle() - Something is not right! The reason it happens is difficult to say. The evaluation order is something Maya dynamically generates on the first frame of your animation, and it's based on the way nodes are connected. Cycles are the most common culprit. Ragdoll cannot stand cycles. But another reason was discovered in this release which was that when you constrain A to B but then delete B, A is left constrained to a broken constraint. This could throw off evaluation, and break the scene. This particular situation has now been fixed!","title":"Something Went Wrong"},{"location":"releases/2021.07.02/#more-accurate-auto-mass","text":"Rigid bodies have an option to have their masses automatically computed from their initial shape. This value was 10,000x wrong, and is now roughly 1-2x wrong. It is 100% accurate for boxes, but diverges from there as it does not take into account the negative volume within its bounding box. Choose Density Be like water, my friend. Responds to Scale The computed mass will respect the size of the object, and the overall scene scale. Important Remember that large mass differences between two rigids that interact can result in instabilities. In the real world, an object with the density of air under a much heavier object with the density of water would crumble . However, it cannot do that here. Instead, it will bounce around and act unnaturally. The recommended max difference is 10x . E.g. one rigid can weigh 10 kg, whereas the other can weigh 100 kg. That's at the edge of what the solver (and the real-world) considers manageable.","title":"More Accurate Auto Mass"},{"location":"releases/2021.07.15/","text":"Highlight for this release is improved Rotate Pivot support. FIXED Rotate Pivot Now smooth like butter! FIXED Re-scale Scaling after making something dynamic FIXED Single Joint Shapes Rare edgecase of dynamic solo joints FIXED Passive Constraints Another rare edgecase in complex animations now fixed FIXED Bake Static Rigids Annoying mistake by Mr. Baker now fixed FIXED Unique Names Regression from previous release, squashed! ADDED Scene Tolerance Support for mega-tiny and super-massive simulations IMPROVED Limit Visualisation Now with colors! Rotate Pivot In a previous release support for the .rotatePivot attribute was added. But it was only partial. It only applied to solo rigid bodies, like the one in that example. Once rigids form a hierarchy, things get more complex, but also more realistic . A lot of character rigs make use of it, some even going as far as to leave NURBS controls at the origin, moving the CVs to where the character is and compensating with the .rotatePivot to make it appear in the right place. This didn't gel with Ragdoll, who uses the center of a control to determine how to draw chains. What is this \"rotate pivot\"? Just so we're all on the same page, here's me creating a control by moving the rotate pivot and CVs rather than translating/rotating the node. Notice how I'm not actually moving it to the hip, but rather hold the D -key and move the rotate pivot. Then I'm moving the CVs to where the rotate pivot is to make it both act and appear at the hip. Why would anyone do this? Hah! Yes that was my thought too! As you can see, to make this work you really have to work at it. My guess is this isn't something riggers do by hand but rather via scripting. Done that way, you don't really notice how odd it is. Either way, there are rigs out there that works like this and it shouldn't limit your use of Ragdoll. Next, I'll repeat this process for each of my controls. Pay special attention to how all of my controls are still technically at the origin. Their rotate/translate channels are all zero. Let's have a look at what the current version of Ragdoll does in this situation. Before Notice how nothing appears! That's because Ragdoll tried figuring out where to generate capsules and how large to make them based on the center of each control. But! The controls are all at the origin . They lie there, right on top of each other, with zero distance from each other. So Ragdoll does what it thinks you want. It generates a series of rigid bodies at the origin with 0 size. When what you really meant was for it to use the center plus this \"rotate pivot\". After This release recognises this, here's what it looks like now. Win! Re-scale Sometimes you're experimenting and aren't quite sure that the scale of an object is what you'd like it to be until you see it in action. Currently, whenever you make something dynamic it'll use the current scale of the NURBS curve or mesh as part of the collision geometry. But! If you change the size after making it dynamic, Ragdoll won't know about that. This was especially damning for geometry that needed to be tesselated, namely the Mesh shape type. The most convenient way of refreshing that was to edit the .shapeVertexLimit attribute, forcing a re-tesselation. That's because Ragdoll cannot know when you resize something. You have to explicitly say you did. That is, until now. Caveat It still isn't perfect. Ragdoll still cannot know when you scale the object. Instead, it queries the current scale on the 1 st frame of the simulation, which means it won't actually recognise a new scale until the 2 nd playthrough . That's because once the simulation starts, the initial state is automatically set. Only then can it know that scale has changed, but by then it is too late! Simulation has already begun. So instead, the change is picked up on the next playthrough. Of course manually setting the initial state (via the Rigging sub-menu) or re-opening the scene will have the same effect so you really shouldn't have to struggle with this in practice. Scene Tolerance Ragdoll assumes you're working with human characters in centimeters, meaning a value of 170 means 170 cm and 0.1 cm is a small distance. If that's true, then you typically won't have to worry about \"tolerances\". But if you're characters are 17,000 units tall or 0.017 units short odd things start to happen. Notice how it initially slides around for no apparent reason? In this case, the cube is much smaller than Ragdoll expects and we can address this by decreasing the global scene scale. Likewise, for very large cubes you will notice similar artifacts. For that, you'd increase the scale. Currently, there exists a Scene Scale on the solver node, which is saved in your scene, and a Scene Scale in the global preferences which is not. The intention is for global scene scale to rarely change, to change alongside a studio's or project's convention, whereas the solver scene scale is more flexible. The default value is 10.0 but it's possible smaller values such as 0.1 is better suited. It's also possible they both belong under global preferences. Give this a try and let me know what you think. Limit Visualisation There are two kinds of limits; twist and swing. Twist is great for hinge-like limits, like knees and elbows, whereas swing is great for more complex 2D limits like shoulders and hips. The current position of a rigid body in terms of swing and twist have always been drawn as a green/red line, but it could sometimes be hard to know which was which. If the red line starts out in the twist limit, then Ragdoll will promptly snap it back into the swing limit. This release colors the twist and swing shapes using the same colors as the current twist and swing axes, making it just a tad easier to see which belongs where. Before After Also notice how the twist axis is now confined into the twist shape itself, making it just a bit more clear how close it is to colliding with that limit. Here's a more complete example of a full set of constraints. Unique Names Prior to a recent release, all new nodes generated by Ragdoll was given a unique name. That really shouldn't matter to Maya, as nodes are distinguished by their parent. For the most part. But sometimes not! For example, cycle warnings produce a message only containing the name of the node itself, not its hierarchy. So you wouldn't be able to tell which of the many rigid nodes were at the root of any cycle by merely looking at this message. And don't get me started on the connection editor. It's perfectly capable of making and breaking connections, but refuses to auto-fill the currently selected nodes if they happen to have the same name as any other node in the scene! In any case, this has now been fixed and all nodes are once again unique. Automated tests have also been put in place to prevent this slip-up from happening again; but do let me know if you find any duplicates as Ragdoll generates a lot of nodes, and it's possible one may have yet slipped through! Passive Constraints Select two rigid to create a constraint. But if one of those rigids was passive, or even animated between passive and active, and had a different passive animation than the initial state, and your constraint could end up like this. Before Especially notice how the passive pose differs from the initial active pose. The active pose was used to compute how to draw the constraint, whereas the passive pose was used during the simulation. After This has now been fixed! Single Joint Shapes In the rare case of turning solo-joints dynamic, you could end up with results like this. Before After This has now been fixed! Bake Static Rigids There was a bug when baking simulation for any rigid what started out passive, e.g. it was hard pinned, but animated active. The Bake Simulation command would mistake these later-simulated rigids as passive, and simply not bake them. This has now been fixed!","title":"2021.07.15"},{"location":"releases/2021.07.15/#rotate-pivot","text":"In a previous release support for the .rotatePivot attribute was added. But it was only partial. It only applied to solo rigid bodies, like the one in that example. Once rigids form a hierarchy, things get more complex, but also more realistic . A lot of character rigs make use of it, some even going as far as to leave NURBS controls at the origin, moving the CVs to where the character is and compensating with the .rotatePivot to make it appear in the right place. This didn't gel with Ragdoll, who uses the center of a control to determine how to draw chains. What is this \"rotate pivot\"? Just so we're all on the same page, here's me creating a control by moving the rotate pivot and CVs rather than translating/rotating the node. Notice how I'm not actually moving it to the hip, but rather hold the D -key and move the rotate pivot. Then I'm moving the CVs to where the rotate pivot is to make it both act and appear at the hip. Why would anyone do this? Hah! Yes that was my thought too! As you can see, to make this work you really have to work at it. My guess is this isn't something riggers do by hand but rather via scripting. Done that way, you don't really notice how odd it is. Either way, there are rigs out there that works like this and it shouldn't limit your use of Ragdoll. Next, I'll repeat this process for each of my controls. Pay special attention to how all of my controls are still technically at the origin. Their rotate/translate channels are all zero. Let's have a look at what the current version of Ragdoll does in this situation. Before Notice how nothing appears! That's because Ragdoll tried figuring out where to generate capsules and how large to make them based on the center of each control. But! The controls are all at the origin . They lie there, right on top of each other, with zero distance from each other. So Ragdoll does what it thinks you want. It generates a series of rigid bodies at the origin with 0 size. When what you really meant was for it to use the center plus this \"rotate pivot\". After This release recognises this, here's what it looks like now. Win!","title":"Rotate Pivot"},{"location":"releases/2021.07.15/#re-scale","text":"Sometimes you're experimenting and aren't quite sure that the scale of an object is what you'd like it to be until you see it in action. Currently, whenever you make something dynamic it'll use the current scale of the NURBS curve or mesh as part of the collision geometry. But! If you change the size after making it dynamic, Ragdoll won't know about that. This was especially damning for geometry that needed to be tesselated, namely the Mesh shape type. The most convenient way of refreshing that was to edit the .shapeVertexLimit attribute, forcing a re-tesselation. That's because Ragdoll cannot know when you resize something. You have to explicitly say you did. That is, until now. Caveat It still isn't perfect. Ragdoll still cannot know when you scale the object. Instead, it queries the current scale on the 1 st frame of the simulation, which means it won't actually recognise a new scale until the 2 nd playthrough . That's because once the simulation starts, the initial state is automatically set. Only then can it know that scale has changed, but by then it is too late! Simulation has already begun. So instead, the change is picked up on the next playthrough. Of course manually setting the initial state (via the Rigging sub-menu) or re-opening the scene will have the same effect so you really shouldn't have to struggle with this in practice.","title":"Re-scale"},{"location":"releases/2021.07.15/#scene-tolerance","text":"Ragdoll assumes you're working with human characters in centimeters, meaning a value of 170 means 170 cm and 0.1 cm is a small distance. If that's true, then you typically won't have to worry about \"tolerances\". But if you're characters are 17,000 units tall or 0.017 units short odd things start to happen. Notice how it initially slides around for no apparent reason? In this case, the cube is much smaller than Ragdoll expects and we can address this by decreasing the global scene scale. Likewise, for very large cubes you will notice similar artifacts. For that, you'd increase the scale. Currently, there exists a Scene Scale on the solver node, which is saved in your scene, and a Scene Scale in the global preferences which is not. The intention is for global scene scale to rarely change, to change alongside a studio's or project's convention, whereas the solver scene scale is more flexible. The default value is 10.0 but it's possible smaller values such as 0.1 is better suited. It's also possible they both belong under global preferences. Give this a try and let me know what you think.","title":"Scene Tolerance"},{"location":"releases/2021.07.15/#limit-visualisation","text":"There are two kinds of limits; twist and swing. Twist is great for hinge-like limits, like knees and elbows, whereas swing is great for more complex 2D limits like shoulders and hips. The current position of a rigid body in terms of swing and twist have always been drawn as a green/red line, but it could sometimes be hard to know which was which. If the red line starts out in the twist limit, then Ragdoll will promptly snap it back into the swing limit. This release colors the twist and swing shapes using the same colors as the current twist and swing axes, making it just a tad easier to see which belongs where. Before After Also notice how the twist axis is now confined into the twist shape itself, making it just a bit more clear how close it is to colliding with that limit. Here's a more complete example of a full set of constraints.","title":"Limit Visualisation"},{"location":"releases/2021.07.15/#unique-names","text":"Prior to a recent release, all new nodes generated by Ragdoll was given a unique name. That really shouldn't matter to Maya, as nodes are distinguished by their parent. For the most part. But sometimes not! For example, cycle warnings produce a message only containing the name of the node itself, not its hierarchy. So you wouldn't be able to tell which of the many rigid nodes were at the root of any cycle by merely looking at this message. And don't get me started on the connection editor. It's perfectly capable of making and breaking connections, but refuses to auto-fill the currently selected nodes if they happen to have the same name as any other node in the scene! In any case, this has now been fixed and all nodes are once again unique. Automated tests have also been put in place to prevent this slip-up from happening again; but do let me know if you find any duplicates as Ragdoll generates a lot of nodes, and it's possible one may have yet slipped through!","title":"Unique Names"},{"location":"releases/2021.07.15/#passive-constraints","text":"Select two rigid to create a constraint. But if one of those rigids was passive, or even animated between passive and active, and had a different passive animation than the initial state, and your constraint could end up like this. Before Especially notice how the passive pose differs from the initial active pose. The active pose was used to compute how to draw the constraint, whereas the passive pose was used during the simulation. After This has now been fixed!","title":"Passive Constraints"},{"location":"releases/2021.07.15/#single-joint-shapes","text":"In the rare case of turning solo-joints dynamic, you could end up with results like this. Before After This has now been fixed!","title":"Single Joint Shapes"},{"location":"releases/2021.07.15/#bake-static-rigids","text":"There was a bug when baking simulation for any rigid what started out passive, e.g. it was hard pinned, but animated active. The Bake Simulation command would mistake these later-simulated rigids as passive, and simply not bake them. This has now been fixed!","title":"Bake Static Rigids"},{"location":"releases/2021.07.27/","text":"Highlight for this release is the Launch of 1.0! ADDED Website Welcome aboard! Website Out with the old, in with the new. As they say! Ragdoll is finally here! Read Announcement Try it Evolution For the fun of it, here's a look at how the website has evolved since day 0. September 2020 Soil was fresh, seeds planted. January 2021 Flowers were blossoming, sun was shining. July 2021 Fruits were ripe, table is set.","title":"2021.07.27"},{"location":"releases/2021.07.27/#website","text":"Out with the old, in with the new. As they say! Ragdoll is finally here! Read Announcement Try it","title":"Website"},{"location":"releases/2021.07.27/#evolution","text":"For the fun of it, here's a look at how the website has evolved since day 0.","title":"Evolution"},{"location":"releases/2021.07.27/#september-2020","text":"Soil was fresh, seeds planted.","title":"September 2020"},{"location":"releases/2021.07.27/#january-2021","text":"Flowers were blossoming, sun was shining.","title":"January 2021"},{"location":"releases/2021.07.27/#july-2021","text":"Fruits were ripe, table is set.","title":"July 2021"},{"location":"releases/2021.08.06/","text":"Highlight for this release is new documentation! META LinkedIn Keep up with the latest news by following along on LinkedIn ADDED Menu Documentation Less mystery, more tips and tricks ADDED Non-commercial telemetry Scene statistics for non-commercial users FIXED Add to Referenced Scene Annoying bug related to referenced physics scene FIXED Maya 2022.1 Ragdoll is now fully compatible with Maya 2022 FIXED Import Physics in Maya 2022 Minor Python 3-related bug got squashed Showcase Put together this example of animating a Pinocchio-like character recently, which is trending on LinkedIn . :D LinkedIn The Ragdoll page on LinkedIn is getting some more attention since launch - keep refreshing that page if you'd like to stay up to date with the latest and greatest, including new version releases and cool simulations to inspire and delight. https://www.linkedin.com/company/ragdolldynamics 3,000% haha, let's see if we can keep that up! Menu Documentation Items from the Ragdoll menu are getting some spotlight in the new Documentation section in the learning material! In it, you'll find basic tutorials, basic information and tips and tricks on how to use each item, such as the Active Rigid . Along with supplementary information such as Debugging Tips and details about the Cycle Protection . \ud83d\udc48 See new navigation to the left Non-Commercial Telemetry Opt-in telemetry was added to Ragdoll a few releases ago via the environment variable RAGDOLL_TELEMETRY . This behavior is now default for Trial and Personal licences of Ragdoll, and remains opt-in for Complete and Unlimited licences. See details Bug Fixes The following bugs were harmed in the making of this release. Add to Referenced Scene A minor but critical bug was discovered whereby you couldn't add a new rigid body to a referenced Ragdoll scene. It had to do with Ragdoll needing to know which scenes are present whenever a new rigid is made, something it keeps track of by listening to an event for \"Maya Open Scene\". But this wasn't triggered for \"Reference Scene\" which led to some confusion. This has now been fixed! Maya 2022.1 Finally that service pack was released for Maya, addressing a critical but which led many users to experience fatal crashes when attempting to delete rigids from their scene. This has now been fixed (by Autodesk!). Import Physics in Maya 2022 A Python 3-related error was discovered in Maya 2022, meaning you couldn't use the UI to browse for Ragdoll files. :( This has now been fixed!","title":"2021.08.06"},{"location":"releases/2021.08.06/#showcase","text":"Put together this example of animating a Pinocchio-like character recently, which is trending on LinkedIn . :D","title":"Showcase"},{"location":"releases/2021.08.06/#linkedin","text":"The Ragdoll page on LinkedIn is getting some more attention since launch - keep refreshing that page if you'd like to stay up to date with the latest and greatest, including new version releases and cool simulations to inspire and delight. https://www.linkedin.com/company/ragdolldynamics 3,000% haha, let's see if we can keep that up!","title":"LinkedIn"},{"location":"releases/2021.08.06/#menu-documentation","text":"Items from the Ragdoll menu are getting some spotlight in the new Documentation section in the learning material! In it, you'll find basic tutorials, basic information and tips and tricks on how to use each item, such as the Active Rigid . Along with supplementary information such as Debugging Tips and details about the Cycle Protection . \ud83d\udc48 See new navigation to the left","title":"Menu Documentation"},{"location":"releases/2021.08.06/#non-commercial-telemetry","text":"Opt-in telemetry was added to Ragdoll a few releases ago via the environment variable RAGDOLL_TELEMETRY . This behavior is now default for Trial and Personal licences of Ragdoll, and remains opt-in for Complete and Unlimited licences. See details","title":"Non-Commercial Telemetry"},{"location":"releases/2021.08.06/#bug-fixes","text":"The following bugs were harmed in the making of this release.","title":"Bug Fixes"},{"location":"releases/2021.08.06/#add-to-referenced-scene","text":"A minor but critical bug was discovered whereby you couldn't add a new rigid body to a referenced Ragdoll scene. It had to do with Ragdoll needing to know which scenes are present whenever a new rigid is made, something it keeps track of by listening to an event for \"Maya Open Scene\". But this wasn't triggered for \"Reference Scene\" which led to some confusion. This has now been fixed!","title":"Add to Referenced Scene"},{"location":"releases/2021.08.06/#maya-20221","text":"Finally that service pack was released for Maya, addressing a critical but which led many users to experience fatal crashes when attempting to delete rigids from their scene. This has now been fixed (by Autodesk!).","title":"Maya 2022.1"},{"location":"releases/2021.08.06/#import-physics-in-maya-2022","text":"A Python 3-related error was discovered in Maya 2022, meaning you couldn't use the UI to browse for Ragdoll files. :( This has now been fixed!","title":"Import Physics in Maya 2022"},{"location":"releases/2021.08.28/","text":"Highlight for this release is new tutorials! ADDED Tutorials Three new tutorials covering basics up to anatomical correctness! ADDED Pivot Editor Faster wheels and knees with this new UI ADDED Personal UI More accurate licence information in the Ragdoll UI ADDED Social Media We're everywhere now! FIXED Worldspace Trajectories Now drawn correctly, in worldspace FIXED Sphere Rendering Minor tweak to the look of the Sphere shape type FIXED Floating Server Details Minor bug fix for floating licence users New Tutorials Three new tutorials from basics to intermediate, with more to come! Bouncing Ball Learn the fundamentals of Ragdoll in this classic animation tutorial. View Tutorial Rally Car Build upon the skills learnt with a bouncing ball to combine several rigids into a car (with an engine!) View Tutorial Manikin Construct a full ragdoll from any rig, even your own custom one! View Tutorial Personal UI The Licence Window at the bottom of the Ragdoll menu now accurately displays your current licence, including Personal, Complete, Unlimited and Batch, along with the licence type - Floating or Node Locked . Social Media Can you believe it. A clear sign of success, not everyone is on Twitter! If you're one of the lucky few, you can now follow along with updates to the project, documentation and general company news from there! https://twitter.com/ragdolldynamics https://facebook.com/ragdolldynamics https://reddit.com/user/ragdolldynamics https://youtube.com/c/RagdollDynamics The only question is, who's going to be the first to follow? \ud83d\ude31 Pivot Editor In making he tutorials, the main bottleneck in terms of time taken was editing constraints. They are both complex and difficult to manage. This release addresses this problem with the Pivot Editor GUI. Basics Here's how to use it to tune a broken knee. Spin & Swap One of the main reasons to want to edit constraint pivots is to align the Twist axis with the main rotation of a knee or elbow. Mirror If the pivots face in opposite directions, orientations can be un-mirrored with the Mirror option. Channel Box Co-op Tuning limits alongside pivots works well too, middle-click drag attributes from the Channel Box like you normally would, whilst dragging in the UI to compensate. Snap Use the snap option to make precise adjustment to specific angles. Worldspace Trajectories Trajectories used to follow the scene wherever it went. Now they'll stay put, where they belong. Before After Sphere Rendering This fixes a minor annoyance you may have noticed, of the outline of spheres visible in shaded mode. Before After Floating Server Details When you first lease a licence from your licence server, the IP and port details are stored on the local machine for quicker access the next time. However, if you then later needed to change those details, then any local machine previously leasing a licence would not be able to update their details. This has now been fixed!","title":"2021.08.28"},{"location":"releases/2021.08.28/#new-tutorials","text":"Three new tutorials from basics to intermediate, with more to come!","title":"New Tutorials"},{"location":"releases/2021.08.28/#bouncing-ball","text":"Learn the fundamentals of Ragdoll in this classic animation tutorial. View Tutorial","title":"Bouncing Ball"},{"location":"releases/2021.08.28/#rally-car","text":"Build upon the skills learnt with a bouncing ball to combine several rigids into a car (with an engine!) View Tutorial","title":"Rally Car"},{"location":"releases/2021.08.28/#manikin","text":"Construct a full ragdoll from any rig, even your own custom one! View Tutorial","title":"Manikin"},{"location":"releases/2021.08.28/#personal-ui","text":"The Licence Window at the bottom of the Ragdoll menu now accurately displays your current licence, including Personal, Complete, Unlimited and Batch, along with the licence type - Floating or Node Locked .","title":"Personal UI"},{"location":"releases/2021.08.28/#social-media","text":"Can you believe it. A clear sign of success, not everyone is on Twitter! If you're one of the lucky few, you can now follow along with updates to the project, documentation and general company news from there! https://twitter.com/ragdolldynamics https://facebook.com/ragdolldynamics https://reddit.com/user/ragdolldynamics https://youtube.com/c/RagdollDynamics The only question is, who's going to be the first to follow? \ud83d\ude31","title":"Social Media"},{"location":"releases/2021.08.28/#pivot-editor","text":"In making he tutorials, the main bottleneck in terms of time taken was editing constraints. They are both complex and difficult to manage. This release addresses this problem with the Pivot Editor GUI.","title":"Pivot Editor"},{"location":"releases/2021.08.28/#basics","text":"Here's how to use it to tune a broken knee.","title":"Basics"},{"location":"releases/2021.08.28/#spin-swap","text":"One of the main reasons to want to edit constraint pivots is to align the Twist axis with the main rotation of a knee or elbow.","title":"Spin &amp; Swap"},{"location":"releases/2021.08.28/#mirror","text":"If the pivots face in opposite directions, orientations can be un-mirrored with the Mirror option.","title":"Mirror"},{"location":"releases/2021.08.28/#channel-box-co-op","text":"Tuning limits alongside pivots works well too, middle-click drag attributes from the Channel Box like you normally would, whilst dragging in the UI to compensate.","title":"Channel Box Co-op"},{"location":"releases/2021.08.28/#snap","text":"Use the snap option to make precise adjustment to specific angles.","title":"Snap"},{"location":"releases/2021.08.28/#worldspace-trajectories","text":"Trajectories used to follow the scene wherever it went. Now they'll stay put, where they belong. Before After","title":"Worldspace Trajectories"},{"location":"releases/2021.08.28/#sphere-rendering","text":"This fixes a minor annoyance you may have noticed, of the outline of spheres visible in shaded mode. Before After","title":"Sphere Rendering"},{"location":"releases/2021.08.28/#floating-server-details","text":"When you first lease a licence from your licence server, the IP and port details are stored on the local machine for quicker access the next time. However, if you then later needed to change those details, then any local machine previously leasing a licence would not be able to update their details. This has now been fixed!","title":"Floating Server Details"},{"location":"releases/2021.09.27/","text":"Highlight for this release is Animation Capture . ADDED Animation Capture AnimCap, a.k.a. Reverse Motion Capture ADDED Self-Collision Overlapping shapes, begone ADDED Lollipop Controls Clarity where there was none IMPROVED Quality of Life Less clutter, more joy IMPROVED No Graph Editor Mess Clean Graph Editor, clean mind IMPROVED No More Cycles Clean Graph Editor, clean mind IMPROVED No Initial State Less is more FIXED Multiple Floating Licences Now behaves as one would expect Showcase Let's start with some eye-candy, thanks to Jason Snyman for the gorilla rig! :) Introduction Lighter, faster , stronger . This release introduces a new way of thinking about physics, and is part \u00bc . Skip Intro # Release Date Description 1 Workflow Today At least 100% faster, but primarily much easier to work with 2 Render Performance 2 weeks later The current bottleneck, expect a 50-100x boost 3 Recording Performance 2 weeks later Currently written in Python, to be written in optimised C++ 4 Interactive Tools 2 weeks later No more fiddling with offsets in the channel box, viewport manipulators galore! Something amazing has happened. Since release only a few weeks ago, Ragdoll is now used in production across the globe in over a dozen countries at the most major of studios, several dozens of mid-sized studios wanting to gain an advantage and hundreds of independent animators and riggers alike. And that is amazing, it is. But something even more amazing has happened; Ragdoll has leaped forward . And that will be what the next 4-part release is about. See, since launch I've had conversations with animators using Ragdoll for the very first time. One of those animators made a request that at first glance didn't look like much. Quote \"I don't like working with green channels, as it is not ideal for animating. Is there a way to I can overcome this?\" - Christopher Page Here's what he was referring to. Notice how the nodes with physics applied got green channels? The reason they are green is because Ragdoll is driving them. They are green rather than yellow because you can still edit them, at the same time as Ragdoll is editing them. Your changes will be reflected in the simulation, this is how you control the simulation as it is running. Can we get rid of that connection? Well.. No? This is Ragdoll's connection to your controls. Without those.. there is no physics. I quickly dismissed the idea and carried on with my day.. But then something clicked .. What if..? In the next section, I'll dive into how this works and why this change goes far beyond just getting rid of green channels. Benefits at a glance \u2714\ufe0f 10,000% greater performance (or more!) \u2714\ufe0f No more graph editor mess \u2714\ufe0f No more initial state \u2714\ufe0f No more cycles \u2714\ufe0f No more clutter in the Outliner \u2714\ufe0f No more clutter in the Viewport \u2714\ufe0f Support for interactive scale \u2714\ufe0f Support for overlapping shapes \u2714\ufe0f Support for IK/FK \u2714\ufe0f Support for space switching \u2714\ufe0f Support for follicles \u2714\ufe0f Support for native Maya constraints \u2714\ufe0f Support for ... From here, this list has no end, because anything capable of affecting the worldspace position and orientation of your controls is natively supported with this workflow. Anything . I'm a techy, gimme the deets The reason this works is because Ragdoll will consider the .worldMatrix attribute of any control and this is the same attribute Maya itself uses for just about anything. Animation Capture Inspired by Motion Capture - Animation Capture is a new way to think about and work with physics in Maya. To learn about it, let's first understand how Motion Capture generally works. Here is a typical data pipeline for motion capture, from real-life actor to final character animation. # Description 1 Markers are attached to an actor 2 Markers are \"captured\" 3 A pointcloud is generated 4 A hierarchy of joints is generated 5 Joints drive a typical character rig 6 Rig drives final geometry for render Each \"marker\" is a dud. Nothing of any complexity. Something for the camera(s) to recognise and track as it moves through space. Once tracked, it's able to translate this marker from a 2D image into a 3D position, and continues to do so for each marker, for the real processing to take place inside software. Once the capture is complete, the human actor can remove the markers and go enjoy the rest of their day. The rest is up to the computer. With 3D positions generated, software takes over to translate these points into a hierarchy; the FK joint hierarchy you may be familiar with if you've ever worked with mocap. The joint hierarchy can then be used to either drive the final geometry, or to drive a more complex character rig which in turn drives the final geometry. Animation Capture is just like that, but in reverse . Instead of capturing a person, it captures your character rig . # Description 1 Markers are attached to a character rig 2 Markers are \"captured\" 3 A rigid is generated for each marker 4 A hierarchy of constraints is generated 5 Simulation is recorded back onto the original character rig Unlike motion capture, we'd like the result mapped back onto our character rig again, which is how animators iterate with physics. Demo 1 - Basics Ok, enough prelude, let's dive in. Before Here's what life was like before, with Active Rigid . After And here's life with Markers . Notice how the channels are left alone? This is the key difference between Marker and Rigid . Although you still provide Ragdoll with controls, Ragdoll no longer drives your controls directly. Instead, it shows you what they would look like if they were driven with physics. Once you're happy with what you see, you Record . Demo 2 - Ragdoll Let's have a look at how Markers work with a full ragdoll. 1. Setup hierarchy The first step is nothing new, you've seen it before. 2. Edit shapes This too, it's second nature by now. Except! Notice how the shapes overlap? That's ok! No longer will you have to worry about self-intersecting shapes. Unless you want it to, with the new Self Collide attribute. :D I'll touch on this a bit more below, under #self-collide Double Except! Release 4/4 in this series will deal with the channel box, and make editing these values interactive in the viewport for a superior experience and a lot less clicks and fiddling with numbers. 3. Animate Now things are getting interesting. To keep our viewport clean, we can offset the simulation slightly. The offset is purely visual and won't affect the simulation or subsequent recording. 4. Record Finally, and this is what separates Markers from Rigids , we record our simulation back onto our controls. Demo 3 - Inverse Kinematics That last example was contrived. No rig is without IK, so how does Markers work here? 1. No IK Since we put markers on the FK controls, Ragdoll doesn't know about what the IK controls are doing. 2. Reassign So let's put markers on the joints driven by both IK and FK, such that when you switch between the two, Ragdoll knows how to follow along. So let's Reassign . 3. Retarget But recording still targets our original FK controls, and what we want is to record our IK controls. So we can Retarget . 4. Record Translation Unlike FK, IK isn't just rotation, but translation too. So let's tell Ragdoll to record the translation from these markers too. And there you have it! This works with IK, SpineIK, Follicles, Geometry Constraints; anything you can throw at it. Demo 4 - Real World Example Here's a work-in-progress animation from Christopher Page (thanks for lending it to me!) Let's see how we can use Ragdoll to help improve upon it. 1. The Problem Notice how the elbow intersects the table as he moves his torso around? A difficult problem and moving target as you need to keep tweaking both the torso and hand IK handle to tune your animation. 2. Isolate Timeline Since this animation is over 600 frames, we'll isolate our work to a small portion of it. For both performance and cleanliness; Ragdoll will only record onto the current timeline (or selected portion of it). 3. Assign Markers Like before, we'll assign markers to the underlying skeleton to respect what the IK solver does. We'll also make the hand Kinematic to respect the original animation exactly. The clavicle is also Kinematic per default, as it was the first assigned control - and is thus the \"root\" of our dynamic hierarchy. 4. Include Table Since we're interacting with the table, we'll include this too. Also Kinematic , no dynamics will be affecting it, and also as a Box shape to speed up and improve the stability of the simulation. 5. Tune Shapes Next we'll isolate contacts with just the elbow area, to respect the hand and lower arm animation. 6. Tune Material In this case, we'd like for the elbow to slide across the table, no friction. More Realism? In the real world, there would be friction and it could come in handy here too. But what should we expect from the elbow rubbing against the table? We should include the torso for this as well, which you absolutely can (and maybe should!). But to keep things simple, we'll let the clavicle preserve it's original animation exactly. 7. Retargeting Ragdoll will record onto the nodes you originally assign, but like before we want recording to go elsewhere; from joints to IK controls. 8. Record Translation Likewise, we'd also like translation included. And we don't care for the shoulder and clavicle animation; all we want is the IK handle and Pole Vector. 9. Record Simulation We're all set! Let's hit Record ! 10. Before And After And there we go! 2 minutes or less, and you've got a reusable setup for correcting the elbow whenever the animation changes. IK is intact and you can keep working with keyframes. Keeping Ragdoll attached to your rig has zero impact on performance (as you can see by looking at the fps counter near the bottom of the two comparisons), and once hidden it has no impact on your Outliner either. All clean! Here's one more I couldn't find room for, an earlier version of the animation with stepped keys and finger simulation. Look at all that juicy finger interaction with the table. \ud83d\ude0a Rig and Model courtesy of Ramon Arango - Apollo Rig New Menu Let's take a moment to reflect on what we've just seen. There are 3 new nodes in Ragdoll. # Node Description rdSolver The \"camera\" that monitors \"Markers\" and performs all heavy-lifting. rdMarker A tracking marker, something to monitor an individual control. rdGroup A collection of markers, with high-level control over many markers. Here's the new menu. If all goes well, it will completely replace the Active Rigid and Active Chain menu items, along with Controls including Mimic . All of those things are made possible in a much easier and performant way using Markers. The most important elements are at the top. # Item Description Assign Single Monitor a single object in the Maya scene. Use this for props, environment and other free-falling things. Assign Group Monitor a series of connected objects, like a limb. Record Transfer simulation to marked objects Like Active Chain , the order of selection determines the order in which markers assume your objects are connected. And adding more markers to a group is done by starting your selection from any point in an existing group and working your way outwards. Just like Active Chain . Limitations You currently cannot create multiple rdSolver nodes, but can work around it by importing one from another Maya scene file. The Guide Space is somewhat complicated. The group has one too that affects all markers, and per default it's set to -1 for Localspace . The benefit is that you can quickly change the space for all markers by changing this one attribute. The downside is that if you want to change it for just one marker, you first need to reset this attribute to 0 . These will be addressed in the upcoming few releases. Recording Markers can be recorded all together, or independently. For example, say you wanted animation from frame 1-100, simulate 101-150 and return to animation from 151-200. You can do that. Furthermore, say you liked what the simulation was doing, but only on one half of the body. Or only on the hip, driving the main trajectory in a physically-plausible way. Keeping the rest of your animation intact. Record All With nothing selected, Ragdoll will record all marked controls to the current Maya playback range. Record Selected Markers Select a few controls to control what gets recorded. Record Range Limit the Maya playback range for control over when recording takes place. Record Selected Range Or, select an explicit range interactively. Intelligent Range A Kinematic marker is entirely animated, so there's no need to actually record those. Ragdoll will ensure only non-kinematic frames are recorded, so you can do things like this. Record to Animation Layer Ragdoll will record to whichever layer is currently active. Input Type In the above examples, I mentioned Kinematic and you probably spotted a few other options too, like Inherit and Guide . What are those? The Input Type is how Ragdoll should interpret the controls you assign. Did you mean for them remain animated, i.e. Kinematic ? Or should they follow the control around, i.e. Guide ? Or should they just fall with gravity, ignoring the original control altogether, i.e. Off ? The Input Type can be set either for a whole group of markers, or each marker individually. Type Description Inherit Do whatever the group is doing, or Kinematic if there is no group Off Do nothing, just fall under gravity Kinematic Follow the input exactly , physics need not apply Guide Follow the input approximately, with some Stiffness and Damping Off Treat the input as a starting position, but nothing else. Kinematic Follow the input exactly, no exceptions. Not even collisions. Guide Space -1 Follow the local angles of the input. Guide Space +1 Follow the world position and orientation of the input. Retarget We've talked a lot about \"retargeting\". But what is that? Per default, markers are recorded onto the controls you assigned, this is called Rig to Rig . But often times, rigs are more complicated and what you want is for the simulation to look at one set of nodes, but record onto another. This is called Joint to Rig , but can be from any source. Even other controls (like FK to IK). The Old Days Think about how you would accomplish this using the Active Rigid or Active Chain commands. That would be a huge pain, but not with markers! Reassign Over in Demo 2 - Ragdoll we \"reassigned\" already marked controls. What does that mean? In that example, we've assigned our FK controls directly, which means Ragdoll would grab the translation and rotation from those controls during simulation. But what we really wanted was the IK controls. But! We couldn't just assign to the IK controls directly, since they are indirectly rotating a characters limbs. So instead, we Reassign the markers previously made onto the underlying joints that follow IK around. We then also Retarget them, since they would have otherwise been recorded onto the original FK controls. Reparent Sometimes, you change your mind. Success! Guide Space Now let's talk about a few things you haven't seen yet. Look, it's Ragdoll Blaine! So what's happening here? Well, it looks like a Soft Pin to his head, along with a slight Guide Strength on the rest of his body. But unlike the Rigid , another significant advantage to Markers is their ability to capture both local and worldspace position and orientation of your controls. And because of this, you are able to interactively choose whether a marker should look at the Worldspace or Localspace position of your controls. Notice how with a Guide Space = -1 the controls arms remain relative the torso. And with Guide Space = 1 they instead follow the worldspace orientation of the controls. Just like a Soft Pin. This attribute is also animatable , and is how you can transition from animation into simulation and back again. Here's a more complete example: Frame Transition 100 Starts as a regular animated character 125 Transitions into physics as he jumps, for a physically-correct trajectory 155 Transitions back to animation once he rolls over on that cabinet 160 Transitions back to physics until he stands up 170 Transitions back into animation to match an exact pose 200 Partially transitions into physics, for secondary motion in the upper body as his arm is raised. Transitions Let's have a look at how you would use markers to transition between simulation and animation. Notice how we're animated up until the jump, and then Ragdoll takes over. Once he approaches that box, we turn our Guide Space from -1 to 1 and have him reach the target pose in worldspace. Once he's close, we switch Input Type to Kinematic and kinematically move him until we once again transition to Guide , this time with a Guide Space or -1 for pose space. Self Collision Previously, it was very important that your shapes did not overlap any shape other than it's immediate neighbour. If they did, chaos ensued. Before Clavicles intersect their parent spine, but also each other! After With the new Self Collision = Off , this is no longer a problem. This can be taken into the extreme! And here's a another example to fill out a large volume in the center of a character. Attention Notice how the spine is made up of many shapes, some of which cover the width of the body, others the depth. An overlapping mess that would never have simply not have been possible without self-collision support! Original asset created by Mehmet Tayfur T\u00fcrkmeno\u011fluwe and Dr. Reel, licensed by The Rookies. No Graph Editor Mess Because Rigids were children of your controls, Maya had a funny way of including them in the Graph Editor that rightly drove animators, myself included, absolutely mad . Before Just look at this; why-oh-why would I want channels from a completely unrelated node when working with the hip? After Contrast that to this, whereby only the nodes you actually select are made visible. You can even select Markers via the Channel Box and deselect your controls to get up real close. No Initial State A significant effort was made to make the simulation start where you expected it to. Under the hood, simulation and animation were at odds with one another. Ragdoll needed to know where to start, but it was also telling your controls where to start. It's an inherent cycle, which was finally broken. Read More You can read all about the month-long journey in the release notes from March Nowadays, you barely have to think about it, but it does occasionally rear its ugly head. It is a hack. With Markers there isn't any cycle to begin with. Ragdoll only reads from your controls, it doesn't write to anything. Under the hood, recording is a 2-step process; first it simulates, and then it writes animation back onto the controls. That's how this cycle is broken, without having any effect on the overall workflow. No More Cycles With the previous version, because Rigids both read and wrote to each control, you could sometimes run into a situation where the parent depends on a child. Before Here, I'll try and make a second chain in the opposite direction of how the controls are laid out hierarchically. This cannot work; because in order for Ragdoll to figure out where the Passive hand should be, it would first need to consult the upper arm, which is both dynamic and a child of the spine, which is also dynamic. It's a lovely cycle. \u2764\ufe0f After With Markers , this isn't a problem because to Ragdoll every limb can now be independently evaluated, in parallel. Lollipop Controls Sometimes, markers are added to an already busy control with tons of Channel Box entries. Lollipop controls can help organise things a little better. These can be moved around and scaled to suit your needs, and will provide access to the same marker node in the channel box, so you can select and edit the marker from either the originally marked control or this lollipop control. Rotate Pivot Use the default Maya rotate pivot to control where to pin a simulation, both in worldspace and localspace. Attention Take care about scale , especially the scale pivot. Ragdoll can sometimes struggle when the scale pivot differs from the rotate pivot. This will be addressed in a future release. Quality of Life Some minor things to brighten your day. Real Ground With Rigids , the ground was embedded into the scene. With Markers , an actual ground is created to for more stability and more control over its physical parameters. Something that can also be animated, and that dynamically appears right underneath your markers. Joints and the Attribute Editor The Attribute Editor doesn't show you Rigids related to Maya joints because of a Maya UI quirk. With Markers , this is no longer a problem! Hidden Solver Hiding the solver completely removes all overhead of having Ragdoll in your scene. Previously, with rdScene and rdRigid , because they were directly connected to your controls, hiding things made little difference. But now, because we no longer have this direct connection, all computations come from explicitly seeing the rdSolver node. No visible rdSolver node, no computations. Period. Enhanced Determinism TLDR Sometimes, re-opening the scene could lead to different results. This has now been fixed. Each time you play a simulation starting from the beginning, the results are the same. This is an important characteristic of any simulation and is called \"determinism\". It used to be the case however that when you re-opened the scene, there was a small chance the results would differ from when you last saved it. This has now been fixed. The determinism is now dependent on the order in which rigid bodies connect to the rdSolver node. It's an array attribute, whose order is saved with the Maya scene. Multiple Floating Licences Whenever a machine connected to your floating licence server, the host and IP were stored on the machine in an effort to speed up subsequent connections made. However, this also meant that you weren't able to update those details. Despite providing new details, Ragdoll would favour the already-stored details. Worse yet, the Ragdoll UI would lie to you, by repeating the connection details provided in the RAGDOLL_FLOATING environment variable, despite those not actually being used. This release addresses this by always using the details you provide, and not bother reusing any previously provided details. In addition, you now have the option to explicitly query and set server details directly. # Will query the *actual* server used by Ragdoll, rather # than return the environment variable you provided cmds . ragdollLicence ( getServer = True ) # Will manipulate the currently-in-use key, meaning it will # try and drop a licence from this address as well cmds . ragdollLicence ( setServer = ( \"localhost\" , 1313 )) Next Release This release is part \u00bc, for next 2/4 release you can expect Performance Improvements . In this release, simulation and overall Maya scenegraph performance has seen a 200x performance boost, the performance is already there. You'll notice it as you try them on your rigs. However, rendering performance has dropped significantly, cancelling out most of that performance gain. Here's what performance looks like now. Rendering mostly Maya default shading, rendeing its own things. Unrelated to Ragdoll. The Rig Evaluation on the other hand is almost entirely Ragdoll. It's connected to every control in this rig, forcing each control to be evaluated in serial; one after the other. Here's what it looks like with Markers . Notice the huge pile of lines to the left? Those are all running parallel and almost entirely default Maya evaluations; things your rig would do without Ragdoll. Rendering on the other hand is almost entirely Ragdoll, it is very slow. To properly compare performance between Rigids and Markers , here's what you should be looking at. This is the only thing Ragdoll does to your rig. This is the entire overhead, the added load onto your rig. 16 microseconds . That's 0.016 ms . For a rig to run at 30 fps, it'll need 1,000/30 = 33 ms per frame. This overhead, 0.016 ms/frame is all Ragdoll needs to solve an entire character, contacts and constraints and forces, all of it. In this particular profiling, that's 430x faster than Rigids , which not only took longer to solve but made everything else slower by just being connected to your controls. So how about we get this rendering performance sorted, shall we? Limitations These are some of the things lacking from Markers in this release that we'll be working on for subsequent releases. Selecting rigids interacively Manipulating shapes interactively Manipulating constraints interactively Toggle between previous animation and recorded simulation Support for recording onto an animation layer No \"live-mode\", where physics drives a control interactively Markers cannot be exported Markers cannot have additional constraints","title":"2021.09.27"},{"location":"releases/2021.09.27/#showcase","text":"Let's start with some eye-candy, thanks to Jason Snyman for the gorilla rig! :)","title":"Showcase"},{"location":"releases/2021.09.27/#introduction","text":"Lighter, faster , stronger . This release introduces a new way of thinking about physics, and is part \u00bc . Skip Intro # Release Date Description 1 Workflow Today At least 100% faster, but primarily much easier to work with 2 Render Performance 2 weeks later The current bottleneck, expect a 50-100x boost 3 Recording Performance 2 weeks later Currently written in Python, to be written in optimised C++ 4 Interactive Tools 2 weeks later No more fiddling with offsets in the channel box, viewport manipulators galore! Something amazing has happened. Since release only a few weeks ago, Ragdoll is now used in production across the globe in over a dozen countries at the most major of studios, several dozens of mid-sized studios wanting to gain an advantage and hundreds of independent animators and riggers alike. And that is amazing, it is. But something even more amazing has happened; Ragdoll has leaped forward . And that will be what the next 4-part release is about. See, since launch I've had conversations with animators using Ragdoll for the very first time. One of those animators made a request that at first glance didn't look like much. Quote \"I don't like working with green channels, as it is not ideal for animating. Is there a way to I can overcome this?\" - Christopher Page Here's what he was referring to. Notice how the nodes with physics applied got green channels? The reason they are green is because Ragdoll is driving them. They are green rather than yellow because you can still edit them, at the same time as Ragdoll is editing them. Your changes will be reflected in the simulation, this is how you control the simulation as it is running. Can we get rid of that connection? Well.. No? This is Ragdoll's connection to your controls. Without those.. there is no physics. I quickly dismissed the idea and carried on with my day.. But then something clicked .. What if..? In the next section, I'll dive into how this works and why this change goes far beyond just getting rid of green channels. Benefits at a glance \u2714\ufe0f 10,000% greater performance (or more!) \u2714\ufe0f No more graph editor mess \u2714\ufe0f No more initial state \u2714\ufe0f No more cycles \u2714\ufe0f No more clutter in the Outliner \u2714\ufe0f No more clutter in the Viewport \u2714\ufe0f Support for interactive scale \u2714\ufe0f Support for overlapping shapes \u2714\ufe0f Support for IK/FK \u2714\ufe0f Support for space switching \u2714\ufe0f Support for follicles \u2714\ufe0f Support for native Maya constraints \u2714\ufe0f Support for ... From here, this list has no end, because anything capable of affecting the worldspace position and orientation of your controls is natively supported with this workflow. Anything . I'm a techy, gimme the deets The reason this works is because Ragdoll will consider the .worldMatrix attribute of any control and this is the same attribute Maya itself uses for just about anything.","title":"Introduction"},{"location":"releases/2021.09.27/#animation-capture","text":"Inspired by Motion Capture - Animation Capture is a new way to think about and work with physics in Maya. To learn about it, let's first understand how Motion Capture generally works. Here is a typical data pipeline for motion capture, from real-life actor to final character animation. # Description 1 Markers are attached to an actor 2 Markers are \"captured\" 3 A pointcloud is generated 4 A hierarchy of joints is generated 5 Joints drive a typical character rig 6 Rig drives final geometry for render Each \"marker\" is a dud. Nothing of any complexity. Something for the camera(s) to recognise and track as it moves through space. Once tracked, it's able to translate this marker from a 2D image into a 3D position, and continues to do so for each marker, for the real processing to take place inside software. Once the capture is complete, the human actor can remove the markers and go enjoy the rest of their day. The rest is up to the computer. With 3D positions generated, software takes over to translate these points into a hierarchy; the FK joint hierarchy you may be familiar with if you've ever worked with mocap. The joint hierarchy can then be used to either drive the final geometry, or to drive a more complex character rig which in turn drives the final geometry. Animation Capture is just like that, but in reverse . Instead of capturing a person, it captures your character rig . # Description 1 Markers are attached to a character rig 2 Markers are \"captured\" 3 A rigid is generated for each marker 4 A hierarchy of constraints is generated 5 Simulation is recorded back onto the original character rig Unlike motion capture, we'd like the result mapped back onto our character rig again, which is how animators iterate with physics.","title":"Animation Capture"},{"location":"releases/2021.09.27/#demo-1-basics","text":"Ok, enough prelude, let's dive in. Before Here's what life was like before, with Active Rigid . After And here's life with Markers . Notice how the channels are left alone? This is the key difference between Marker and Rigid . Although you still provide Ragdoll with controls, Ragdoll no longer drives your controls directly. Instead, it shows you what they would look like if they were driven with physics. Once you're happy with what you see, you Record .","title":"Demo 1 - Basics"},{"location":"releases/2021.09.27/#demo-2-ragdoll","text":"Let's have a look at how Markers work with a full ragdoll. 1. Setup hierarchy The first step is nothing new, you've seen it before. 2. Edit shapes This too, it's second nature by now. Except! Notice how the shapes overlap? That's ok! No longer will you have to worry about self-intersecting shapes. Unless you want it to, with the new Self Collide attribute. :D I'll touch on this a bit more below, under #self-collide Double Except! Release 4/4 in this series will deal with the channel box, and make editing these values interactive in the viewport for a superior experience and a lot less clicks and fiddling with numbers. 3. Animate Now things are getting interesting. To keep our viewport clean, we can offset the simulation slightly. The offset is purely visual and won't affect the simulation or subsequent recording. 4. Record Finally, and this is what separates Markers from Rigids , we record our simulation back onto our controls.","title":"Demo 2 - Ragdoll"},{"location":"releases/2021.09.27/#demo-3-inverse-kinematics","text":"That last example was contrived. No rig is without IK, so how does Markers work here? 1. No IK Since we put markers on the FK controls, Ragdoll doesn't know about what the IK controls are doing. 2. Reassign So let's put markers on the joints driven by both IK and FK, such that when you switch between the two, Ragdoll knows how to follow along. So let's Reassign . 3. Retarget But recording still targets our original FK controls, and what we want is to record our IK controls. So we can Retarget . 4. Record Translation Unlike FK, IK isn't just rotation, but translation too. So let's tell Ragdoll to record the translation from these markers too. And there you have it! This works with IK, SpineIK, Follicles, Geometry Constraints; anything you can throw at it.","title":"Demo 3 - Inverse Kinematics"},{"location":"releases/2021.09.27/#demo-4-real-world-example","text":"Here's a work-in-progress animation from Christopher Page (thanks for lending it to me!) Let's see how we can use Ragdoll to help improve upon it. 1. The Problem Notice how the elbow intersects the table as he moves his torso around? A difficult problem and moving target as you need to keep tweaking both the torso and hand IK handle to tune your animation. 2. Isolate Timeline Since this animation is over 600 frames, we'll isolate our work to a small portion of it. For both performance and cleanliness; Ragdoll will only record onto the current timeline (or selected portion of it). 3. Assign Markers Like before, we'll assign markers to the underlying skeleton to respect what the IK solver does. We'll also make the hand Kinematic to respect the original animation exactly. The clavicle is also Kinematic per default, as it was the first assigned control - and is thus the \"root\" of our dynamic hierarchy. 4. Include Table Since we're interacting with the table, we'll include this too. Also Kinematic , no dynamics will be affecting it, and also as a Box shape to speed up and improve the stability of the simulation. 5. Tune Shapes Next we'll isolate contacts with just the elbow area, to respect the hand and lower arm animation. 6. Tune Material In this case, we'd like for the elbow to slide across the table, no friction. More Realism? In the real world, there would be friction and it could come in handy here too. But what should we expect from the elbow rubbing against the table? We should include the torso for this as well, which you absolutely can (and maybe should!). But to keep things simple, we'll let the clavicle preserve it's original animation exactly. 7. Retargeting Ragdoll will record onto the nodes you originally assign, but like before we want recording to go elsewhere; from joints to IK controls. 8. Record Translation Likewise, we'd also like translation included. And we don't care for the shoulder and clavicle animation; all we want is the IK handle and Pole Vector. 9. Record Simulation We're all set! Let's hit Record ! 10. Before And After And there we go! 2 minutes or less, and you've got a reusable setup for correcting the elbow whenever the animation changes. IK is intact and you can keep working with keyframes. Keeping Ragdoll attached to your rig has zero impact on performance (as you can see by looking at the fps counter near the bottom of the two comparisons), and once hidden it has no impact on your Outliner either. All clean! Here's one more I couldn't find room for, an earlier version of the animation with stepped keys and finger simulation. Look at all that juicy finger interaction with the table. \ud83d\ude0a Rig and Model courtesy of Ramon Arango - Apollo Rig","title":"Demo 4 - Real World Example"},{"location":"releases/2021.09.27/#new-menu","text":"Let's take a moment to reflect on what we've just seen. There are 3 new nodes in Ragdoll. # Node Description rdSolver The \"camera\" that monitors \"Markers\" and performs all heavy-lifting. rdMarker A tracking marker, something to monitor an individual control. rdGroup A collection of markers, with high-level control over many markers. Here's the new menu. If all goes well, it will completely replace the Active Rigid and Active Chain menu items, along with Controls including Mimic . All of those things are made possible in a much easier and performant way using Markers. The most important elements are at the top. # Item Description Assign Single Monitor a single object in the Maya scene. Use this for props, environment and other free-falling things. Assign Group Monitor a series of connected objects, like a limb. Record Transfer simulation to marked objects Like Active Chain , the order of selection determines the order in which markers assume your objects are connected. And adding more markers to a group is done by starting your selection from any point in an existing group and working your way outwards. Just like Active Chain . Limitations You currently cannot create multiple rdSolver nodes, but can work around it by importing one from another Maya scene file. The Guide Space is somewhat complicated. The group has one too that affects all markers, and per default it's set to -1 for Localspace . The benefit is that you can quickly change the space for all markers by changing this one attribute. The downside is that if you want to change it for just one marker, you first need to reset this attribute to 0 . These will be addressed in the upcoming few releases.","title":"New Menu"},{"location":"releases/2021.09.27/#recording","text":"Markers can be recorded all together, or independently. For example, say you wanted animation from frame 1-100, simulate 101-150 and return to animation from 151-200. You can do that. Furthermore, say you liked what the simulation was doing, but only on one half of the body. Or only on the hip, driving the main trajectory in a physically-plausible way. Keeping the rest of your animation intact. Record All With nothing selected, Ragdoll will record all marked controls to the current Maya playback range. Record Selected Markers Select a few controls to control what gets recorded. Record Range Limit the Maya playback range for control over when recording takes place. Record Selected Range Or, select an explicit range interactively. Intelligent Range A Kinematic marker is entirely animated, so there's no need to actually record those. Ragdoll will ensure only non-kinematic frames are recorded, so you can do things like this. Record to Animation Layer Ragdoll will record to whichever layer is currently active.","title":"Recording"},{"location":"releases/2021.09.27/#input-type","text":"In the above examples, I mentioned Kinematic and you probably spotted a few other options too, like Inherit and Guide . What are those? The Input Type is how Ragdoll should interpret the controls you assign. Did you mean for them remain animated, i.e. Kinematic ? Or should they follow the control around, i.e. Guide ? Or should they just fall with gravity, ignoring the original control altogether, i.e. Off ? The Input Type can be set either for a whole group of markers, or each marker individually. Type Description Inherit Do whatever the group is doing, or Kinematic if there is no group Off Do nothing, just fall under gravity Kinematic Follow the input exactly , physics need not apply Guide Follow the input approximately, with some Stiffness and Damping Off Treat the input as a starting position, but nothing else. Kinematic Follow the input exactly, no exceptions. Not even collisions. Guide Space -1 Follow the local angles of the input. Guide Space +1 Follow the world position and orientation of the input.","title":"Input Type"},{"location":"releases/2021.09.27/#retarget","text":"We've talked a lot about \"retargeting\". But what is that? Per default, markers are recorded onto the controls you assigned, this is called Rig to Rig . But often times, rigs are more complicated and what you want is for the simulation to look at one set of nodes, but record onto another. This is called Joint to Rig , but can be from any source. Even other controls (like FK to IK). The Old Days Think about how you would accomplish this using the Active Rigid or Active Chain commands. That would be a huge pain, but not with markers!","title":"Retarget"},{"location":"releases/2021.09.27/#reassign","text":"Over in Demo 2 - Ragdoll we \"reassigned\" already marked controls. What does that mean? In that example, we've assigned our FK controls directly, which means Ragdoll would grab the translation and rotation from those controls during simulation. But what we really wanted was the IK controls. But! We couldn't just assign to the IK controls directly, since they are indirectly rotating a characters limbs. So instead, we Reassign the markers previously made onto the underlying joints that follow IK around. We then also Retarget them, since they would have otherwise been recorded onto the original FK controls.","title":"Reassign"},{"location":"releases/2021.09.27/#reparent","text":"Sometimes, you change your mind. Success!","title":"Reparent"},{"location":"releases/2021.09.27/#guide-space","text":"Now let's talk about a few things you haven't seen yet. Look, it's Ragdoll Blaine! So what's happening here? Well, it looks like a Soft Pin to his head, along with a slight Guide Strength on the rest of his body. But unlike the Rigid , another significant advantage to Markers is their ability to capture both local and worldspace position and orientation of your controls. And because of this, you are able to interactively choose whether a marker should look at the Worldspace or Localspace position of your controls. Notice how with a Guide Space = -1 the controls arms remain relative the torso. And with Guide Space = 1 they instead follow the worldspace orientation of the controls. Just like a Soft Pin. This attribute is also animatable , and is how you can transition from animation into simulation and back again. Here's a more complete example: Frame Transition 100 Starts as a regular animated character 125 Transitions into physics as he jumps, for a physically-correct trajectory 155 Transitions back to animation once he rolls over on that cabinet 160 Transitions back to physics until he stands up 170 Transitions back into animation to match an exact pose 200 Partially transitions into physics, for secondary motion in the upper body as his arm is raised.","title":"Guide Space"},{"location":"releases/2021.09.27/#transitions","text":"Let's have a look at how you would use markers to transition between simulation and animation. Notice how we're animated up until the jump, and then Ragdoll takes over. Once he approaches that box, we turn our Guide Space from -1 to 1 and have him reach the target pose in worldspace. Once he's close, we switch Input Type to Kinematic and kinematically move him until we once again transition to Guide , this time with a Guide Space or -1 for pose space.","title":"Transitions"},{"location":"releases/2021.09.27/#self-collision","text":"Previously, it was very important that your shapes did not overlap any shape other than it's immediate neighbour. If they did, chaos ensued. Before Clavicles intersect their parent spine, but also each other! After With the new Self Collision = Off , this is no longer a problem. This can be taken into the extreme! And here's a another example to fill out a large volume in the center of a character. Attention Notice how the spine is made up of many shapes, some of which cover the width of the body, others the depth. An overlapping mess that would never have simply not have been possible without self-collision support! Original asset created by Mehmet Tayfur T\u00fcrkmeno\u011fluwe and Dr. Reel, licensed by The Rookies.","title":"Self Collision"},{"location":"releases/2021.09.27/#no-graph-editor-mess","text":"Because Rigids were children of your controls, Maya had a funny way of including them in the Graph Editor that rightly drove animators, myself included, absolutely mad . Before Just look at this; why-oh-why would I want channels from a completely unrelated node when working with the hip? After Contrast that to this, whereby only the nodes you actually select are made visible. You can even select Markers via the Channel Box and deselect your controls to get up real close.","title":"No Graph Editor Mess"},{"location":"releases/2021.09.27/#no-initial-state","text":"A significant effort was made to make the simulation start where you expected it to. Under the hood, simulation and animation were at odds with one another. Ragdoll needed to know where to start, but it was also telling your controls where to start. It's an inherent cycle, which was finally broken. Read More You can read all about the month-long journey in the release notes from March Nowadays, you barely have to think about it, but it does occasionally rear its ugly head. It is a hack. With Markers there isn't any cycle to begin with. Ragdoll only reads from your controls, it doesn't write to anything. Under the hood, recording is a 2-step process; first it simulates, and then it writes animation back onto the controls. That's how this cycle is broken, without having any effect on the overall workflow.","title":"No Initial State"},{"location":"releases/2021.09.27/#no-more-cycles","text":"With the previous version, because Rigids both read and wrote to each control, you could sometimes run into a situation where the parent depends on a child. Before Here, I'll try and make a second chain in the opposite direction of how the controls are laid out hierarchically. This cannot work; because in order for Ragdoll to figure out where the Passive hand should be, it would first need to consult the upper arm, which is both dynamic and a child of the spine, which is also dynamic. It's a lovely cycle. \u2764\ufe0f After With Markers , this isn't a problem because to Ragdoll every limb can now be independently evaluated, in parallel.","title":"No More Cycles"},{"location":"releases/2021.09.27/#lollipop-controls","text":"Sometimes, markers are added to an already busy control with tons of Channel Box entries. Lollipop controls can help organise things a little better. These can be moved around and scaled to suit your needs, and will provide access to the same marker node in the channel box, so you can select and edit the marker from either the originally marked control or this lollipop control.","title":"Lollipop Controls"},{"location":"releases/2021.09.27/#rotate-pivot","text":"Use the default Maya rotate pivot to control where to pin a simulation, both in worldspace and localspace. Attention Take care about scale , especially the scale pivot. Ragdoll can sometimes struggle when the scale pivot differs from the rotate pivot. This will be addressed in a future release.","title":"Rotate Pivot"},{"location":"releases/2021.09.27/#quality-of-life","text":"Some minor things to brighten your day.","title":"Quality of Life"},{"location":"releases/2021.09.27/#real-ground","text":"With Rigids , the ground was embedded into the scene. With Markers , an actual ground is created to for more stability and more control over its physical parameters. Something that can also be animated, and that dynamically appears right underneath your markers.","title":"Real Ground"},{"location":"releases/2021.09.27/#joints-and-the-attribute-editor","text":"The Attribute Editor doesn't show you Rigids related to Maya joints because of a Maya UI quirk. With Markers , this is no longer a problem!","title":"Joints and the Attribute Editor"},{"location":"releases/2021.09.27/#hidden-solver","text":"Hiding the solver completely removes all overhead of having Ragdoll in your scene. Previously, with rdScene and rdRigid , because they were directly connected to your controls, hiding things made little difference. But now, because we no longer have this direct connection, all computations come from explicitly seeing the rdSolver node. No visible rdSolver node, no computations. Period.","title":"Hidden Solver"},{"location":"releases/2021.09.27/#enhanced-determinism","text":"TLDR Sometimes, re-opening the scene could lead to different results. This has now been fixed. Each time you play a simulation starting from the beginning, the results are the same. This is an important characteristic of any simulation and is called \"determinism\". It used to be the case however that when you re-opened the scene, there was a small chance the results would differ from when you last saved it. This has now been fixed. The determinism is now dependent on the order in which rigid bodies connect to the rdSolver node. It's an array attribute, whose order is saved with the Maya scene.","title":"Enhanced Determinism"},{"location":"releases/2021.09.27/#multiple-floating-licences","text":"Whenever a machine connected to your floating licence server, the host and IP were stored on the machine in an effort to speed up subsequent connections made. However, this also meant that you weren't able to update those details. Despite providing new details, Ragdoll would favour the already-stored details. Worse yet, the Ragdoll UI would lie to you, by repeating the connection details provided in the RAGDOLL_FLOATING environment variable, despite those not actually being used. This release addresses this by always using the details you provide, and not bother reusing any previously provided details. In addition, you now have the option to explicitly query and set server details directly. # Will query the *actual* server used by Ragdoll, rather # than return the environment variable you provided cmds . ragdollLicence ( getServer = True ) # Will manipulate the currently-in-use key, meaning it will # try and drop a licence from this address as well cmds . ragdollLicence ( setServer = ( \"localhost\" , 1313 ))","title":"Multiple Floating Licences"},{"location":"releases/2021.09.27/#next-release","text":"This release is part \u00bc, for next 2/4 release you can expect Performance Improvements . In this release, simulation and overall Maya scenegraph performance has seen a 200x performance boost, the performance is already there. You'll notice it as you try them on your rigs. However, rendering performance has dropped significantly, cancelling out most of that performance gain. Here's what performance looks like now. Rendering mostly Maya default shading, rendeing its own things. Unrelated to Ragdoll. The Rig Evaluation on the other hand is almost entirely Ragdoll. It's connected to every control in this rig, forcing each control to be evaluated in serial; one after the other. Here's what it looks like with Markers . Notice the huge pile of lines to the left? Those are all running parallel and almost entirely default Maya evaluations; things your rig would do without Ragdoll. Rendering on the other hand is almost entirely Ragdoll, it is very slow. To properly compare performance between Rigids and Markers , here's what you should be looking at. This is the only thing Ragdoll does to your rig. This is the entire overhead, the added load onto your rig. 16 microseconds . That's 0.016 ms . For a rig to run at 30 fps, it'll need 1,000/30 = 33 ms per frame. This overhead, 0.016 ms/frame is all Ragdoll needs to solve an entire character, contacts and constraints and forces, all of it. In this particular profiling, that's 430x faster than Rigids , which not only took longer to solve but made everything else slower by just being connected to your controls. So how about we get this rendering performance sorted, shall we?","title":"Next Release"},{"location":"releases/2021.09.27/#limitations","text":"These are some of the things lacking from Markers in this release that we'll be working on for subsequent releases. Selecting rigids interacively Manipulating shapes interactively Manipulating constraints interactively Toggle between previous animation and recorded simulation Support for recording onto an animation layer No \"live-mode\", where physics drives a control interactively Markers cannot be exported Markers cannot have additional constraints","title":"Limitations"},{"location":"releases/2021.10.07/","text":"Highlight for this release is Performance , and is part 2/4 of the new Markers . ADDED Performance Less work, greater parallelism and more GPU ADDED Overlap Groups Fine control over what overlaps with what ADDED Asleep Start simulating on first contact ADDED Ignore Gravity Because sometimes, you don't want to play by the rules ENHANCED Quality of Life Automated clean-up, support for Z-up and more! Showcase You know the drill, we'll start with some eye candy. \ud83c\udf6c New Shading Now more like actual candy. Nom nom nom! Raining Ragdolls Quick! Get inside! Do the Robot Model and Rig courtesy of Amedeo Beratta Vehicular Render Made by @tris Guide Space Mania Oh the trickery you can get up to. \ud83e\udd73 Anniversary That's right! Ragdoll turned 1 this week! \ud83e\udd73 In my original business plan, I had written.. \"Revenue, year 1: \u00a320,000\" ..which was blissfully optimistic. However! I'm happy to say that Ragdoll blew past this in the first 6 days into launch, on the 28 th of July this year. Very few startups achieve this amount of revenue in year 1; the vast majority achieve \u00a30 for the first number of years (I watch a lot of Dragon's Den \ud83d\ude05), the expectation being that they will regain their investment once enough value has been created. But given we're past this point already, this to me is validation that you want this . So, let's keep it going, shall we? :) Manikin Rig Throughout these notes, I'll be using this guy here. Feel free to download and play around with it. Download Manikin Performance This release was all about performance, so how did we do? In short, very well! We're now a lot closer to the capabilities of your hardware with a lot less waste. Because you see, software development is a lot like Jenga. You start off with a tower full of bricks, but every brick adds to the overall weight of the tower. And not every brick is necessary to keep it standing. The Eiffel Tower is an example of what a structure can look like with the absolute minimal amount of material. It is an optimal shape; anything added is wasted weight, anything removed would sacrifice stability. That is the structure we've been working towards with this release. In terms of time spent, Ragdoll has three stages. # Stage Description 1 Evaluation This is primarily your character rig - the transform hierarchy, constraints, any deformers, and so forth. It is how data is passed from Maya into Ragdoll. 2 Simulation Once data has been aquired, Ragdoll considers all of it and applies forces, solves constraints, contacts, that kind of thing. 3 Rendering Finally, we need pixels. In the case of Ragdoll, this means generating and uploading geometry to the GPU; including capsules but also your meshes which are converted into \"convex hulls\". Simulation has always been fast and in the previous release, we focused entirely on workflow which had an indirect impact on Evaluation and Rendering . One got faster, but the other got slower. Changes in Part \u00bc Let's recap what happened in the previous release. We tackled Evaluation which boosted performance by 2-10x by unlocking parallelism. Before, the better your character rig benefited from multithreading the worse it would perform with Ragdoll. Ragdoll would force any control you simulated into serial evaluation - to compute one after another - because the solver was fundamentally single-threaded. With Markers, Ragdoll separated from the overall rig evaluation, which meant (1) your rig can continue running in parallel and (2) Ragdoll could also run in parallel. Consider this example. Rigids Markers This is how Maya scheduled evaluation for this scene with Rigid versus Marker . To the left, everything runs one after the other. It's terrible. To the right, every box is evaluated in parallel. Which means the more boxes and cores you have, the better utilisation you get. The scene itself is very simple, it's this one here. So evaluation got faster, but rendering got slower. All-in-all we gained about 100% performance. With this release, we'll tackle that rendering block. Let's have a look at what's changed, in order of most-to-least significance. Topic Savings Description Less CPU to GPU communication 1550x More buffers, less uniforms Connection Monitoring 40x Less dependence on time, more on physical connections being made and unmade Change Monitoring 40x Ignore anything that hasn't actually changed Less Dirty Propagation 3x Less of a shotgun blast, more like a sniper CPU to GPU Communication The previous release, and each one before it, had 1 shader per rigid. In the case of 600 rigid bodies, that meant 600 shaders. 600 shaders means 600 parameter updates of primarily color and 600 unique draw calls. On top of this, all geometry was regenerated and re-uploaded to the GPU on every frame. Robust, but not very fast. This release consolidates all shaders into one , colors are uploaded only once alongside their geometry and rendered using a custom GLSL shader (i.e. OpenGL 3.3). What about DirectX? If you are on Windows and can't use OpenGL for whichever reason, there is backwards compatibility built-in. from ragdoll import options options . write ( \"useShaders\" , False ) Or via the Ragdoll Preferences. Bearing in mind this will cost you 50% of the rendering performance and won't benefit from future shading related features and improvements. The option will remain until it's clear whether and how much it is actually used. (Let us know in the chat! ) Let's have a look at how this change affects your overall experience. Before (7fps) After (130 fps) A closer look reveals exactly where this improvement comes from. Before This block is what we control, it's the Ragdoll rendering pipeline taking a whopping 93 ms per refresh. After With this release, this number dropped to 0.06ms (58 microseconds) that's an improvement of 1550x (!). What about the other blocks? The bottleneck has now moved to that green one and all of those blue, and those are Maya's internal rendering pipeline. There isn't much we can do to directly impact it; it's mostly out of our hands. However, by massaging our data more and making life easier for Maya it should be possible to reduce these as well. See Future Work for details on next steps, and if this is something you, fellow reader, is familiar with do get in touch! Finally, as a result of having complete control over the shader running on the GPU, we're now able to more intimately design it to look the way we want. Expect more refinements here over time. Before After Connection & Change Monitoring In the previous release, and all versions of Ragdoll so far, we've tasked Maya with evaluating every plug on every frame, including the heavy-duty plugs between Rigid Body -> Solver . Here's what this felt like in a scenario of 600 unique objects. Before (5 fps) Painful! The reason is because even though we're only moving a single box, Ragdoll checks-in with all other boxes too. After (90 fps) Blissful. In this case, only one of the boxes is actually updated, as one would expect. Let's have a closer look at where performance is going here. Before Oh that's ghastly. Not only does it spend time evaluating all of those boxes, but it's making the solver take much longer consolidating the results taking a whopping 56 ms . After Whereas now, as one would expect, we're only evaluating this one box in a total of 0.7ms , resulting in a performance improvement 80x. That looks like 3? And that's true, it still makes three separate calls to this one box. Which means there's more room to optimise here, and we'll get there. Needless to say, this happened before as well but was obscured by how many calls there actually are. Luckily, at least two of these calls happen in parallel. 600 capsules The current framerate on 600 unique objects, something for future Ragdoll to try and compete with. For reference, an average ragdoll consists of about 20-30 objects. Future Work There is at least 4-16x performance left on the table for specialised cases. Work Savings Benefit Optimised Render Items 4x Native Maya still renders 4x faster than us, which means there's more things we can do. Instancing for Rendering 2-4x Every render item is currently unique which means neither Maya nor your GPU is able to reuse geometry. Instancing is how games is able to render millions of objects on-screen at 60 fps, and best we can hope for is thousands. Instancing for Simulation 2-4x Likewise, every physics object is unique and, again, instancing in simulation is how games is able to run destruction and have thousands of objects interact in real-time. The challenge in both of these is deduplication; of identifying which of the many shapes you use can reuse their geometry. Overlap Group Specify which markers may overlap rather than collide. This can be useful to enable dense areas of a character, like the clavicles, where there is natural overlap amongst large shapes like with the neck and spine. Value Meaning -1 No overlap allowed 0 Default, respects self-collision on the group (if any) 1-255 Overlap everything with the same number An rdMarker part of a rdGroup can get an overlap group assigned procedurally, based on other members of that group. For example, in a complete ragdoll, all markers are part of the same group. So a Self Collide = On means these will all be given the same overlap group. If it isn't in a group, then 0 is the same as -1 , in that it will collide with everything. Let's have a look at a few scenarios. Collide with Everything In this example, every marker is part of the same group. The group has Self Collide = Off , which is fine for just about every marker except the fingers . In that case, we do want self-collision, so they are given the group -1 . Respect Self Collision In this case, we're happy with a default group of 0 since we don't need anything to self collide. Especially these clavicles that overlap significantly! Surgical Control Finally, for the very specific cases of wanting two or more markers to overlap. Notice how we give both the ground and 3 of the boxes an Overlap Group = 5 . Asleep Sometimes, you want things to stay put until something comes into contact with it. That's when you can tell a marker to start asleep, and \"wake up\" when necessary. Ignore Gravity It surrounds us. It penetrates us. It binds the galaxy together. But sometimes, you just don't care. Quality of Life A few things to make your day that much more bright. \ud83c\udf1e Guide Space 2.0 In the previous release, we introduced Guide Space . Which was a quick way of controlling whether a simulation should follow your animation in.. Local Space World Space Both But it was challenging to control, not very obvious. Especially with how it was also taking into account its \"group\" guide space. This release addresses this by enabling you to specify a guide space for all markers and selectively override only the ones you're interested in. Just like how the Input Space works. Group Guide Space Override all guide spaces, by editing the group. Marker Guide Space Or gain surgical control over guide space per-marker. Have Fun \ud83e\udd2d Auto Delete The Delete All Physics menu command does what it says on the tin; it deletes all Ragdoll nodes from your Maya scene. But deleting a node, such as the new rSolver left behind anything associated with it, like rGroup and any rMarker nodes. This releases addresses this by automatically removing anything that depends on the node you delete. For example.. Deleting a rMarker node also deletes any associated lollipop controls Deleting a rGroup also deletes the associated rMarker nodes Deleting the rSolver deletes all rGroup and rMarker nodes Therefore, deleting a solver is now equivalent to Delete All Physics , making it much more intuitive to delete things on a whim. Reset Button Minor cosmetic improvement, the Reset to Default button now has an icon so you can actually tell it's a reset button (and not a bug, as many have pointed out \ud83d\ude05). Z-up The default plane and solver offset was a off in the previous release, this fixes that. You can also manually re-adjust the plane and remove and orientation from the solver node to fix it locally, the solver itself is A-OK. Auto Time Rather than having to specify which frame to start simulating at, Ragdoll can now keep track of your animation start frame. Either the start of the range , or the full timeline. Or, you can still set a Custom start time for when you do care about specifics. Limitations Monitoring for and responding to changes is a hard problem. Odds are some things aren't updating the way you expect, which could affect viewport rendering, or worse, the actual simulation. If you encounter any such issues, please let us know in the chat or ping me directly at marcus@ragdolldynamics.com Here are the currently known issues that we'll be fixing once a solution presents itself. Motion Blur As an unintended consequence of the optimisation and shader work, we're currently compliant with Maya's requirement for motion blur. Since all of our simulation is transform-based, it means all of what you simulate can be motion blurred, as opposed to deformer and particle-based motion. It won't work with any animated attributes, which makes it rather limited in what you can use it for. \ud83e\udd14 Maintain Offset IK/FK If you retarget a marker, the difference between the original and target is stored. When you record, you have the option to Maintain Offset . That's important if the assigned control has a different position and/or orientation than the destination control. For example, you can assign to a joint, but record onto a NURBS control. For example, IK joints are assigned markers but are retargeted onto FK controls, it's important that you retarget when they are both in a similar pose. Otherwise, the difference between them will remain after recording. To combat this, you have two options. Do not maintain offset Make sure IK and FK match when you Retarget (1) may not always be an option. If the position and/or orientation of an assigned control is simply different, then there isn't much you can do. :( (2) is your best option. If you make a mistake, you can always re-retarget to the same control again, and the offset will be updated. Recording Kinematic Markers When a marker treats the input as Kinematic , it means it won't simulate it. It'll be 100% locked to animation. If that's the case, then there's really no point in recording those keys, right? Because they'd be 100% identical to the animation? Except! If there's a parent, then we'll still need those keys to compensate for the parent not being kinematic. Problem Let's record without kinematic keys. Notice how the hand isn't given any keys, even though it needed them? Solution Record all keys, and the hand - even though kinematic - will still get recorded. Record to Custom Attributes Sometimes, rotation isn't coming from Rotate X but rather a custom Ball Roll attribute on a different IK control. As Ragdoll only understands Translate and Rotate , how would you go about recording onto this attribute!? Here's what you can do. Create a new Locator Retarget the foot to this Locator Connect Locator.rotateX -> R_foot_CTL.ballRoll Now Ragdoll will record onto a familiar channel, and Maya will handle the conversion back onto the rig. Slow Constraints Like in earlier versions, drawing constraints are the slowest part. If you don't need them, disable them. You can do that either on the rSolver node, or individually per rMarker node. Resources Some well-hidden but essential resources for any of the above. If you are into anything related to Maya plug-in development and performance, you'll treasure these as I have. Parallel Evaluation VP2 API Porting Guide for Locators VP2 API Porting Guide Part 1 VP2 API Porting Guide Part 2","title":"2021.10.07"},{"location":"releases/2021.10.07/#showcase","text":"You know the drill, we'll start with some eye candy. \ud83c\udf6c New Shading Now more like actual candy. Nom nom nom! Raining Ragdolls Quick! Get inside! Do the Robot Model and Rig courtesy of Amedeo Beratta Vehicular Render Made by @tris Guide Space Mania Oh the trickery you can get up to. \ud83e\udd73","title":"Showcase"},{"location":"releases/2021.10.07/#anniversary","text":"That's right! Ragdoll turned 1 this week! \ud83e\udd73 In my original business plan, I had written.. \"Revenue, year 1: \u00a320,000\" ..which was blissfully optimistic. However! I'm happy to say that Ragdoll blew past this in the first 6 days into launch, on the 28 th of July this year. Very few startups achieve this amount of revenue in year 1; the vast majority achieve \u00a30 for the first number of years (I watch a lot of Dragon's Den \ud83d\ude05), the expectation being that they will regain their investment once enough value has been created. But given we're past this point already, this to me is validation that you want this . So, let's keep it going, shall we? :)","title":"Anniversary"},{"location":"releases/2021.10.07/#manikin-rig","text":"Throughout these notes, I'll be using this guy here. Feel free to download and play around with it. Download Manikin","title":"Manikin Rig"},{"location":"releases/2021.10.07/#performance","text":"This release was all about performance, so how did we do? In short, very well! We're now a lot closer to the capabilities of your hardware with a lot less waste. Because you see, software development is a lot like Jenga. You start off with a tower full of bricks, but every brick adds to the overall weight of the tower. And not every brick is necessary to keep it standing. The Eiffel Tower is an example of what a structure can look like with the absolute minimal amount of material. It is an optimal shape; anything added is wasted weight, anything removed would sacrifice stability. That is the structure we've been working towards with this release. In terms of time spent, Ragdoll has three stages. # Stage Description 1 Evaluation This is primarily your character rig - the transform hierarchy, constraints, any deformers, and so forth. It is how data is passed from Maya into Ragdoll. 2 Simulation Once data has been aquired, Ragdoll considers all of it and applies forces, solves constraints, contacts, that kind of thing. 3 Rendering Finally, we need pixels. In the case of Ragdoll, this means generating and uploading geometry to the GPU; including capsules but also your meshes which are converted into \"convex hulls\". Simulation has always been fast and in the previous release, we focused entirely on workflow which had an indirect impact on Evaluation and Rendering . One got faster, but the other got slower. Changes in Part \u00bc Let's recap what happened in the previous release. We tackled Evaluation which boosted performance by 2-10x by unlocking parallelism. Before, the better your character rig benefited from multithreading the worse it would perform with Ragdoll. Ragdoll would force any control you simulated into serial evaluation - to compute one after another - because the solver was fundamentally single-threaded. With Markers, Ragdoll separated from the overall rig evaluation, which meant (1) your rig can continue running in parallel and (2) Ragdoll could also run in parallel. Consider this example. Rigids Markers This is how Maya scheduled evaluation for this scene with Rigid versus Marker . To the left, everything runs one after the other. It's terrible. To the right, every box is evaluated in parallel. Which means the more boxes and cores you have, the better utilisation you get. The scene itself is very simple, it's this one here. So evaluation got faster, but rendering got slower. All-in-all we gained about 100% performance. With this release, we'll tackle that rendering block. Let's have a look at what's changed, in order of most-to-least significance. Topic Savings Description Less CPU to GPU communication 1550x More buffers, less uniforms Connection Monitoring 40x Less dependence on time, more on physical connections being made and unmade Change Monitoring 40x Ignore anything that hasn't actually changed Less Dirty Propagation 3x Less of a shotgun blast, more like a sniper","title":"Performance"},{"location":"releases/2021.10.07/#cpu-to-gpu-communication","text":"The previous release, and each one before it, had 1 shader per rigid. In the case of 600 rigid bodies, that meant 600 shaders. 600 shaders means 600 parameter updates of primarily color and 600 unique draw calls. On top of this, all geometry was regenerated and re-uploaded to the GPU on every frame. Robust, but not very fast. This release consolidates all shaders into one , colors are uploaded only once alongside their geometry and rendered using a custom GLSL shader (i.e. OpenGL 3.3). What about DirectX? If you are on Windows and can't use OpenGL for whichever reason, there is backwards compatibility built-in. from ragdoll import options options . write ( \"useShaders\" , False ) Or via the Ragdoll Preferences. Bearing in mind this will cost you 50% of the rendering performance and won't benefit from future shading related features and improvements. The option will remain until it's clear whether and how much it is actually used. (Let us know in the chat! ) Let's have a look at how this change affects your overall experience. Before (7fps) After (130 fps) A closer look reveals exactly where this improvement comes from. Before This block is what we control, it's the Ragdoll rendering pipeline taking a whopping 93 ms per refresh. After With this release, this number dropped to 0.06ms (58 microseconds) that's an improvement of 1550x (!). What about the other blocks? The bottleneck has now moved to that green one and all of those blue, and those are Maya's internal rendering pipeline. There isn't much we can do to directly impact it; it's mostly out of our hands. However, by massaging our data more and making life easier for Maya it should be possible to reduce these as well. See Future Work for details on next steps, and if this is something you, fellow reader, is familiar with do get in touch! Finally, as a result of having complete control over the shader running on the GPU, we're now able to more intimately design it to look the way we want. Expect more refinements here over time. Before After","title":"CPU to GPU Communication"},{"location":"releases/2021.10.07/#connection-change-monitoring","text":"In the previous release, and all versions of Ragdoll so far, we've tasked Maya with evaluating every plug on every frame, including the heavy-duty plugs between Rigid Body -> Solver . Here's what this felt like in a scenario of 600 unique objects. Before (5 fps) Painful! The reason is because even though we're only moving a single box, Ragdoll checks-in with all other boxes too. After (90 fps) Blissful. In this case, only one of the boxes is actually updated, as one would expect. Let's have a closer look at where performance is going here. Before Oh that's ghastly. Not only does it spend time evaluating all of those boxes, but it's making the solver take much longer consolidating the results taking a whopping 56 ms . After Whereas now, as one would expect, we're only evaluating this one box in a total of 0.7ms , resulting in a performance improvement 80x. That looks like 3? And that's true, it still makes three separate calls to this one box. Which means there's more room to optimise here, and we'll get there. Needless to say, this happened before as well but was obscured by how many calls there actually are. Luckily, at least two of these calls happen in parallel. 600 capsules The current framerate on 600 unique objects, something for future Ragdoll to try and compete with. For reference, an average ragdoll consists of about 20-30 objects.","title":"Connection &amp; Change Monitoring"},{"location":"releases/2021.10.07/#future-work","text":"There is at least 4-16x performance left on the table for specialised cases. Work Savings Benefit Optimised Render Items 4x Native Maya still renders 4x faster than us, which means there's more things we can do. Instancing for Rendering 2-4x Every render item is currently unique which means neither Maya nor your GPU is able to reuse geometry. Instancing is how games is able to render millions of objects on-screen at 60 fps, and best we can hope for is thousands. Instancing for Simulation 2-4x Likewise, every physics object is unique and, again, instancing in simulation is how games is able to run destruction and have thousands of objects interact in real-time. The challenge in both of these is deduplication; of identifying which of the many shapes you use can reuse their geometry.","title":"Future Work"},{"location":"releases/2021.10.07/#overlap-group","text":"Specify which markers may overlap rather than collide. This can be useful to enable dense areas of a character, like the clavicles, where there is natural overlap amongst large shapes like with the neck and spine. Value Meaning -1 No overlap allowed 0 Default, respects self-collision on the group (if any) 1-255 Overlap everything with the same number An rdMarker part of a rdGroup can get an overlap group assigned procedurally, based on other members of that group. For example, in a complete ragdoll, all markers are part of the same group. So a Self Collide = On means these will all be given the same overlap group. If it isn't in a group, then 0 is the same as -1 , in that it will collide with everything. Let's have a look at a few scenarios.","title":"Overlap Group"},{"location":"releases/2021.10.07/#collide-with-everything","text":"In this example, every marker is part of the same group. The group has Self Collide = Off , which is fine for just about every marker except the fingers . In that case, we do want self-collision, so they are given the group -1 .","title":"Collide with Everything"},{"location":"releases/2021.10.07/#respect-self-collision","text":"In this case, we're happy with a default group of 0 since we don't need anything to self collide. Especially these clavicles that overlap significantly!","title":"Respect Self Collision"},{"location":"releases/2021.10.07/#surgical-control","text":"Finally, for the very specific cases of wanting two or more markers to overlap. Notice how we give both the ground and 3 of the boxes an Overlap Group = 5 .","title":"Surgical Control"},{"location":"releases/2021.10.07/#asleep","text":"Sometimes, you want things to stay put until something comes into contact with it. That's when you can tell a marker to start asleep, and \"wake up\" when necessary.","title":"Asleep"},{"location":"releases/2021.10.07/#ignore-gravity","text":"It surrounds us. It penetrates us. It binds the galaxy together. But sometimes, you just don't care.","title":"Ignore Gravity"},{"location":"releases/2021.10.07/#quality-of-life","text":"A few things to make your day that much more bright. \ud83c\udf1e","title":"Quality of Life"},{"location":"releases/2021.10.07/#guide-space-20","text":"In the previous release, we introduced Guide Space . Which was a quick way of controlling whether a simulation should follow your animation in.. Local Space World Space Both But it was challenging to control, not very obvious. Especially with how it was also taking into account its \"group\" guide space. This release addresses this by enabling you to specify a guide space for all markers and selectively override only the ones you're interested in. Just like how the Input Space works. Group Guide Space Override all guide spaces, by editing the group. Marker Guide Space Or gain surgical control over guide space per-marker. Have Fun \ud83e\udd2d","title":"Guide Space 2.0"},{"location":"releases/2021.10.07/#auto-delete","text":"The Delete All Physics menu command does what it says on the tin; it deletes all Ragdoll nodes from your Maya scene. But deleting a node, such as the new rSolver left behind anything associated with it, like rGroup and any rMarker nodes. This releases addresses this by automatically removing anything that depends on the node you delete. For example.. Deleting a rMarker node also deletes any associated lollipop controls Deleting a rGroup also deletes the associated rMarker nodes Deleting the rSolver deletes all rGroup and rMarker nodes Therefore, deleting a solver is now equivalent to Delete All Physics , making it much more intuitive to delete things on a whim.","title":"Auto Delete"},{"location":"releases/2021.10.07/#reset-button","text":"Minor cosmetic improvement, the Reset to Default button now has an icon so you can actually tell it's a reset button (and not a bug, as many have pointed out \ud83d\ude05).","title":"Reset Button"},{"location":"releases/2021.10.07/#z-up","text":"The default plane and solver offset was a off in the previous release, this fixes that. You can also manually re-adjust the plane and remove and orientation from the solver node to fix it locally, the solver itself is A-OK.","title":"Z-up"},{"location":"releases/2021.10.07/#auto-time","text":"Rather than having to specify which frame to start simulating at, Ragdoll can now keep track of your animation start frame. Either the start of the range , or the full timeline. Or, you can still set a Custom start time for when you do care about specifics.","title":"Auto Time"},{"location":"releases/2021.10.07/#limitations","text":"Monitoring for and responding to changes is a hard problem. Odds are some things aren't updating the way you expect, which could affect viewport rendering, or worse, the actual simulation. If you encounter any such issues, please let us know in the chat or ping me directly at marcus@ragdolldynamics.com Here are the currently known issues that we'll be fixing once a solution presents itself.","title":"Limitations"},{"location":"releases/2021.10.07/#motion-blur","text":"As an unintended consequence of the optimisation and shader work, we're currently compliant with Maya's requirement for motion blur. Since all of our simulation is transform-based, it means all of what you simulate can be motion blurred, as opposed to deformer and particle-based motion. It won't work with any animated attributes, which makes it rather limited in what you can use it for. \ud83e\udd14","title":"Motion Blur"},{"location":"releases/2021.10.07/#maintain-offset-ikfk","text":"If you retarget a marker, the difference between the original and target is stored. When you record, you have the option to Maintain Offset . That's important if the assigned control has a different position and/or orientation than the destination control. For example, you can assign to a joint, but record onto a NURBS control. For example, IK joints are assigned markers but are retargeted onto FK controls, it's important that you retarget when they are both in a similar pose. Otherwise, the difference between them will remain after recording. To combat this, you have two options. Do not maintain offset Make sure IK and FK match when you Retarget (1) may not always be an option. If the position and/or orientation of an assigned control is simply different, then there isn't much you can do. :( (2) is your best option. If you make a mistake, you can always re-retarget to the same control again, and the offset will be updated.","title":"Maintain Offset IK/FK"},{"location":"releases/2021.10.07/#recording-kinematic-markers","text":"When a marker treats the input as Kinematic , it means it won't simulate it. It'll be 100% locked to animation. If that's the case, then there's really no point in recording those keys, right? Because they'd be 100% identical to the animation? Except! If there's a parent, then we'll still need those keys to compensate for the parent not being kinematic. Problem Let's record without kinematic keys. Notice how the hand isn't given any keys, even though it needed them? Solution Record all keys, and the hand - even though kinematic - will still get recorded.","title":"Recording Kinematic Markers"},{"location":"releases/2021.10.07/#record-to-custom-attributes","text":"Sometimes, rotation isn't coming from Rotate X but rather a custom Ball Roll attribute on a different IK control. As Ragdoll only understands Translate and Rotate , how would you go about recording onto this attribute!? Here's what you can do. Create a new Locator Retarget the foot to this Locator Connect Locator.rotateX -> R_foot_CTL.ballRoll Now Ragdoll will record onto a familiar channel, and Maya will handle the conversion back onto the rig.","title":"Record to Custom Attributes"},{"location":"releases/2021.10.07/#slow-constraints","text":"Like in earlier versions, drawing constraints are the slowest part. If you don't need them, disable them. You can do that either on the rSolver node, or individually per rMarker node.","title":"Slow Constraints"},{"location":"releases/2021.10.07/#resources","text":"Some well-hidden but essential resources for any of the above. If you are into anything related to Maya plug-in development and performance, you'll treasure these as I have. Parallel Evaluation VP2 API Porting Guide for Locators VP2 API Porting Guide Part 1 VP2 API Porting Guide Part 2","title":"Resources"},{"location":"releases/2021.10.25/","text":"Highlight for this release is Linking and Caching , and is part 3 out of 4 of the new Markers . ADDED Solver Linking Run two or more solvers together as one ADDED Solver Caching Run once and update on-demand ADDED Marker Limits On par with the previous constraints, but much easier to work with ADDED Marker Constraints Including Soft Pin! ADDED Cascading Attributes Control an entire simulation from one spot ADDED Recording Performance A bit faster recording Showcase Let's start these notes with some examples of what you can do with all of the new features added. \ud83e\udd70 Best Friends, No Matter What Two referenced characters, their solvers linked. Hang On! The new Distance Constraint at work. Dance Baby! The new Pin Constraint working alongside a Distance Constraint and regular old pose matching. Manikin Rig Updated with limits from this release. As before, this guy can either be opened or referenced into your scene. See Solver Linking for how you can reference multiple characters into the same simulation. Download Manikin New Tutorials Markers have one part left before being considered complete, at which point they can completely succeed Active Rigid and Active Chain . Until then, here's how you can get started with Markers today. td { vertical-align: middle !important; } Tutorial Duration Description Markers 101 01:23 What are markers? Markers 101 - Key Concepts 03:23 Overview of Input Type and Pose Space Markers 101 - Local and World 03:00 Overview of the two Pose Spaces, local and world Overlapping Motion I 02:27 The very basics or Capture and Record Overlapping Motion II 02:21 Animation layers Full Ragdoll I 04:08 Hierarchy and volume Full Ragdoll II 04:05 Kinematic and animation Full Ragdoll III 04:30 Self collisions and recording IK I 03:00 Capturing the skeleton IK II 01:59 Retargeting to IK controls IK III 01:59 Record both Translation and Rotation Practical Example I 06:53 Fix table and elbow intersection in this dialog performance Solver Linking Reference two characters, link their solvers. Until now, you've been able to author physics using Active Chain and combine scenes using the Combine Scene menu item. That would transfer all connected rigids from one scene to another. But, that feature is destructive . There's no way to \"uncombine\" and even if you could, there's no record of what was originally combined. Let me introduce Solver Linking , a lightweight and non-destructive alternative. Linking This fellow is referenced twice, and get their solvers linked together. Unlinking Unlinking restores their previous behavior exactly. That's neat, but can you.. I know exactly what you're thinking, I was thinking the same thing. Can you link a solver to another solver that is also linked? So that I can build a network of simple solvers that all work together to form one complex solver? Yes. Yes, you can. \ud83e\udd2d See below. Example Here are 2 assets, a manikin and a backpack. Manikin Backback The backback and manikin has been combined into one, which is then referenced twice into the final scene for a total of 4 unique solvers. Non-destructively link solvers Notice the hierarchy of solvers formed here, enabling you to build complex solvers out of many small solvers. Non-destructively unlinking too Likewise, safely deconstruct a network of solvers by just removing the connection. Technically, a solver is added to another solver in the same manner a marker, group and constraint is added. One big happy family. Solver Caching Ragdoll runs alongside your character animation, but sometimes it can be useful to keep the results from a previous run and stop being so interactive. Meet Cache and Uncache . Caching is entirely non-destructive, and in fact leverages the very same cache you've been enjoying all this time whenever rewinding. The menu commands toggle an attribute on your solver node, called .cache and automatically plays the entire timeline for you. But the same result can be achieved by setting the attribute and playing it yourself. The minimal HUD will show you what's been cached, and like before once you resume playback from a cached to an uncached frame, Ragdoll will continue filling up the cache as one would expect. Look forward to a future release where caching happens in the background, as you work. Something that can also be handy from time to time (pun!). Limitations The viewport HUD currently draws relative the solver node in your Outliner. Moving this node also moves the HUD, which isn't right. Moving it along the Z-axis can actually cause the HUD to vanish due to being outside of the camera frustrum. Other than that, if you encounter odd behavior let me know. This should work just fine in all cases where Ragdoll works, since the underlying mechanics are the same. Marker Limits Markers now support the limits you've grown accustomed to from chains and constraints. They are much easier to work with, now that they are built-in to each marker and have an understanding for what a \"parent\" is. You should find a lot less need to use Edit Pivots from here on, and in the next release you'll also get some interactive manipulators to avoid the Channel Box even more. Limit Type Hinge Limit The simplest of limits, allow a limb to rotate along a single axis. Like hinges on a door. Use this for knees and elbows. Ragdoll Limit For more complex anatomical limits, such as shoulders and hips, use the \"ragdoll\" limit for control over each of the 3 rotate axes. Defaults A good place to start is to just play with default settings and get an idea of what it looks like. Customise In this case, we'll keep the leg from crossing over too far, and from bending too far backwards. Like a real human leg. Custom Limit The Hinge and Ragdoll limits should cover the vast majority of limit needs, but sometimes you need more control. The Custom limit lets you control the parent and child frames independently, similar to the \"traditional\" Rigid constraints let you do. Here's an example of replicating the Ragdoll constraint with a custom limit. Axis Specify the \"main\" axis for your limit. Different rigs follow different conventions, and this attribute enables you to keep Ragdoll in the loop. It should typically align with whatever axis your joint or control points in the direction of the child joint or control. Rotation vs Offset You can either rotate or offset the limit. Rotation rotates both parent and child frames Offset rotates only the parent frame Remember The Parent Frame is the space in which a Child Frame is allowed to move. Marker Constraints You can now constrain one marker to anothe! Constraint Type Description Weld Constraint Simplest of constraints, welds two markers together; no change to their distance or relative orientation is allowed. This is akin to the Maya Parent Constraint Distance Constraint Maintain a minimum, maximum or total distance between two markers. Pin Constraint Match a position and orientation in worldspace, similar to Drive Space = World . Weld Maintain the position and orientation of one marker relative another from the first frame onwards. Distance A simple but versatile constraint with animatable distance. Maintain Start Distance Whatever the distance between two markers, it will be maintained throughout a simulation. Minimum Distance Alternatively, only respond to when two controls get too close. Maximum Distance Conversely, keep markers from getting too far away from each other. Custom Distance Or go all-in, with both a minimum and maximum distance, for the most complex behavior. Offsets Control at which point on a control to measure the distance. Animated Distance Both min and max distance, along with stiffness and damping, can be animated for some pretty rad effects. Hard Distance A Stiffness = -1 means the constraint is \"hard\". It will not accept any slack or \"springiness\". In this example, the distance is animated whilst soft, and transitioned into a hard constraint. Notice how it snaps into place once hard. Limitation A limitation of a hard constraint is that the distance cannot be animated whilst hard. You can however animate it between values of -1 and above, to transition to and from hard to soft. Pin Similar to the Soft Pin used with Rigids, this creates a new position and orientation a marker will try and reach. It's exactly what you get using Guide Space = World on the markers themselves, but with the convenience of a new transform you can animate. They will both try and pull on the marker, greatest stiffness wins! Cascading Attributes Sometimes, you want to tweak the overall look of an entire simulation at once, rather than tweaking or modifying individual nodes. Now you can. All guides, limits and constraints now have their values combined with equivalent values on the solver node. Edit One Here's how you edit just a single marker or constraint. Edit Many And here's how you can edit them all. Animation Guides and Constraints can be animated, however Limits cannot. This behavior is consistent with the rdGroup node too, here's the complete attribute hierarchy. Recording Performance A mere 15% boost to Recording performance. Before After More was expected, and odds are there's room to optimise this further. But, the bottleneck is writing keyframes which cannot happen across multiple threads. It also needs to happen alongside evaluating your rig, which is dirtied with setting of each key, else it cannot take into account the various constraints, offset groups and IK solvers happening in there. On the upside, the more complex your rig, the more benefit you should see from this optimisation. What happens in the above examples are extremely lightweight rigs with no animation, hence the difference is minor. Remainder Markers are almost feature complete. Most if not all things you could do with Rigids are now possible with markers. Except for: Forces Export & Import These will be addressed in an upcoming release. The next release will focus on getting those darn shape and limit attributes out of the Channel Box and into the viewport for interactive control.","title":"2021.10.25"},{"location":"releases/2021.10.25/#showcase","text":"Let's start these notes with some examples of what you can do with all of the new features added. \ud83e\udd70 Best Friends, No Matter What Two referenced characters, their solvers linked. Hang On! The new Distance Constraint at work. Dance Baby! The new Pin Constraint working alongside a Distance Constraint and regular old pose matching.","title":"Showcase"},{"location":"releases/2021.10.25/#manikin-rig","text":"Updated with limits from this release. As before, this guy can either be opened or referenced into your scene. See Solver Linking for how you can reference multiple characters into the same simulation. Download Manikin","title":"Manikin Rig"},{"location":"releases/2021.10.25/#new-tutorials","text":"Markers have one part left before being considered complete, at which point they can completely succeed Active Rigid and Active Chain . Until then, here's how you can get started with Markers today. td { vertical-align: middle !important; } Tutorial Duration Description Markers 101 01:23 What are markers? Markers 101 - Key Concepts 03:23 Overview of Input Type and Pose Space Markers 101 - Local and World 03:00 Overview of the two Pose Spaces, local and world Overlapping Motion I 02:27 The very basics or Capture and Record Overlapping Motion II 02:21 Animation layers Full Ragdoll I 04:08 Hierarchy and volume Full Ragdoll II 04:05 Kinematic and animation Full Ragdoll III 04:30 Self collisions and recording IK I 03:00 Capturing the skeleton IK II 01:59 Retargeting to IK controls IK III 01:59 Record both Translation and Rotation Practical Example I 06:53 Fix table and elbow intersection in this dialog performance","title":"New Tutorials"},{"location":"releases/2021.10.25/#solver-linking","text":"Reference two characters, link their solvers. Until now, you've been able to author physics using Active Chain and combine scenes using the Combine Scene menu item. That would transfer all connected rigids from one scene to another. But, that feature is destructive . There's no way to \"uncombine\" and even if you could, there's no record of what was originally combined. Let me introduce Solver Linking , a lightweight and non-destructive alternative. Linking This fellow is referenced twice, and get their solvers linked together. Unlinking Unlinking restores their previous behavior exactly. That's neat, but can you.. I know exactly what you're thinking, I was thinking the same thing. Can you link a solver to another solver that is also linked? So that I can build a network of simple solvers that all work together to form one complex solver? Yes. Yes, you can. \ud83e\udd2d See below.","title":"Solver Linking"},{"location":"releases/2021.10.25/#example","text":"Here are 2 assets, a manikin and a backpack. Manikin Backback The backback and manikin has been combined into one, which is then referenced twice into the final scene for a total of 4 unique solvers. Non-destructively link solvers Notice the hierarchy of solvers formed here, enabling you to build complex solvers out of many small solvers. Non-destructively unlinking too Likewise, safely deconstruct a network of solvers by just removing the connection. Technically, a solver is added to another solver in the same manner a marker, group and constraint is added. One big happy family.","title":"Example"},{"location":"releases/2021.10.25/#solver-caching","text":"Ragdoll runs alongside your character animation, but sometimes it can be useful to keep the results from a previous run and stop being so interactive. Meet Cache and Uncache . Caching is entirely non-destructive, and in fact leverages the very same cache you've been enjoying all this time whenever rewinding. The menu commands toggle an attribute on your solver node, called .cache and automatically plays the entire timeline for you. But the same result can be achieved by setting the attribute and playing it yourself. The minimal HUD will show you what's been cached, and like before once you resume playback from a cached to an uncached frame, Ragdoll will continue filling up the cache as one would expect. Look forward to a future release where caching happens in the background, as you work. Something that can also be handy from time to time (pun!).","title":"Solver Caching"},{"location":"releases/2021.10.25/#limitations","text":"The viewport HUD currently draws relative the solver node in your Outliner. Moving this node also moves the HUD, which isn't right. Moving it along the Z-axis can actually cause the HUD to vanish due to being outside of the camera frustrum. Other than that, if you encounter odd behavior let me know. This should work just fine in all cases where Ragdoll works, since the underlying mechanics are the same.","title":"Limitations"},{"location":"releases/2021.10.25/#marker-limits","text":"Markers now support the limits you've grown accustomed to from chains and constraints. They are much easier to work with, now that they are built-in to each marker and have an understanding for what a \"parent\" is. You should find a lot less need to use Edit Pivots from here on, and in the next release you'll also get some interactive manipulators to avoid the Channel Box even more. Limit Type","title":"Marker Limits"},{"location":"releases/2021.10.25/#hinge-limit","text":"The simplest of limits, allow a limb to rotate along a single axis. Like hinges on a door. Use this for knees and elbows.","title":"Hinge Limit"},{"location":"releases/2021.10.25/#ragdoll-limit","text":"For more complex anatomical limits, such as shoulders and hips, use the \"ragdoll\" limit for control over each of the 3 rotate axes. Defaults A good place to start is to just play with default settings and get an idea of what it looks like. Customise In this case, we'll keep the leg from crossing over too far, and from bending too far backwards. Like a real human leg.","title":"Ragdoll Limit"},{"location":"releases/2021.10.25/#custom-limit","text":"The Hinge and Ragdoll limits should cover the vast majority of limit needs, but sometimes you need more control. The Custom limit lets you control the parent and child frames independently, similar to the \"traditional\" Rigid constraints let you do. Here's an example of replicating the Ragdoll constraint with a custom limit.","title":"Custom Limit"},{"location":"releases/2021.10.25/#axis","text":"Specify the \"main\" axis for your limit. Different rigs follow different conventions, and this attribute enables you to keep Ragdoll in the loop. It should typically align with whatever axis your joint or control points in the direction of the child joint or control.","title":"Axis"},{"location":"releases/2021.10.25/#rotation-vs-offset","text":"You can either rotate or offset the limit. Rotation rotates both parent and child frames Offset rotates only the parent frame Remember The Parent Frame is the space in which a Child Frame is allowed to move.","title":"Rotation vs Offset"},{"location":"releases/2021.10.25/#marker-constraints","text":"You can now constrain one marker to anothe! Constraint Type Description Weld Constraint Simplest of constraints, welds two markers together; no change to their distance or relative orientation is allowed. This is akin to the Maya Parent Constraint Distance Constraint Maintain a minimum, maximum or total distance between two markers. Pin Constraint Match a position and orientation in worldspace, similar to Drive Space = World .","title":"Marker Constraints"},{"location":"releases/2021.10.25/#weld","text":"Maintain the position and orientation of one marker relative another from the first frame onwards.","title":"Weld"},{"location":"releases/2021.10.25/#distance","text":"A simple but versatile constraint with animatable distance. Maintain Start Distance Whatever the distance between two markers, it will be maintained throughout a simulation. Minimum Distance Alternatively, only respond to when two controls get too close. Maximum Distance Conversely, keep markers from getting too far away from each other. Custom Distance Or go all-in, with both a minimum and maximum distance, for the most complex behavior. Offsets Control at which point on a control to measure the distance. Animated Distance Both min and max distance, along with stiffness and damping, can be animated for some pretty rad effects. Hard Distance A Stiffness = -1 means the constraint is \"hard\". It will not accept any slack or \"springiness\". In this example, the distance is animated whilst soft, and transitioned into a hard constraint. Notice how it snaps into place once hard. Limitation A limitation of a hard constraint is that the distance cannot be animated whilst hard. You can however animate it between values of -1 and above, to transition to and from hard to soft.","title":"Distance"},{"location":"releases/2021.10.25/#pin","text":"Similar to the Soft Pin used with Rigids, this creates a new position and orientation a marker will try and reach. It's exactly what you get using Guide Space = World on the markers themselves, but with the convenience of a new transform you can animate. They will both try and pull on the marker, greatest stiffness wins!","title":"Pin"},{"location":"releases/2021.10.25/#cascading-attributes","text":"Sometimes, you want to tweak the overall look of an entire simulation at once, rather than tweaking or modifying individual nodes. Now you can. All guides, limits and constraints now have their values combined with equivalent values on the solver node. Edit One Here's how you edit just a single marker or constraint. Edit Many And here's how you can edit them all. Animation Guides and Constraints can be animated, however Limits cannot. This behavior is consistent with the rdGroup node too, here's the complete attribute hierarchy.","title":"Cascading Attributes"},{"location":"releases/2021.10.25/#recording-performance","text":"A mere 15% boost to Recording performance. Before After More was expected, and odds are there's room to optimise this further. But, the bottleneck is writing keyframes which cannot happen across multiple threads. It also needs to happen alongside evaluating your rig, which is dirtied with setting of each key, else it cannot take into account the various constraints, offset groups and IK solvers happening in there. On the upside, the more complex your rig, the more benefit you should see from this optimisation. What happens in the above examples are extremely lightweight rigs with no animation, hence the difference is minor.","title":"Recording Performance"},{"location":"releases/2021.10.25/#remainder","text":"Markers are almost feature complete. Most if not all things you could do with Rigids are now possible with markers. Except for: Forces Export & Import These will be addressed in an upcoming release. The next release will focus on getting those darn shape and limit attributes out of the Channel Box and into the viewport for interactive control.","title":"Remainder"},{"location":"releases/2021.11.15/","text":"Highlight for this release is Markers part 4 of 4 ! Previous Parts Part 1 - Animation Capture Part 2 - Performance Part 3 - Linking and Caching Part 4 - See below \ud83d\ude07 ADDED Ragdoll for MacOS You heard it right, it's here! ADDED Robust Rendering Consistent across all platforms and GPUs ADDED Robust Recording More resilient to locked controls and custom rotation axes ADDED Robust Caching I dare you to try and break it \ud83d\ude19 ADDED Snap to Simulation Single-frame recording, for quick posing ADDED Extract Simulation Get the raw data as a baked joint hierarchy, super fast! ADDED Frameskip Method Now accessible per-solver, as an attribute ADDED Trial Renewal Ready to give it another go? Now you can ADDED Replace Mesh An old friend has returned, for Markers ADDED Auto Limit Transfer locked Maya channels into physics FIXED Scale Mastery Negative, non-uniform, you name it FIXED Unloading Ragdoll on Linux Guaranteed to crash, but no more! UPDATED PATH and Windows If you don't know what this is, you don't have to worry about it In with the new, out with the old The next few releases will slowly but surely replace Rigids with Markers. So if there is anything you find yourself unable to do with Markers, let us know and we'll get that in there as soon as possible. Chat Contact Showcase Let's start off with some eye candy. \ud83d\ude07 Spiderman Courtesy of Jason Snyman, a.k.a. the wizard. Piggyback Ride Thought it was fun to see how the simulation would look with the previous simulation as input! Motion Graphics Courtesy of Peter Crowther, for their client https://atech.cloud/ Design company. Art direction Matt Walpole. https://www.welaunch.co.uk/ Halloween And another from Jason! Recap We did it! We're at part 4 out of 4 of the new Markers. Just about. \ud83e\udd70 This release here was intended to round off the interactive manipulators - so that you didn't have to fiddle around the channel box to edit shapes, constraints and limits - but we ran into a wall with our drawing API (see Robust Rendering below) which led us to throw everything out and start from scratch. \ud83d\ude14 On the upside, we've now got a significantly stronger foundation upon which to build manipulators, you will see these in action in the next release. Part 5 out of 4! \ud83e\udd70 These are the things scheduled for the next releases. Next Release Description Interactive Manipulators Editing shapes is hard, constraints too. And limits. Export & Import Rigids could be exported and later imported, Markers does not have this ability yet Forces Next up, native Maya fields for Ragdoll Mechanical Constraints Like vehicle suspension are nowhere to be seen just yet. New Terminology A few things found a more representative name in this release. Before After Guide --> Pose, e.g. Pose Space Input Type --> Behaviour, e.g. Kinematic and Pose Match Assign Single --> Assign Individual Assign Group --> Assign Hierarchy What does it mean? Still fuzzy on what \"assign\" means? Refer back to the introductory tutorials from the last release here. (hint: it's motion capture terminology) Introductory Tutorials Future of Rigids When Markers was first discovered , it wasn't clear whether they would live alongside Rigids, or replace them. But at this point it's safe to say Markers is applicable to everything rigids can do with far greater performance and usability. Which is why from this release onwards Rigids are now to be considered deprecated . Long live Markers! The following few releases will be about transitioning from Rigids to Markers. Tutorials will be updated, the documentation too and you're encouraged to start using Markers for your everyday animation tasks. Rigids will live on for the next few releases and eventually end up in a Legacy sub-menu until being completely removed in February 2022. February 2022 Deadline If you didn't read the above, remember this date for when Active Rigid and Active Chain goes bye-bye. Ragdoll for MacOS There is now an option to download Ragdoll for MacOS ! \ud83c\udf4e Download for Mac Heads Up If you are a Mac user, please let us know how you get along. The builds were made on Big Sur and should work well with Big Sur, but Autodesk recommends El Capitan . Robust Rendering This release has taken quite a while, and not because of MacOS support but because of rendering . In short, we've had to throw out and rebuild a significant chunk of Ragdoll for this release. Everything related to lines, everything! The reason is that an unlucky few of you have had the following experience with Ragdoll. Those lines don't look quite right.. \ud83e\udd14 In short, the reason for this is that the Maya API for drawing lines ends up looking different across various graphics cards and versions of Maya. Maya 2019 was especially egregious. But let's dig deeper. Digging Deeper Animator? This next part is mostly for techies, feel free to skip ahead. Whenever Ragdoll drew shapes, like capsules and convex hulls, it used part of Maya's drawing API called MRenderItem . Lines on the other hand - like those for limits and guides - were drawn using a simplified API called MUIDrawManager . drawManager -> circle ( point , radius ); drawManager -> line ( pointA , pointB , thickness ); // And so on.. Which is a fantastic, well-designed API that has worked great for the past year. Until it didn't. As it happens, this API is broken.. Reports were coming in from all across the globe about lines looking like.. Well, like this. Some if it I could replicate, this here is Maya 2019 in which the behavior is erratic. But the same could be said for some hardware and driver combinations; most of which I have never been able to replicate here. This version throws all of that out the window, and reimplements it from scratch. It's a pity, because the API was very easy to work with and a great way to get started rendering in Maya. That said, our new API is not only much faster but also much more powerful . You can expect to see a lot of new 2D rendering, including fully interactive UI elements in 3D space. Until then, if you've been having issues with Ragdoll and lines, you can now breathe easy. Caveat This is great and all, but it no longer supports DirectX . In the previous release, we already started moving away from DirectX, and if you've been using it you would have gotten some warnings about it. If not, then you've got nothing to worry about for this release. OpenGL is where the action is at, and is supported equally on each platform; including MacOS! Robust Recording Recording now automatically ends up on an Animation Layer per default, with only the simulated controls associated with it. It is also at least 2x faster and less sensitive to quirks in a rig or skeletal hierarchy. Here are the things it didn't take into account before, but does now. Uniform Scale Non-uniform Scale Negative Uniform Scale Negative Non-uniform Scale Rotate Pivot Scale Pivot Rotate Axis Joint Orient Locked Channels And that should cover it! Important Recording is the most important aspect of Markers; if you can't get the simulation out then it's all for nothing. So do reach out via the.. chat or contact form ..if you have any issues with this, and a fix will be crafted in a hot minute. Performance I mentioned a 200% increase in performance, didn't I? Let's have a quick look (pun!). Before A solid 49 fps. After 135 fps. The numbers speak for themselves. At the end of the day, the main bottlenecks are out of Ragdoll's hands: Running the simulation Evaluating the rig Twice (!) Overhead from the recording Sometimes, the simulation is really fast; it will usually be the fastest of the four. Other times, evaluating the rig is fast; such as if there are no keyframes and no fancy processing like follicles or spline IK. But the overhead from recording should approach zero as time goes on. About (3), Ragdoll must evaluate your rig twice. Once to provide the simulation with your animation, and a second time to bake the resulting simulation back onto your controls. Why so slow? Interestingly, this is what made Active Rigid and Active Chain so slow. It was doing recording every frame, whether you wanted to or not. It was how the simulation was made visible to you; by continuously recording it. With Markers, we delay the recording until you hit Record Simulation , which is the primary way in which they enable us to reap this crazy amount of performance out of Maya. Robust Caching Several improvements were made to Caching, introduced in the last version. More intuitive visual aid Caching from the Start Frame Continuing cache after visiting the Start Frame Caching whilst standing on the start frame could cause hiccups on occasion, this release fixes that. Before There was also a minor issue whereby if you cached half-way, revisited the start frame and then went back to resume caching, it would resume from the wrong spot and thus break the cache. In either of these cases, one could disable and re-enable the cache to \"fix\" it, but now you don't have to! Notice how it doesn't update the cache when standing on the start frame? After And, like before, you can enable caching via the solver. The only difference is that the menu item automatically plays through the entire timeline for you. Snap to Simulation Yet another way to work with physics, by transferring individual poses from the solver into your animation. You can use it to pose or layout a scene. Coming Up An upcoming release will enable you to advance time in the simulation, without affecting time in Maya. Such that you can \"relax\" a pose, for example. \ud83d\ude01 Frameskip Method Ragdoll needs a consistent progression of time to provide reliable results. So per default, if it notices a frame being skipped , it kindly pauses and waits until you revisit the last simulated frame. Alternatively, you can let it look the other way and pretend time has progressed linearly, like nCloth and countless other solvers do. Pause The default. It's safe, predictable, but requires Play Every Frame to work. Ignore The nCloth and nHair default, of trying its best to simulate even though it wasn't given the frames inbetween. Unpredictable, unreliable but may handle playing along with sound. Aside from not giving you the same result each time you play, if too many frames are skipped your simulation can completely explode. You can semi-work around this by increasing the number of substeps, forcing more simulation frames to fill for the missing frames. Non-deterministic Bear in mind that the Ignore method cannot give you the same results each playthrough. The Pause method is guaranteed to give you the same results, and are identical to what you get when you Record Simulation too. Extract Simulation Get data out of the solver and into a baked joint hierarchy. You can use this to build a library of animations, or to handle the retargeting from simulation to animation manually by just constraining to the resulting joint hierarchy. Performance Notice how fast this is! A Debugging Companion It can also be used for situations where Record Simulation doesn't do what you need it to. The extracted skeleton will be a plain joint hierarchy, with no scale, and guaranteed to match the simulation exactly. So you can extract it, and constrain your rig to it. Trial Renewal You've already given Ragdoll a go many moons ago, but really like where things have gone since? Well you're in luck. You can now request a re-trial! Submit your request Replace Mesh You can now replace the original geometry assigned to your marker, just like you could with Rigids. Auto Limits Markers are now able to infer which axes to lock in the simulation, based on the locked channels of your control or joint. Notice in this example how some of the channels are locked. With the Auto Limit option checked, the corresponding limit axes will be locked too, such as to prevent the simulation from rotating around those axes. If you forget or want to detect locked axes on an existing marker, you can use the Utility option too. Scale Mastery Simplified and more robust, scale now handles well for all manner of shapes. Unloading on Linux Linux users were not able to unload and later reload Ragdoll, without experiencing a fatal crash. This was a problem related to the dynamic licensing library not letting go of its TCP handle and forcing the plug-in to remain loaded, even though you kindly asked it to unload. This has now been fixed, and the plug-in can safely be unloaded and reloaded and unloaded and reloaded over and over and over again. Enjoy! PATH and Windows For TDs The following is meant for administrators and TDs With the introduction of Mac support a change was made to the way LimeLM - the licencing software used by Ragdoll - is distributed. Rather than being statically linked on Linux and dynamically linked but programatically located on Windows, it is now dynamically linked and automatically located on all platforms. Windows Only This only applies to Windows. Linux and Mac references the libraries relative the plug-in location. In short, you don't have to worry about it. You don't have to care about this, unless you are on Windows and care about what's on your PATH to which this happens. # Windows os . environ [ \"PATH\" ] += \"; \\\\ Ragdoll \\\\ shared \\\\ windows\" The change is coming from the Ragdoll.mod file. Why am I telling you this? In the wildly unlikely chance that there is another plug-in using a different version of LimeLM in your arsenal, there may be a conflict whereby: Ragdoll module is loaded, appends v1.0 of LimeLM to PATH Other Plug-in module is loaded, appends v0.5beta of LimeLM to PATH Ragdoll plug-in is loaded, picks up v0.5beta Other Plug-in plug-in is loaded, picks up v0.5beta This will be resolved in a later version of Ragdoll, but until then, in the unlikely event there is a conflict, here's what you can do. import os before = os . environ [ \"PATH\" ] os . environ [ \"PATH\" ] = \"/path/to/Ragdoll/shared: %s \" % before cmds . loadPlugin ( \"ragdoll\" ) os . environ [ \"PATH\" ] = before Namely, rather than loading Ragdoll from your plug-in manager, load it using this wrapper script. It will ensure Ragdoll's path is picked up ahead of any third-party plug-in, without negatively affecting anything around it.","title":"2021.11.15"},{"location":"releases/2021.11.15/#showcase","text":"Let's start off with some eye candy. \ud83d\ude07 Spiderman Courtesy of Jason Snyman, a.k.a. the wizard. Piggyback Ride Thought it was fun to see how the simulation would look with the previous simulation as input! Motion Graphics Courtesy of Peter Crowther, for their client https://atech.cloud/ Design company. Art direction Matt Walpole. https://www.welaunch.co.uk/ Halloween And another from Jason!","title":"Showcase"},{"location":"releases/2021.11.15/#recap","text":"We did it! We're at part 4 out of 4 of the new Markers. Just about. \ud83e\udd70 This release here was intended to round off the interactive manipulators - so that you didn't have to fiddle around the channel box to edit shapes, constraints and limits - but we ran into a wall with our drawing API (see Robust Rendering below) which led us to throw everything out and start from scratch. \ud83d\ude14 On the upside, we've now got a significantly stronger foundation upon which to build manipulators, you will see these in action in the next release. Part 5 out of 4! \ud83e\udd70 These are the things scheduled for the next releases. Next Release Description Interactive Manipulators Editing shapes is hard, constraints too. And limits. Export & Import Rigids could be exported and later imported, Markers does not have this ability yet Forces Next up, native Maya fields for Ragdoll Mechanical Constraints Like vehicle suspension are nowhere to be seen just yet.","title":"Recap"},{"location":"releases/2021.11.15/#new-terminology","text":"A few things found a more representative name in this release. Before After Guide --> Pose, e.g. Pose Space Input Type --> Behaviour, e.g. Kinematic and Pose Match Assign Single --> Assign Individual Assign Group --> Assign Hierarchy What does it mean? Still fuzzy on what \"assign\" means? Refer back to the introductory tutorials from the last release here. (hint: it's motion capture terminology) Introductory Tutorials","title":"New Terminology"},{"location":"releases/2021.11.15/#future-of-rigids","text":"When Markers was first discovered , it wasn't clear whether they would live alongside Rigids, or replace them. But at this point it's safe to say Markers is applicable to everything rigids can do with far greater performance and usability. Which is why from this release onwards Rigids are now to be considered deprecated . Long live Markers! The following few releases will be about transitioning from Rigids to Markers. Tutorials will be updated, the documentation too and you're encouraged to start using Markers for your everyday animation tasks. Rigids will live on for the next few releases and eventually end up in a Legacy sub-menu until being completely removed in February 2022. February 2022 Deadline If you didn't read the above, remember this date for when Active Rigid and Active Chain goes bye-bye.","title":"Future of Rigids"},{"location":"releases/2021.11.15/#ragdoll-for-macos","text":"There is now an option to download Ragdoll for MacOS ! \ud83c\udf4e Download for Mac Heads Up If you are a Mac user, please let us know how you get along. The builds were made on Big Sur and should work well with Big Sur, but Autodesk recommends El Capitan .","title":"Ragdoll for MacOS"},{"location":"releases/2021.11.15/#robust-rendering","text":"This release has taken quite a while, and not because of MacOS support but because of rendering . In short, we've had to throw out and rebuild a significant chunk of Ragdoll for this release. Everything related to lines, everything! The reason is that an unlucky few of you have had the following experience with Ragdoll. Those lines don't look quite right.. \ud83e\udd14 In short, the reason for this is that the Maya API for drawing lines ends up looking different across various graphics cards and versions of Maya. Maya 2019 was especially egregious. But let's dig deeper.","title":"Robust Rendering"},{"location":"releases/2021.11.15/#digging-deeper","text":"Animator? This next part is mostly for techies, feel free to skip ahead. Whenever Ragdoll drew shapes, like capsules and convex hulls, it used part of Maya's drawing API called MRenderItem . Lines on the other hand - like those for limits and guides - were drawn using a simplified API called MUIDrawManager . drawManager -> circle ( point , radius ); drawManager -> line ( pointA , pointB , thickness ); // And so on.. Which is a fantastic, well-designed API that has worked great for the past year. Until it didn't. As it happens, this API is broken.. Reports were coming in from all across the globe about lines looking like.. Well, like this. Some if it I could replicate, this here is Maya 2019 in which the behavior is erratic. But the same could be said for some hardware and driver combinations; most of which I have never been able to replicate here. This version throws all of that out the window, and reimplements it from scratch. It's a pity, because the API was very easy to work with and a great way to get started rendering in Maya. That said, our new API is not only much faster but also much more powerful . You can expect to see a lot of new 2D rendering, including fully interactive UI elements in 3D space. Until then, if you've been having issues with Ragdoll and lines, you can now breathe easy. Caveat This is great and all, but it no longer supports DirectX . In the previous release, we already started moving away from DirectX, and if you've been using it you would have gotten some warnings about it. If not, then you've got nothing to worry about for this release. OpenGL is where the action is at, and is supported equally on each platform; including MacOS!","title":"Digging Deeper"},{"location":"releases/2021.11.15/#robust-recording","text":"Recording now automatically ends up on an Animation Layer per default, with only the simulated controls associated with it. It is also at least 2x faster and less sensitive to quirks in a rig or skeletal hierarchy. Here are the things it didn't take into account before, but does now. Uniform Scale Non-uniform Scale Negative Uniform Scale Negative Non-uniform Scale Rotate Pivot Scale Pivot Rotate Axis Joint Orient Locked Channels And that should cover it! Important Recording is the most important aspect of Markers; if you can't get the simulation out then it's all for nothing. So do reach out via the.. chat or contact form ..if you have any issues with this, and a fix will be crafted in a hot minute.","title":"Robust Recording"},{"location":"releases/2021.11.15/#performance","text":"I mentioned a 200% increase in performance, didn't I? Let's have a quick look (pun!). Before A solid 49 fps. After 135 fps. The numbers speak for themselves. At the end of the day, the main bottlenecks are out of Ragdoll's hands: Running the simulation Evaluating the rig Twice (!) Overhead from the recording Sometimes, the simulation is really fast; it will usually be the fastest of the four. Other times, evaluating the rig is fast; such as if there are no keyframes and no fancy processing like follicles or spline IK. But the overhead from recording should approach zero as time goes on. About (3), Ragdoll must evaluate your rig twice. Once to provide the simulation with your animation, and a second time to bake the resulting simulation back onto your controls. Why so slow? Interestingly, this is what made Active Rigid and Active Chain so slow. It was doing recording every frame, whether you wanted to or not. It was how the simulation was made visible to you; by continuously recording it. With Markers, we delay the recording until you hit Record Simulation , which is the primary way in which they enable us to reap this crazy amount of performance out of Maya.","title":"Performance"},{"location":"releases/2021.11.15/#robust-caching","text":"Several improvements were made to Caching, introduced in the last version. More intuitive visual aid Caching from the Start Frame Continuing cache after visiting the Start Frame Caching whilst standing on the start frame could cause hiccups on occasion, this release fixes that. Before There was also a minor issue whereby if you cached half-way, revisited the start frame and then went back to resume caching, it would resume from the wrong spot and thus break the cache. In either of these cases, one could disable and re-enable the cache to \"fix\" it, but now you don't have to! Notice how it doesn't update the cache when standing on the start frame? After And, like before, you can enable caching via the solver. The only difference is that the menu item automatically plays through the entire timeline for you.","title":"Robust Caching"},{"location":"releases/2021.11.15/#snap-to-simulation","text":"Yet another way to work with physics, by transferring individual poses from the solver into your animation. You can use it to pose or layout a scene. Coming Up An upcoming release will enable you to advance time in the simulation, without affecting time in Maya. Such that you can \"relax\" a pose, for example. \ud83d\ude01","title":"Snap to Simulation"},{"location":"releases/2021.11.15/#frameskip-method","text":"Ragdoll needs a consistent progression of time to provide reliable results. So per default, if it notices a frame being skipped , it kindly pauses and waits until you revisit the last simulated frame. Alternatively, you can let it look the other way and pretend time has progressed linearly, like nCloth and countless other solvers do.","title":"Frameskip Method"},{"location":"releases/2021.11.15/#pause","text":"The default. It's safe, predictable, but requires Play Every Frame to work.","title":"Pause"},{"location":"releases/2021.11.15/#ignore","text":"The nCloth and nHair default, of trying its best to simulate even though it wasn't given the frames inbetween. Unpredictable, unreliable but may handle playing along with sound. Aside from not giving you the same result each time you play, if too many frames are skipped your simulation can completely explode. You can semi-work around this by increasing the number of substeps, forcing more simulation frames to fill for the missing frames. Non-deterministic Bear in mind that the Ignore method cannot give you the same results each playthrough. The Pause method is guaranteed to give you the same results, and are identical to what you get when you Record Simulation too.","title":"Ignore"},{"location":"releases/2021.11.15/#extract-simulation","text":"Get data out of the solver and into a baked joint hierarchy. You can use this to build a library of animations, or to handle the retargeting from simulation to animation manually by just constraining to the resulting joint hierarchy. Performance Notice how fast this is!","title":"Extract Simulation"},{"location":"releases/2021.11.15/#a-debugging-companion","text":"It can also be used for situations where Record Simulation doesn't do what you need it to. The extracted skeleton will be a plain joint hierarchy, with no scale, and guaranteed to match the simulation exactly. So you can extract it, and constrain your rig to it.","title":"A Debugging Companion"},{"location":"releases/2021.11.15/#trial-renewal","text":"You've already given Ragdoll a go many moons ago, but really like where things have gone since? Well you're in luck. You can now request a re-trial! Submit your request","title":"Trial Renewal"},{"location":"releases/2021.11.15/#replace-mesh","text":"You can now replace the original geometry assigned to your marker, just like you could with Rigids.","title":"Replace Mesh"},{"location":"releases/2021.11.15/#auto-limits","text":"Markers are now able to infer which axes to lock in the simulation, based on the locked channels of your control or joint. Notice in this example how some of the channels are locked. With the Auto Limit option checked, the corresponding limit axes will be locked too, such as to prevent the simulation from rotating around those axes. If you forget or want to detect locked axes on an existing marker, you can use the Utility option too.","title":"Auto Limits"},{"location":"releases/2021.11.15/#scale-mastery","text":"Simplified and more robust, scale now handles well for all manner of shapes.","title":"Scale Mastery"},{"location":"releases/2021.11.15/#unloading-on-linux","text":"Linux users were not able to unload and later reload Ragdoll, without experiencing a fatal crash. This was a problem related to the dynamic licensing library not letting go of its TCP handle and forcing the plug-in to remain loaded, even though you kindly asked it to unload. This has now been fixed, and the plug-in can safely be unloaded and reloaded and unloaded and reloaded over and over and over again. Enjoy!","title":"Unloading on Linux"},{"location":"releases/2021.11.15/#path-and-windows","text":"For TDs The following is meant for administrators and TDs With the introduction of Mac support a change was made to the way LimeLM - the licencing software used by Ragdoll - is distributed. Rather than being statically linked on Linux and dynamically linked but programatically located on Windows, it is now dynamically linked and automatically located on all platforms. Windows Only This only applies to Windows. Linux and Mac references the libraries relative the plug-in location. In short, you don't have to worry about it. You don't have to care about this, unless you are on Windows and care about what's on your PATH to which this happens. # Windows os . environ [ \"PATH\" ] += \"; \\\\ Ragdoll \\\\ shared \\\\ windows\" The change is coming from the Ragdoll.mod file. Why am I telling you this? In the wildly unlikely chance that there is another plug-in using a different version of LimeLM in your arsenal, there may be a conflict whereby: Ragdoll module is loaded, appends v1.0 of LimeLM to PATH Other Plug-in module is loaded, appends v0.5beta of LimeLM to PATH Ragdoll plug-in is loaded, picks up v0.5beta Other Plug-in plug-in is loaded, picks up v0.5beta This will be resolved in a later version of Ragdoll, but until then, in the unlikely event there is a conflict, here's what you can do. import os before = os . environ [ \"PATH\" ] os . environ [ \"PATH\" ] = \"/path/to/Ragdoll/shared: %s \" % before cmds . loadPlugin ( \"ragdoll\" ) os . environ [ \"PATH\" ] = before Namely, rather than loading Ragdoll from your plug-in manager, load it using this wrapper script. It will ensure Ragdoll's path is picked up ahead of any third-party plug-in, without negatively affecting anything around it.","title":"PATH and Windows"},{"location":"releases/2021.12.12/","text":"Highlight for this release is The Manipulator ! ADDED Manipulator Edit things faster and visually with these new tricks ADDED Independent Pose Axes Control X, Y and Z axes independently ADDED Quality of Life Can never have too much of this. FIXED Auto Limits II More predictable, more usable FIXED Disappearing Limits Two solvers, one removed, caused limit indicators to vanish FIXED Lollipop Hierarchy Lollipops could break a hierarchy of markers, but no more FIXED Replace Intermediate Mesh Intermediate meshes could make Replace Mesh more complicated FIXED White Window on Maya Exit Ragdoll could sometime prevent Maya from exiting properly ADDED Customise Recording An advanced topic for big pipelines Legacy Rigids This release marks the end of Active Rigid and Active Chain . Important If you read only one paragraph in this document, read this. Tutorials have been updated, documentation as well and you are encouraged to use Markers which are far superior in both performance and usability. Rigids remain accessible via the new Legacy submenu in the Ragdoll menu Scenes made with Rigids remain functional, and will continue to run until end of February 2022. Documentation for Rigids can be found at the bottom of the left-hand side, under Legacy Showcase Let's kick things off with some eye candy! Flying Lizard A work-in-progress clip from Jason Snyman. Ragdoll in 30 Seconds A brief overview of what Ragdoll is. Mocap Chap Footage from one of the the new tutorials . Now watch what happens when we increase the mass of the box by 50x. \ud83d\ude01 New Tutorials Have a look! Manikin (with Markers!) Full Manikin (with the Manipulator!) IK (with Retargeting!) Mocap Chap (with Fun!) Manipulators One of the most challenging aspect of Ragdoll to date is editing shapes and limits. These have now been greatly simplified via the use of \"manipulators\", similar to your standard Translate/Rotate/Scale manipulators. Except on steroids. Here's a 21 second overview. Before Here's the equivalent process in the last version. Sped up by 4x. It's is about as boring to watch as it was to make. \ud83d\ude04 Notice how shapes and limits need manual adjustment on both sides, because there was no symmetry . And notice how many clicks it takes to make one change, keep expanding that item in the Channel Box over and over and over. Activate You have a few options for activating the manipulator. Run Ragdoll -> Manipulator Select a Ragdoll node and press T on your keyboard Select a Ragdoll node and click the Show Manipulator Tool in the Toolbar Any of the Ragdoll nodes can be selected in order to enable the manipulator via the T keyboard shortcut. Solver Shape At the time of this writing, the solver needs its shape selected, not the parent transform. This will be addressed in a future release. A comfortable workflow is.. Select any assigned control Select the marker DG node in the Channel Box Press T The selected Marker will be pre-selected in the manipulator. Alternatively, press the Show Manipulator Tool button in the Toolbar. Shape Modes This release introduces a manipulator with two \"modes\". Mode Description Shape Mode Edit shape properties, like Length , Radius , Position and Orientation Limit Mode Edit limit properties, like Twist and Swing along with their pivots. In Shape Mode, you currently have 5 manipulators. Manipulator Description Translate Affects the Shape Offset attribute Rotate Affects the Shape Rotation attribute Scale Affects the Shape Radius and Shape Extents attributes Length Affects the Shape Length attribute, for the Capsule shape HUD Individual control over primary attributes, like Shape Extents axes Translate Hold the middle-mouse button to translate. Rotate Hold Ctrl + middle-mouse button to rotate. Scale Hold Ctrl + left-mouse button to scale. Length The Capsule shape have additional in-view manipulators you can drag to affect each side independently. HUD Finally, attributes without a visual handle can be edited via the viewport HUD. Limit Mode In Limit Mode, you currently have 2 manipulators. Manipulator Description Limit Affects the Limit Range XYZ attributes HUD For locking and enabling of limits Enable and Disable Click the Axis button to limit the rotation about a particular axis. Lock and Unlock Click the Lock button to prevent all rotation about the axis. Asymmetrical Edits Hold Ctrl to make asymmetrical edits Some limbs start out at the center of their limit. Like your hip and neck. They are typically modeled to enable equal movement in each axis. Other limbs, like the elbow and knee, are typically modeled in the extreme of their limit. Able to only rotate in one direction. For these cases, they need an asymmetrical limit. With limits in multiple axes, keep an eye out for how asymmetrical edits to one axis affect the others. Why are they moving? Under the hood, each axis must be still be symmetrical; edits only appear to be asymmetrical for your convenience. What's really happening is the entire limit is both changing shape and also rotating and the rotation is causing all axes to move. This is an inherent limitation of limits (pun!) in Ragdoll and is unlikely to be addressed in the future, so we'll have to work with it. If you mess up and want to start from scratch, hit the Reset button, also found under Ragdoll -> Utilities -> Reset Constraint Frames Symmetry Enabled per default, symmetry will mirror your edits across an axis. There are 2 types of symmetry at the time of this writing. Type Description World Look for a marker across the current axis in worldspace Pose Based on the pose at the time of assigning markers, which is typically symmetrical. Each of which can be made symmetrical in either the X, Y or Z axes. The Pose axis means you can make changes even if a character has been posed after having been assigned. A feature particularly useful when assigning to the A- or T-pose of a character rig. Pose Based Symmetry Because these controls were assigned in the T-pose of the rig, you can use Pose-based symmetry to make changes even when the character is currently asymmetrical. Multiple Rigs If two or more characters are present in the scene, and they were all rigged in the same pose, at the center of the world, then Ragdoll will only look at markers in the same rdGroup as the selected Marker. Search Distance On the right-hand side of the Enable Symmetry button, there is a Search Distance gizmo. Drag to edit this value When you select a marker on one side, it will search for a marker at the opposite side of the axis you've chosen. Because positions are all approximate, it uses a maximum search distance to look for it. Matches Ideally, there should only be one match. But in a crowded hierarchy there may be several. Tune the Search Distance to control the number of matches, to ensure it doesn't pick the wrong one. Multi-select Disable Symmetry to enable multi-select Hold Shift to select and manipulate multiple markers at once. Drag-select Will be added in a future release. Undo & Redo No surprises here. Changes made using the manipulator is undoable as you would expect, with the exception that it currently does not let you undo the selection itself like normal Maya selection does; this will be addressed in a future release. Fit-to-view Tap the F key to fit any selected Marker(s) to the view, like you would expect from selected Maya nodes. Caveat This currently only applies if you've activated the manipulator using the Ragdoll -> Manipulator menu item, or have the rdSolver shape node selected. Select Node Click the Select Node button to select this node in Maya Per default, Ragdoll and Maya selection are separate. You can have Maya select the node(s) currently seleted in Ragdoll by pressing the Select Node button. You can automate this using the Synchronise button at the far-left of the HUD. Why is this not on per default? The solver is what is actually being fitted. If the selection is changed to a marker (which is not a DAG node, and therefore lacks a visual representation) then fit-to-view no longer works. This will be addressed in a future release and made into the default. With Multi-select or symmetry enabled, all selected markers will be selected in Maya, to make bulk edits via the Channel Box easier. Manipulator Help On the right-hand side is an overview of the hotkeys and mouse button combinations you can use, and what they do. It can be hidden via the HUD button on the upper right-hand side. Quality of Life More of this! 1D, 2D and 3D Limits Ragdoll used to have a preference as to which axes you use for limits. X is great for 1D limits, like a hinge, elbow or knee YZ is great for 2D limits, like a shoulder or hip But XY is no good. XZ is also bad. And god forbid you should attempt use Y or Z as a hinge limit. Ragdoll would try, but try in vain. Knowing which combination to use is not easy, and now you no longer have to. Pick an axis, any axis or combination of axes and Ragdoll will figure things out on its end. You don't have to worry about it. As an added bonus, the limit axis now aligns with your Maya axis! (with one caveat, see below) Here's a table to make this absolutely clear. \ud83e\udd70 Maya Rotate Axis Ragdoll Limit Axis X = X Y = Y Z = Z Caveat With one exception, see Asymmetrical Limits under Limit Mode above. As soon as they rotate, they will no longer align with Maya; which isn't a problem most of the time, but can be. Cache On Record Previously, when you recorded your simulation back onto your character rig, a new simulation would kick in the next time you played. And because your character rig has now changed - to follow the original simulation - the new simulation will be different. This makes logical sense but can be unexpected. So now, the Cache attribute on the solver is automatically enabled to let you compare and contrast your character rig with the simulation; and avoid needless re-simulating when what you really wanted was to record-and-forget. Once you're ready to re-simulate, run the Uncache command or set the Cache attribute back to Off . Faster Deltas Pose Deltas are now cleaner and more performant (up to 10x). Deltas are the triangular-looking shapes drawn to visualise the difference between your animation and the current simulation. They are now only drawn when there is at least some difference, which means the vast majority of them in a complex scene are now not drawn, speeding up your viewport significantly. Before After Notice how they only appear if there is actually a difference between the animation and simulation. Ground Fits Grid Previous releases would put a ground underneath the first assigned controls, with a size relative the size of your selection. Turns out, this wasn't great in practice and usually ended up being too small. In this release, the ground inherits whatever size your viewport grid is. Auto Limits II The previous release introduced Auto Limits whereby Ragdoll would look at the locked-state of your Rotate channels and try to figure out how to replicate this effect physically. This sometimes worked, sometimes not. This release fixes that, covering all combinations of locked channels, with any manner of joint or rotate axis. Here's what locking the Rotate channels will result in. Unlocking them, we can see how much of an effect it has. Thanks to the more robust and predictable limits in this release, the Maya axis will now always align with the Ragdoll limit axes! Lollipop Hierarchy The Create Lollipop option of Markers generates an extra control shape in the viewport that you can use to manipulate a Marker. The goal being to make it easier to spot a Marker in a potentially busy channel box. But the last release didn't let you use Assign Hierarchy with Create Lollipop without ending up with a broken hierarchy. Before After Disappearing Limits The limit indicator is drawn using a 2D drawing API which is initialised whenever a Solver is created. It was however uninitialized whenever any Solver was deleted, so if you had 2 solvers you were out of luck. A re-open of the scene would fix it, but it was annoying and incorrect. This has now been fixed. Replace Intermediate Mesh In the previous release, if a mesh had a second \"intermediate\" mesh it would be more difficult to use it with the Replace Mesh command. Before After Here's it working with intermediate shapes, and the new Maintain History option which was always true in the previous release. Without it, modifications to the original mesh are ignored; such as a skinned mesh. Transform Limits Recording onto transforms with Maya's native limits on them could result in this. This has now been fixed. How? Since you asked, they are simply disabled. I've never seen or heard of anyone actually using these and was surprised to find they were in active use by the native motion capture library that ships with Maya. If you or anyone you know do use them, let me know and they will be given support. Separate Translate XYZ Amount The Pose Stiffness in World space affected each axis equally. You can now control each axis independently, to for example follow an input animation closely along the ground plane, the X and Z-axes, but allow for it to deviate along the Y-axis, Separate Twist and Swing Amount The Pose Stiffness and Pose Damping parameters of Markers apply to both Swing and Twist - that is, rotations around the X and YZ axes. You can now control these independently, for an even finer control over the resulting simulation. Maya Exit There was a memory leak, whereby Maya would sometimes freeze on exit, with an anomymous-looking dialog box appearing on Windows. This has been fixed. Customised Recording Some rigs don't work with Maya's default Parent and Orient constraint. As a result, neither does Record Simulation or Snap to Simulation because those commands use these default constraints. If this is you, then I have good news. You can now override the command responsible for creating these constraints with one that uses your custom in-house constraints instead. Custom Attach","title":"2021.12.12"},{"location":"releases/2021.12.12/#legacy-rigids","text":"This release marks the end of Active Rigid and Active Chain . Important If you read only one paragraph in this document, read this. Tutorials have been updated, documentation as well and you are encouraged to use Markers which are far superior in both performance and usability. Rigids remain accessible via the new Legacy submenu in the Ragdoll menu Scenes made with Rigids remain functional, and will continue to run until end of February 2022. Documentation for Rigids can be found at the bottom of the left-hand side, under Legacy","title":"Legacy Rigids"},{"location":"releases/2021.12.12/#showcase","text":"Let's kick things off with some eye candy! Flying Lizard A work-in-progress clip from Jason Snyman. Ragdoll in 30 Seconds A brief overview of what Ragdoll is. Mocap Chap Footage from one of the the new tutorials . Now watch what happens when we increase the mass of the box by 50x. \ud83d\ude01","title":"Showcase"},{"location":"releases/2021.12.12/#new-tutorials","text":"Have a look! Manikin (with Markers!) Full Manikin (with the Manipulator!) IK (with Retargeting!) Mocap Chap (with Fun!)","title":"New Tutorials"},{"location":"releases/2021.12.12/#manipulators","text":"One of the most challenging aspect of Ragdoll to date is editing shapes and limits. These have now been greatly simplified via the use of \"manipulators\", similar to your standard Translate/Rotate/Scale manipulators. Except on steroids. Here's a 21 second overview. Before Here's the equivalent process in the last version. Sped up by 4x. It's is about as boring to watch as it was to make. \ud83d\ude04 Notice how shapes and limits need manual adjustment on both sides, because there was no symmetry . And notice how many clicks it takes to make one change, keep expanding that item in the Channel Box over and over and over.","title":"Manipulators"},{"location":"releases/2021.12.12/#activate","text":"You have a few options for activating the manipulator. Run Ragdoll -> Manipulator Select a Ragdoll node and press T on your keyboard Select a Ragdoll node and click the Show Manipulator Tool in the Toolbar Any of the Ragdoll nodes can be selected in order to enable the manipulator via the T keyboard shortcut. Solver Shape At the time of this writing, the solver needs its shape selected, not the parent transform. This will be addressed in a future release. A comfortable workflow is.. Select any assigned control Select the marker DG node in the Channel Box Press T The selected Marker will be pre-selected in the manipulator. Alternatively, press the Show Manipulator Tool button in the Toolbar.","title":"Activate"},{"location":"releases/2021.12.12/#shape-modes","text":"This release introduces a manipulator with two \"modes\". Mode Description Shape Mode Edit shape properties, like Length , Radius , Position and Orientation Limit Mode Edit limit properties, like Twist and Swing along with their pivots. In Shape Mode, you currently have 5 manipulators. Manipulator Description Translate Affects the Shape Offset attribute Rotate Affects the Shape Rotation attribute Scale Affects the Shape Radius and Shape Extents attributes Length Affects the Shape Length attribute, for the Capsule shape HUD Individual control over primary attributes, like Shape Extents axes Translate Hold the middle-mouse button to translate. Rotate Hold Ctrl + middle-mouse button to rotate. Scale Hold Ctrl + left-mouse button to scale. Length The Capsule shape have additional in-view manipulators you can drag to affect each side independently. HUD Finally, attributes without a visual handle can be edited via the viewport HUD.","title":"Shape Modes"},{"location":"releases/2021.12.12/#limit-mode","text":"In Limit Mode, you currently have 2 manipulators. Manipulator Description Limit Affects the Limit Range XYZ attributes HUD For locking and enabling of limits Enable and Disable Click the Axis button to limit the rotation about a particular axis. Lock and Unlock Click the Lock button to prevent all rotation about the axis. Asymmetrical Edits Hold Ctrl to make asymmetrical edits Some limbs start out at the center of their limit. Like your hip and neck. They are typically modeled to enable equal movement in each axis. Other limbs, like the elbow and knee, are typically modeled in the extreme of their limit. Able to only rotate in one direction. For these cases, they need an asymmetrical limit. With limits in multiple axes, keep an eye out for how asymmetrical edits to one axis affect the others. Why are they moving? Under the hood, each axis must be still be symmetrical; edits only appear to be asymmetrical for your convenience. What's really happening is the entire limit is both changing shape and also rotating and the rotation is causing all axes to move. This is an inherent limitation of limits (pun!) in Ragdoll and is unlikely to be addressed in the future, so we'll have to work with it. If you mess up and want to start from scratch, hit the Reset button, also found under Ragdoll -> Utilities -> Reset Constraint Frames","title":"Limit Mode"},{"location":"releases/2021.12.12/#symmetry","text":"Enabled per default, symmetry will mirror your edits across an axis. There are 2 types of symmetry at the time of this writing. Type Description World Look for a marker across the current axis in worldspace Pose Based on the pose at the time of assigning markers, which is typically symmetrical. Each of which can be made symmetrical in either the X, Y or Z axes. The Pose axis means you can make changes even if a character has been posed after having been assigned. A feature particularly useful when assigning to the A- or T-pose of a character rig. Pose Based Symmetry Because these controls were assigned in the T-pose of the rig, you can use Pose-based symmetry to make changes even when the character is currently asymmetrical. Multiple Rigs If two or more characters are present in the scene, and they were all rigged in the same pose, at the center of the world, then Ragdoll will only look at markers in the same rdGroup as the selected Marker. Search Distance On the right-hand side of the Enable Symmetry button, there is a Search Distance gizmo. Drag to edit this value When you select a marker on one side, it will search for a marker at the opposite side of the axis you've chosen. Because positions are all approximate, it uses a maximum search distance to look for it. Matches Ideally, there should only be one match. But in a crowded hierarchy there may be several. Tune the Search Distance to control the number of matches, to ensure it doesn't pick the wrong one.","title":"Symmetry"},{"location":"releases/2021.12.12/#multi-select","text":"Disable Symmetry to enable multi-select Hold Shift to select and manipulate multiple markers at once. Drag-select Will be added in a future release.","title":"Multi-select"},{"location":"releases/2021.12.12/#undo-redo","text":"No surprises here. Changes made using the manipulator is undoable as you would expect, with the exception that it currently does not let you undo the selection itself like normal Maya selection does; this will be addressed in a future release.","title":"Undo &amp; Redo"},{"location":"releases/2021.12.12/#fit-to-view","text":"Tap the F key to fit any selected Marker(s) to the view, like you would expect from selected Maya nodes. Caveat This currently only applies if you've activated the manipulator using the Ragdoll -> Manipulator menu item, or have the rdSolver shape node selected.","title":"Fit-to-view"},{"location":"releases/2021.12.12/#select-node","text":"Click the Select Node button to select this node in Maya Per default, Ragdoll and Maya selection are separate. You can have Maya select the node(s) currently seleted in Ragdoll by pressing the Select Node button. You can automate this using the Synchronise button at the far-left of the HUD. Why is this not on per default? The solver is what is actually being fitted. If the selection is changed to a marker (which is not a DAG node, and therefore lacks a visual representation) then fit-to-view no longer works. This will be addressed in a future release and made into the default. With Multi-select or symmetry enabled, all selected markers will be selected in Maya, to make bulk edits via the Channel Box easier.","title":"Select Node"},{"location":"releases/2021.12.12/#manipulator-help","text":"On the right-hand side is an overview of the hotkeys and mouse button combinations you can use, and what they do. It can be hidden via the HUD button on the upper right-hand side.","title":"Manipulator Help"},{"location":"releases/2021.12.12/#quality-of-life","text":"More of this!","title":"Quality of Life"},{"location":"releases/2021.12.12/#1d-2d-and-3d-limits","text":"Ragdoll used to have a preference as to which axes you use for limits. X is great for 1D limits, like a hinge, elbow or knee YZ is great for 2D limits, like a shoulder or hip But XY is no good. XZ is also bad. And god forbid you should attempt use Y or Z as a hinge limit. Ragdoll would try, but try in vain. Knowing which combination to use is not easy, and now you no longer have to. Pick an axis, any axis or combination of axes and Ragdoll will figure things out on its end. You don't have to worry about it. As an added bonus, the limit axis now aligns with your Maya axis! (with one caveat, see below) Here's a table to make this absolutely clear. \ud83e\udd70 Maya Rotate Axis Ragdoll Limit Axis X = X Y = Y Z = Z Caveat With one exception, see Asymmetrical Limits under Limit Mode above. As soon as they rotate, they will no longer align with Maya; which isn't a problem most of the time, but can be.","title":"1D, 2D and 3D Limits"},{"location":"releases/2021.12.12/#cache-on-record","text":"Previously, when you recorded your simulation back onto your character rig, a new simulation would kick in the next time you played. And because your character rig has now changed - to follow the original simulation - the new simulation will be different. This makes logical sense but can be unexpected. So now, the Cache attribute on the solver is automatically enabled to let you compare and contrast your character rig with the simulation; and avoid needless re-simulating when what you really wanted was to record-and-forget. Once you're ready to re-simulate, run the Uncache command or set the Cache attribute back to Off .","title":"Cache On Record"},{"location":"releases/2021.12.12/#faster-deltas","text":"Pose Deltas are now cleaner and more performant (up to 10x). Deltas are the triangular-looking shapes drawn to visualise the difference between your animation and the current simulation. They are now only drawn when there is at least some difference, which means the vast majority of them in a complex scene are now not drawn, speeding up your viewport significantly. Before After Notice how they only appear if there is actually a difference between the animation and simulation.","title":"Faster Deltas"},{"location":"releases/2021.12.12/#ground-fits-grid","text":"Previous releases would put a ground underneath the first assigned controls, with a size relative the size of your selection. Turns out, this wasn't great in practice and usually ended up being too small. In this release, the ground inherits whatever size your viewport grid is.","title":"Ground Fits Grid"},{"location":"releases/2021.12.12/#auto-limits-ii","text":"The previous release introduced Auto Limits whereby Ragdoll would look at the locked-state of your Rotate channels and try to figure out how to replicate this effect physically. This sometimes worked, sometimes not. This release fixes that, covering all combinations of locked channels, with any manner of joint or rotate axis. Here's what locking the Rotate channels will result in. Unlocking them, we can see how much of an effect it has. Thanks to the more robust and predictable limits in this release, the Maya axis will now always align with the Ragdoll limit axes!","title":"Auto Limits II"},{"location":"releases/2021.12.12/#lollipop-hierarchy","text":"The Create Lollipop option of Markers generates an extra control shape in the viewport that you can use to manipulate a Marker. The goal being to make it easier to spot a Marker in a potentially busy channel box. But the last release didn't let you use Assign Hierarchy with Create Lollipop without ending up with a broken hierarchy. Before After","title":"Lollipop Hierarchy"},{"location":"releases/2021.12.12/#disappearing-limits","text":"The limit indicator is drawn using a 2D drawing API which is initialised whenever a Solver is created. It was however uninitialized whenever any Solver was deleted, so if you had 2 solvers you were out of luck. A re-open of the scene would fix it, but it was annoying and incorrect. This has now been fixed.","title":"Disappearing Limits"},{"location":"releases/2021.12.12/#replace-intermediate-mesh","text":"In the previous release, if a mesh had a second \"intermediate\" mesh it would be more difficult to use it with the Replace Mesh command. Before After Here's it working with intermediate shapes, and the new Maintain History option which was always true in the previous release. Without it, modifications to the original mesh are ignored; such as a skinned mesh.","title":"Replace Intermediate Mesh"},{"location":"releases/2021.12.12/#transform-limits","text":"Recording onto transforms with Maya's native limits on them could result in this. This has now been fixed. How? Since you asked, they are simply disabled. I've never seen or heard of anyone actually using these and was surprised to find they were in active use by the native motion capture library that ships with Maya. If you or anyone you know do use them, let me know and they will be given support.","title":"Transform Limits"},{"location":"releases/2021.12.12/#separate-translate-xyz-amount","text":"The Pose Stiffness in World space affected each axis equally. You can now control each axis independently, to for example follow an input animation closely along the ground plane, the X and Z-axes, but allow for it to deviate along the Y-axis,","title":"Separate Translate XYZ Amount"},{"location":"releases/2021.12.12/#separate-twist-and-swing-amount","text":"The Pose Stiffness and Pose Damping parameters of Markers apply to both Swing and Twist - that is, rotations around the X and YZ axes. You can now control these independently, for an even finer control over the resulting simulation.","title":"Separate Twist and Swing Amount"},{"location":"releases/2021.12.12/#maya-exit","text":"There was a memory leak, whereby Maya would sometimes freeze on exit, with an anomymous-looking dialog box appearing on Windows. This has been fixed.","title":"Maya Exit"},{"location":"releases/2021.12.12/#customised-recording","text":"Some rigs don't work with Maya's default Parent and Orient constraint. As a result, neither does Record Simulation or Snap to Simulation because those commands use these default constraints. If this is you, then I have good news. You can now override the command responsible for creating these constraints with one that uses your custom in-house constraints instead. Custom Attach","title":"Customised Recording"},{"location":"releases/2021.12.15/","text":"Minor maintenance release. FIXED Unselectable Viewport Icons Happened from time to time FIXED Clean Channel Box An option to clean or not to clean FIXED Legacy Viewport A rare case of unselectable widgets in the Manipulator UI. FIXED Overlap Group for non Grouped Markers Markers not part of a group would have trouble respecting its overlap group FIXED Z-up The ground was tweaked, and with it Z-up lost support FIXED Double HUD The manipulator could overlap Maya's native HUD, but no more ADDED Fine-grained control over unconvenitional orientations Showcase As is tradition, we must start with candy. Now, it's only been 3 days so all I have for you today is this amazing piece of animation here. \ud83d\ude05 Wyvern 2 Follow-up to the WIP from last release from The Wizard, a.k.a. Jason Snyman. See on LinkedIn Wasp Here's a response to a question on LinkedIn about whether or not you can use Ragdoll to make animation cycles. So here are 3 parts. The finished cycle The input animation The default simulation, before cycling it Total time spent 1h, including rigging and skinning. The model is a default Maya model from the Content Browser. Clean Channel Box With the manipulator in the last release, the Channel Box saw a huge spring cleaning. Before After It was, however, a little too aggressive. Some of the attributes were still useful, especially for making sweeping changes across lots of markers at once. So in this release, you know have the option of: Having these attributes visible on Assign via the Option Dialog Toggling these attributes on/off via Ragdoll -> Utilities -> Toggle Marker Attributes Legacy Viewport More specifically, the environment variable MAYA_ENABLE_VP2_PLUGIN_LOCATOR_LEGACY_DRAW , is still in use in some studios. This variable would cause the Manipulator UI to be unselectable. This has now been fixed. Collision Group Lone markers, like boxes and other environment assets and props have an Overlap Group like any other. But unless they are also part of a group, they would sometimes not respect the Overlap Group , requiring a scene re-open in order to take effect. This has now been fixed. Z-up The default ground now correctly fits the grid even in a Z-up Maya scene. Double HUD The Manipulator HUD could sometimes fight with Maya's default HUD. Now it'll step aside temporarily until the manipulator is done. Room to improve It will temporarily toggle the Maya HUD on/off in the currently active viewport, based on the viewport your mouse is currently hovering. This can get finnicky sometimes. If it does, the option toggled is the one under Display -> HUD in the Maya viewport. This will be improved in a future release. Robust Viewport Icons The viewport icons would sometimes be unselectable. This was due to Maya being unable to provide Ragdoll with the correct \"Active View\", which Ragdoll uses to map your mouse to 3D. This has now been fixed, by no longer relying on the Active View. Edit Constraint Frames The previous release simplified limits by a lot, but there are still cases where the default orientation of some rig controls ends up in a funny situation. Note This does not matter to the simulation. It is only a rendering artefact. To make this a little easier to work with, you can rotate the entire limit like this. Note You don't need the locators once you are done editing them, you should definitely delete them. This will be made redundant in a future version as it gets much too technical and too easy to shoot yourself in the foot. If you make a mistake, delete the locators and call Reset Constraint Frames in the same menu to start again.","title":"2021.12.15"},{"location":"releases/2021.12.15/#showcase","text":"As is tradition, we must start with candy. Now, it's only been 3 days so all I have for you today is this amazing piece of animation here. \ud83d\ude05 Wyvern 2 Follow-up to the WIP from last release from The Wizard, a.k.a. Jason Snyman. See on LinkedIn Wasp Here's a response to a question on LinkedIn about whether or not you can use Ragdoll to make animation cycles. So here are 3 parts. The finished cycle The input animation The default simulation, before cycling it Total time spent 1h, including rigging and skinning. The model is a default Maya model from the Content Browser.","title":"Showcase"},{"location":"releases/2021.12.15/#clean-channel-box","text":"With the manipulator in the last release, the Channel Box saw a huge spring cleaning. Before After It was, however, a little too aggressive. Some of the attributes were still useful, especially for making sweeping changes across lots of markers at once. So in this release, you know have the option of: Having these attributes visible on Assign via the Option Dialog Toggling these attributes on/off via Ragdoll -> Utilities -> Toggle Marker Attributes","title":"Clean Channel Box"},{"location":"releases/2021.12.15/#legacy-viewport","text":"More specifically, the environment variable MAYA_ENABLE_VP2_PLUGIN_LOCATOR_LEGACY_DRAW , is still in use in some studios. This variable would cause the Manipulator UI to be unselectable. This has now been fixed.","title":"Legacy Viewport"},{"location":"releases/2021.12.15/#collision-group","text":"Lone markers, like boxes and other environment assets and props have an Overlap Group like any other. But unless they are also part of a group, they would sometimes not respect the Overlap Group , requiring a scene re-open in order to take effect. This has now been fixed.","title":"Collision Group"},{"location":"releases/2021.12.15/#z-up","text":"The default ground now correctly fits the grid even in a Z-up Maya scene.","title":"Z-up"},{"location":"releases/2021.12.15/#double-hud","text":"The Manipulator HUD could sometimes fight with Maya's default HUD. Now it'll step aside temporarily until the manipulator is done. Room to improve It will temporarily toggle the Maya HUD on/off in the currently active viewport, based on the viewport your mouse is currently hovering. This can get finnicky sometimes. If it does, the option toggled is the one under Display -> HUD in the Maya viewport. This will be improved in a future release.","title":"Double HUD"},{"location":"releases/2021.12.15/#robust-viewport-icons","text":"The viewport icons would sometimes be unselectable. This was due to Maya being unable to provide Ragdoll with the correct \"Active View\", which Ragdoll uses to map your mouse to 3D. This has now been fixed, by no longer relying on the Active View.","title":"Robust Viewport Icons"},{"location":"releases/2021.12.15/#edit-constraint-frames","text":"The previous release simplified limits by a lot, but there are still cases where the default orientation of some rig controls ends up in a funny situation. Note This does not matter to the simulation. It is only a rendering artefact. To make this a little easier to work with, you can rotate the entire limit like this. Note You don't need the locators once you are done editing them, you should definitely delete them. This will be made redundant in a future version as it gets much too technical and too easy to shoot yourself in the foot. If you make a mistake, delete the locators and call Reset Constraint Frames in the same menu to start again.","title":"Edit Constraint Frames"},{"location":"releases/2022.01.17/","text":"Highlight for this release is Ragdoll 2.0 ! ADDED Ragdoll 2.0 Talk about next-gen! ADDED Export & Import Export physics from one scene and import into another ADDED Density Automatically compute the mass based on shape volumes ADDED Level of Detail Manage complexity with two or more levels of detail ADDED Truly Non-keyable Feedback on whether or not an attribute is keyable or not ADDED Markers API The API has been reinvigorated with Markers FIXED Mandarin Serial Number Unicode mishap led to a non-sensical message in Mandarin FIXED Delta Drawing Bug Funny drawing in the viewport has been fixed FIXED Shape Sync Changes to shape properties outside of the start frame could leave Ragdoll and Maya out of sync ADDED Max Mass Ratio Keeping you safe ADDED Profiler View An in-depth look at where Ragdoll spends its time ADDED DirectX Windows users rejoice, DirectX is here FIXED Crash on Deleted Mesh Replace a mesh, delete it and crash no more. DEPRECATED Legacy API All legacy Python functionaliy now resides in its own package DEPRECATED Removed attributes These attributes were harmed in the making of this release. Showcase Let's start with the good stuff. Medusa Breakdown Excellent Animation and breakdown by Andras Ormos . https://youtu.be/6wsnvsyNGYQ Batman Learning Cursive Animation by Jason Snyman , with a very interesting approach to getting ink out of a pen digitally. \ud83d\ude04 DMV Lady Courtesy of Dragana Mandic. On LinkedIn Scalable Rig, Scalable Ragdoll No special setup required, if your rig is scalable then so is Ragdoll. Circus Import Toying with the ability to import characters into the same solver. The Ocean Give a man a fish, and you'll feed him for 2 ragdolls. Noodles Something from the Linux world. Ragdoll 2.0 Since 28 th July 2021, Ragdoll has been publicly available under the \"early bird\" umbrella. It started out with a reduced price point for those brave enough to venture into new territory and expect a few left turns every now and then as kinks are worked out in the software. Now the time has come to step into the world as an adult piece of software with the guarantees of any commercially available software and a pricing to reflect that. And as Ragdoll has grown significantly since those days - given the new Markers - it's only reasonable to consider this Ragdoll 2.0 . January Voucher Pricing has now reached its intended price point, leaving Early Bird behind. For the next two weeks however, you can use this voucher code to get the Early Bird discount before the deadline. Valid for: Ragdoll Unlimited Voucher Code: uX1bFhjZ Purchase Page: https://ragdolldynamics.com/pricing-commercial Looking Back The Ragdoll of today is very different from the Ragdoll of July 2021. Back then, I had no idea that this amount of performance and usability was possible and was prepared to cram tutorials and documentation until everyone was accustomed to the complexity of physics simulation. \ud83d\ude04 But then something happened - Markers . Like lightning from a clear sky, it unexpectedly changed everything. Performance is now far beyond what Maya is expected to handle, with physics much much faster than simply skinning of a character, and close to the performance of native IK handles. This opens up a lot of possibilities. The problems faced back then.. Like the massive endevour starting a simulation wherever your character was . Or the need for controls other than your rig to actually animate the thing Not to mention the constant chasing of supporting Maya's numerous ways of affecting the position and orientation of your controls, from rotate axes, to rotate pivots, to scale , to... . None of those problems are a problem with Markers. Because Markers look at the world from a different perspective, they just work . It made Ragdoll not only more user friendly and significantly faster but also simpler to develop and smaller in size . The code for Markers is about \u2153 of the equivalent for Rigids. Just think about that! And most of all, it opened up for all the things you are about to see happen for Ragdoll in the coming months. \ud83d\ude43 Ragdoll Flavours Let's take a quick look at the different versions of Ragdoll and how they differ. Flavour Description Ragdoll Unlimited The fully-featured, unrestricted version of Ragdoll. When people talk about Ragdoll, this is the version they mean. Ragdoll Complete The cost-effective flavour of Ragdoll, suitable for freelancers and indie studios. It lacks studio-conveniences such as a Python API for pipeline integration, export to JSON for sharing of physics configurations and is less performant than \"Ragdoll Unlimited\", being unable to operate in parallel across multiple cores. Ragdoll Batch A non-interactive version without ability to render into the viewport. Suitable for automation and pipeline integration. Ragdoll Personal A non-commercial version, suitable for students and anyone wanting to fool around with Ragdoll at home. It is identical to Unlimited, except that it has limits on how much can be recorded and exported. Ragdoll Educational A non-commercial version of Ragdoll Unlimited whose saved scenes cannot be opened with a commercial licence. Ragdoll Trial A non-commercial first experience with Ragdoll; this is what you get when downloading Ragdoll onto a new machine and use it without activating it first. Similar limitations to Personal, except it also expires about a month after first use. Ragdoll Unlimited This is the version you want . It contains everything mentioned on any website, is capable of doing everything you've seen Ragdoll do and is the unrestricted, unlimited and gold standard of Ragdoll. Ragdoll Complete This is the version for freelancers. It is Ragdoll Unlimited, with a few limitations. Limited Performance Limited Export Limited Python API Performance is limited in how quickly Ragdoll is able to read from your character. Ragdoll is natively parallel, but Complete turns any character you assign markers to into a Serial affair. Limiting performance by the number of cores you have in your machine. The advantage of export is that your rigs don't need physics built-in. They can remain simple and without physics, until the animator actually needs it. This feature is limited to 10 markers ; for the time being. Generally, export is reserved for Unlimited and users in need of pipeline integration. But Complete let's you get at least a taste of the comfort and flexibility of exporting your physics contraptions from one scene and importing onto an unsuspecting character in another. Like Export, the ability to interact with Ragdoll through Python is an important part of any production pipeline; not so much for the individual animator of small indie studio. Info At the time of this writing, this limitation is not yet in place, and users of Complete is currently able to utilise the Python API just like users of Unlimited. This will be addressed in an upcoming release. Ragdoll Batch This is the version for your render farm . It's a low-cost alternative to Ragdoll Unlimited, without the ability to render into the viewport. Making it effectively useful only via Python. It is also unable to export and lacks the parallelism of Unlimited. Unlike all other flavours, a Batch licence is reserved per-process; meaning that if you spin up 2 mayapy instances on the same machine, it will occupy 2 licences. This obviously only works if your licences are floating, as otherwise a machine can only carry a single node-locked licence, limiting it to a single process running Ragdoll Batch. Ragdoll Feature Grid Leaving Early Access, Ragdoll is stepping into the world as a 1.0. Here's an overview of what you can expect from now on. Feature Trial Personal Complete Unlimited Batch Commercial Use \u274c \u274c \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Interactive Tools \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Python API \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u2714\ufe0f Multi-Threading \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c JSON Import/Export \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c Per-machine Licence \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Batch has a per-process licence, meaning it will occupy one seat per individually running process. Non-commercial Limitations Trial and Personal licences are non-commercial , meaning they can't be used for commercial purposes. Such as in a studio, or for anything where money is involved. When a file saved with a non-commercial licence of Ragdoll is opened in a commercial licence, it'll temporarily turn your licence into a non-commercial licence. Feature Unlimited Complete Non-commercial Export Unlimited markers Up to 10 markers Up to 10 markers Record Unlimited frames Unlimited frames Up to 100 frames Early Birds Did you purchase a Ragdoll Personal licence before this release? Then as thanks for believing in us and joining early, these limits do not apply to you. Your version is still unrestricted for non-commercial use. Enjoy! \ud83e\udd70 Import You can now import a Ragdoll setup exported from Maya, back into Maya. It'll re-create everything just the way it was. Can I export scenes I made with an earlier version? Yes, anything made with Markers can be exported regardless of when it was made. What is included in the export? Just about everything. Solvers Groups Markers Constraints Colors Attribute changes Retargeting Reparenting Replaced meshes Thumbnail of your viewport What isn't included in the export? Very little. The mesh itself is not stored, the mesh is expected to come from your rig. Including any mesh you replace. This may be added in a future release. The cached simulation, although it will be soon. Will I get identical results when simulating an imported scene? Yes, anything else is a bug. More precisely, determinism depends on (1) the type and number of items in the solver along with (2) the order in which these are created. Both of these are part of the exported file format and is taken into account during import. Meaning you should get identical results so long as the content is the same. Example Here's an exported Ragdoll setup for the free CG Spectrum Tiger rig. Download Ragdoll file ( 2.8 mb ) Download Rig To use it, download the rig and import the Ragdoll file. It contains 2 levels of detail . Level Content Level 0 Body and feet Level 1 Everything on Level 0, plus toes Workflow Here's the rundown. Assign markers Tweak values Export Open a new scene, with the same character Import On import, Ragdoll will try and find the names of what you exported in your currently opened scene. If all names match, import should go smoothly. Preserving all of your hard work! If names do not match, if for example the namespace differs, there is an option to override the namespace from the file via the Namespace dropdown menu. If names don't match at all , if for example it was grouped differently on export or it is a different character altogether, then you can try using the Search and Replace fields to modify the names searched for by Ragdoll. Export Once you're happy with your character, it's time to export. Towards the bottom of the UI, you'll get a preview of what is about to be exported. This can help clarify that what ends up on disk is what you expect. Import In a new scene, with the same character, same names and everything, import as you'd expect. At the bottom of this UI, you'll get a preview of what's in the file on disk, along with how it will associate the node names found in the file with what you have on disk. Namespace from File Odds are, the character you're importing either has no namespace, or has a different namespace to what you've currently got in your scene. As in this example here, with 3 copies of the same character, each with its own namespace. Use the Namespace dropdown to select one of the current namespaces in your scene, or Custom to type one in yourself. Solver from File Per default, Ragdoll will import the file into the current solver in your scene, if any. Or, you can import the original solver from the source file. Known Limitations Here are a few things that will be addressed over time. Let us know if you encounter anything else! https://ragdolldynamics.com/chat Limitation Result Missing Replaced Mesh If you replace the mesh of a marker, but this mesh isn't present in the scene during import, you'll get a Capsule instead. The vertices of the geometry isn't stored in the exported file, only the name of the mesh you replaced with. Linked Solvers These turn into a single, unified solver on import. Density Ragdoll can now automatically compute a suitable mass for each Marker, based on the volume of your shape and a density of your choosing. In other words, big objects become heavy, small objects become light. Before After Presets Provide a custom density, or choose from one of the provided ones. Density Value Off Do not compute, use the Mass attribute Cotton Very sparse, 0.05 grams per cubic centimeter Wood Sparse, 0.2 grams per cubic centimeter Flesh Default, 1.0g/cm3 Uranium Dense, 19.0g/cm3 Black Hole Very, very dense Custom You pick Mass is computed based on the volume of your shape, along with a density of your choosing. Options Choose between various densities either at creation-time or after creation. Visualise The computed mass updates interactively as you change the size and type of your shape, including convex hulls! In the Manipulator, you'll be able to not only only edit the density, but preview the computed mass given the current shape volume and density you provide. Level of Detail Setup your character once with all bells-and-whistles, and interactively pick which level of detail to use for your simulation in a given situation. Usecases Body at Level 0 , fingers at Level 1 Props at Level 1 , muscles at Level 2 Major masses at Level 0 , extremities at Level 1 and Level 2 For example, here's a Wasp character with 3 levels of increasing detail. As you'd expect, it'll record only the currently active markers. Workflow Here's how it works. Give each marker a \"level\", such as 1 Tell solver which \"level\" to solve at, such as 1 And that's it! Any marker with a matching level is simulated and recorded. Operators What does each level mean? The answer lies in the \"operator\". Operator Description Less Than If the Marker Level is less than (or equal) to the Solver Level , simulate it. Greater Than If the Marker Level is greater than (or equal) to the Solver Level , simulate it. Equal If the Marker Level is equal to the Solver Level , simulate it. NotEqual If the Marker Level is not equal to the Solver Level , simulate it. With these, you can use each level for.. An increasing amount of detail An increasing amount of reduction Something completely custom With Equal and NotEqual operators, you can have some markers appear or disappear on particular levels, enabling endless combinations. Roadmap This should cover a majority of cases, but there are things you cannot yet do, but will be able to in the future. Capsule on one level, Mesh on another. For higher-resolution contacts. Dense hierarchy of controls at one level, sparse at another. For e.g. twist joints versus a simple 2-joint chain, or a densely packed spine versus just hip and torso controls. Algorithm For the geeks out there, here's what the underlying algorithm looks like in Python. # Membership types Minimum = 1 # Present at this level and higher Maximum = 3 # Present at this level and lower Only = 4 # Only present at this level Not = 5 # Present at all levels *except* this one markers = [ { \"name\" : \"hip\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"spine\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"neck\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"head\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_upper_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_lower_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"R_hand\" , \"level\" : 1 , \"membership\" : Minimum }, { \"name\" : \"L_foot_box\" , \"level\" : 1 , \"membership\" : Maximum }, { \"name\" : \"L_foot_convex\" , \"level\" : 2 , \"membership\" : Minimum }, { \"name\" : \"R_toe_capsule\" , \"level\" : 2 , \"membership\" : Not }, { \"name\" : \"R_toe_convex\" , \"level\" : 2 , \"membership\" : Only }, ] def resolve ( level ): print ( \"Level %d \" % level ) for marker in markers : if marker [ \"membership\" ] == Minimum and marker [ \"level\" ] <= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Maximum and marker [ \"level\" ] >= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Only and marker [ \"level\" ] == level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Not and marker [ \"level\" ] != level : print ( \" - {name} ( {level} )\" . format ( ** marker )) resolve ( 0 ) resolve ( 1 ) resolve ( 2 ) Run this, and this is what you'll find. Level 0 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 1 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 2 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_convex ( 2 ) - R_toe_convex ( 2 ) Markers API With the retirement of the legacy Python API, a new Markers API is now available. API Documentation API Reference from maya import cmds import ragdoll.api as rd box = cmds . polyCube () solver = rd . createSolver () marker = rd . assignMarker ( box [ 0 ], solver ) rd . recordPhysics () The new export and import mechanic can be accessed from here too. import ragdoll.api as rd fname = r \"c:\\path\\to\\my_ragdoll.rag\" # Get everything out rd . exportPhysics ( fname ) # Remove everything rd . deleteAllPhysics () # Bring everything back rd . reinterpretPhysics ( fname ) Legacy API The old Rigid API is still accessible under a new home. from ragdoll.legacy import commands commands . create_active_rigid () commands . create_point_constraint () # ... But will be removed entirely soon, so do transition away from it ASAP. Quality of Life Make it more difficult to make mistakes with these new additions. \ud83d\ude0a Max Mass Ratio With Density , there's a chance Markers get Ragdoll into a situation it does not like; namely that the difference between masses are too great. Give me the technical details As you wish. \ud83e\udd13 Ragdoll doesn't like differences any greater than 10x, sometimes 100x, else it can fail or become unstable. For example, if the torso of your character has a mass of 100kg, and the foot Marker has a mass of 0.5kg, that's a ratio of 100/0.5 = 200x which is far greater than Ragdoll would like. As a result, the body would crush the foot which would be unable to properly hold the entire body up. Up until now, the masses on all Markers have had a default value of 1kg. Meaning that regardless of the size of a Marker - be it the torso, the head or tip of a finger - it would always have a mass of 1.0. As a result, hands would typically end up far heavier than the rest of the body. Before Here's an example of the solver failing. There are three identical chains, the tip of the last one having a mass of 10,000. That's 10,000x greater then each link in the chain. As a result, Markers separate; that is incorrect. After If we limit the maximum ratio to just 1000x, we get the correct behavior. You can also see how it affected the other two chains. They now behave more similarly, because in order to ensure a mass ratio across the whole system, the mass of their tips need to be reduced as well. The new Max Mass Ratio attribute protects against these situations, letting you give objects a suitable mass and only have to worry about which should weigh more, and which should weigh less. Ragdoll will balance everything out before passing it along to be simulated. What are the consequences? Sometimes, large mass ratios are what you want. For example, a heavy weight on a string tends to do quite well with ratios up to 1000x. But markers being crushed by another marker 1000x its weight tends to not do as well. So the result is less of an effect at the extreme ratios. In the Manipulator, you can preview the final mass used given the density and the ratio you specified. DirectX Look. Closely. Look. Closlier. That's right! You've now got the option to use Ragdoll with Maya in DirectX viewport mode. Truly Non-keyable Some Ragdoll attributes are keyable, others are not. Which is which? Impossible to say. Until now! On attempting to keyframe a non-keyable attribute, you'll now see an error message along with a visual cue things might not work out the way you expect. As opposed to happily setting that keyframe but then ignoring it once the simulation starts, like it used to. A little quality of life for ya'! Pro-tip for Riggers There are at least 2 ways to prevent non-keyable attributes from being keyframed. MFnAttribute::setConnectable(false); MPxNode::legalConnection() The former means you are also unable to make a control and connect it to multiple non-keyable attributes. Like if you wanted to control Mass of a series of markers from a single source, or the Overlap Group . The latter on the other hand is more flexible. It allows Ragdoll to prevent connections to specific attributes or types of nodes, like animCurve nodes, which means animators won't be able to keyframe it but you'll still be able to build controls for it. And that's exactly how it works. Delta Drawing Bug The worldspace deltas were drawn separate from the marker they affected, which could produce a jarring effect especially when the solver position had been offset. Before After This has now been fixed. More Performance As an added bonus, we're now also doing 2 matrix multiplications less per frame , per marker . That kind of thing adds up quickly. Shape Sync If you play, pause and then change the Shape from Box to Capsule nothing happens. Because the shape, like many other attributes, can only be changed on the start frame. But, when you later returned to the start frame, the shape would still not update. This has now been fixed. Profiler View Mostly meant to keep the development of Ragdoll fast and interactive, you can now spot where most time is spent via the built-in Maya Profiler. Here's what one frame of this looks like; 5 ms to both simulate and render Ragdoll in the viewport. Removed Attributes These attributes were no longer relevant in the last release, but were still present in the Channel Editor. These have now been hidden and will no longer be saved with your file. A few weeks from now, they will be removed. limitAutoOrient limitType limitAxis limitOffsetX limitOffsetY limitOffsetZ limitOffset limitRotationX limitRotationY limitRotationZ limitRotation Mandarin Serial Number It has come to my attention that the first thing every new user of Ragdoll sees is this dialog, with this message for a serial number. And yet.. Nobody has said a thing! \ud83e\udd23 Correction shout-out to @Rosaline for pointing this out just a few days ago! According to my Mandarin-speaking friends, this is jibberish (or at least should be!) and is a result of badly translated Unicode to ASCII characters. This has now been fixed!","title":"2022.01.17"},{"location":"releases/2022.01.17/#showcase","text":"Let's start with the good stuff. Medusa Breakdown Excellent Animation and breakdown by Andras Ormos . https://youtu.be/6wsnvsyNGYQ Batman Learning Cursive Animation by Jason Snyman , with a very interesting approach to getting ink out of a pen digitally. \ud83d\ude04 DMV Lady Courtesy of Dragana Mandic. On LinkedIn Scalable Rig, Scalable Ragdoll No special setup required, if your rig is scalable then so is Ragdoll. Circus Import Toying with the ability to import characters into the same solver. The Ocean Give a man a fish, and you'll feed him for 2 ragdolls. Noodles Something from the Linux world.","title":"Showcase"},{"location":"releases/2022.01.17/#ragdoll-20","text":"Since 28 th July 2021, Ragdoll has been publicly available under the \"early bird\" umbrella. It started out with a reduced price point for those brave enough to venture into new territory and expect a few left turns every now and then as kinks are worked out in the software. Now the time has come to step into the world as an adult piece of software with the guarantees of any commercially available software and a pricing to reflect that. And as Ragdoll has grown significantly since those days - given the new Markers - it's only reasonable to consider this Ragdoll 2.0 .","title":"Ragdoll 2.0"},{"location":"releases/2022.01.17/#january-voucher","text":"Pricing has now reached its intended price point, leaving Early Bird behind. For the next two weeks however, you can use this voucher code to get the Early Bird discount before the deadline. Valid for: Ragdoll Unlimited Voucher Code: uX1bFhjZ Purchase Page: https://ragdolldynamics.com/pricing-commercial","title":"January Voucher"},{"location":"releases/2022.01.17/#looking-back","text":"The Ragdoll of today is very different from the Ragdoll of July 2021. Back then, I had no idea that this amount of performance and usability was possible and was prepared to cram tutorials and documentation until everyone was accustomed to the complexity of physics simulation. \ud83d\ude04 But then something happened - Markers . Like lightning from a clear sky, it unexpectedly changed everything. Performance is now far beyond what Maya is expected to handle, with physics much much faster than simply skinning of a character, and close to the performance of native IK handles. This opens up a lot of possibilities. The problems faced back then.. Like the massive endevour starting a simulation wherever your character was . Or the need for controls other than your rig to actually animate the thing Not to mention the constant chasing of supporting Maya's numerous ways of affecting the position and orientation of your controls, from rotate axes, to rotate pivots, to scale , to... . None of those problems are a problem with Markers. Because Markers look at the world from a different perspective, they just work . It made Ragdoll not only more user friendly and significantly faster but also simpler to develop and smaller in size . The code for Markers is about \u2153 of the equivalent for Rigids. Just think about that! And most of all, it opened up for all the things you are about to see happen for Ragdoll in the coming months. \ud83d\ude43","title":"Looking Back"},{"location":"releases/2022.01.17/#ragdoll-flavours","text":"Let's take a quick look at the different versions of Ragdoll and how they differ. Flavour Description Ragdoll Unlimited The fully-featured, unrestricted version of Ragdoll. When people talk about Ragdoll, this is the version they mean. Ragdoll Complete The cost-effective flavour of Ragdoll, suitable for freelancers and indie studios. It lacks studio-conveniences such as a Python API for pipeline integration, export to JSON for sharing of physics configurations and is less performant than \"Ragdoll Unlimited\", being unable to operate in parallel across multiple cores. Ragdoll Batch A non-interactive version without ability to render into the viewport. Suitable for automation and pipeline integration. Ragdoll Personal A non-commercial version, suitable for students and anyone wanting to fool around with Ragdoll at home. It is identical to Unlimited, except that it has limits on how much can be recorded and exported. Ragdoll Educational A non-commercial version of Ragdoll Unlimited whose saved scenes cannot be opened with a commercial licence. Ragdoll Trial A non-commercial first experience with Ragdoll; this is what you get when downloading Ragdoll onto a new machine and use it without activating it first. Similar limitations to Personal, except it also expires about a month after first use.","title":"Ragdoll Flavours"},{"location":"releases/2022.01.17/#ragdoll-unlimited","text":"This is the version you want . It contains everything mentioned on any website, is capable of doing everything you've seen Ragdoll do and is the unrestricted, unlimited and gold standard of Ragdoll.","title":"Ragdoll Unlimited"},{"location":"releases/2022.01.17/#ragdoll-complete","text":"This is the version for freelancers. It is Ragdoll Unlimited, with a few limitations. Limited Performance Limited Export Limited Python API Performance is limited in how quickly Ragdoll is able to read from your character. Ragdoll is natively parallel, but Complete turns any character you assign markers to into a Serial affair. Limiting performance by the number of cores you have in your machine. The advantage of export is that your rigs don't need physics built-in. They can remain simple and without physics, until the animator actually needs it. This feature is limited to 10 markers ; for the time being. Generally, export is reserved for Unlimited and users in need of pipeline integration. But Complete let's you get at least a taste of the comfort and flexibility of exporting your physics contraptions from one scene and importing onto an unsuspecting character in another. Like Export, the ability to interact with Ragdoll through Python is an important part of any production pipeline; not so much for the individual animator of small indie studio. Info At the time of this writing, this limitation is not yet in place, and users of Complete is currently able to utilise the Python API just like users of Unlimited. This will be addressed in an upcoming release.","title":"Ragdoll Complete"},{"location":"releases/2022.01.17/#ragdoll-batch","text":"This is the version for your render farm . It's a low-cost alternative to Ragdoll Unlimited, without the ability to render into the viewport. Making it effectively useful only via Python. It is also unable to export and lacks the parallelism of Unlimited. Unlike all other flavours, a Batch licence is reserved per-process; meaning that if you spin up 2 mayapy instances on the same machine, it will occupy 2 licences. This obviously only works if your licences are floating, as otherwise a machine can only carry a single node-locked licence, limiting it to a single process running Ragdoll Batch.","title":"Ragdoll Batch"},{"location":"releases/2022.01.17/#ragdoll-feature-grid","text":"Leaving Early Access, Ragdoll is stepping into the world as a 1.0. Here's an overview of what you can expect from now on. Feature Trial Personal Complete Unlimited Batch Commercial Use \u274c \u274c \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Interactive Tools \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Python API \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u2714\ufe0f Multi-Threading \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c JSON Import/Export \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c Per-machine Licence \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Batch has a per-process licence, meaning it will occupy one seat per individually running process.","title":"Ragdoll Feature Grid"},{"location":"releases/2022.01.17/#non-commercial-limitations","text":"Trial and Personal licences are non-commercial , meaning they can't be used for commercial purposes. Such as in a studio, or for anything where money is involved. When a file saved with a non-commercial licence of Ragdoll is opened in a commercial licence, it'll temporarily turn your licence into a non-commercial licence. Feature Unlimited Complete Non-commercial Export Unlimited markers Up to 10 markers Up to 10 markers Record Unlimited frames Unlimited frames Up to 100 frames Early Birds Did you purchase a Ragdoll Personal licence before this release? Then as thanks for believing in us and joining early, these limits do not apply to you. Your version is still unrestricted for non-commercial use. Enjoy! \ud83e\udd70","title":"Non-commercial Limitations"},{"location":"releases/2022.01.17/#import","text":"You can now import a Ragdoll setup exported from Maya, back into Maya. It'll re-create everything just the way it was. Can I export scenes I made with an earlier version? Yes, anything made with Markers can be exported regardless of when it was made. What is included in the export? Just about everything. Solvers Groups Markers Constraints Colors Attribute changes Retargeting Reparenting Replaced meshes Thumbnail of your viewport What isn't included in the export? Very little. The mesh itself is not stored, the mesh is expected to come from your rig. Including any mesh you replace. This may be added in a future release. The cached simulation, although it will be soon. Will I get identical results when simulating an imported scene? Yes, anything else is a bug. More precisely, determinism depends on (1) the type and number of items in the solver along with (2) the order in which these are created. Both of these are part of the exported file format and is taken into account during import. Meaning you should get identical results so long as the content is the same.","title":"Import"},{"location":"releases/2022.01.17/#example","text":"Here's an exported Ragdoll setup for the free CG Spectrum Tiger rig. Download Ragdoll file ( 2.8 mb ) Download Rig To use it, download the rig and import the Ragdoll file. It contains 2 levels of detail . Level Content Level 0 Body and feet Level 1 Everything on Level 0, plus toes","title":"Example"},{"location":"releases/2022.01.17/#workflow","text":"Here's the rundown. Assign markers Tweak values Export Open a new scene, with the same character Import On import, Ragdoll will try and find the names of what you exported in your currently opened scene. If all names match, import should go smoothly. Preserving all of your hard work! If names do not match, if for example the namespace differs, there is an option to override the namespace from the file via the Namespace dropdown menu. If names don't match at all , if for example it was grouped differently on export or it is a different character altogether, then you can try using the Search and Replace fields to modify the names searched for by Ragdoll. Export Once you're happy with your character, it's time to export. Towards the bottom of the UI, you'll get a preview of what is about to be exported. This can help clarify that what ends up on disk is what you expect. Import In a new scene, with the same character, same names and everything, import as you'd expect. At the bottom of this UI, you'll get a preview of what's in the file on disk, along with how it will associate the node names found in the file with what you have on disk.","title":"Workflow"},{"location":"releases/2022.01.17/#namespace-from-file","text":"Odds are, the character you're importing either has no namespace, or has a different namespace to what you've currently got in your scene. As in this example here, with 3 copies of the same character, each with its own namespace. Use the Namespace dropdown to select one of the current namespaces in your scene, or Custom to type one in yourself.","title":"Namespace from File"},{"location":"releases/2022.01.17/#solver-from-file","text":"Per default, Ragdoll will import the file into the current solver in your scene, if any. Or, you can import the original solver from the source file.","title":"Solver from File"},{"location":"releases/2022.01.17/#known-limitations","text":"Here are a few things that will be addressed over time. Let us know if you encounter anything else! https://ragdolldynamics.com/chat Limitation Result Missing Replaced Mesh If you replace the mesh of a marker, but this mesh isn't present in the scene during import, you'll get a Capsule instead. The vertices of the geometry isn't stored in the exported file, only the name of the mesh you replaced with. Linked Solvers These turn into a single, unified solver on import.","title":"Known Limitations"},{"location":"releases/2022.01.17/#density","text":"Ragdoll can now automatically compute a suitable mass for each Marker, based on the volume of your shape and a density of your choosing. In other words, big objects become heavy, small objects become light. Before After","title":"Density"},{"location":"releases/2022.01.17/#presets","text":"Provide a custom density, or choose from one of the provided ones. Density Value Off Do not compute, use the Mass attribute Cotton Very sparse, 0.05 grams per cubic centimeter Wood Sparse, 0.2 grams per cubic centimeter Flesh Default, 1.0g/cm3 Uranium Dense, 19.0g/cm3 Black Hole Very, very dense Custom You pick Mass is computed based on the volume of your shape, along with a density of your choosing.","title":"Presets"},{"location":"releases/2022.01.17/#options","text":"Choose between various densities either at creation-time or after creation.","title":"Options"},{"location":"releases/2022.01.17/#visualise","text":"The computed mass updates interactively as you change the size and type of your shape, including convex hulls! In the Manipulator, you'll be able to not only only edit the density, but preview the computed mass given the current shape volume and density you provide.","title":"Visualise"},{"location":"releases/2022.01.17/#level-of-detail","text":"Setup your character once with all bells-and-whistles, and interactively pick which level of detail to use for your simulation in a given situation. Usecases Body at Level 0 , fingers at Level 1 Props at Level 1 , muscles at Level 2 Major masses at Level 0 , extremities at Level 1 and Level 2 For example, here's a Wasp character with 3 levels of increasing detail. As you'd expect, it'll record only the currently active markers.","title":"Level of Detail"},{"location":"releases/2022.01.17/#workflow_1","text":"Here's how it works. Give each marker a \"level\", such as 1 Tell solver which \"level\" to solve at, such as 1 And that's it! Any marker with a matching level is simulated and recorded.","title":"Workflow"},{"location":"releases/2022.01.17/#operators","text":"What does each level mean? The answer lies in the \"operator\". Operator Description Less Than If the Marker Level is less than (or equal) to the Solver Level , simulate it. Greater Than If the Marker Level is greater than (or equal) to the Solver Level , simulate it. Equal If the Marker Level is equal to the Solver Level , simulate it. NotEqual If the Marker Level is not equal to the Solver Level , simulate it. With these, you can use each level for.. An increasing amount of detail An increasing amount of reduction Something completely custom With Equal and NotEqual operators, you can have some markers appear or disappear on particular levels, enabling endless combinations. Roadmap This should cover a majority of cases, but there are things you cannot yet do, but will be able to in the future. Capsule on one level, Mesh on another. For higher-resolution contacts. Dense hierarchy of controls at one level, sparse at another. For e.g. twist joints versus a simple 2-joint chain, or a densely packed spine versus just hip and torso controls.","title":"Operators"},{"location":"releases/2022.01.17/#algorithm","text":"For the geeks out there, here's what the underlying algorithm looks like in Python. # Membership types Minimum = 1 # Present at this level and higher Maximum = 3 # Present at this level and lower Only = 4 # Only present at this level Not = 5 # Present at all levels *except* this one markers = [ { \"name\" : \"hip\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"spine\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"neck\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"head\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_upper_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"L_lower_leg\" , \"level\" : 0 , \"membership\" : Minimum }, { \"name\" : \"R_hand\" , \"level\" : 1 , \"membership\" : Minimum }, { \"name\" : \"L_foot_box\" , \"level\" : 1 , \"membership\" : Maximum }, { \"name\" : \"L_foot_convex\" , \"level\" : 2 , \"membership\" : Minimum }, { \"name\" : \"R_toe_capsule\" , \"level\" : 2 , \"membership\" : Not }, { \"name\" : \"R_toe_convex\" , \"level\" : 2 , \"membership\" : Only }, ] def resolve ( level ): print ( \"Level %d \" % level ) for marker in markers : if marker [ \"membership\" ] == Minimum and marker [ \"level\" ] <= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Maximum and marker [ \"level\" ] >= level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Only and marker [ \"level\" ] == level : print ( \" - {name} ( {level} )\" . format ( ** marker )) if marker [ \"membership\" ] == Not and marker [ \"level\" ] != level : print ( \" - {name} ( {level} )\" . format ( ** marker )) resolve ( 0 ) resolve ( 1 ) resolve ( 2 ) Run this, and this is what you'll find. Level 0 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 1 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_box ( 1 ) - R_toe_capsule ( 2 ) Level 2 - hip ( 0 ) - spine ( 0 ) - neck ( 0 ) - head ( 0 ) - L_upper_leg ( 0 ) - L_lower_leg ( 0 ) - R_hand ( 1 ) - L_foot_convex ( 2 ) - R_toe_convex ( 2 )","title":"Algorithm"},{"location":"releases/2022.01.17/#markers-api","text":"With the retirement of the legacy Python API, a new Markers API is now available. API Documentation API Reference from maya import cmds import ragdoll.api as rd box = cmds . polyCube () solver = rd . createSolver () marker = rd . assignMarker ( box [ 0 ], solver ) rd . recordPhysics () The new export and import mechanic can be accessed from here too. import ragdoll.api as rd fname = r \"c:\\path\\to\\my_ragdoll.rag\" # Get everything out rd . exportPhysics ( fname ) # Remove everything rd . deleteAllPhysics () # Bring everything back rd . reinterpretPhysics ( fname )","title":"Markers API"},{"location":"releases/2022.01.17/#legacy-api","text":"The old Rigid API is still accessible under a new home. from ragdoll.legacy import commands commands . create_active_rigid () commands . create_point_constraint () # ... But will be removed entirely soon, so do transition away from it ASAP.","title":"Legacy API"},{"location":"releases/2022.01.17/#quality-of-life","text":"Make it more difficult to make mistakes with these new additions. \ud83d\ude0a","title":"Quality of Life"},{"location":"releases/2022.01.17/#max-mass-ratio","text":"With Density , there's a chance Markers get Ragdoll into a situation it does not like; namely that the difference between masses are too great. Give me the technical details As you wish. \ud83e\udd13 Ragdoll doesn't like differences any greater than 10x, sometimes 100x, else it can fail or become unstable. For example, if the torso of your character has a mass of 100kg, and the foot Marker has a mass of 0.5kg, that's a ratio of 100/0.5 = 200x which is far greater than Ragdoll would like. As a result, the body would crush the foot which would be unable to properly hold the entire body up. Up until now, the masses on all Markers have had a default value of 1kg. Meaning that regardless of the size of a Marker - be it the torso, the head or tip of a finger - it would always have a mass of 1.0. As a result, hands would typically end up far heavier than the rest of the body. Before Here's an example of the solver failing. There are three identical chains, the tip of the last one having a mass of 10,000. That's 10,000x greater then each link in the chain. As a result, Markers separate; that is incorrect. After If we limit the maximum ratio to just 1000x, we get the correct behavior. You can also see how it affected the other two chains. They now behave more similarly, because in order to ensure a mass ratio across the whole system, the mass of their tips need to be reduced as well. The new Max Mass Ratio attribute protects against these situations, letting you give objects a suitable mass and only have to worry about which should weigh more, and which should weigh less. Ragdoll will balance everything out before passing it along to be simulated. What are the consequences? Sometimes, large mass ratios are what you want. For example, a heavy weight on a string tends to do quite well with ratios up to 1000x. But markers being crushed by another marker 1000x its weight tends to not do as well. So the result is less of an effect at the extreme ratios. In the Manipulator, you can preview the final mass used given the density and the ratio you specified.","title":"Max Mass Ratio"},{"location":"releases/2022.01.17/#directx","text":"Look. Closely. Look. Closlier. That's right! You've now got the option to use Ragdoll with Maya in DirectX viewport mode.","title":"DirectX"},{"location":"releases/2022.01.17/#truly-non-keyable","text":"Some Ragdoll attributes are keyable, others are not. Which is which? Impossible to say. Until now! On attempting to keyframe a non-keyable attribute, you'll now see an error message along with a visual cue things might not work out the way you expect. As opposed to happily setting that keyframe but then ignoring it once the simulation starts, like it used to. A little quality of life for ya'! Pro-tip for Riggers There are at least 2 ways to prevent non-keyable attributes from being keyframed. MFnAttribute::setConnectable(false); MPxNode::legalConnection() The former means you are also unable to make a control and connect it to multiple non-keyable attributes. Like if you wanted to control Mass of a series of markers from a single source, or the Overlap Group . The latter on the other hand is more flexible. It allows Ragdoll to prevent connections to specific attributes or types of nodes, like animCurve nodes, which means animators won't be able to keyframe it but you'll still be able to build controls for it. And that's exactly how it works.","title":"Truly Non-keyable"},{"location":"releases/2022.01.17/#delta-drawing-bug","text":"The worldspace deltas were drawn separate from the marker they affected, which could produce a jarring effect especially when the solver position had been offset. Before After This has now been fixed. More Performance As an added bonus, we're now also doing 2 matrix multiplications less per frame , per marker . That kind of thing adds up quickly.","title":"Delta Drawing Bug"},{"location":"releases/2022.01.17/#shape-sync","text":"If you play, pause and then change the Shape from Box to Capsule nothing happens. Because the shape, like many other attributes, can only be changed on the start frame. But, when you later returned to the start frame, the shape would still not update. This has now been fixed.","title":"Shape Sync"},{"location":"releases/2022.01.17/#profiler-view","text":"Mostly meant to keep the development of Ragdoll fast and interactive, you can now spot where most time is spent via the built-in Maya Profiler. Here's what one frame of this looks like; 5 ms to both simulate and render Ragdoll in the viewport.","title":"Profiler View"},{"location":"releases/2022.01.17/#removed-attributes","text":"These attributes were no longer relevant in the last release, but were still present in the Channel Editor. These have now been hidden and will no longer be saved with your file. A few weeks from now, they will be removed. limitAutoOrient limitType limitAxis limitOffsetX limitOffsetY limitOffsetZ limitOffset limitRotationX limitRotationY limitRotationZ limitRotation","title":"Removed Attributes"},{"location":"releases/2022.01.17/#mandarin-serial-number","text":"It has come to my attention that the first thing every new user of Ragdoll sees is this dialog, with this message for a serial number. And yet.. Nobody has said a thing! \ud83e\udd23 Correction shout-out to @Rosaline for pointing this out just a few days ago! According to my Mandarin-speaking friends, this is jibberish (or at least should be!) and is a result of badly translated Unicode to ASCII characters. This has now been fixed!","title":"Mandarin Serial Number"},{"location":"releases/2022.01.21/","text":"Minor release with some fixed for you, especially Floating Licence users . ADDED Keyframe on Snap to Simulation More use for this nifty little feature FIXED Commarcial Floating Licences There was a glitch in the Matrix FIXED Limits excluded from import Limits were exported, but not imported FIXED Z-up is inconsistent Foolproof implementation FIXED Scaled Limits The manipulator stuggled to display limits when scaled FIXED Manipulator and Viewport Shadows Now visible even in the darkest of times Snap to Simulation In addition to recording your simulation, you can also snap your rig to wherever the simulation is currently at. See original announcement However this only applied to things that aren't yet keyframed. Useful to layout and setting of an initial pose for your character. With this release, it will also keyframe your rig, such that you can use it to interactively animate a character on specific frames, as you simulate. You know what, it's easier to just show you. \ud83d\ude04 Commercial Floating Licence A glitch was found that turned Floating Licences into non-commercial licences, imposing the recording and exporting limits of 100 frames and 10 markers. This has now been fixed. Limits and Export The new Import functionality introduced in the last version neglected to include limits , this has now been fixed! Z-up is Inconsistent One user experienced having their gravity turned sideways, thinking Maya was configured with Z-up when really it was Y-up. It still unclear exactly why this happened, but the one potential edgecase has now been strengthened. If you experience gravity facing the wrong way, or the ground plane being orthogonal to your viewport grid, let us know! Scaled Limits When your rig or controls are scaled, the Manipulator wasn't able to accurately provide you with the limit handles. This has now been fixed. Manipulator and Viewport Shadows It used to be the case that the manipulator became invisible whenever viewport shadows was enabled. This has now been fixed!","title":"2022.01.21"},{"location":"releases/2022.01.21/#snap-to-simulation","text":"In addition to recording your simulation, you can also snap your rig to wherever the simulation is currently at. See original announcement However this only applied to things that aren't yet keyframed. Useful to layout and setting of an initial pose for your character. With this release, it will also keyframe your rig, such that you can use it to interactively animate a character on specific frames, as you simulate. You know what, it's easier to just show you. \ud83d\ude04","title":"Snap to Simulation"},{"location":"releases/2022.01.21/#commercial-floating-licence","text":"A glitch was found that turned Floating Licences into non-commercial licences, imposing the recording and exporting limits of 100 frames and 10 markers. This has now been fixed.","title":"Commercial Floating Licence"},{"location":"releases/2022.01.21/#limits-and-export","text":"The new Import functionality introduced in the last version neglected to include limits , this has now been fixed!","title":"Limits and Export"},{"location":"releases/2022.01.21/#z-up-is-inconsistent","text":"One user experienced having their gravity turned sideways, thinking Maya was configured with Z-up when really it was Y-up. It still unclear exactly why this happened, but the one potential edgecase has now been strengthened. If you experience gravity facing the wrong way, or the ground plane being orthogonal to your viewport grid, let us know!","title":"Z-up is Inconsistent"},{"location":"releases/2022.01.21/#scaled-limits","text":"When your rig or controls are scaled, the Manipulator wasn't able to accurately provide you with the limit handles. This has now been fixed.","title":"Scaled Limits"},{"location":"releases/2022.01.21/#manipulator-and-viewport-shadows","text":"It used to be the case that the manipulator became invisible whenever viewport shadows was enabled. This has now been fixed!","title":"Manipulator and Viewport Shadows"},{"location":"releases/2022.02.01/","text":"Highlight for this release is Quality of Life! UPDATED Kinematic & Dynamic The two pillars of Ragdoll ADDED Group and Ungroup Markers can now be arbitrarily grouped ADDED Lollipop 2.0 More powerful, more flexible lollipops ADDED Match by Name Importing can now match by name, rather than the full hierarchy ADDED Record Range Options Undimmed and ready to go! ADDED Offline Activation Wizard Simpler than ever FIXED Scaled Limits The manipulator stuggled to display limits when scaled FIXED Scaled Replaced Meshes Replaced meshes didn't used to like being scaled FIXED More Robust Recording Also interactive and faster! FIXED Manipulator and Multiple Viewports Now easier on both the eyes and mind. Showcase Let's start with the good stuff. Pounce Our Manikin is stuck! Batman Writes A behind-the-scenes from Jason's cool constraint setup. Kinematic & Dynamic Also known as \"Animated\" and \"Simulated\" Marker behaviour has been simplified. Groups are now either Kinematic - for fully animated, no physics involved - or Dynamic for having things affected by gravity and contacts with other Markers. In the above example, I'm alternating between Kinematic and Dynamic for the entire character. Changed As part of this simplification, two things have changed. Initial State was removed Pose Match was renamed to Dynamic Initial State can be achieved with Dynamic and a Pose Stiffness of 0 . And like before, individual markers can be overridden to be either Kinematic or Dynamic . When set to Inherit it continues to use whatever value was found in the group. ..speaking of which! Group In the previous version, a group was automatically created whenever you assign to a connected series of controls. This release enables you to group standalone markers too, and to retroactively group markers in any way you please. New Group Select some markers, put them in a group. Move To Group Select one or more markers, along with a destination group, and move them. Group on Assign When assigning markers, you are now also able to pick which group to put it into, or whether to make a new group. Or no group! Lollipop 2.0 Lollipops now feature Marker and Group attributes in the Channel Box; less clicks! Customisable Rotate and scale the resulting lollipops to fit your rig and workflow. Retroactive Lollipops Should you have markers without a lollipop, assign them afterwards using the Lollipop menu item. This is also where you can customise which attributes should appear on them. Pro tip The Use Proxy Attributes option makes attributes editable both on the Lollipop and on the original Marker. The downside however is that they make life in the Graph Editor less pleasant. \ud83e\udd14 With Proxy Attributes Without Proxy Attributes Quality of Life Some improvements and reshufflings to make your life more complete. \ud83e\udd70 Robust Recording There hasn't yet been any rig not supported by Ragdoll, until last week when @mandala got in touch with a new challenge. A rig made with an rigging system plug-in called Contour . Recording this rig results in cycle warnings, presumably because part of how it operates depends on viewport updates. In this update, there is a (default) Nice and Steady option for recording which ensures the viewport stays up-to-date with the dependency graph, and that did the trick! Match By Name Importing markers onto a character in a different group, or a different character altogether, could be tricky since their hierarchies would differ. There is now an option to find a matching control by name rather than its full path. In this example, the character has a different parent group than when it was exported, changing all of the full paths to each control. Scale Replace In the case of scaled markers with a replaced mesh, this happened. Before But no longer! After Offline Activation Wizard The offline activation process has now been streamlined; no longer requiring an email conversation back and forth. It should take some of our load off, whilst at the same time enabling you to offline activate when we are sleeping. \ud83d\ude05 https://learn.ragdolldynamics.com/licencing/#offline-activation Activation Deactivation Offline Trial Notification Whenever someone attempts to trial Ragdoll, but their machine is not connected to the internet, they would receive a message about how their Trial has expired.. Even though it was never activated in the first place! This has now been fixed. World Translate Visualisation The translation component of the World Pose Space wasn't very visible before, now it is! It's also drawn using the color of the Marker it's associated with, to aid in figuring out what it's actually affecting. And also make things a little nicer to look at. Before After Record Leaving Joints Behind Sometimes, Ragdoll could leave some remains after recording your simulation. This has now been fixed. Existing Constraints Deleted on Record Under rare circumstances, it's possible to assign a marker onto a control that's been constrained. It wouldn't make sense to record onto this control; because what should you expect to have happen? The control is either animated or it is constrained. At the moment, this constraint is also recorded and once complete your original constraint is deleted. If possible! If the constraint is from a referenced file, then you'll instead see an error. \ud83e\udd14 Record Range Options The Record UI has seen some updates. It used to always record your current playback range, but can now be customised. Record To Selected Range You can now drag-select on the timeline to record only that specific region. Record Full Range The minimum and maximum range on your timeline, beyond what is played back. Record Playback Range Record only the range currently played back, this is the default and current behaviour. Customise Range And finally, provide your own values. These values, along with the option of which range to pick from, is remembered alongside your Maya preferences just like all other Ragdoll options. Existing Constraints In the rare circumstance of: Assigning to a constrained control That is also kinematic And running Record You would find yourself with a missing constraint. As it happens, when Maya encounters an existing constraint it won't actually create a new constraint when you try and constrain again. Instead, it will append to this constraint. As a result, since Recording constrains your character to the simulation and then bakes the keyframes, once it was complete and went on to clean up any new constraints it had made, it also deleted yours. This has now been fixed. Manipulator & Multiple Viewports The Ragdoll Manipulator didn't like multiple viewports being present at the same time, resulting in a similar situation as 2021.12.15 . Ragdoll now draws and responds to the manipulator in the currently active viewport. Plug-in Unload and New Scene Sometimes, especially on a floating licence, you'd like to release your licence such that another artist can pick it up. To do that, you can either go to the Ragdoll UI and Drop Lease for a floating licence of Deactivate for a node-locked licence. Or, you can simply unload the plug-in. As it happens, if you did then Ragdoll would clear your scene. Without confirmation. \ud83d\ude35 This has now been fixed. You'll still need to ensure no Ragdoll nodes are present in your scene though, like any normal plug-in. Delete from Selection A new menu item has been added to delete physics only from the current selection. Pro tip I This was possible using the Use Selection option within the Delete Physics option dialog. Pro tip II Markers can also be manually deleted in the Outliner, they are DG nodes. Pro tip III Another way of deleting an individual marker is: Select your assigned control Select Marker in Channel Box Deselect control Hit Delete or Backspace on your keyboard Pro tip IV Yet another way of deleting an individual marker is: Select your assigned control Select Marker in Channel Box Ctrl + Right-click on marker Select Delete Node Minor Tweaks Limits are now included when importing physics Drive Space Custom appears under in the channel box when Drive Space = Custom Pin Constraint now visible in Wireframe mode Pin Constraint visible both with solver offset and at the origin Distance and Pin Constraints can now be hidden via the Outliner The Include Kinematic option for record has been fixed Python API: The opts argument of api.reinterpret is repaired","title":"2022.02.01"},{"location":"releases/2022.02.01/#showcase","text":"Let's start with the good stuff. Pounce Our Manikin is stuck! Batman Writes A behind-the-scenes from Jason's cool constraint setup.","title":"Showcase"},{"location":"releases/2022.02.01/#kinematic-dynamic","text":"Also known as \"Animated\" and \"Simulated\" Marker behaviour has been simplified. Groups are now either Kinematic - for fully animated, no physics involved - or Dynamic for having things affected by gravity and contacts with other Markers. In the above example, I'm alternating between Kinematic and Dynamic for the entire character. Changed As part of this simplification, two things have changed. Initial State was removed Pose Match was renamed to Dynamic Initial State can be achieved with Dynamic and a Pose Stiffness of 0 . And like before, individual markers can be overridden to be either Kinematic or Dynamic . When set to Inherit it continues to use whatever value was found in the group. ..speaking of which!","title":"Kinematic &amp; Dynamic"},{"location":"releases/2022.02.01/#group","text":"In the previous version, a group was automatically created whenever you assign to a connected series of controls. This release enables you to group standalone markers too, and to retroactively group markers in any way you please.","title":"Group"},{"location":"releases/2022.02.01/#new-group","text":"Select some markers, put them in a group.","title":"New Group"},{"location":"releases/2022.02.01/#move-to-group","text":"Select one or more markers, along with a destination group, and move them.","title":"Move To Group"},{"location":"releases/2022.02.01/#group-on-assign","text":"When assigning markers, you are now also able to pick which group to put it into, or whether to make a new group. Or no group!","title":"Group on Assign"},{"location":"releases/2022.02.01/#lollipop-20","text":"Lollipops now feature Marker and Group attributes in the Channel Box; less clicks!","title":"Lollipop 2.0"},{"location":"releases/2022.02.01/#customisable","text":"Rotate and scale the resulting lollipops to fit your rig and workflow.","title":"Customisable"},{"location":"releases/2022.02.01/#retroactive-lollipops","text":"Should you have markers without a lollipop, assign them afterwards using the Lollipop menu item. This is also where you can customise which attributes should appear on them. Pro tip The Use Proxy Attributes option makes attributes editable both on the Lollipop and on the original Marker. The downside however is that they make life in the Graph Editor less pleasant. \ud83e\udd14 With Proxy Attributes Without Proxy Attributes","title":"Retroactive Lollipops"},{"location":"releases/2022.02.01/#quality-of-life","text":"Some improvements and reshufflings to make your life more complete. \ud83e\udd70","title":"Quality of Life"},{"location":"releases/2022.02.01/#robust-recording","text":"There hasn't yet been any rig not supported by Ragdoll, until last week when @mandala got in touch with a new challenge. A rig made with an rigging system plug-in called Contour . Recording this rig results in cycle warnings, presumably because part of how it operates depends on viewport updates. In this update, there is a (default) Nice and Steady option for recording which ensures the viewport stays up-to-date with the dependency graph, and that did the trick!","title":"Robust Recording"},{"location":"releases/2022.02.01/#match-by-name","text":"Importing markers onto a character in a different group, or a different character altogether, could be tricky since their hierarchies would differ. There is now an option to find a matching control by name rather than its full path. In this example, the character has a different parent group than when it was exported, changing all of the full paths to each control.","title":"Match By Name"},{"location":"releases/2022.02.01/#scale-replace","text":"In the case of scaled markers with a replaced mesh, this happened. Before But no longer! After","title":"Scale Replace"},{"location":"releases/2022.02.01/#offline-activation-wizard","text":"The offline activation process has now been streamlined; no longer requiring an email conversation back and forth. It should take some of our load off, whilst at the same time enabling you to offline activate when we are sleeping. \ud83d\ude05 https://learn.ragdolldynamics.com/licencing/#offline-activation Activation Deactivation","title":"Offline Activation Wizard"},{"location":"releases/2022.02.01/#offline-trial-notification","text":"Whenever someone attempts to trial Ragdoll, but their machine is not connected to the internet, they would receive a message about how their Trial has expired.. Even though it was never activated in the first place! This has now been fixed.","title":"Offline Trial Notification"},{"location":"releases/2022.02.01/#world-translate-visualisation","text":"The translation component of the World Pose Space wasn't very visible before, now it is! It's also drawn using the color of the Marker it's associated with, to aid in figuring out what it's actually affecting. And also make things a little nicer to look at. Before After","title":"World Translate Visualisation"},{"location":"releases/2022.02.01/#record-leaving-joints-behind","text":"Sometimes, Ragdoll could leave some remains after recording your simulation. This has now been fixed.","title":"Record Leaving Joints Behind"},{"location":"releases/2022.02.01/#existing-constraints-deleted-on-record","text":"Under rare circumstances, it's possible to assign a marker onto a control that's been constrained. It wouldn't make sense to record onto this control; because what should you expect to have happen? The control is either animated or it is constrained. At the moment, this constraint is also recorded and once complete your original constraint is deleted. If possible! If the constraint is from a referenced file, then you'll instead see an error. \ud83e\udd14","title":"Existing Constraints Deleted on Record"},{"location":"releases/2022.02.01/#record-range-options","text":"The Record UI has seen some updates. It used to always record your current playback range, but can now be customised. Record To Selected Range You can now drag-select on the timeline to record only that specific region. Record Full Range The minimum and maximum range on your timeline, beyond what is played back. Record Playback Range Record only the range currently played back, this is the default and current behaviour. Customise Range And finally, provide your own values. These values, along with the option of which range to pick from, is remembered alongside your Maya preferences just like all other Ragdoll options.","title":"Record Range Options"},{"location":"releases/2022.02.01/#existing-constraints","text":"In the rare circumstance of: Assigning to a constrained control That is also kinematic And running Record You would find yourself with a missing constraint. As it happens, when Maya encounters an existing constraint it won't actually create a new constraint when you try and constrain again. Instead, it will append to this constraint. As a result, since Recording constrains your character to the simulation and then bakes the keyframes, once it was complete and went on to clean up any new constraints it had made, it also deleted yours. This has now been fixed.","title":"Existing Constraints"},{"location":"releases/2022.02.01/#manipulator-multiple-viewports","text":"The Ragdoll Manipulator didn't like multiple viewports being present at the same time, resulting in a similar situation as 2021.12.15 . Ragdoll now draws and responds to the manipulator in the currently active viewport.","title":"Manipulator &amp; Multiple Viewports"},{"location":"releases/2022.02.01/#plug-in-unload-and-new-scene","text":"Sometimes, especially on a floating licence, you'd like to release your licence such that another artist can pick it up. To do that, you can either go to the Ragdoll UI and Drop Lease for a floating licence of Deactivate for a node-locked licence. Or, you can simply unload the plug-in. As it happens, if you did then Ragdoll would clear your scene. Without confirmation. \ud83d\ude35 This has now been fixed. You'll still need to ensure no Ragdoll nodes are present in your scene though, like any normal plug-in.","title":"Plug-in Unload and New Scene"},{"location":"releases/2022.02.01/#delete-from-selection","text":"A new menu item has been added to delete physics only from the current selection. Pro tip I This was possible using the Use Selection option within the Delete Physics option dialog. Pro tip II Markers can also be manually deleted in the Outliner, they are DG nodes. Pro tip III Another way of deleting an individual marker is: Select your assigned control Select Marker in Channel Box Deselect control Hit Delete or Backspace on your keyboard Pro tip IV Yet another way of deleting an individual marker is: Select your assigned control Select Marker in Channel Box Ctrl + Right-click on marker Select Delete Node","title":"Delete from Selection"},{"location":"releases/2022.02.01/#minor-tweaks","text":"Limits are now included when importing physics Drive Space Custom appears under in the channel box when Drive Space = Custom Pin Constraint now visible in Wireframe mode Pin Constraint visible both with solver offset and at the origin Distance and Pin Constraints can now be hidden via the Outliner The Include Kinematic option for record has been fixed Python API: The opts argument of api.reinterpret is repaired","title":"Minor Tweaks"},{"location":"releases/2022.02.14/","text":"Highlight for this release is Fields! ADDED Fields All of Maya's native fields, now supported by Ragdoll ADDED Compound Shapes Combine multiple meshes for a single collision shape ADDED Manikin 3 Next iteration of the default Ragdoll rig FIXED Robust Frame Skips Unbreakable real-time playback FIXED Kinematic Stiffness Kinematic markers acting more like you'd expect FIXED Manipulator and Viewport HUD Better handling of hiding of the HUD FIXED Negative Scale One more edgecase caught and squashed! FIXED Untrusted Plug-in Locator One less warning to worry about FIXED Kinematic Stiffness Stiffness of kinematic now affects dynamic parent as expected FIXED Capsule Length Axis Use the Maya scale manipulator as you'd expect Jason Snyman Today I'm happy to announce that Jason Snyman joins Ragdoll Dynamics! \ud83c\udf89 https://www.linkedin.com/in/jason-snyman-84711b1/ Jason is a wizard of an animator with 20 years of experience in the industry - from King Kong and Avatar to Game of Thrones - and will be helping you become the best animator you can be, with Ragdoll at your side. That means tutorials, live streams and more of these awesome demos you may already have seen on LinkedIn! Batman and Shark Dragon and Kong Dragon on Branch Showcase You know the drill. Let's get into it. Live Stream We hosted a live stream last Friday! If you couldn't make it, it's been recorded and is made available here. :) https://www.youtube.com/watch?v=P9iEX-IuiRI Dragon Jason's latest animation, using the newly added Fields ! Model by Antoine Verney-Carron Dragon \u2764\ufe0f Kong I just can't stop watching this. Manikin Marine He's packing! Tentacle Field Manikin 3.0 The Manikin has been updated to leverage the new goodies from this release, go ahead and grab it here! Features IK/FK legs IK/FK arms Anatomical limits New compound shapes Fully scalable Download Fields Ragdoll now supports all of Maya's native fields . What are fields? A field represents a set of forces applied to each Marker. Ranging from Gravity to Turbulence , each field carries unique properties you can use to emulate some environment or environmental effect, like wind and gravity fields along a curve. What is the difference from regular Maya fields? They are the very same! If you're already familiar with them, from e.g. nParticles of nCloth, then you can leverage your experience with Ragdoll, and vice versa if you ever venture into nCloth and friends. Let's walk through these fields one-by-one! Turbulence The perhaps most interesting field. Apply forces in \"random\" directions, based on the worldspace positions of your Markers. The way to think of turbulence is as Perlin Noise you may have seen in images such as this. Where the amount of white determines the amount of force being applied. As a Marker travels across this field, both the magnitude and direction changes in interesting ways. Drag Apply an opposite force to any motion. The faster things move, the greater the force. Pro tip This field is similar to Ragdoll's Air Density . Not technically , but practically. Wind Apply a uniform force, at a given speed, in a given direction. Like wind, including a kitchen fan with some Spread . Gravity A familiar force, except this one can be also be animated! Newton Force Markers towards or away from a point in space. Radial A more curious field; with a force which increases as it gets farther from the source. Uniform Apply a constant force. That's all. Vortex Apply forces in a circular pattern. Volume Axis Field A field for when you don't know what field you want. A true Swiss Army Knife of fields, can do everything from Vortex, to Newton to Turbulence in one convenient node. Volume Curve Have some fun with this curve-based field. Perhaps to emulate an underwater current? In this example, I'm also using a Drag field to keep things from flying off into space. Pro tip The curve is a normal Maya NURBS curve. If you need more points, right click and add points as you normally would. Combined Fields Make two or more fields to combine their effect and create complex forces or series of forces! Centroids Where within each Marker should a field apply forces? Center of Mass Volumetric At the center, forces will be nice and predictable; except they won't be able to introduce rotations to your Marker, which may or may not be what you want. For the most realistic fields, use volumetric centroids. Here's another example using the Turbulence Field. Which is better? Up to you! There is a tiny performance penalty for volumetric origins, as the number of forces increase. But you shouldn't notice much if any impact on performance. Centroid Seed For complex meshes, centroids can end up in unwanted locations or gather in an area with dense vertices. That's when you can give the algorithm a little jolt to try and see whether there is a better alternative out there. Use Selected as Source Some forces act according to their position in the world. Attach a field to a Marker to create an interesting relationship between the two. Non-commercial Ragdoll This feature is limited to 100 frames in non-commercial versions of Ragdoll. Distance constrain two markers, and attach a field to the outer-most Marker for a doubly-interesting effect. That also wrecks your brain. \ud83d\ude43 Field Scale If forces start becoming large, you may find yourself in a situation where the visualisation needs to tone down just a bit. In the solver settings, you will find options to scale those lines (i.e. Field Scale ), as well as control how many steps into the future (i.e. Field Iterations ) it should draw for you. Ignore Field Fine-tune the effect of fields by having one or more Markers ignore the effect of fields. Force Modes Fields can apply to your markers in 2 different ways. Mode Description Math Force Traditional force mass * distance / time^2 Impulse Typically used for contacts mass * distance / time Which should I use? The default is Force , whereas Impulse is what is typically used for collision handling. Experiment, and let us know which you prefer! Compound Shape Combine multiple meshes for a complex \"compound shape\". Vertices connected by edges are considered an \"island\", each island is then turned into an independent convex hull. Like this complex endevour. 434 islands in 147 ms That's how long it took Ragdoll to generate the simulation volumes for the above meshes. You can slice an dice any mesh to introduce new islands at will, for complete control. Performance? If you're wondering what effect this many meshes has on your simulation, the answer is we haven't noticed any. Go crazy, and if you do notice anything, let us know! Mesh Decomposition Collision shapes are generated from each individual \"island\"; that is, groups of vertices that are connected by at least one edge. When you combine two or more meshes together, they will naturally form individal islands. Sometimes, you'd rather treat the entire mesh as one big shape and for that you can use the Mesh Decomposition = Mesh Islands . Shape Vertex Limit Also notice how the vertex limit is applied to each island . Meaning that you can achieve much higher resolution for your collision shapes by cutting things up into pieces! Quality of Life Let's brighten up your day, shall we? \ud83e\udd70 Robust Frame Skips Anyone playing back their simulation to audio may prefer Ragdoll with a Frameskip Method = Ignore . Such that it'll keep simulating, even though the result won't be 100% reproducible. But! If you did, you may have ran into this. Notice how it sometimes fails to keep up with fast time changes? Well, no longer! Caveat Like before however, the simulated result you get when frames are skipped will still differ from the result when frames are not skipped, or when different frames get skipped. The final recorded result will not skip any frames, so you should use this while working but ensure there aren't any frames skipped when you tune and tweak the final values. Manipulator and HUD The View Cube and other viewport ornaments are automatically and temporarily hidden whenever you use the Manipulator. But sometimes, Ragdoll could get confused and leave you having to manually re-enable the viewport HUD. This has now been fixed, and Ragdoll will more predictably re-enable any HUD it hides. Kinematic Stiffness Markers set to Kinematic would also lose their stiffness with their parent. Before After This has now been fixed. Pro tip To achieve the effect from the previous version, set Pose Stiffness to 0 Untrusted Plugin Location Users of Maya 2022 would experience this dialog when getting started with Ragdoll. This has now been fixed. Negative Scale Edgecase A rare case was discovered by @BigRoy whereby negatively scaled controllers would yield an incorrect shape drawing. The simulation was fine, but it wasn't looking quite right in the viewport. Before After This has now been fixed! Import Additions These attributes were added to the export and import mechanism. Nice Name Long Name World Pose Translate X driveAbsoluteLinearX World Pose Translate Y driveAbsoluteLinearY World Pose Translate Z driveAbsoluteLinearZ Pose Twist Amount driveAngularAmountTwist Pose Swing Amount driveAngularAmountSwing Capsule Length All this time, capsules had been scaled in an axis that didn't align with your scale manipulator. No longer! Before After","title":"2022.02.14"},{"location":"releases/2022.02.14/#jason-snyman","text":"Today I'm happy to announce that Jason Snyman joins Ragdoll Dynamics! \ud83c\udf89 https://www.linkedin.com/in/jason-snyman-84711b1/ Jason is a wizard of an animator with 20 years of experience in the industry - from King Kong and Avatar to Game of Thrones - and will be helping you become the best animator you can be, with Ragdoll at your side. That means tutorials, live streams and more of these awesome demos you may already have seen on LinkedIn! Batman and Shark Dragon and Kong Dragon on Branch","title":"Jason Snyman"},{"location":"releases/2022.02.14/#showcase","text":"You know the drill. Let's get into it. Live Stream We hosted a live stream last Friday! If you couldn't make it, it's been recorded and is made available here. :) https://www.youtube.com/watch?v=P9iEX-IuiRI Dragon Jason's latest animation, using the newly added Fields ! Model by Antoine Verney-Carron Dragon \u2764\ufe0f Kong I just can't stop watching this. Manikin Marine He's packing! Tentacle Field","title":"Showcase"},{"location":"releases/2022.02.14/#manikin-30","text":"The Manikin has been updated to leverage the new goodies from this release, go ahead and grab it here! Features IK/FK legs IK/FK arms Anatomical limits New compound shapes Fully scalable Download","title":"Manikin 3.0"},{"location":"releases/2022.02.14/#fields","text":"Ragdoll now supports all of Maya's native fields . What are fields? A field represents a set of forces applied to each Marker. Ranging from Gravity to Turbulence , each field carries unique properties you can use to emulate some environment or environmental effect, like wind and gravity fields along a curve. What is the difference from regular Maya fields? They are the very same! If you're already familiar with them, from e.g. nParticles of nCloth, then you can leverage your experience with Ragdoll, and vice versa if you ever venture into nCloth and friends. Let's walk through these fields one-by-one!","title":"Fields"},{"location":"releases/2022.02.14/#turbulence","text":"The perhaps most interesting field. Apply forces in \"random\" directions, based on the worldspace positions of your Markers. The way to think of turbulence is as Perlin Noise you may have seen in images such as this. Where the amount of white determines the amount of force being applied. As a Marker travels across this field, both the magnitude and direction changes in interesting ways.","title":"Turbulence"},{"location":"releases/2022.02.14/#drag","text":"Apply an opposite force to any motion. The faster things move, the greater the force. Pro tip This field is similar to Ragdoll's Air Density . Not technically , but practically.","title":"Drag"},{"location":"releases/2022.02.14/#wind","text":"Apply a uniform force, at a given speed, in a given direction. Like wind, including a kitchen fan with some Spread .","title":"Wind"},{"location":"releases/2022.02.14/#gravity","text":"A familiar force, except this one can be also be animated!","title":"Gravity"},{"location":"releases/2022.02.14/#newton","text":"Force Markers towards or away from a point in space.","title":"Newton"},{"location":"releases/2022.02.14/#radial","text":"A more curious field; with a force which increases as it gets farther from the source.","title":"Radial"},{"location":"releases/2022.02.14/#uniform","text":"Apply a constant force. That's all.","title":"Uniform"},{"location":"releases/2022.02.14/#vortex","text":"Apply forces in a circular pattern.","title":"Vortex"},{"location":"releases/2022.02.14/#volume-axis-field","text":"A field for when you don't know what field you want. A true Swiss Army Knife of fields, can do everything from Vortex, to Newton to Turbulence in one convenient node.","title":"Volume Axis Field"},{"location":"releases/2022.02.14/#volume-curve","text":"Have some fun with this curve-based field. Perhaps to emulate an underwater current? In this example, I'm also using a Drag field to keep things from flying off into space. Pro tip The curve is a normal Maya NURBS curve. If you need more points, right click and add points as you normally would.","title":"Volume Curve"},{"location":"releases/2022.02.14/#combined-fields","text":"Make two or more fields to combine their effect and create complex forces or series of forces!","title":"Combined Fields"},{"location":"releases/2022.02.14/#centroids","text":"Where within each Marker should a field apply forces? Center of Mass Volumetric At the center, forces will be nice and predictable; except they won't be able to introduce rotations to your Marker, which may or may not be what you want. For the most realistic fields, use volumetric centroids. Here's another example using the Turbulence Field. Which is better? Up to you! There is a tiny performance penalty for volumetric origins, as the number of forces increase. But you shouldn't notice much if any impact on performance.","title":"Centroids"},{"location":"releases/2022.02.14/#centroid-seed","text":"For complex meshes, centroids can end up in unwanted locations or gather in an area with dense vertices. That's when you can give the algorithm a little jolt to try and see whether there is a better alternative out there.","title":"Centroid Seed"},{"location":"releases/2022.02.14/#use-selected-as-source","text":"Some forces act according to their position in the world. Attach a field to a Marker to create an interesting relationship between the two. Non-commercial Ragdoll This feature is limited to 100 frames in non-commercial versions of Ragdoll. Distance constrain two markers, and attach a field to the outer-most Marker for a doubly-interesting effect. That also wrecks your brain. \ud83d\ude43","title":"Use Selected as Source"},{"location":"releases/2022.02.14/#field-scale","text":"If forces start becoming large, you may find yourself in a situation where the visualisation needs to tone down just a bit. In the solver settings, you will find options to scale those lines (i.e. Field Scale ), as well as control how many steps into the future (i.e. Field Iterations ) it should draw for you.","title":"Field Scale"},{"location":"releases/2022.02.14/#ignore-field","text":"Fine-tune the effect of fields by having one or more Markers ignore the effect of fields.","title":"Ignore Field"},{"location":"releases/2022.02.14/#force-modes","text":"Fields can apply to your markers in 2 different ways. Mode Description Math Force Traditional force mass * distance / time^2 Impulse Typically used for contacts mass * distance / time Which should I use? The default is Force , whereas Impulse is what is typically used for collision handling. Experiment, and let us know which you prefer!","title":"Force Modes"},{"location":"releases/2022.02.14/#compound-shape","text":"Combine multiple meshes for a complex \"compound shape\". Vertices connected by edges are considered an \"island\", each island is then turned into an independent convex hull. Like this complex endevour. 434 islands in 147 ms That's how long it took Ragdoll to generate the simulation volumes for the above meshes. You can slice an dice any mesh to introduce new islands at will, for complete control. Performance? If you're wondering what effect this many meshes has on your simulation, the answer is we haven't noticed any. Go crazy, and if you do notice anything, let us know!","title":"Compound Shape"},{"location":"releases/2022.02.14/#mesh-decomposition","text":"Collision shapes are generated from each individual \"island\"; that is, groups of vertices that are connected by at least one edge. When you combine two or more meshes together, they will naturally form individal islands. Sometimes, you'd rather treat the entire mesh as one big shape and for that you can use the Mesh Decomposition = Mesh Islands . Shape Vertex Limit Also notice how the vertex limit is applied to each island . Meaning that you can achieve much higher resolution for your collision shapes by cutting things up into pieces!","title":"Mesh Decomposition"},{"location":"releases/2022.02.14/#quality-of-life","text":"Let's brighten up your day, shall we? \ud83e\udd70","title":"Quality of Life"},{"location":"releases/2022.02.14/#robust-frame-skips","text":"Anyone playing back their simulation to audio may prefer Ragdoll with a Frameskip Method = Ignore . Such that it'll keep simulating, even though the result won't be 100% reproducible. But! If you did, you may have ran into this. Notice how it sometimes fails to keep up with fast time changes? Well, no longer! Caveat Like before however, the simulated result you get when frames are skipped will still differ from the result when frames are not skipped, or when different frames get skipped. The final recorded result will not skip any frames, so you should use this while working but ensure there aren't any frames skipped when you tune and tweak the final values.","title":"Robust Frame Skips"},{"location":"releases/2022.02.14/#manipulator-and-hud","text":"The View Cube and other viewport ornaments are automatically and temporarily hidden whenever you use the Manipulator. But sometimes, Ragdoll could get confused and leave you having to manually re-enable the viewport HUD. This has now been fixed, and Ragdoll will more predictably re-enable any HUD it hides.","title":"Manipulator and HUD"},{"location":"releases/2022.02.14/#kinematic-stiffness","text":"Markers set to Kinematic would also lose their stiffness with their parent. Before After This has now been fixed. Pro tip To achieve the effect from the previous version, set Pose Stiffness to 0","title":"Kinematic Stiffness"},{"location":"releases/2022.02.14/#untrusted-plugin-location","text":"Users of Maya 2022 would experience this dialog when getting started with Ragdoll. This has now been fixed.","title":"Untrusted Plugin Location"},{"location":"releases/2022.02.14/#negative-scale-edgecase","text":"A rare case was discovered by @BigRoy whereby negatively scaled controllers would yield an incorrect shape drawing. The simulation was fine, but it wasn't looking quite right in the viewport. Before After This has now been fixed!","title":"Negative Scale Edgecase"},{"location":"releases/2022.02.14/#import-additions","text":"These attributes were added to the export and import mechanism. Nice Name Long Name World Pose Translate X driveAbsoluteLinearX World Pose Translate Y driveAbsoluteLinearY World Pose Translate Z driveAbsoluteLinearZ Pose Twist Amount driveAngularAmountTwist Pose Swing Amount driveAngularAmountSwing","title":"Import Additions"},{"location":"releases/2022.02.14/#capsule-length","text":"All this time, capsules had been scaled in an axis that didn't align with your scale manipulator. No longer! Before After","title":"Capsule Length"},{"location":"releases/2022.02.28/","text":"Highlight for this release is Complex Geometry! ADDED Environment Static polygonal geometry for collisions ADDED Automatic Mesh Islands Ain't got no time to slice? ADDED Soft Joints More natural ragdolls with some softness inbetween limbs ADDED Forum 2.0 Same old forum. New and improved! ADDED Subscriptions Monthly licencing, now available ADDED Licence Conservation Lease only the licences you actively use ADDED Select with the Manipulator Selecting Markers got a bit easier ADDED Reset Shape Return to simpler days ADDED Solver Management Merge or extract markers from solvers ADDED Group API The group mechanic was added to the public API FIXED Multiple Manipulators Two or more solvers no longer breaks the Manipulator FIXED Lease Licence in UI Now you can actually use that Lease button REMOVED Legacy Legacy files still open and run, but can no longer be authored. Showcase Before we get into the new features of this release, let's have a look back at some highlights of the week. For the Love of Ragdoll Animation by Kevin Taylor, model by Shaun Keenan. On LinkedIn Dragon Setup Livestream The dragon from the latest livestream last Friday! https://www.youtube.com/watch?v=xHgFIvgg7O4 Chewsday A little experiment with worldspace rotation stiffness. Rhino Workout Soft joints for some belly-jiggle. Rhino Walk Nice self-walking rhino. Self Walking Manikin Same trick, different character. :) Soft Joints Jason experimenting with the new Soft Joints feature. Facial Animation Getting some nice secondary motion out of moving the head and jaw around! Environment Ragdoll now supports static environments; meaning environments that cannot move or deform, but allow for normal polygonal geometry without the need for a simplified \"convex hull\". As you might expect, this works well for environments like terrain and other complex geometry that is otherwise hard to turn into a rounded mesh. Performance It's fast. Normal shapes are limited in how complex they can get, and as such you never really run into a situation where the shape noticeably affects performance. Triangle meshes are different; they can be of any complexity. Up to millions of polygons and beyond. So it falls upon you to decide where to make the performance/quality tradeoff! Vertex Count Cooking Time Run-time performance 400 0.39 ms 685 fps 8'000 3.51 ms 599 fps 16'000 14.3 ms 594 fps 64'000 61.5 ms 327 fps 256'000 287.7 ms 40 fps 1'000'000 1490 ms 2 fps What is cooking time? The time it takes for Ragdoll to convert your polygonal geometry into the internal representation needed for collision detection. It involves splitting up the mesh into areas or \"zones\" for faster lookup. This only happens when the mesh actively changes and when first opening the Maya scene, and won't affect playback speed. Automatic Mesh Islands Ragdoll needs \"convex\" meshes for anything that moves. What is a convex mesh? Think of it like a shrink-wrapped version of your mesh. In 2D, it might look something like this. Notice how the points in the middle are excluded? This is an optimal shape for collision detection, as you can draw a straight line from anywhere in the world and know that if it ever hits this shape, it hits it in only 1 spot. In the previous release, \"Mesh Islands\" were introduced to turn each separate polygonal island into its own convex hull and glued together as one complex shape. With that, you have a great deal of control over the final collision shape Multi-cut settings Tick the Extract Faces box, and zero out those values to get Maya to perform an actual split in the geometry as you cut. Otherwise, it will only insert new edge-loops and not actually create two separate meshes. It did, however, mean that you had to take the time to manually slice up the mesh, which may not always be feasible. This release introduces an automatic method of slicing up a given mesh, into a close approximation of the original mesh. Attributes There are a number of parameters to tune when generating your convex hulls, here's what they mean. Attribute Description Resolution The number of \"voxels\" to generate from a given volume; the greater the number the more accurate the resulting representation. At the expense of time. Values between 100-1000 are normally sufficient. Concavity The maximum allowed different in angle across the surface of the resulting meshes. It might be thought of as \"roundness\". Symmetry Bias Slices are made either horizontally and vertically, or radially. This value controls how much to favour the former. Revolute Bias And this value controls how much to favour the latter Min Volume Ignore computed volumes that are smaller than this. It can help reduce the number of very tiny meshes. Max Convex Hulls How many separate meshes to make. This will depend on the complexity of your mesh, but generally the lower the better. Plane Downsampling Performance related, lower values take longer Hull Downsampling Also perforamnce related, lower values take longer Fill Mode Various ways to deal with geometry that isn't a closed volume. A sphere for example is a closed volume, whereas a plane is not. Approximate Hull Performance related, faster when ticked. Project Hull Vertices See what the generated meshes look like before they are \"shrink-wrapped\" back onto your model. These give you a good sense of how large the voxel resolution is. Complexity Over time, as we learn more about which parameters work best in the most general case, I'd like to reduce the number of attributes here. Ideally we would only have a Quality attribute with Low , Medium and High settings. Performance It's slow. The process of automatically slicing your geometry is not real-time, it can take up to a few seconds or more. On the upside, it only ever happens when the mesh changes and does not affect playback performance. Here are some timings for the meshes in the below simulation. Object Pieces Time rMarker_Barrels 30 1.9 s rMarker_Ceratopsia 16 0.7 s rMarker_FingerPlates 64 6.1 s rMarker_LeaflessTree 183 6.3 s rMarker_bull 16 0.8 s rMarker_fish 16 0.7 s rMarker_hand_basemesh 16 0.3 s rMarker_horse 16 0.9 s rMarker_humanBody 32 2.9 s rMarker_jetFighter 16 0.5 s rMarker_polySurface9 16 1.6 s rMarker_shirt 16 0.9 s Faster performance is on the map This method is new to us, and we expect to find faster - ideally real-time - alternatives to this in the future. Soft Joints To balance out the talk of complex but hard geometry, let's talk about \"soft joints\". Once I set Translate Motion = Soft and the feet hits the ground, notice how: The spine is compressed The legs are compressed The arms are extended Here's a more extreme example. General Purpose We're calling it \"soft joints\" when in reality this is Pose Stiffness but for translation rather than rotation. Which means you could use it for tentacles and other appendages that depend on not just rotating limbs but squishy and compressed limbs. Potentially stretchy limbs and spines too? We haven't yet explored this fully, so take it for a spin and let us know what you come up with. \ud83d\ude0a Caveat When stiffness goes too low, limbs detach. This is unintended behaviour and will be addressed in a future release. Proper breakable constraints are on the map, but this isn't it. So use with caution, and limit it to create softness between your limbs. Forum The forum has gotten a face-lift! This will henceforth be where tutorials and showcases appear, along with notifications for new releases! So sign up, subscribe to the News category to receive notifications when things happen in Ragdoll-land! https://forums.ragdolldynamics.com/ Subscriptions Out of beta and available to all. If you need a more low-cost but commercial introduction to Ragdoll in your studio, then this is for you. https://ragdolldynamics.com/pricing-commercial Group API You can now make groups via the API. from maya import cmds from ragdoll import api solver = api . createSolver () ground = api . createGround ( solver ) group = api . createGroup ( solver ) sphere , _ = cmds . polySphere () cmds . move ( 0 , 10 , 0 ) marker = api . assignMarker ( sphere , group ) cmds . evalDeferred ( cmds . play ) The assignMarker command has also been simplified and does not longer implicitly create a group. Quality of Life A few more things to make your day that much more bright. Merge Solvers You can now merge two solvers together, move markers from one solver to another and extract markers into a new solver. Extract Markers Sometimes, you want some of your markers to be part of a separate solvers. Move to Solver Rather than merge two solvers in its entirety, move specific markers from one solver to another. Manipulator with Multiple Solvers The Manipulator can now be used in scenes with two or more solvers in them! Manipulator Selection You can now use the Manipulator to select both the Marker and Maya node, such that attributes can be edited in the Channel Box. Manipulator Fit-to-view Using the manipulator via the Ragdoll menu enabled you to also benefit from the F key, to fit your selection to the current camera. But if a Marker or Group was selected and editable in the Channel Box, that no longer worked. Because under the hood, what you were really fitting in view was the solver shape node. This has now been fixed such that you can fit any selected Marker, regardless of whether the solver shape node is selected or not! Select During Playback The Manipulator can now be used to select Markers during playback. Caveat Selection is based on the current simulated state and doesn't understand rewind. To fix this, step at least 1 frame forward whenever you attempt to select, to ensure the selection and simulation is staying in sync. This will be addressed in a future release. Reset Shape Whenever you assign a Marker, a default shape is computed based on your selection and available geometry or NURBS curves. Refit Assignment Likewise, when you branched off into a tree-like structure for your markers, you could easily end up with something like this. This has now been addressed, whereby the marker which forms a fork now being reset automatically. Licence Conservation Applies to This feature only applies to Floating Licence customers. In the previous release, a licence was leased on plug-in load. The problem was that, sometimes, an artist merely opens a scene with Ragdoll in it. Maya will determine that this file requires the Ragdoll plug-in to be loaded, and loads it. Upon load, Ragdoll would go ahead and check out a licence. But this artist doesn't necessarily want to interact with Ragdoll, it could have been a texture artist opening up an animator's scene, or someone rendering it. This release introduces \"licence conservation\" which only tries to lease a licence upon a simulation taking place. That means a lease is not made on plug-in load, nor on scene open. If a solver is hidden from view, nor does it take place on playback start. Only once simulation visibly begins is a lease requested, helping you save those precious seats for the artists that need it most. Markers are still rendered in the viewport on the start frame for everyone, without a lease. The Solver is automatically hidden upon failure to lease a licence, pausing any further requests until it is made visible again. Minor Releases Inbetween this release and the previous release there were a few minor releases made. Fix crash on fit-to-view Fix crash on replaced mesh with 0 vertices Hide prototype world and local attributes on the rdGroup node The Request Lease button in the Ragdoll UI now actually works Legacy The menu items for the old Legacy interface to Ragdoll Dynamics has now been removed. Scenes created with this interface will still open, so this is your last chance to save your work and transition to the current Marker-based workflow.","title":"2022.02.28"},{"location":"releases/2022.02.28/#showcase","text":"Before we get into the new features of this release, let's have a look back at some highlights of the week. For the Love of Ragdoll Animation by Kevin Taylor, model by Shaun Keenan. On LinkedIn Dragon Setup Livestream The dragon from the latest livestream last Friday! https://www.youtube.com/watch?v=xHgFIvgg7O4 Chewsday A little experiment with worldspace rotation stiffness. Rhino Workout Soft joints for some belly-jiggle. Rhino Walk Nice self-walking rhino. Self Walking Manikin Same trick, different character. :) Soft Joints Jason experimenting with the new Soft Joints feature. Facial Animation Getting some nice secondary motion out of moving the head and jaw around!","title":"Showcase"},{"location":"releases/2022.02.28/#environment","text":"Ragdoll now supports static environments; meaning environments that cannot move or deform, but allow for normal polygonal geometry without the need for a simplified \"convex hull\". As you might expect, this works well for environments like terrain and other complex geometry that is otherwise hard to turn into a rounded mesh.","title":"Environment"},{"location":"releases/2022.02.28/#performance","text":"It's fast. Normal shapes are limited in how complex they can get, and as such you never really run into a situation where the shape noticeably affects performance. Triangle meshes are different; they can be of any complexity. Up to millions of polygons and beyond. So it falls upon you to decide where to make the performance/quality tradeoff! Vertex Count Cooking Time Run-time performance 400 0.39 ms 685 fps 8'000 3.51 ms 599 fps 16'000 14.3 ms 594 fps 64'000 61.5 ms 327 fps 256'000 287.7 ms 40 fps 1'000'000 1490 ms 2 fps What is cooking time? The time it takes for Ragdoll to convert your polygonal geometry into the internal representation needed for collision detection. It involves splitting up the mesh into areas or \"zones\" for faster lookup. This only happens when the mesh actively changes and when first opening the Maya scene, and won't affect playback speed.","title":"Performance"},{"location":"releases/2022.02.28/#automatic-mesh-islands","text":"Ragdoll needs \"convex\" meshes for anything that moves. What is a convex mesh? Think of it like a shrink-wrapped version of your mesh. In 2D, it might look something like this. Notice how the points in the middle are excluded? This is an optimal shape for collision detection, as you can draw a straight line from anywhere in the world and know that if it ever hits this shape, it hits it in only 1 spot. In the previous release, \"Mesh Islands\" were introduced to turn each separate polygonal island into its own convex hull and glued together as one complex shape. With that, you have a great deal of control over the final collision shape Multi-cut settings Tick the Extract Faces box, and zero out those values to get Maya to perform an actual split in the geometry as you cut. Otherwise, it will only insert new edge-loops and not actually create two separate meshes. It did, however, mean that you had to take the time to manually slice up the mesh, which may not always be feasible. This release introduces an automatic method of slicing up a given mesh, into a close approximation of the original mesh.","title":"Automatic Mesh Islands"},{"location":"releases/2022.02.28/#attributes","text":"There are a number of parameters to tune when generating your convex hulls, here's what they mean. Attribute Description Resolution The number of \"voxels\" to generate from a given volume; the greater the number the more accurate the resulting representation. At the expense of time. Values between 100-1000 are normally sufficient. Concavity The maximum allowed different in angle across the surface of the resulting meshes. It might be thought of as \"roundness\". Symmetry Bias Slices are made either horizontally and vertically, or radially. This value controls how much to favour the former. Revolute Bias And this value controls how much to favour the latter Min Volume Ignore computed volumes that are smaller than this. It can help reduce the number of very tiny meshes. Max Convex Hulls How many separate meshes to make. This will depend on the complexity of your mesh, but generally the lower the better. Plane Downsampling Performance related, lower values take longer Hull Downsampling Also perforamnce related, lower values take longer Fill Mode Various ways to deal with geometry that isn't a closed volume. A sphere for example is a closed volume, whereas a plane is not. Approximate Hull Performance related, faster when ticked. Project Hull Vertices See what the generated meshes look like before they are \"shrink-wrapped\" back onto your model. These give you a good sense of how large the voxel resolution is. Complexity Over time, as we learn more about which parameters work best in the most general case, I'd like to reduce the number of attributes here. Ideally we would only have a Quality attribute with Low , Medium and High settings.","title":"Attributes"},{"location":"releases/2022.02.28/#performance_1","text":"It's slow. The process of automatically slicing your geometry is not real-time, it can take up to a few seconds or more. On the upside, it only ever happens when the mesh changes and does not affect playback performance. Here are some timings for the meshes in the below simulation. Object Pieces Time rMarker_Barrels 30 1.9 s rMarker_Ceratopsia 16 0.7 s rMarker_FingerPlates 64 6.1 s rMarker_LeaflessTree 183 6.3 s rMarker_bull 16 0.8 s rMarker_fish 16 0.7 s rMarker_hand_basemesh 16 0.3 s rMarker_horse 16 0.9 s rMarker_humanBody 32 2.9 s rMarker_jetFighter 16 0.5 s rMarker_polySurface9 16 1.6 s rMarker_shirt 16 0.9 s Faster performance is on the map This method is new to us, and we expect to find faster - ideally real-time - alternatives to this in the future.","title":"Performance"},{"location":"releases/2022.02.28/#soft-joints","text":"To balance out the talk of complex but hard geometry, let's talk about \"soft joints\". Once I set Translate Motion = Soft and the feet hits the ground, notice how: The spine is compressed The legs are compressed The arms are extended Here's a more extreme example.","title":"Soft Joints"},{"location":"releases/2022.02.28/#general-purpose","text":"We're calling it \"soft joints\" when in reality this is Pose Stiffness but for translation rather than rotation. Which means you could use it for tentacles and other appendages that depend on not just rotating limbs but squishy and compressed limbs. Potentially stretchy limbs and spines too? We haven't yet explored this fully, so take it for a spin and let us know what you come up with. \ud83d\ude0a","title":"General Purpose"},{"location":"releases/2022.02.28/#caveat","text":"When stiffness goes too low, limbs detach. This is unintended behaviour and will be addressed in a future release. Proper breakable constraints are on the map, but this isn't it. So use with caution, and limit it to create softness between your limbs.","title":"Caveat"},{"location":"releases/2022.02.28/#forum","text":"The forum has gotten a face-lift! This will henceforth be where tutorials and showcases appear, along with notifications for new releases! So sign up, subscribe to the News category to receive notifications when things happen in Ragdoll-land! https://forums.ragdolldynamics.com/","title":"Forum"},{"location":"releases/2022.02.28/#subscriptions","text":"Out of beta and available to all. If you need a more low-cost but commercial introduction to Ragdoll in your studio, then this is for you. https://ragdolldynamics.com/pricing-commercial","title":"Subscriptions"},{"location":"releases/2022.02.28/#group-api","text":"You can now make groups via the API. from maya import cmds from ragdoll import api solver = api . createSolver () ground = api . createGround ( solver ) group = api . createGroup ( solver ) sphere , _ = cmds . polySphere () cmds . move ( 0 , 10 , 0 ) marker = api . assignMarker ( sphere , group ) cmds . evalDeferred ( cmds . play ) The assignMarker command has also been simplified and does not longer implicitly create a group.","title":"Group API"},{"location":"releases/2022.02.28/#quality-of-life","text":"A few more things to make your day that much more bright.","title":"Quality of Life"},{"location":"releases/2022.02.28/#merge-solvers","text":"You can now merge two solvers together, move markers from one solver to another and extract markers into a new solver.","title":"Merge Solvers"},{"location":"releases/2022.02.28/#extract-markers","text":"Sometimes, you want some of your markers to be part of a separate solvers.","title":"Extract Markers"},{"location":"releases/2022.02.28/#move-to-solver","text":"Rather than merge two solvers in its entirety, move specific markers from one solver to another.","title":"Move to Solver"},{"location":"releases/2022.02.28/#manipulator-with-multiple-solvers","text":"The Manipulator can now be used in scenes with two or more solvers in them!","title":"Manipulator with Multiple Solvers"},{"location":"releases/2022.02.28/#manipulator-selection","text":"You can now use the Manipulator to select both the Marker and Maya node, such that attributes can be edited in the Channel Box.","title":"Manipulator Selection"},{"location":"releases/2022.02.28/#manipulator-fit-to-view","text":"Using the manipulator via the Ragdoll menu enabled you to also benefit from the F key, to fit your selection to the current camera. But if a Marker or Group was selected and editable in the Channel Box, that no longer worked. Because under the hood, what you were really fitting in view was the solver shape node. This has now been fixed such that you can fit any selected Marker, regardless of whether the solver shape node is selected or not!","title":"Manipulator Fit-to-view"},{"location":"releases/2022.02.28/#select-during-playback","text":"The Manipulator can now be used to select Markers during playback. Caveat Selection is based on the current simulated state and doesn't understand rewind. To fix this, step at least 1 frame forward whenever you attempt to select, to ensure the selection and simulation is staying in sync. This will be addressed in a future release.","title":"Select During Playback"},{"location":"releases/2022.02.28/#reset-shape","text":"Whenever you assign a Marker, a default shape is computed based on your selection and available geometry or NURBS curves.","title":"Reset Shape"},{"location":"releases/2022.02.28/#refit-assignment","text":"Likewise, when you branched off into a tree-like structure for your markers, you could easily end up with something like this. This has now been addressed, whereby the marker which forms a fork now being reset automatically.","title":"Refit Assignment"},{"location":"releases/2022.02.28/#licence-conservation","text":"Applies to This feature only applies to Floating Licence customers. In the previous release, a licence was leased on plug-in load. The problem was that, sometimes, an artist merely opens a scene with Ragdoll in it. Maya will determine that this file requires the Ragdoll plug-in to be loaded, and loads it. Upon load, Ragdoll would go ahead and check out a licence. But this artist doesn't necessarily want to interact with Ragdoll, it could have been a texture artist opening up an animator's scene, or someone rendering it. This release introduces \"licence conservation\" which only tries to lease a licence upon a simulation taking place. That means a lease is not made on plug-in load, nor on scene open. If a solver is hidden from view, nor does it take place on playback start. Only once simulation visibly begins is a lease requested, helping you save those precious seats for the artists that need it most. Markers are still rendered in the viewport on the start frame for everyone, without a lease. The Solver is automatically hidden upon failure to lease a licence, pausing any further requests until it is made visible again.","title":"Licence Conservation"},{"location":"releases/2022.02.28/#minor-releases","text":"Inbetween this release and the previous release there were a few minor releases made. Fix crash on fit-to-view Fix crash on replaced mesh with 0 vertices Hide prototype world and local attributes on the rdGroup node The Request Lease button in the Ragdoll UI now actually works","title":"Minor Releases"},{"location":"releases/2022.02.28/#legacy","text":"The menu items for the old Legacy interface to Ragdoll Dynamics has now been removed. Scenes created with this interface will still open, so this is your last chance to save your work and transition to the current Marker-based workflow.","title":"Legacy"},{"location":"releases/2022.03.14/","text":"Highlight for this release is Quality of Life! IMPROVED Manipulator and Multiple Solvers Choose which solver to manipulate, with this new UI IMPROVED Import Symmetry Symmetry on already-animated characters! IMPROVED Manipulator Deselect A little more convenient IMPROVED Clean Abort on Record Less clutter when in a rush IMPROVED Coloured Limits Edit limits with more confidence IMPROVED Auto Cache A perhaps more intuitive default? IMPROVED On-Location Pin Pin now appears where the simulation is, rather than the animation. IMPROVED Limit on Select Now limits are less obstructing to look at FIXED Nested Namespaces and Import Complexity defeated FIXED Animated Pose Space Blunder from the previous release FIXED Fix Unlink Solver Now it actually works FIXED Translate XYZ The world axes are local no more FIXED Export without .rag Minor hiccup, now burped FIXED Euler Filter Actually working the way you'd expect FIXED 0 Density Catch-all for density going too low Showcase Let's catch up on a few highlights over the past 2 weeks. Instict Andrei got Ragdoll introduced to this beautiful thing. https://forums.ragdolldynamics.com/t/instinct/154 Some nice stills. Rhinos Jason's working on a new tutorial for how to make self-walking quadrupeds. Work in Progress On LinkedIn Quality of Life Let's have some more, shall we? \ud83e\udd73 Manipulator and Multiple Solvers The Manipulator operates on 1 solver at a time. When there are two or more manipulator in the scene, Ragdoll will now be more kind and smart about which one you mean. Select any.. Assigned control Retargeted control Marker Group Solver Constraint ..and the manipulator will figure out which solver you mean. When unsure, it will ask you to clarify. Selection Highlight Each marker have 3 possible nodes you can select. The marker itself, a DG node The source transform, the control you originally assigned The destination transform(s), where simulation is recorded onto Selecting the marker and source transforms gave you a handy selection highlighting in the viewport, confirming what you had selected. But so far, selecting a destination transform did no such thing. Until now! Notice how this also helps you detect whether something has a target at all, like the upper legs here. These remain unrecorded, as they are connected to the hip and driven by IK. Contact Visualisation You can now visualise when and where contacts occur. This can help spot self-collisions too! Import Symmetry Symmetry is now preserved on import. For any character authored in a symmetrical pose, the Ragdoll Manipulator would let you operate on this character on both sides at once. But until now, this symmetry was lost if at any point an import was made on a character was not symmetrical, such as an animated character. This changes today! Manipulator Deselect With nothing selected, you now have access to the Solver in the Channel Box. Clean Abort on Record Almost rhymes. If recording takes too long and you hit the ESC key to cancel, Ragdoll no longer leaves a mess behind. It's clean! Coloured Limits The manipulator now colors limits by their axis. Where X is red, Y is green and Z is blue; just as you'd expect. Auto Cache There is now an option to disable auto cache upon completed record. This will let the simulation continue running after recording, using your newly recorded controls as input. On-Location Pin Whenever you make a new Pin Constraint, it would appear at the location of your animation. But now, it will appear wherever the simulated version of your animation is. Limit on Select Limits are now only visible when selected, making things a little less messy in the viewport. Fixes Some house cleaning of minor things that could sometimes trip you up. Nested Namespaces and Import Ragdoll is now happy to import physics onto any number of namespaces. Animated Pose Space The previous release broke any transition between Local and World , this has now been fixed. Translate XYZ When you want a marker to follow your animation in worldspace in all but one or two axes, you can use World Pose Translation . However, in the previous release, the axes were aligned with the control rather than the world. This has now been fixed. Fix Unlink Solver Linking two solvers is a non-destructive method of getting multiple characters to interact in the same scene. As it happens, you haven't been able to unlink until now. Export without .rag As it happens, the Import Options will only show you files that have a .rag extension. But! The Export Options would permit export of files without this extension. As a result, it could appear as though nothing was exported. :( This has now been fixed. Euler Filter To keep gimbal locks from happening in your recorded simulation, an \"Euler Filter\" could be automatically applied. This hasn't been the case so far, but has now been fixed. 0 Density Giving markers a density of 0 would make it infinitely light, or infinitely heavy depending on your perspective. Such things does not exist in the real world and cannot be simulated. Ragdoll will now protect you against this.","title":"2022.03.14"},{"location":"releases/2022.03.14/#showcase","text":"Let's catch up on a few highlights over the past 2 weeks. Instict Andrei got Ragdoll introduced to this beautiful thing. https://forums.ragdolldynamics.com/t/instinct/154 Some nice stills. Rhinos Jason's working on a new tutorial for how to make self-walking quadrupeds. Work in Progress On LinkedIn","title":"Showcase"},{"location":"releases/2022.03.14/#quality-of-life","text":"Let's have some more, shall we? \ud83e\udd73","title":"Quality of Life"},{"location":"releases/2022.03.14/#manipulator-and-multiple-solvers","text":"The Manipulator operates on 1 solver at a time. When there are two or more manipulator in the scene, Ragdoll will now be more kind and smart about which one you mean. Select any.. Assigned control Retargeted control Marker Group Solver Constraint ..and the manipulator will figure out which solver you mean. When unsure, it will ask you to clarify.","title":"Manipulator and Multiple Solvers"},{"location":"releases/2022.03.14/#selection-highlight","text":"Each marker have 3 possible nodes you can select. The marker itself, a DG node The source transform, the control you originally assigned The destination transform(s), where simulation is recorded onto Selecting the marker and source transforms gave you a handy selection highlighting in the viewport, confirming what you had selected. But so far, selecting a destination transform did no such thing. Until now! Notice how this also helps you detect whether something has a target at all, like the upper legs here. These remain unrecorded, as they are connected to the hip and driven by IK.","title":"Selection Highlight"},{"location":"releases/2022.03.14/#contact-visualisation","text":"You can now visualise when and where contacts occur. This can help spot self-collisions too!","title":"Contact Visualisation"},{"location":"releases/2022.03.14/#import-symmetry","text":"Symmetry is now preserved on import. For any character authored in a symmetrical pose, the Ragdoll Manipulator would let you operate on this character on both sides at once. But until now, this symmetry was lost if at any point an import was made on a character was not symmetrical, such as an animated character. This changes today!","title":"Import Symmetry"},{"location":"releases/2022.03.14/#manipulator-deselect","text":"With nothing selected, you now have access to the Solver in the Channel Box.","title":"Manipulator Deselect"},{"location":"releases/2022.03.14/#clean-abort-on-record","text":"Almost rhymes. If recording takes too long and you hit the ESC key to cancel, Ragdoll no longer leaves a mess behind. It's clean!","title":"Clean Abort on Record"},{"location":"releases/2022.03.14/#coloured-limits","text":"The manipulator now colors limits by their axis. Where X is red, Y is green and Z is blue; just as you'd expect.","title":"Coloured Limits"},{"location":"releases/2022.03.14/#auto-cache","text":"There is now an option to disable auto cache upon completed record. This will let the simulation continue running after recording, using your newly recorded controls as input.","title":"Auto Cache"},{"location":"releases/2022.03.14/#on-location-pin","text":"Whenever you make a new Pin Constraint, it would appear at the location of your animation. But now, it will appear wherever the simulated version of your animation is.","title":"On-Location Pin"},{"location":"releases/2022.03.14/#limit-on-select","text":"Limits are now only visible when selected, making things a little less messy in the viewport.","title":"Limit on Select"},{"location":"releases/2022.03.14/#fixes","text":"Some house cleaning of minor things that could sometimes trip you up.","title":"Fixes"},{"location":"releases/2022.03.14/#nested-namespaces-and-import","text":"Ragdoll is now happy to import physics onto any number of namespaces.","title":"Nested Namespaces and Import"},{"location":"releases/2022.03.14/#animated-pose-space","text":"The previous release broke any transition between Local and World , this has now been fixed.","title":"Animated Pose Space"},{"location":"releases/2022.03.14/#translate-xyz","text":"When you want a marker to follow your animation in worldspace in all but one or two axes, you can use World Pose Translation . However, in the previous release, the axes were aligned with the control rather than the world. This has now been fixed.","title":"Translate XYZ"},{"location":"releases/2022.03.14/#fix-unlink-solver","text":"Linking two solvers is a non-destructive method of getting multiple characters to interact in the same scene. As it happens, you haven't been able to unlink until now.","title":"Fix Unlink Solver"},{"location":"releases/2022.03.14/#export-without-rag","text":"As it happens, the Import Options will only show you files that have a .rag extension. But! The Export Options would permit export of files without this extension. As a result, it could appear as though nothing was exported. :( This has now been fixed.","title":"Export without .rag"},{"location":"releases/2022.03.14/#euler-filter","text":"To keep gimbal locks from happening in your recorded simulation, an \"Euler Filter\" could be automatically applied. This hasn't been the case so far, but has now been fixed.","title":"Euler Filter"},{"location":"releases/2022.03.14/#0-density","text":"Giving markers a density of 0 would make it infinitely light, or infinitely heavy depending on your perspective. Such things does not exist in the real world and cannot be simulated. Ragdoll will now protect you against this.","title":"0 Density"},{"location":"tutorials/animation_to_physics/","text":"","title":"Animation to physics"},{"location":"tutorials/manikin/","text":"Manikin \"Make your own motion reference\" In this tutorial, we will setup a human-like character for use as reference or constraint target to your rig. You will be able to pose and position this Manikin like you would a real Manikin, and drop it from various heights and onto various obstacles to produce realistic poses as it falls. Something the animator can import and throw around for reference on how it would look like. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to apply markers onto rig controls \u2714\ufe0f How to tune the collision shapes of the markers \u2714\ufe0f How to record your simulation back onto the rig controls Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Spelling There are two ways to spell \"Manikin\", this tutorial is based on this term here. https://www.healthysimulation.com/Manikin/ Bring Your Own Rig Follow this tutorial either using our provided Manikin rig, or your own character. It can have any number of limbs. Download Manikin Download Final Scene Motivation Why should we even bother simulating a character? Finding motion reference is one of the most important activities for any animator. And yet I can safely challenge you to find reference for perhaps the most common motion in all blockbuster movies today, something that is either impossible or dangerous for actors or animators alike. Or how about reference of someone simply falling over, perhaps from heat stroke or staring into the sun. This is, after all, one of the major reasons for pursuing computer graphics in storytelling rather than real people. Animators bring life to characters, but of equal challenge is that of lifelessness . Of natural and realistic motion without someone behind the wheel. Be it getting hit or shot , blasted or thrown , animating lifelessnes is a enough to challenge even the most senior of animators. As you will find, there is a lot more we can do once our motion reference is in 3D, on our actual character rig witin Maya and infinitely customisable . As opposed to some video on the internet. Setup Create a new reference of your chosen character rig or download this Manikin rig to get started. Play around with the controls to get a feel for what we're working with. This character is entirely FK which will make simulating it straightforward. Dynamics The stage is set, now let's apply physics. Torso Let's start with the Torso. Select hip_ctl Shift select torso_ctl Shift select head_ctl Run Assign and Connect This will produce our first Group , which is a collection of connected Markers . New Concept Group The rdGroup node contains attributes that affect all contained markers. It's where you'd edit the overall look and feel of your character, like how stiff it should be and whether or not body parts should collide with each other. Each Marker can either inherit or otherwise override these values. Left Arm Next we will continue from the torso_ctl and out into the arms. Select the torso_ctl Shift select L_clavicle_ctl Shift select L_upperArm_ctl Shift select L_lowerArm_ctl Shift select L_hand_ctl Run Assign and Connect Is the order important? Yes, the order in which you select will determine how the markers are connected . Your first selection is extra important, as it determines whether to start a new group, like for the hip_ctl , or to add to an existing group, like the torso_ctl . In this case, we would very much like our arm to be connected to the torso. Can I skip the clavicles? Yes, if you have extra controls - such as twist or bend - you can skip these if you don't care to simulate them. Simply skip over them as you select, from torso_ctl directly to L_upperarm_ctl . Right Arm Now repeat the above process for the other arm. Legs Now let's continue down the hips and into the legs. Select the hip_ctl Shift select L_thigh_ctl Shift select L_knee_ctl Shift select L_foot_ctl Run Assign and Connect We will address those long feet shortly. \ud83d\udc43 Drop Test That's enough setup, let's drop him! Select hip_ctl Set Behaviour = Dynamic Drop the Manikin a few times New Concept Behaviour Each Marker has a \"behaviour\", which tells Ragdoll it should interpret the control it has been assigned. Should it fall with gravity? Should it try and match the pose? Should it remain fully animated, even in simulation? The default behaviour for Assign and Connect is to give the first selection - the \"root\" - a Kinematic behaviour. What does Kinematic mean? Kinematic means \"copy the animation into simulation and make no changes to it\" By instead setting this to Dynamic , then Ragdoll will only use the animation for the starting position and orientation of the simulation. Inherit Alternatively, you can set it to Inherit to have it inherit the value of the rGroup node that was created for the whole character. Tuning Next let's address the elephant in the room; the shapes. They look aweful. Volumes The shape of each collider affects your simulation in 2 ways. Contact Points Rotation Mass The contact point can be important if your character interacts with an environment or another character. Like in this case where the feet are incorrectly colliding with the ground because of a bad shape. That's not always the case though, sometimes you just want overlapping motion without contacts in which case the shapes won't matter. They do however also affect their resistance to rotation. Consider this. Here, we rotate the exact same shapes, the exact same amount in the exact same amount of time. And yet they respond differently. This shape has vastly different dimensions in the X, Y and Z directions, resulting in a different rotation mass for each one. As a result, the effort required to rotate it in each axis differs too. In practice, you'll find this for just about any limb on a character, which is typically longer in one axis. For our Manikin, this is especially true for the default clavicle shapes. Override Rotate Mass In some cases, you have a shape but want it to act like a different shape. Rotate Mass is very similar to normal Mass , except in 3 dimensions. Where the position of an object is affected equal in X, Y and Z directions, rotations have 3 separate masses. Shapes With this in mind, let's tune some shapes. Run Manipulator from the Ragdoll menu Alternatively Select a rMarker node in the Channel Box, or the rGroup node in your Outliner, and hit the T key on your keyboard. You can also select the shape of the rSolver node. This brings up the Manipulator interface, where you can manipulate shapes using mouse gestures. Great, now let's turn those hands and feet into boxes. Translate, Rotate and Scale Notice I'm using the.. Middle-Mouse Button to Translate CTRL + Middle-Mouse Button to Rotate CTRL + Left-Mouse Button to Scale The help text screen-right will help you remember these. Symmetry Also notice the edits are symmetrical; even when they don't start out that way like the feet! Recording That's all there is for setting up your character rig for simulation! Let's now transfer the simulation back onto the rig. Run Record Simulation Enjoy Start Again The recorded simulation ends up on an Animation Layer , and is also Cached . To start over, delete this layer and disable the cache. Next Steps In the next tutorial, we'll take this a bit further. As you play around with the Pose Stiffness on either the rGroup or individual rMarker nodes, you'll find some limbs start to misbehave. Especially the knees and elbows, that normally won't allow rotations past a certain angle in a real human (or Manikin for that matter!). That isn't the case here, because we've left out a critical part of any complete ragdoll. Full Ragdoll See you there!","title":"Manikin"},{"location":"tutorials/manikin/#manikin","text":"\"Make your own motion reference\" In this tutorial, we will setup a human-like character for use as reference or constraint target to your rig. You will be able to pose and position this Manikin like you would a real Manikin, and drop it from various heights and onto various obstacles to produce realistic poses as it falls. Something the animator can import and throw around for reference on how it would look like. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to apply markers onto rig controls \u2714\ufe0f How to tune the collision shapes of the markers \u2714\ufe0f How to record your simulation back onto the rig controls Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Spelling There are two ways to spell \"Manikin\", this tutorial is based on this term here. https://www.healthysimulation.com/Manikin/","title":"Manikin"},{"location":"tutorials/manikin/#bring-your-own-rig","text":"Follow this tutorial either using our provided Manikin rig, or your own character. It can have any number of limbs. Download Manikin Download Final Scene","title":"Bring Your Own Rig"},{"location":"tutorials/manikin/#motivation","text":"Why should we even bother simulating a character? Finding motion reference is one of the most important activities for any animator. And yet I can safely challenge you to find reference for perhaps the most common motion in all blockbuster movies today, something that is either impossible or dangerous for actors or animators alike. Or how about reference of someone simply falling over, perhaps from heat stroke or staring into the sun. This is, after all, one of the major reasons for pursuing computer graphics in storytelling rather than real people. Animators bring life to characters, but of equal challenge is that of lifelessness . Of natural and realistic motion without someone behind the wheel. Be it getting hit or shot , blasted or thrown , animating lifelessnes is a enough to challenge even the most senior of animators. As you will find, there is a lot more we can do once our motion reference is in 3D, on our actual character rig witin Maya and infinitely customisable . As opposed to some video on the internet.","title":"Motivation"},{"location":"tutorials/manikin/#setup","text":"Create a new reference of your chosen character rig or download this Manikin rig to get started. Play around with the controls to get a feel for what we're working with. This character is entirely FK which will make simulating it straightforward.","title":"Setup"},{"location":"tutorials/manikin/#dynamics","text":"The stage is set, now let's apply physics.","title":"Dynamics"},{"location":"tutorials/manikin/#torso","text":"Let's start with the Torso. Select hip_ctl Shift select torso_ctl Shift select head_ctl Run Assign and Connect This will produce our first Group , which is a collection of connected Markers . New Concept Group The rdGroup node contains attributes that affect all contained markers. It's where you'd edit the overall look and feel of your character, like how stiff it should be and whether or not body parts should collide with each other. Each Marker can either inherit or otherwise override these values.","title":"Torso"},{"location":"tutorials/manikin/#left-arm","text":"Next we will continue from the torso_ctl and out into the arms. Select the torso_ctl Shift select L_clavicle_ctl Shift select L_upperArm_ctl Shift select L_lowerArm_ctl Shift select L_hand_ctl Run Assign and Connect Is the order important? Yes, the order in which you select will determine how the markers are connected . Your first selection is extra important, as it determines whether to start a new group, like for the hip_ctl , or to add to an existing group, like the torso_ctl . In this case, we would very much like our arm to be connected to the torso. Can I skip the clavicles? Yes, if you have extra controls - such as twist or bend - you can skip these if you don't care to simulate them. Simply skip over them as you select, from torso_ctl directly to L_upperarm_ctl .","title":"Left Arm"},{"location":"tutorials/manikin/#right-arm","text":"Now repeat the above process for the other arm.","title":"Right Arm"},{"location":"tutorials/manikin/#legs","text":"Now let's continue down the hips and into the legs. Select the hip_ctl Shift select L_thigh_ctl Shift select L_knee_ctl Shift select L_foot_ctl Run Assign and Connect We will address those long feet shortly. \ud83d\udc43","title":"Legs"},{"location":"tutorials/manikin/#drop-test","text":"That's enough setup, let's drop him! Select hip_ctl Set Behaviour = Dynamic Drop the Manikin a few times New Concept Behaviour Each Marker has a \"behaviour\", which tells Ragdoll it should interpret the control it has been assigned. Should it fall with gravity? Should it try and match the pose? Should it remain fully animated, even in simulation? The default behaviour for Assign and Connect is to give the first selection - the \"root\" - a Kinematic behaviour. What does Kinematic mean? Kinematic means \"copy the animation into simulation and make no changes to it\" By instead setting this to Dynamic , then Ragdoll will only use the animation for the starting position and orientation of the simulation. Inherit Alternatively, you can set it to Inherit to have it inherit the value of the rGroup node that was created for the whole character.","title":"Drop Test"},{"location":"tutorials/manikin/#tuning","text":"Next let's address the elephant in the room; the shapes. They look aweful.","title":"Tuning"},{"location":"tutorials/manikin/#volumes","text":"The shape of each collider affects your simulation in 2 ways. Contact Points Rotation Mass The contact point can be important if your character interacts with an environment or another character. Like in this case where the feet are incorrectly colliding with the ground because of a bad shape. That's not always the case though, sometimes you just want overlapping motion without contacts in which case the shapes won't matter. They do however also affect their resistance to rotation. Consider this. Here, we rotate the exact same shapes, the exact same amount in the exact same amount of time. And yet they respond differently. This shape has vastly different dimensions in the X, Y and Z directions, resulting in a different rotation mass for each one. As a result, the effort required to rotate it in each axis differs too. In practice, you'll find this for just about any limb on a character, which is typically longer in one axis. For our Manikin, this is especially true for the default clavicle shapes. Override Rotate Mass In some cases, you have a shape but want it to act like a different shape. Rotate Mass is very similar to normal Mass , except in 3 dimensions. Where the position of an object is affected equal in X, Y and Z directions, rotations have 3 separate masses.","title":"Volumes"},{"location":"tutorials/manikin/#shapes","text":"With this in mind, let's tune some shapes. Run Manipulator from the Ragdoll menu Alternatively Select a rMarker node in the Channel Box, or the rGroup node in your Outliner, and hit the T key on your keyboard. You can also select the shape of the rSolver node. This brings up the Manipulator interface, where you can manipulate shapes using mouse gestures. Great, now let's turn those hands and feet into boxes. Translate, Rotate and Scale Notice I'm using the.. Middle-Mouse Button to Translate CTRL + Middle-Mouse Button to Rotate CTRL + Left-Mouse Button to Scale The help text screen-right will help you remember these. Symmetry Also notice the edits are symmetrical; even when they don't start out that way like the feet!","title":"Shapes"},{"location":"tutorials/manikin/#recording","text":"That's all there is for setting up your character rig for simulation! Let's now transfer the simulation back onto the rig. Run Record Simulation Enjoy","title":"Recording"},{"location":"tutorials/manikin/#start-again","text":"The recorded simulation ends up on an Animation Layer , and is also Cached . To start over, delete this layer and disable the cache.","title":"Start Again"},{"location":"tutorials/manikin/#next-steps","text":"In the next tutorial, we'll take this a bit further. As you play around with the Pose Stiffness on either the rGroup or individual rMarker nodes, you'll find some limbs start to misbehave. Especially the knees and elbows, that normally won't allow rotations past a certain angle in a real human (or Manikin for that matter!). That isn't the case here, because we've left out a critical part of any complete ragdoll. Full Ragdoll See you there!","title":"Next Steps"},{"location":"tutorials/manikin_ik/","text":"Manikin and IK In the previous tutorial we turned a character rig into a ragdoll, driven by your animation. In this tutorial, we'll have a look at how we apply this to the IK controls of a rig. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to assign markers to joints \u2714\ufe0f How to retarget joints to controls Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Bring Your Own Rig Follow this tutorial either using our provided Manikin rig, or your own character. It can have any number of limbs. Download Manikin Download Final Scene Setup Let's start fresh, with a non-dynamic character rig. In this case, the IK controls are disabled per default, so let's enable them. Select master_ctl Set Left Leg Fk Ik = 1 Set Right Leg Fk Ik = 1 Assign to Upper Body As per usual, let's assign markers onto the FK controls in the upper body. Find IK Joints The legs are different. We don't want to pass the position of the IK controls in the solver, instead what we want are the joints they drive. Where are the joints in my rig? The location of these will differ in every rig. What's important is that they are the ones that move when you move your IK controls. Any joints that do that will suffice. In the case of the Manikin, these will be located under the skeleton_grp . Assign to IK Joints Once you've found a suitable set of joints, assign to them as per usual. Starting from the hip. Recording Per default, Ragdoll will record onto the control you assign. However, we don't want keyframes on our IK joints. We want keyframes on our IK controls . Therefore, we aren't ready to record just yet. Notice how our IK controls didn't get any keyframes? Retarget Because we did not assign to our IK controls, we'll need to retarget the joints onto the controls. Now when we record, our retargeted IK controls will be getting keyframes from our simulated IK joints. Not Just IK This will work between any controls or joints. Even from one rig to another, or more complex IK like Spline IK. The Record Simulation command uses a native Maya Parent Constraint between the assigned and retargeted controls, so anywhere you could manually do this will work with this command. Finalise That's it for this tutorial! Here's some test animation. Shapes Grab the manipulator and tweak those shapes to fit your character. Test Animation Then drop some keys on our IK rig to see it in action.","title":"Inverse Kinematics"},{"location":"tutorials/manikin_ik/#manikin-and-ik","text":"In the previous tutorial we turned a character rig into a ragdoll, driven by your animation. In this tutorial, we'll have a look at how we apply this to the IK controls of a rig. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to assign markers to joints \u2714\ufe0f How to retarget joints to controls Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums","title":"Manikin and IK"},{"location":"tutorials/manikin_ik/#bring-your-own-rig","text":"Follow this tutorial either using our provided Manikin rig, or your own character. It can have any number of limbs. Download Manikin Download Final Scene","title":"Bring Your Own Rig"},{"location":"tutorials/manikin_ik/#setup","text":"Let's start fresh, with a non-dynamic character rig. In this case, the IK controls are disabled per default, so let's enable them. Select master_ctl Set Left Leg Fk Ik = 1 Set Right Leg Fk Ik = 1","title":"Setup"},{"location":"tutorials/manikin_ik/#assign-to-upper-body","text":"As per usual, let's assign markers onto the FK controls in the upper body.","title":"Assign to Upper Body"},{"location":"tutorials/manikin_ik/#find-ik-joints","text":"The legs are different. We don't want to pass the position of the IK controls in the solver, instead what we want are the joints they drive. Where are the joints in my rig? The location of these will differ in every rig. What's important is that they are the ones that move when you move your IK controls. Any joints that do that will suffice. In the case of the Manikin, these will be located under the skeleton_grp .","title":"Find IK Joints"},{"location":"tutorials/manikin_ik/#assign-to-ik-joints","text":"Once you've found a suitable set of joints, assign to them as per usual. Starting from the hip.","title":"Assign to IK Joints"},{"location":"tutorials/manikin_ik/#recording","text":"Per default, Ragdoll will record onto the control you assign. However, we don't want keyframes on our IK joints. We want keyframes on our IK controls . Therefore, we aren't ready to record just yet. Notice how our IK controls didn't get any keyframes?","title":"Recording"},{"location":"tutorials/manikin_ik/#retarget","text":"Because we did not assign to our IK controls, we'll need to retarget the joints onto the controls. Now when we record, our retargeted IK controls will be getting keyframes from our simulated IK joints. Not Just IK This will work between any controls or joints. Even from one rig to another, or more complex IK like Spline IK. The Record Simulation command uses a native Maya Parent Constraint between the assigned and retargeted controls, so anywhere you could manually do this will work with this command.","title":"Retarget"},{"location":"tutorials/manikin_ik/#finalise","text":"That's it for this tutorial! Here's some test animation.","title":"Finalise"},{"location":"tutorials/manikin_ik/#shapes","text":"Grab the manipulator and tweak those shapes to fit your character.","title":"Shapes"},{"location":"tutorials/manikin_ik/#test-animation","text":"Then drop some keys on our IK rig to see it in action.","title":"Test Animation"},{"location":"tutorials/manikin_ragdoll/","text":"Manikin Ragdoll In the previous tutorial we assigned markers onto a rig such that you can achieve overlapping motion. That's enough for some things, but other times you don't want any animation. You just want to drop a ragdoll someplace dangerous and watch it go. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to prevent unrealistic poses \u2714\ufe0f How to author and tune \"limits\" Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Bring Your Own Rig Either continue from the last tutorial or start anew with your own rig. Download Manikin Download Final Scene Limits Next let's see how our character behaves when there isn't any animation around to steer it. Select hip_ctl_rGroup Set Behaviour = Dynamic Set Pose Stiffness = 0.0 As in our last tutorial when we changed the hip_ctl from Kinematic to Dynamic , now we do the same but for the whole character! Yikes! That's a mess. No longer is the animation holding a pose together, it's all up to gravity and the anatomy of our character now. The way we will address this is via \"limits\", which is like locked rotate channels except they also lock a range of values. We can use this to replicate natural limits in our human joints. Legs Let's start at legs and work our way up. First, let's figure out what axis we want to rotate, and which we want to lock . Ok, great. The Z axis should rotate but X and Y should be locked. Run Ragdoll -> Manipulator Select the lower leg Switch to Limit Mode Enable limits around X , Y and Z Lock X and Y Next, tune the minimum and maximum values of the limit. Tune Minimum and Maximum Separately By holding the Ctrl key, you can manipulate one bound at a time. Then we can do the same for the feet. Something like that should do the trick. Clavicles Let's keep the clavicles simple. We'll allow only 1 axis of rotation by locking the others. Run Ragdoll -> Manipulator Edit the clavicle Arms We'll lock the X and Y axes of the lower arm like we did for the lower leg. Run Ragdoll -> Manipulator Edit the lower arm Edit the hand Hip and Spine Both the hip and spine should be allowed to rotate around all three axes, so we can leave these at their default values for now. Run Ragdoll -> Manipulator Edit the hip and spine And that's it! From here, we can hide the limits to have another look at contacts. Contacts If we hide away our limits for a moment, we can see something that's not right. Notice how the arm intersects the leg? That's because, per default, the limbs within a single group are allowed to overlap. Should I enable Self Collision? Normally the answer is \"no\", but when you do this can be overridden on the rGroup node. Overlap Group Let's address this by having these overlap with Nothing . Finalise You now know enough to construct any character of any anatomy! You have learnt \u2714\ufe0f How to limit the motion between two limbs \u2714\ufe0f How to tune the minimum and maximum bound of each limit As you tune, try dropping the Manikin from different heights and angles. Put an obstacle underneath for more detail and to catch more edge cases. Once you are unable to produce an unnatural pose, you are done! Download Completed Scene For your reference, here is the completed scene with the Manikin file referenced. Download Manikin Download Final Scene Damped Limits You can tune the behaviour of each limit to capture the look you're after, such as making things a little more damped . Global Damping This, and other stiffness and damping-related attributes, can be controlled globally - for every limit in your scene - via the rSolver node. Soft Limits Sometimes, a limit is hard . Like your elbow. It won't allow you to continue rotating it once it's straighted out. You'll break it! Other limits are more flexible. Let's reflect this in our simulation by reducing their range and lowering their Stiffness , accepting that they will exceed it, but get gently pushed back. Accurate Feet Feet contact with the ground is often more important than other contacts. For such cases, a box or capsule shape may not be enough. So let's use Replace Mesh to fix that. Select L_foot_jnt Select a mesh Run Replace Mesh Animation In most cases, you'll want some control over the resulting simulation. Just a little bit.","title":"Full Ragdoll"},{"location":"tutorials/manikin_ragdoll/#manikin-ragdoll","text":"In the previous tutorial we assigned markers onto a rig such that you can achieve overlapping motion. That's enough for some things, but other times you don't want any animation. You just want to drop a ragdoll someplace dangerous and watch it go. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to prevent unrealistic poses \u2714\ufe0f How to author and tune \"limits\" Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums","title":"Manikin Ragdoll"},{"location":"tutorials/manikin_ragdoll/#bring-your-own-rig","text":"Either continue from the last tutorial or start anew with your own rig. Download Manikin Download Final Scene","title":"Bring Your Own Rig"},{"location":"tutorials/manikin_ragdoll/#limits","text":"Next let's see how our character behaves when there isn't any animation around to steer it. Select hip_ctl_rGroup Set Behaviour = Dynamic Set Pose Stiffness = 0.0 As in our last tutorial when we changed the hip_ctl from Kinematic to Dynamic , now we do the same but for the whole character! Yikes! That's a mess. No longer is the animation holding a pose together, it's all up to gravity and the anatomy of our character now. The way we will address this is via \"limits\", which is like locked rotate channels except they also lock a range of values. We can use this to replicate natural limits in our human joints.","title":"Limits"},{"location":"tutorials/manikin_ragdoll/#legs","text":"Let's start at legs and work our way up. First, let's figure out what axis we want to rotate, and which we want to lock . Ok, great. The Z axis should rotate but X and Y should be locked. Run Ragdoll -> Manipulator Select the lower leg Switch to Limit Mode Enable limits around X , Y and Z Lock X and Y Next, tune the minimum and maximum values of the limit. Tune Minimum and Maximum Separately By holding the Ctrl key, you can manipulate one bound at a time. Then we can do the same for the feet. Something like that should do the trick.","title":"Legs"},{"location":"tutorials/manikin_ragdoll/#clavicles","text":"Let's keep the clavicles simple. We'll allow only 1 axis of rotation by locking the others. Run Ragdoll -> Manipulator Edit the clavicle","title":"Clavicles"},{"location":"tutorials/manikin_ragdoll/#arms","text":"We'll lock the X and Y axes of the lower arm like we did for the lower leg. Run Ragdoll -> Manipulator Edit the lower arm Edit the hand","title":"Arms"},{"location":"tutorials/manikin_ragdoll/#hip-and-spine","text":"Both the hip and spine should be allowed to rotate around all three axes, so we can leave these at their default values for now. Run Ragdoll -> Manipulator Edit the hip and spine And that's it! From here, we can hide the limits to have another look at contacts.","title":"Hip and Spine"},{"location":"tutorials/manikin_ragdoll/#contacts","text":"If we hide away our limits for a moment, we can see something that's not right. Notice how the arm intersects the leg? That's because, per default, the limbs within a single group are allowed to overlap. Should I enable Self Collision? Normally the answer is \"no\", but when you do this can be overridden on the rGroup node.","title":"Contacts"},{"location":"tutorials/manikin_ragdoll/#overlap-group","text":"Let's address this by having these overlap with Nothing .","title":"Overlap Group"},{"location":"tutorials/manikin_ragdoll/#finalise","text":"You now know enough to construct any character of any anatomy! You have learnt \u2714\ufe0f How to limit the motion between two limbs \u2714\ufe0f How to tune the minimum and maximum bound of each limit As you tune, try dropping the Manikin from different heights and angles. Put an obstacle underneath for more detail and to catch more edge cases. Once you are unable to produce an unnatural pose, you are done! Download Completed Scene For your reference, here is the completed scene with the Manikin file referenced. Download Manikin Download Final Scene","title":"Finalise"},{"location":"tutorials/manikin_ragdoll/#damped-limits","text":"You can tune the behaviour of each limit to capture the look you're after, such as making things a little more damped . Global Damping This, and other stiffness and damping-related attributes, can be controlled globally - for every limit in your scene - via the rSolver node.","title":"Damped Limits"},{"location":"tutorials/manikin_ragdoll/#soft-limits","text":"Sometimes, a limit is hard . Like your elbow. It won't allow you to continue rotating it once it's straighted out. You'll break it! Other limits are more flexible. Let's reflect this in our simulation by reducing their range and lowering their Stiffness , accepting that they will exceed it, but get gently pushed back.","title":"Soft Limits"},{"location":"tutorials/manikin_ragdoll/#accurate-feet","text":"Feet contact with the ground is often more important than other contacts. For such cases, a box or capsule shape may not be enough. So let's use Replace Mesh to fix that. Select L_foot_jnt Select a mesh Run Replace Mesh","title":"Accurate Feet"},{"location":"tutorials/manikin_ragdoll/#animation","text":"In most cases, you'll want some control over the resulting simulation. Just a little bit.","title":"Animation"},{"location":"tutorials/mocap_chap/","text":"Mocap Chap In the previous tutorials we've turned a character rig into a full ragdoll, driven by your animation. This time we'll look at applying physics to only parts of a character, like the upper body of this mocap clip found in Maya's default Content Browser. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to apply physics to mocap \u2714\ufe0f How to simulate only part of a character Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Overview When and why would you even want simulation on parts of a character? Tails Props Muscles Are three simple and somewhat obvious examples, more complex examples include what we're about to do in this tutorial. Namely, edit the mass of an object picked up during the original motion capture. Download Final Scene Setup Let's start by importing our motion capture clip; this can be any clip but if you'd like to follow along here's what you do. Windows -> General Editors -> Content Browser Drag and drop Smash.fbx Unrecognized file type? Make sure the fbxmaya.mll plug-in is loaded via the Maya Plug-in Manager. Here's what this clip looks like. Symmetry (optional) In order for Ragdoll to recognise symmetry later when we edit the shapes using the Manipulator , we'll need to assign markers in a symmetrical pose. Rewind to frame 0 Select the root Set Translate X and Translate Z to 0 Run Select -> Select Hierarchy Right-click and hold Run Assume Preferred Angle Set a keyframe on everything Assign Markers In this case, I'm ignoring fingers along with the center joint in each limb, like the lower arms and upper legs. From here, we can move our simulation to frame to 1 . We don't need frame 0 anymore. Kinematic Legs In this tutorial, we're only going to worry about the upper body, so let's turn those legs into 100% animation via the Kinematic behaviour. Tuning The stage is set, it's time to tune! Shapes Nothing special here, and since we have no geometry to fill we have some creative freedom in how we want our character to look! Let's have a look at where defaults values gets us. Not bad! But since we want our simulation to be close to the original mocap, we'll need to make some changes. Stiffness and Substeps The default solver substeps and iterations get you to a Stiffness of about 10 . In order to achieve a higher stiffness, we'll need more of those. Select rSolver Set Substeps = 8 Set Iterations = 8 Select Hips_rGroup Set Pose Stiffness = 40 Set Pose Damping = 0.25 Box Let's get the box in on the action. Attach Hands to Box He does a good job holding onto that box through friction between hand and box alone, but let's help him out by \"glueing\" the two together using a Distance Constraint Select the box Shift select the left hand Run Ragdoll -> Constrain -> Distance Repeat the process for the right hand The default distance will be From Start , meaning it will try and keep whatever the distance was between the box and the hands at the start of the simulation. What we want however is for the Maximum distance to be 0 , and for it to only start having an effect once the hands overlap the box. Now let's edit the point at which the hand and box snap together. Select one of the constraint Edit the Parent Offset Since we selected the box first , it is considered the \"parent\". Animate On and Off Next, let's activate this constraint once hands are in place. Go to frame 80 Set a keyframe on both constraints Stiffness = 0 Go to frame 81 Key Stiffness = 0.5 Likewise, we'll want the hands to release the box at some point later. Go to frame 178 Key Stiffness = 0.5 Go to frame 179 Key Stiffness = 0 Finalise And that's it! We've now massaged our original motion capture into carrying a box of similar weight to the motion. Let's make some changes and see what happens. More Mass What if the box was heavier? Select the box Select the rMarker_pCube1 in the Channel Box Press T on your keyboard Set Mass = 10 Mass and Cache When tuning single values like this, it can be helpful to leave the Maya timeline in place and let the simulation update independently. Next Steps At this point, you're able to turn any old motion capture hierarchy into a partial or fully-fledged ragdoll. Why not try a few more from the Content Browser? Or download any of the hundreds of freely available clips from here. https://www.mixamo.com https://www.rokoko.com http://mocap.cs.cmu.edu","title":"Mocap Chap"},{"location":"tutorials/mocap_chap/#mocap-chap","text":"In the previous tutorials we've turned a character rig into a full ragdoll, driven by your animation. This time we'll look at applying physics to only parts of a character, like the upper body of this mocap clip found in Maya's default Content Browser. Version 1.1 - Up to date Written for Ragdoll 2021.12.10 and above. Estimated Time \ud83d\udd50 10 minutes You will learn \u2714\ufe0f How to apply physics to mocap \u2714\ufe0f How to simulate only part of a character Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums","title":"Mocap Chap"},{"location":"tutorials/mocap_chap/#overview","text":"When and why would you even want simulation on parts of a character? Tails Props Muscles Are three simple and somewhat obvious examples, more complex examples include what we're about to do in this tutorial. Namely, edit the mass of an object picked up during the original motion capture. Download Final Scene","title":"Overview"},{"location":"tutorials/mocap_chap/#setup","text":"Let's start by importing our motion capture clip; this can be any clip but if you'd like to follow along here's what you do. Windows -> General Editors -> Content Browser Drag and drop Smash.fbx Unrecognized file type? Make sure the fbxmaya.mll plug-in is loaded via the Maya Plug-in Manager. Here's what this clip looks like.","title":"Setup"},{"location":"tutorials/mocap_chap/#symmetry-optional","text":"In order for Ragdoll to recognise symmetry later when we edit the shapes using the Manipulator , we'll need to assign markers in a symmetrical pose. Rewind to frame 0 Select the root Set Translate X and Translate Z to 0 Run Select -> Select Hierarchy Right-click and hold Run Assume Preferred Angle Set a keyframe on everything","title":"Symmetry (optional)"},{"location":"tutorials/mocap_chap/#assign-markers","text":"In this case, I'm ignoring fingers along with the center joint in each limb, like the lower arms and upper legs. From here, we can move our simulation to frame to 1 . We don't need frame 0 anymore.","title":"Assign Markers"},{"location":"tutorials/mocap_chap/#kinematic-legs","text":"In this tutorial, we're only going to worry about the upper body, so let's turn those legs into 100% animation via the Kinematic behaviour.","title":"Kinematic Legs"},{"location":"tutorials/mocap_chap/#tuning","text":"The stage is set, it's time to tune!","title":"Tuning"},{"location":"tutorials/mocap_chap/#shapes","text":"Nothing special here, and since we have no geometry to fill we have some creative freedom in how we want our character to look! Let's have a look at where defaults values gets us. Not bad! But since we want our simulation to be close to the original mocap, we'll need to make some changes.","title":"Shapes"},{"location":"tutorials/mocap_chap/#stiffness-and-substeps","text":"The default solver substeps and iterations get you to a Stiffness of about 10 . In order to achieve a higher stiffness, we'll need more of those. Select rSolver Set Substeps = 8 Set Iterations = 8 Select Hips_rGroup Set Pose Stiffness = 40 Set Pose Damping = 0.25","title":"Stiffness and Substeps"},{"location":"tutorials/mocap_chap/#box","text":"Let's get the box in on the action.","title":"Box"},{"location":"tutorials/mocap_chap/#attach-hands-to-box","text":"He does a good job holding onto that box through friction between hand and box alone, but let's help him out by \"glueing\" the two together using a Distance Constraint Select the box Shift select the left hand Run Ragdoll -> Constrain -> Distance Repeat the process for the right hand The default distance will be From Start , meaning it will try and keep whatever the distance was between the box and the hands at the start of the simulation. What we want however is for the Maximum distance to be 0 , and for it to only start having an effect once the hands overlap the box. Now let's edit the point at which the hand and box snap together. Select one of the constraint Edit the Parent Offset Since we selected the box first , it is considered the \"parent\".","title":"Attach Hands to Box"},{"location":"tutorials/mocap_chap/#animate-on-and-off","text":"Next, let's activate this constraint once hands are in place. Go to frame 80 Set a keyframe on both constraints Stiffness = 0 Go to frame 81 Key Stiffness = 0.5 Likewise, we'll want the hands to release the box at some point later. Go to frame 178 Key Stiffness = 0.5 Go to frame 179 Key Stiffness = 0","title":"Animate On and Off"},{"location":"tutorials/mocap_chap/#finalise","text":"And that's it! We've now massaged our original motion capture into carrying a box of similar weight to the motion. Let's make some changes and see what happens.","title":"Finalise"},{"location":"tutorials/mocap_chap/#more-mass","text":"What if the box was heavier? Select the box Select the rMarker_pCube1 in the Channel Box Press T on your keyboard Set Mass = 10","title":"More Mass"},{"location":"tutorials/mocap_chap/#mass-and-cache","text":"When tuning single values like this, it can be helpful to leave the Maya timeline in place and let the simulation update independently.","title":"Mass and Cache"},{"location":"tutorials/mocap_chap/#next-steps","text":"At this point, you're able to turn any old motion capture hierarchy into a partial or fully-fledged ragdoll. Why not try a few more from the Content Browser? Or download any of the hundreds of freely available clips from here. https://www.mixamo.com https://www.rokoko.com http://mocap.cs.cmu.edu","title":"Next Steps"},{"location":"tutorials/rookie_wasp/","text":"Rookie Wasp In this tutorial, we'll make an animation cycle using Ragdoll. Version 1.1 - Up to date Written for Ragdoll 2021.12.13 and above. Estimated Time \ud83d\udd50 15 minutes You will learn \u2714\ufe0f How to rig a model from Maya's Content Browser \u2714\ufe0f How to simulate a cycle \u2714\ufe0f How to create a seamless cycle Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Videos See here for part 1 and 2 of this tutorial. Part I - Setup (07:02 mins) Part II - Looping (07:31 mins)","title":"Rookie Wasp"},{"location":"tutorials/rookie_wasp/#rookie-wasp","text":"In this tutorial, we'll make an animation cycle using Ragdoll. Version 1.1 - Up to date Written for Ragdoll 2021.12.13 and above. Estimated Time \ud83d\udd50 15 minutes You will learn \u2714\ufe0f How to rig a model from Maya's Content Browser \u2714\ufe0f How to simulate a cycle \u2714\ufe0f How to create a seamless cycle Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums","title":"Rookie Wasp"},{"location":"tutorials/rookie_wasp/#videos","text":"See here for part 1 and 2 of this tutorial. Part I - Setup (07:02 mins) Part II - Looping (07:31 mins)","title":"Videos"},{"location":"tutorials/self_walking/","text":"Walking Rhino In this tutorial, we'll make a self-walking character using our Rhino asset. Version 1.0 - Up to date Written for Ragdoll 2022.03.14 and above. Estimated Time \ud83d\udd50 5 minutes You will need \u2714\ufe0f The Rhino asset \u2714\ufe0f Or your own character You will learn \u2714\ufe0f How to pin just the rotation of a marker \u2714\ufe0f How to get your character walking on its own Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums Videos See here for part 1 of 1 this tutorial. YouTube Video (03:16 mins) Timeline 00:00 Import and Setup 00:25 Pinning the Chest 00:40 Different Pin Values 01:25 Animating a Basic Walk Cycle 02:10 Final tweaks 02:40 Record and Render Next Steps Why not put a few of them together with Solver Linking? Stampede Tutorial","title":"Self Walking"},{"location":"tutorials/self_walking/#walking-rhino","text":"In this tutorial, we'll make a self-walking character using our Rhino asset. Version 1.0 - Up to date Written for Ragdoll 2022.03.14 and above. Estimated Time \ud83d\udd50 5 minutes You will need \u2714\ufe0f The Rhino asset \u2714\ufe0f Or your own character You will learn \u2714\ufe0f How to pin just the rotation of a marker \u2714\ufe0f How to get your character walking on its own Where to find help If you find or run into any issues with this tutorials, here's what you can do. \u2714\ufe0f Ask in the chat \u2714\ufe0f Ask on the forums","title":"Walking Rhino"},{"location":"tutorials/self_walking/#videos","text":"See here for part 1 of 1 this tutorial. YouTube Video (03:16 mins) Timeline 00:00 Import and Setup 00:25 Pinning the Chest 00:40 Different Pin Values 01:25 Animating a Basic Walk Cycle 02:10 Final tweaks 02:40 Record and Render","title":"Videos"},{"location":"tutorials/self_walking/#next-steps","text":"Why not put a few of them together with Solver Linking? Stampede Tutorial","title":"Next Steps"},{"location":"tutorials/videos/","text":"Videos Learn by watching. Heads up These were recorded just before Markers were finalised, but are still applicable to 2021.12.12 and above. Tutorial Duration Description Markers 101 01:23 What are markers? Markers 101 - Key Concepts 03:23 Overview of Input Type and Pose Space Markers 101 - Local and World 03:00 Overview of the two Pose Spaces, local and world Overlapping Motion I 02:27 The very basics or Capture and Record Overlapping Motion II 02:21 Animation layers Full Ragdoll I 04:08 Hierarchy and volume Full Ragdoll II 04:05 Kinematic and animation Full Ragdoll III 04:30 Self collisions and recording IK I 03:00 Capturing the skeleton IK II 01:59 Retargeting to IK controls IK III 01:59 Record both Translation and Rotation Practical Example I 06:53 Fix table and elbow intersection in this dialog performance Replace Reference Workflow 01:34 An ideal workflow for Ragdoll in a production pipeline with animators.","title":"Videos"},{"location":"tutorials/videos/#videos","text":"Learn by watching. Heads up These were recorded just before Markers were finalised, but are still applicable to 2021.12.12 and above. Tutorial Duration Description Markers 101 01:23 What are markers? Markers 101 - Key Concepts 03:23 Overview of Input Type and Pose Space Markers 101 - Local and World 03:00 Overview of the two Pose Spaces, local and world Overlapping Motion I 02:27 The very basics or Capture and Record Overlapping Motion II 02:21 Animation layers Full Ragdoll I 04:08 Hierarchy and volume Full Ragdoll II 04:05 Kinematic and animation Full Ragdoll III 04:30 Self collisions and recording IK I 03:00 Capturing the skeleton IK II 01:59 Retargeting to IK controls IK III 01:59 Record both Translation and Rotation Practical Example I 06:53 Fix table and elbow intersection in this dialog performance Replace Reference Workflow 01:34 An ideal workflow for Ragdoll in a production pipeline with animators.","title":"Videos"}]}