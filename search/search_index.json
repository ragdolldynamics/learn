{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn RAGDOLL Real-time physics for Autodesk\u00ae Maya 2020 Ragdoll provides animators with real-time physics for fast, automatic overlapping motion. Learn more Download Releases","title":"Home"},{"location":"api/","text":"Ragdoll consists of custom (locator) nodes written in C++, but everything involved in connecting these up and generating the dependency network happens in Python. This API is exposed to you for integration with auto-rigging, tools development and generally just extend the capabilities of the system. Overview from maya import cmds from ragdoll import api as rd from ragdoll.vendor import cmdx cube , _ = cmds . polyCube () cube = cmdx . encode ( cube ) # Convert to cmdx cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) See ragdoll/interactive.py for more examples See ragdoll/tools.py for more examples Types All functions take and return instances of cmdx . from maya import cmds from ragdoll import api as rd from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a scene scene = rd . createScene () assert isinstance ( scene , cmdx . DagNode ) assert scene . type () == \"rdScene\" # Every scene needs one or more rigid bodies rigid = rd . createRigid ( cube , scene ) assert isinstance ( rigid , cmdx . DagNode ) assert rigid . type () == \"rdRigid\" # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play ) See mottosso/cmdx for details about types Members Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createRigid ( node , scene , compute_mass = True ) api . createCollider ( node , scene , compute_mass = True ) # Constraints api . pointConstraint ( parent , child , scene ) api . orientConstraint ( parent , child , scene ) api . hingeConstraint ( parent , child , scene ) api . socketConstraint ( parent , child , scene ) api . parentConstraint ( parent , child , scene ) api . convertToPoint ( con ) api . convertToOrient ( con ) api . convertToHinge ( con , secondary_axis = \"y\" ) api . convertToSocket ( con ) api . convertToParent ( con ) # Controls api . createAbsoluteControl ( rigid ) api . createRelativeControl ( rigid ) api . createActiveControl ( reference , rigid ) api . createKinematicControl ( rigid ) # Forces api . createForce ( type , rigid , scene ) api . createSlice ( scene ) api . assignForce ( rigid , force ) # Utilities api . transferAttributes ( a , b , mirror = True ) api . transferRigid ( ra , rb ) api . transferConstraint ( ca , cb , mirror = True ) api . editConstraintFrames ( con ) api . duplicate ( rigid ) Each member is also available in optional snake_case","title":"API"},{"location":"api/#overview","text":"from maya import cmds from ragdoll import api as rd from ragdoll.vendor import cmdx cube , _ = cmds . polyCube () cube = cmdx . encode ( cube ) # Convert to cmdx cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) See ragdoll/interactive.py for more examples See ragdoll/tools.py for more examples","title":"Overview"},{"location":"api/#types","text":"All functions take and return instances of cmdx . from maya import cmds from ragdoll import api as rd from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a scene scene = rd . createScene () assert isinstance ( scene , cmdx . DagNode ) assert scene . type () == \"rdScene\" # Every scene needs one or more rigid bodies rigid = rd . createRigid ( cube , scene ) assert isinstance ( rigid , cmdx . DagNode ) assert rigid . type () == \"rdRigid\" # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play ) See mottosso/cmdx for details about types","title":"Types"},{"location":"api/#members","text":"Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createRigid ( node , scene , compute_mass = True ) api . createCollider ( node , scene , compute_mass = True ) # Constraints api . pointConstraint ( parent , child , scene ) api . orientConstraint ( parent , child , scene ) api . hingeConstraint ( parent , child , scene ) api . socketConstraint ( parent , child , scene ) api . parentConstraint ( parent , child , scene ) api . convertToPoint ( con ) api . convertToOrient ( con ) api . convertToHinge ( con , secondary_axis = \"y\" ) api . convertToSocket ( con ) api . convertToParent ( con ) # Controls api . createAbsoluteControl ( rigid ) api . createRelativeControl ( rigid ) api . createActiveControl ( reference , rigid ) api . createKinematicControl ( rigid ) # Forces api . createForce ( type , rigid , scene ) api . createSlice ( scene ) api . assignForce ( rigid , force ) # Utilities api . transferAttributes ( a , b , mirror = True ) api . transferRigid ( ra , rb ) api . transferConstraint ( ca , cb , mirror = True ) api . editConstraintFrames ( con ) api . duplicate ( rigid ) Each member is also available in optional snake_case","title":"Members"},{"location":"download/","text":"Get Ragdoll onto your system. Install I'm new here We're still in early access, buddy. It's secret. How did you even find this place? Name Email Message Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. However you can also do what Linux users do, and unzip the plug-in straight into your home directory. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS Are you serious? Hold your breath Tap your toes You should now see a new Ragdoll menu. See Release History Everything ok? No menu You've booted up Maya, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' Fair enough, let's go deeper. from os.path import join modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = join ( modules_path , \"Ragdoll-Maya-2021_06_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here . FAQ What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2021 What are my licensing options? Trial - 60 days of non-commercial use, no strings attached NodeLocked - Any number of users, one machine per licence Floating - Any number of machines, one user per licence Headless - A cost-effective alternative for distributed simulations What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? Best not to, you'll see this warning message in your Script Editor. Warning: Ragdoll evaluation skipped, frame change too large Letting you know to rewind and not trust the results until you do. How do I disable the ground? A static collider is automatically added on the Maya grid per default, it can be disabled on the rdScene node via the .useGround attribute. Why not use nHair for overlapping animation? Yes, and while your at it, why not stick razor blades in your eyes? Seriously though, Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance. Limitations As of Ragdoll 2020.12.07 these are the current known limitations of Ragdoll. Must visit start frame on scene open Poor support for the scale attribute Poor support for any rotateAxis other than XYZ Attributes jointOrient , rotatePivot and rotatePivotTranslate will be zeroed out When weight painting rigid joints, cannot right-click \"Select influence\"","title":"Download"},{"location":"download/#install","text":"I'm new here We're still in early access, buddy. It's secret. How did you even find this place? Name Email Message Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. However you can also do what Linux users do, and unzip the plug-in straight into your home directory. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS Are you serious? Hold your breath Tap your toes You should now see a new Ragdoll menu. See Release History Everything ok? No menu You've booted up Maya, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' Fair enough, let's go deeper. from os.path import join modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = join ( modules_path , \"Ragdoll-Maya-2021_06_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here .","title":"Install"},{"location":"download/#faq","text":"What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2021 What are my licensing options? Trial - 60 days of non-commercial use, no strings attached NodeLocked - Any number of users, one machine per licence Floating - Any number of machines, one user per licence Headless - A cost-effective alternative for distributed simulations What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? Best not to, you'll see this warning message in your Script Editor. Warning: Ragdoll evaluation skipped, frame change too large Letting you know to rewind and not trust the results until you do. How do I disable the ground? A static collider is automatically added on the Maya grid per default, it can be disabled on the rdScene node via the .useGround attribute. Why not use nHair for overlapping animation? Yes, and while your at it, why not stick razor blades in your eyes? Seriously though, Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance.","title":"FAQ"},{"location":"download/#limitations","text":"As of Ragdoll 2020.12.07 these are the current known limitations of Ragdoll. Must visit start frame on scene open Poor support for the scale attribute Poor support for any rotateAxis other than XYZ Attributes jointOrient , rotatePivot and rotatePivotTranslate will be zeroed out When weight painting rigid joints, cannot right-click \"Select influence\"","title":"Limitations"},{"location":"examples/","text":"Examples Download and have a go! 6.78 mb Example 1 | Just a Girl An example of hair simulation with Ragdoll. Download 2.93 mb Example 2 | mGirl An example of cloth simulation with Ragdoll. Download 2.77 mb Example 3 | Muscle An example of muscle simulation with Ragdoll. Download 1.18 mb Example 4 | Overview Some basic object types to fool around with. Download 0.16 mb Example 5 | Parkour An animated Ragdoll \"parkour\" character. Download 4.15 mb Example 6 | mHair Basic character setup with basic hair controls. Download 0.44 mb Example 7 | Mechanical An accurate mechanical contraption. Download 0.40 mb Example 8 | Driving A late night drive on a busy dirt road. Download 0.05 mb Example 9 | Dynamic Control A regular animation control. With dynamics! Download 2.91 mb Example 10 | Dance, Baby Fool around with guide strength to affect this dance performance! Download 0.24 mb Example 11 | Slowmo Manipulate time with the timeMultiplier attribute. Download","title":"Examples"},{"location":"examples/#examples","text":"Download and have a go! 6.78 mb","title":"Examples"},{"location":"menu/","text":"The Ragdoll menu is where you'll find just about everything there is to do with Ragdoll.","title":"Menu"},{"location":"overview/","text":"Ragdoll is a real-time physics solver for Maya, similar the native nCloth and nHair solvers except it works on transforms rather than points. That makes it better equipped to integrate with your existing animation controls and doesn't require translating from points like people did in the 90's. This domain contains Ragdoll learning resources, for a more general overview see the Product Page . Where to Find Help? Source Description Option Button Most menu items have an option button (square on the right-hand side) with more information and customisations for that particular item. Hover option In the Option Dialog, hovering over any option triggers helptext at the bottom of the window describing what it does. UI Videos Some menu items have videos associated with them, with a brief less-than-10 second example of how to use it and what to use it for. YouTube Videos Longer-form videos can be found here Tutorials Longer-form, written tutorials are about to appear on this website, watch this space. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . What's Next? Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch Me I've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"Overview"},{"location":"overview/#where-to-find-help","text":"Source Description Option Button Most menu items have an option button (square on the right-hand side) with more information and customisations for that particular item. Hover option In the Option Dialog, hovering over any option triggers helptext at the bottom of the window describing what it does. UI Videos Some menu items have videos associated with them, with a brief less-than-10 second example of how to use it and what to use it for. YouTube Videos Longer-form videos can be found here Tutorials Longer-form, written tutorials are about to appear on this website, watch this space. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid .","title":"Where to Find Help?"},{"location":"overview/#whats-next","text":"Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch Me I've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"What's Next?"},{"location":"reference/","text":"A summary of concepts and commands found in Ragdoll. Menu All items found in the Ragdoll menu at the top of Maya's main window. Item Description Active Rigid Customise the creation of a new rigid body. Passive Rigid Customise the creation of a new passive rigid body. Muscle Make a muscle from the selected anchor points. Constraint Constrain one rigid to another. Point Constraint the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. Parent Constrain both the position and orientation of two rigid bodies. Hinge A special kind of Socket Constraint Socket Constraint the position and limit the orientation between two rigid bodies. Convert Rigid Convert selected Rigid to a different type. Convert Constraint Convert selected Constraint to a different type. Kinematic Animate a passive rigid body with an external transform. Guide Animate an active rigid body with an external transform. Push Create a force which acts like a magnet, pushing rigids away from it. Pull Create a force which acts like an inverse magnet, pushing rigids towards it. Directional Create a force which acts like gravity, applying a constant force in a particular direction. Wind Create a force similar to wind, with editable turbulence. Visualiser Visualise 3D forces with a 2D slice, much like an MRI. Assign to Selected Assign force to the selected rigids. Character Generate a character from the selected joint hierarchy. Create Dynamic Control Create a new dynamic control from the currently selected regular control(s). Edit Constraint Frames Edit the parent and child frames using a native Maya transform. Duplicate Selected Create a new rigid, using the selected rigid as a template for position, orientation and shape. Transfer Attributes Copy attributes from one rigid body to another. Convert to Polygons Convert selected rigids and controls into polygons. Normalise shapes Resize shapes within a hierarchy to avoid some being too different. Set Initial State Re-establish the starting position and orientation of selected rigids. Delete All Physics Clear the Maya scene of anything related to Ragdoll. Edit Global Scale Edit the scale at which Ragdoll draws things, like constraints. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though. Create The top part of the menu contain commands to create new rigids. Active Rigid The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box. Rigids either output or input a transform. The active rigid outputs a transform, passing information from solver into your Maya scene. Basics Basics Turn any native Maya polygon or NURBS object into a rigid by selecting it and clicking 'Active Rigid'. Multiple Selection Multiple Selection When two or more objects are selected - whether it be polygons, NURBS or joints - they'll all be turned into rigids. Blend Existing Animation Blend Existing Animation If the selected node(s) are animated, the animation can be used as a target for the subsequent simulation using the 'Blend' option. Blend and Edit Blend and Edit Once turned into rigids, your original animation remains intact and can be edited just like before. You can also blend between the original input and final simulation via the blendSimulation node. Passive Rigid Customise the creation of a new passive rigid body. Basics Basics Turn any polygonal, NURBS surface or joint into a rigid which can be animated but isn't affected by the simulation. Muscle Make a muscle from the selected anchor points. Option Description Default Aim Axis Which axis to treat as aim for the resulting muscle. X Up Axis Which axis to treat as the up-axis for the resulting muscle. Y Flex How much to allow the muscle to contract, from not-at-all to all-the-way. 0.75 Radius Capsule radius, how thick of a muscle to make. 1.0 Convert Rigid Convert selected Rigid to a different type. Option Description Default Rigid Type Convert a rigid from dynamic to kinematic, or vice versa. 'Auto' turns dynamic into kinematic and vice versa. Auto Convert Constraint Convert selected Constraint to a different type. Option Description Default Convert Constraint Type The type of constraint to convert to. Point Constraint Like normal Maya constraints, these limit the motion of one rigid relative another. For example, the Parent Constraint will make one rigid move as though it was a child of the other, whereas the Point Constraint will only limit position whilst letting orientation roam free. Option Description Default Constraint Type The type of constraint created. Point Maintain Offset Keep rigids where they are, or snap them together. Offsets can be manipulated with the Edit Constraint Frames menu item. True Auto Orient Orient constraint automatically by aiming towards the immediate child. Otherwise use the local orientation of the node. True Guide Strength Include some guide strength with this constraint. 1.0 Point Constraint the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship. Parent Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid. Socket Constraint the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints. Hinge A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well suited for hinge-like appendages, like elbows and knees. Utilities High-level tools for animators and riggers that build upon the lower-level concepts above. Everything here can be created manually using a combination of the above commends or by making the connections yourself. Character An auto-rigger, designed to produce an animatable character from a skeleton hierarchy. Option Description Default Copy Turn a copy of the selected hierarchy into a character, rather than the hierarchy itself. True Control Create an additional control hierarchy from generated character. True Normalise Shapes Make sure shapes are relatively evenly sized. This can help prevent 'stick-figures' which are tougher to control. False Stop Behaviour Whether to include the joint with a 'Stop' label in the generated character or not. Inclusive Dynamic Control Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between. Option Description Default Shape Type The initial shape to represent the selected control. Don't worry, this can be changed afterwards. - Mesh : Suitable for controls that wrap around the model - Capsule : Suitable for flat controls, e.g. a circle Mesh Last For Length Do not turn the last selected node into a dynamic control, use it to determine capsule length of the previous control. False Edit Global Scale Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend. Option Description Default Gizmo Scale Scale at which to draw viewport widgets, like constraints. 1.0 Node Types All roads lead to Rome. In the case of Ragdoll, all nodes plug into rdScene which is where simulation takes place. Anything connected to it is able to interact with each other, it is typically where all rigids, constraints and forces related to a given character connects. Each Ragdoll node starts with rd , e.g. rdRigid Scene Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference Rigid A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Passive Rigid pass data from Maya to Ragdoll Active Rigid pass data from Ragdoll to Maya Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals of the shape. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference Constraint A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference","title":"Reference"},{"location":"reference/#menu","text":"All items found in the Ragdoll menu at the top of Maya's main window. Item Description Active Rigid Customise the creation of a new rigid body. Passive Rigid Customise the creation of a new passive rigid body. Muscle Make a muscle from the selected anchor points. Constraint Constrain one rigid to another. Point Constraint the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. Parent Constrain both the position and orientation of two rigid bodies. Hinge A special kind of Socket Constraint Socket Constraint the position and limit the orientation between two rigid bodies. Convert Rigid Convert selected Rigid to a different type. Convert Constraint Convert selected Constraint to a different type. Kinematic Animate a passive rigid body with an external transform. Guide Animate an active rigid body with an external transform. Push Create a force which acts like a magnet, pushing rigids away from it. Pull Create a force which acts like an inverse magnet, pushing rigids towards it. Directional Create a force which acts like gravity, applying a constant force in a particular direction. Wind Create a force similar to wind, with editable turbulence. Visualiser Visualise 3D forces with a 2D slice, much like an MRI. Assign to Selected Assign force to the selected rigids. Character Generate a character from the selected joint hierarchy. Create Dynamic Control Create a new dynamic control from the currently selected regular control(s). Edit Constraint Frames Edit the parent and child frames using a native Maya transform. Duplicate Selected Create a new rigid, using the selected rigid as a template for position, orientation and shape. Transfer Attributes Copy attributes from one rigid body to another. Convert to Polygons Convert selected rigids and controls into polygons. Normalise shapes Resize shapes within a hierarchy to avoid some being too different. Set Initial State Re-establish the starting position and orientation of selected rigids. Delete All Physics Clear the Maya scene of anything related to Ragdoll. Edit Global Scale Edit the scale at which Ragdoll draws things, like constraints. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though.","title":"Menu"},{"location":"reference/#create","text":"The top part of the menu contain commands to create new rigids.","title":"Create"},{"location":"reference/#active-rigid","text":"The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box. Rigids either output or input a transform. The active rigid outputs a transform, passing information from solver into your Maya scene. Basics","title":"Active Rigid"},{"location":"reference/#passive-rigid","text":"Customise the creation of a new passive rigid body. Basics","title":"Passive Rigid"},{"location":"reference/#muscle","text":"Make a muscle from the selected anchor points. Option Description Default Aim Axis Which axis to treat as aim for the resulting muscle. X Up Axis Which axis to treat as the up-axis for the resulting muscle. Y Flex How much to allow the muscle to contract, from not-at-all to all-the-way. 0.75 Radius Capsule radius, how thick of a muscle to make. 1.0","title":"Muscle"},{"location":"reference/#convert-rigid","text":"Convert selected Rigid to a different type. Option Description Default Rigid Type Convert a rigid from dynamic to kinematic, or vice versa. 'Auto' turns dynamic into kinematic and vice versa. Auto","title":"Convert Rigid"},{"location":"reference/#convert-constraint","text":"Convert selected Constraint to a different type. Option Description Default Convert Constraint Type The type of constraint to convert to. Point","title":"Convert Constraint"},{"location":"reference/#constraint","text":"Like normal Maya constraints, these limit the motion of one rigid relative another. For example, the Parent Constraint will make one rigid move as though it was a child of the other, whereas the Point Constraint will only limit position whilst letting orientation roam free. Option Description Default Constraint Type The type of constraint created. Point Maintain Offset Keep rigids where they are, or snap them together. Offsets can be manipulated with the Edit Constraint Frames menu item. True Auto Orient Orient constraint automatically by aiming towards the immediate child. Otherwise use the local orientation of the node. True Guide Strength Include some guide strength with this constraint. 1.0","title":"Constraint"},{"location":"reference/#point","text":"Constraint the position of two rigid bodies.","title":"Point"},{"location":"reference/#orient","text":"Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship.","title":"Orient"},{"location":"reference/#parent","text":"Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid.","title":"Parent"},{"location":"reference/#socket","text":"Constraint the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints.","title":"Socket"},{"location":"reference/#hinge","text":"A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well suited for hinge-like appendages, like elbows and knees.","title":"Hinge"},{"location":"reference/#utilities","text":"High-level tools for animators and riggers that build upon the lower-level concepts above. Everything here can be created manually using a combination of the above commends or by making the connections yourself.","title":"Utilities"},{"location":"reference/#character","text":"An auto-rigger, designed to produce an animatable character from a skeleton hierarchy. Option Description Default Copy Turn a copy of the selected hierarchy into a character, rather than the hierarchy itself. True Control Create an additional control hierarchy from generated character. True Normalise Shapes Make sure shapes are relatively evenly sized. This can help prevent 'stick-figures' which are tougher to control. False Stop Behaviour Whether to include the joint with a 'Stop' label in the generated character or not. Inclusive","title":"Character"},{"location":"reference/#dynamic-control","text":"Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between. Option Description Default Shape Type The initial shape to represent the selected control. Don't worry, this can be changed afterwards. - Mesh : Suitable for controls that wrap around the model - Capsule : Suitable for flat controls, e.g. a circle Mesh Last For Length Do not turn the last selected node into a dynamic control, use it to determine capsule length of the previous control. False","title":"Dynamic Control"},{"location":"reference/#edit-global-scale","text":"Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend. Option Description Default Gizmo Scale Scale at which to draw viewport widgets, like constraints. 1.0","title":"Edit Global Scale"},{"location":"reference/#node-types","text":"All roads lead to Rome. In the case of Ragdoll, all nodes plug into rdScene which is where simulation takes place. Anything connected to it is able to interact with each other, it is typically where all rigids, constraints and forces related to a given character connects. Each Ragdoll node starts with rd , e.g. rdRigid","title":"Node Types"},{"location":"reference/#scene","text":"Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference","title":"Scene"},{"location":"reference/#rigid","text":"A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Passive Rigid pass data from Maya to Ragdoll Active Rigid pass data from Ragdoll to Maya Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals of the shape. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference","title":"Rigid"},{"location":"reference/#constraint_1","text":"A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference","title":"Constraint"},{"location":"releases/","text":"Stay up to date with the latest improvements and fixes to Ragdoll. 2020.12.07 - Dynamic Control Improvements 2020.12.01 - Character 2.0 2020.11.24 - Hotfix 2020.11.23 - Dynamic Control 2.0 2020.11.22 - Bugfixes 2020.11.17 - Splash Screen 2020.11.16 - Cached Playback 2020.11.10 - Multi-threading","title":"Releases"},{"location":"nodes/rdConstraint/","text":"Reference sheet for the rdConstraint node type. from maya import cmds cmds . createNode ( \"rdConstraint\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Constraint"},{"location":"nodes/rdConstraint/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdRigid/","text":"Reference sheet for the rdRigid node type. from maya import cmds cmds . createNode ( \"rdRigid\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . enum 1 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals of the shape. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Rigid"},{"location":"nodes/rdRigid/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . enum 1 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals of the shape. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdScene/","text":"Reference sheet for the rdScene node type. from maya import cmds cmds . createNode ( \"rdScene\" ) Attributes Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Scene"},{"location":"nodes/rdScene/#attributes","text":"Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"releases/2020.11.10/","text":"Performance! NEW Multi-threading Ragdoll now supports multiple solvers in the same Maya scene, each of which run in parallel offering a 2-3x increase in FPS NEW UI Menu items now have additional customisation with a new UI interface. NEW Animation Influence Dynamic Controls can now respond to animation input, either kinematically or as a guided influence to your simulation. This means you can turn your controllers dynamic, and add additional animation to steer the simulation! NEW Exploratory Menu The menu is now fully unlocked, with user-friendly messages letting you know how to use it if you are unfamiliar. The goal is facilitating exploration and curiosity in a safe environment with reliable undo. FIXED Hinge Constraint A constraint being converted to/from a hinge constraint no longer breaks the constraint. FIXED Set Initial State Modify the position and orientation of your rigid bodies after creation with this feature. Multi-Threading Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead. Option Dialogs Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches. Animation Influence The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"2020.11.10"},{"location":"releases/2020.11.10/#multi-threading","text":"Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead.","title":"Multi-Threading"},{"location":"releases/2020.11.10/#option-dialogs","text":"Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches.","title":"Option Dialogs"},{"location":"releases/2020.11.10/#animation-influence","text":"The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"Animation Influence"},{"location":"releases/2020.11.16/","text":"The highlight for this release is Cached Playback! NEW Cached Playback You can now leverage Maya 2020's native cached playback for your simulations, speeding up playback performance and lowering iteration times. NEW Help Videos Ragdoll commands now come with how-to videos built directly into the UI. NEW Shape orientation and joints Shapes relied on the jointOrient being proper for joints, gone are the days. FIXED Wireframe Bug The wireframe for the Box shape does now draw correctly with a custom rdRigid.shapeRotation FIXED Outliner Icon Support on Linux Linux now benefits from the same pretty icons as Windows FIXED Logging Warnings These now emit a yellow color in your Command Line FIXED Boxes and Joints Joints converted to Rigids can now be set to Box shape with proper orientation Cached Playback Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids ![ragdollcached1](https://user-images.githubusercontent.com/2152766/98826001-0fac2400-242d-11eb-9261-9b6e19034076.gif) ![ragdollcached2](https://user-images.githubusercontent.com/2152766/98825995-0e7af700-242d-11eb-835d-355756fcaf9d.gif) Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor Known Limitations with Cached Playback There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. Slice Connection The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection Output Geometry Guide `rdRigid.ouputGeometry` Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why. The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! Help Videos Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll. Shape Orientation Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"2020.11.16"},{"location":"releases/2020.11.16/#cached-playback","text":"Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids ![ragdollcached1](https://user-images.githubusercontent.com/2152766/98826001-0fac2400-242d-11eb-9261-9b6e19034076.gif) ![ragdollcached2](https://user-images.githubusercontent.com/2152766/98825995-0e7af700-242d-11eb-835d-355756fcaf9d.gif) Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor","title":"Cached Playback"},{"location":"releases/2020.11.16/#known-limitations-with-cached-playback","text":"There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. Slice Connection The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection Output Geometry Guide `rdRigid.ouputGeometry` Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why. The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release!","title":"Known Limitations with Cached Playback"},{"location":"releases/2020.11.16/#help-videos","text":"Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll.","title":"Help Videos"},{"location":"releases/2020.11.16/#shape-orientation","text":"Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"Shape Orientation"},{"location":"releases/2020.11.17/","text":"Minor release. NEW Installation confirmation Ragdoll now lets you know whether the install went successful or not. This appears on first launch, and can be revisited via the Ragdoll menu. This is also where updates will be found, along with future new-user material like links to docs and tutorials. FIXED The Ragdoll | Character menu item has been fixed and is operating at 100% Install Confirmation It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"2020.11.17"},{"location":"releases/2020.11.17/#install-confirmation","text":"It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"Install Confirmation"},{"location":"releases/2020.11.22/","text":"Minor release, no breaking changes. FIXED Capsule orientation used to face the wrong direction with some joints FIXED Creating a new collider is now undoable like you would expect FIXED Message printed when converting a rigid is now accurate FIXED Kinematic/Dynamic option from Convert Options does no longer bleeds into the Create Rigid Options ADDED Auto option to Convert Rigid , to toggle a rigid between dynamic and kinematic CHANGED The rdRigid.kinematic attribute is now up-top, better indicating its importance CHANGED The Ragdoll | Convert menu item is now split into Convert Rigid and Convert Constraint CHANGED Renamed Convex Hull -> Mesh , should make more sense now Capsule Orientation Fixed a bug where the capsule of a joint would face the wrong way. What is Rigid Body Dynamics? Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body Performance Tips Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"2020.11.22"},{"location":"releases/2020.11.22/#capsule-orientation","text":"Fixed a bug where the capsule of a joint would face the wrong way.","title":"Capsule Orientation"},{"location":"releases/2020.11.22/#what-is-rigid-body-dynamics","text":"Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body","title":"What is Rigid Body Dynamics?"},{"location":"releases/2020.11.22/#performance-tips","text":"Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"Performance Tips"},{"location":"releases/2020.11.23/","text":"The headline of this release is Dynamic Control 2.0 CHANGED Dynamic Control Removed fuss and simplified the interface. CHANGED \"Delete All Physics\" Now deletes all physics, regardless of the current selection CHANGED Rigid versus Collider Learn about what these mean and how to convert between the two. ADDED Center of mass (Advanced) Now you can change the point at which a rigid body is balanced ADDED Angular mass (Advanced) Typically computed automatically from the shape and size of your rigid, now you can manually define this. ADDED Auto Connect More clarity, and also usable with things other than joints Dynamic Control 2.0 Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos Limitations Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment. Center of Mass If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it Angular Mass In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\" or \"moment of inertia\". It's like mass, but in terms of rotation rather than position. The broom has a low angular mass around its length axis, and a high angular mass in the other two axes. That makes it \"heavier\" around some axes but not others. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, then the angular mass will also be lighter around its length then its width. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it Auto Connect The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"2020.11.23"},{"location":"releases/2020.11.23/#dynamic-control-20","text":"Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos","title":"Dynamic Control 2.0"},{"location":"releases/2020.11.23/#limitations","text":"Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment.","title":"Limitations"},{"location":"releases/2020.11.23/#center-of-mass","text":"If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it","title":"Center of Mass"},{"location":"releases/2020.11.23/#angular-mass","text":"In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\" or \"moment of inertia\". It's like mass, but in terms of rotation rather than position. The broom has a low angular mass around its length axis, and a high angular mass in the other two axes. That makes it \"heavier\" around some axes but not others. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, then the angular mass will also be lighter around its length then its width. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it","title":"Angular Mass"},{"location":"releases/2020.11.23/#auto-connect","text":"The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"Auto Connect"},{"location":"releases/2020.11.24/","text":"Hotfix, the last release broke a few things. FIXED You can now save the Maya scene. Imagine that! FIXED You can now enable the Ragdoll solver after having disabled it That's all, have mercy.","title":"2020.11.24"},{"location":"releases/2020.12.01/","text":"Lots of good stuff! CHANGED Active & Passive Rigid More intuitive jargon for these suckers CHANGED Character 2.0 New and improved, now with cup-holders! ADDED Dynamic Control Capsules For those flat controls ADDED Time Multiplier Speed up or slow down your simulation, can be animated! ADDED Normalise Shapes Evenly distribute shapes across a hierarchy ADDED Auto Orient Don't bother orienting your joints with this nifty automation, now the X-axis always means \"length\" CHANGED Delete all Physics now also deletes Ragdoll's attributes on your animation controls, for that squeaky clean feeling ADDED Support for custom Rotate Order means more character controls now work out-of-the-box. FIXED Undo bug and rdRigid The rigids should now clean up after themselves better FIXED Simulation start time now uses the start range rather than start time, which is what you would expect NOTES Stick figures Learn about how thickness affects your simulation NOTES Animation in 1995 Witness how little our industry has changed since then, let's fix that! Active & Passive Rigid Body The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\"). Character 2.0 - \"Auto-Ragger\" This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page Dynamic Control Capsules Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page Normalise Shapes An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up Time Multiplier Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene Rotate Order Now rigids plya well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one! Auto Orient Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons. Undo Bug There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed! Stick Figures In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head? Animation in 1995 Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"2020.12.01"},{"location":"releases/2020.12.01/#active-passive-rigid-body","text":"The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\").","title":"Active &amp; Passive Rigid Body"},{"location":"releases/2020.12.01/#character-20-auto-ragger","text":"This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page","title":"Character 2.0 - \"Auto-Ragger\""},{"location":"releases/2020.12.01/#dynamic-control-capsules","text":"Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.01/#normalise-shapes","text":"An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up","title":"Normalise Shapes"},{"location":"releases/2020.12.01/#time-multiplier","text":"Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene","title":"Time Multiplier"},{"location":"releases/2020.12.01/#rotate-order","text":"Now rigids plya well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one!","title":"Rotate Order"},{"location":"releases/2020.12.01/#auto-orient","text":"Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons.","title":"Auto Orient"},{"location":"releases/2020.12.01/#undo-bug","text":"There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed!","title":"Undo Bug"},{"location":"releases/2020.12.01/#stick-figures","text":"In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head?","title":"Stick Figures"},{"location":"releases/2020.12.01/#animation-in-1995","text":"Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"Animation in 1995"},{"location":"releases/2020.12.07/","text":"Ragdoll 2020.12.07 Small release with important changes if you use Dynamic Controls on complex rigs with pre-existing animation. ADDED Blend Rigid Now rigids can do some of what Dynamic Controls can do. :) FIXED Dynamic Control switch Shape You can now switch to capsules after having created them as meshes. FIXED Dynamic Control and Undo If your controls have pre-existing animation, undo will now work properly FIXED Dynamic Control and Auto Orient If you controls have intermediate groups between themselves, auto axis will now work properly Blend Rigid Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box. Dynamic Control Capsules Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around. Dynamic Control and Undo You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo. Dynamic Control and Orient Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"2020.12.07"},{"location":"releases/2020.12.07/#ragdoll-20201207","text":"Small release with important changes if you use Dynamic Controls on complex rigs with pre-existing animation. ADDED Blend Rigid Now rigids can do some of what Dynamic Controls can do. :) FIXED Dynamic Control switch Shape You can now switch to capsules after having created them as meshes. FIXED Dynamic Control and Undo If your controls have pre-existing animation, undo will now work properly FIXED Dynamic Control and Auto Orient If you controls have intermediate groups between themselves, auto axis will now work properly","title":"Ragdoll 2020.12.07"},{"location":"releases/2020.12.07/#blend-rigid","text":"Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box.","title":"Blend Rigid"},{"location":"releases/2020.12.07/#dynamic-control-capsules","text":"Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around.","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.07/#dynamic-control-and-undo","text":"You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo.","title":"Dynamic Control and Undo"},{"location":"releases/2020.12.07/#dynamic-control-and-orient","text":"Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"Dynamic Control and Orient"}]}