{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn RAGDOLL Real-time physics for Autodesk\u00ae Maya 2018-2022 Ragdoll provides animators with real-time physics for fast, automatic overlapping motion. Learn more Download Releases","title":"Home"},{"location":"about/","text":"Here's a brief overview of how Ragdoll came to be. In 2008 Marcus graduated from Blekinge Tekniska H\u00f6gskola and ventured into the world as character animator at Meindbender; to work on The Duplicators and The Pirate amongst others. In 2012 He joined Framestore and familiarised himself with the world of physics simulation, developing the technology behind the tethers for Alfonso Cuaron's feature film Gravity, and later completed work on the Cloak of Leviation in Doctor Strange. In 2015 He started a company called Abstract Factory developing tools in Python for use in production pipelines, including Avalon , Pyblish , Qt.py , cmdx and Allzpark ; later recieving the \"Best Tool\" award for Pyblish at the 2020 DigiPro/The Pipeline Conference. In 2017 He started a company called WeightShift with co-founders Danny Chapman and Tim Daust. They had just wrapped up the Endorphin and Euphoria projects at Natural Motion. Like Euphoria, WeightShift developed a physically based animation tool, except this one was tailed to Autodesk Maya and got adopted by major feature film studios including Framestore (Harry Potter, Gravity et. al.) and Weta Digital (Avatar, Lord of the Rings et. al.) In 2020 Epic purchases WeightShift In 2020 Ragdoll enters chat Ragdoll carries on where WeightShift left off, but turns things on its head. Rather than targeting riggers and technical animators, Ragdoll adopts a \"no-rigging required\" approach. Sometime in 2021 Ragdoll is released.","title":"About"},{"location":"api/","text":"Ragdoll consists of custom ( MPxLocatorNode ) nodes written in C++, but everything involved in connecting these up and generating the dependency network happens in Python. This API is exposed to you for integration with auto-rigging, tools development and to generally just extend the capabilities of the system. The API is also available on GitHub for issue tracking and user contributions. Overview There are 3 supported methods of integrating Ragdoll into your pipeline. Each with its own flare. api.py - Public interface commands.py - Low-level commands interactive.py - User-facing commands api.py The publicly facing programming interface to Ragdoll. Use this for tools integrated with other tools that rely on heavy compatibility between versions and few surprises on what goes in and out. \u2714\ufe0f Guaranteed backwards compatibility \u2714\ufe0f High interoperability with maya.cmds , including camelCase \u2714\ufe0f No dependence on user selection or preferences \u274c Limited to documented and officially supported features from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) commands.py The api.py module builds on commands.py , but wraps it in a string-based interface so as to make it compatible with your everyday calls to maya.cmds . All of api.py is present in commands.py , along with a few extras that may or may not change over time. It is best suited for tight integration and control but is primarily used internally for implementing interactive.py and tools.py . \u2714\ufe0f Fast \u2714\ufe0f Flexible \u2714\ufe0f Same guarantees as api.py for identical members \u274c Unfamiliar data cmdx types commands.py uses the highly performant cmdx library to communicate with Maya and all return values are instances of cmdx . from maya import cmds from ragdoll import commands as rc from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a scene scene = rc . create_scene () assert isinstance ( scene , cmdx . DagNode ) assert scene . type () == \"rdScene\" # Every scene needs one or more rigid bodies rigid = rc . create_rigid ( cube , scene ) assert isinstance ( rigid , cmdx . DagNode ) assert rigid . type () == \"rdRigid\" # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play ) interactive.py Finally, this module is used for UI elements like the main Ragdoll menu. Every function takes selection into account, along with any preferences set via the Option Dialogs. It's useful for when you want to replicate what the menu does, including taking selection into account and outputting warning messages in the Script Editor. It won't raise exceptions like api and commands , instead each function return either True for success or nothing for failure. Failures typically follow one or more warning messages. \u2714\ufe0f Animator-friendly, useful for quick scripts \u274c No usable return value \u274c Sensitive to user preferences \u274c No guarantee on backwards compatibility \u274c Verbose output in Script Editor from maya import cmds from ragdoll import interactive as ri cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) cmds . select ( cube ) ri . create_rigid () cmds . evalDeferred ( cmds . play ) Members Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createScene () api . createRigid ( node , scene , passive = False , compute_mass = True ) # Constraints api . pointConstraint ( parent , child , scene ) api . orientConstraint ( parent , child , scene ) api . hingeConstraint ( parent , child , scene ) api . socketConstraint ( parent , child , scene ) api . parentConstraint ( parent , child , scene ) api . convertToPoint ( con ) api . convertToOrient ( con ) api . convertToHinge ( con , secondary_axis = \"y\" ) api . convertToSocket ( con ) api . convertToParent ( con ) # Controls api . createAbsoluteControl ( rigid ) api . createRelativeControl ( rigid ) api . createActiveControl ( reference , rigid ) api . createKinematicControl ( rigid ) # Forces api . createForce ( type , rigid , scene ) api . createSlice ( scene ) api . assignForce ( rigid , force ) # Utilities api . transferAttributes ( a , b , mirror = True ) api . transferRigid ( ra , rb ) api . transferConstraint ( ca , cb , mirror = True ) api . editConstraintFrames ( con ) api . duplicate ( rigid ) Environment Variables Gain more control over the integration of Ragdoll into your pipeline with these optional environment variables. For example, to manually load the Ragdoll plug-in and Maya menu, set RAGDOLL_NO_AUTOLOAD=1 and then call: import ragdoll.interactive ragdoll . interactive . install () Added Ragdoll 2021.01.14 Variable Description Default RAGDOLL_PLUGIN Override absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset","title":"API Reference"},{"location":"api/#overview","text":"There are 3 supported methods of integrating Ragdoll into your pipeline. Each with its own flare. api.py - Public interface commands.py - Low-level commands interactive.py - User-facing commands","title":"Overview"},{"location":"api/#apipy","text":"The publicly facing programming interface to Ragdoll. Use this for tools integrated with other tools that rely on heavy compatibility between versions and few surprises on what goes in and out. \u2714\ufe0f Guaranteed backwards compatibility \u2714\ufe0f High interoperability with maya.cmds , including camelCase \u2714\ufe0f No dependence on user selection or preferences \u274c Limited to documented and officially supported features from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play )","title":"api.py"},{"location":"api/#commandspy","text":"The api.py module builds on commands.py , but wraps it in a string-based interface so as to make it compatible with your everyday calls to maya.cmds . All of api.py is present in commands.py , along with a few extras that may or may not change over time. It is best suited for tight integration and control but is primarily used internally for implementing interactive.py and tools.py . \u2714\ufe0f Fast \u2714\ufe0f Flexible \u2714\ufe0f Same guarantees as api.py for identical members \u274c Unfamiliar data cmdx types commands.py uses the highly performant cmdx library to communicate with Maya and all return values are instances of cmdx . from maya import cmds from ragdoll import commands as rc from ragdoll.vendor import cmdx cmds . file ( new = True , force = True ) cube , _ = map ( cmdx . encode , cmds . polyCube ()) cube [ \"translateY\" ] = 10 cube [ \"rotate\" , cmdx . Degrees ] = ( 35 , 50 , 30 ) # Every simulation needs a scene scene = rc . create_scene () assert isinstance ( scene , cmdx . DagNode ) assert scene . type () == \"rdScene\" # Every scene needs one or more rigid bodies rigid = rc . create_rigid ( cube , scene ) assert isinstance ( rigid , cmdx . DagNode ) assert rigid . type () == \"rdRigid\" # Allow start frame to evaluate before progressing cmds . evalDeferred ( cmds . play )","title":"commands.py"},{"location":"api/#interactivepy","text":"Finally, this module is used for UI elements like the main Ragdoll menu. Every function takes selection into account, along with any preferences set via the Option Dialogs. It's useful for when you want to replicate what the menu does, including taking selection into account and outputting warning messages in the Script Editor. It won't raise exceptions like api and commands , instead each function return either True for success or nothing for failure. Failures typically follow one or more warning messages. \u2714\ufe0f Animator-friendly, useful for quick scripts \u274c No usable return value \u274c Sensitive to user preferences \u274c No guarantee on backwards compatibility \u274c Verbose output in Script Editor from maya import cmds from ragdoll import interactive as ri cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) cmds . select ( cube ) ri . create_rigid () cmds . evalDeferred ( cmds . play )","title":"interactive.py"},{"location":"api/#members","text":"Currently available members of ragdoll.api . Call help() for usage instructions # Fundamentals api . createScene () api . createRigid ( node , scene , passive = False , compute_mass = True ) # Constraints api . pointConstraint ( parent , child , scene ) api . orientConstraint ( parent , child , scene ) api . hingeConstraint ( parent , child , scene ) api . socketConstraint ( parent , child , scene ) api . parentConstraint ( parent , child , scene ) api . convertToPoint ( con ) api . convertToOrient ( con ) api . convertToHinge ( con , secondary_axis = \"y\" ) api . convertToSocket ( con ) api . convertToParent ( con ) # Controls api . createAbsoluteControl ( rigid ) api . createRelativeControl ( rigid ) api . createActiveControl ( reference , rigid ) api . createKinematicControl ( rigid ) # Forces api . createForce ( type , rigid , scene ) api . createSlice ( scene ) api . assignForce ( rigid , force ) # Utilities api . transferAttributes ( a , b , mirror = True ) api . transferRigid ( ra , rb ) api . transferConstraint ( ca , cb , mirror = True ) api . editConstraintFrames ( con ) api . duplicate ( rigid )","title":"Members"},{"location":"api/#environment-variables","text":"Gain more control over the integration of Ragdoll into your pipeline with these optional environment variables. For example, to manually load the Ragdoll plug-in and Maya menu, set RAGDOLL_NO_AUTOLOAD=1 and then call: import ragdoll.interactive ragdoll . interactive . install () Added Ragdoll 2021.01.14 Variable Description Default RAGDOLL_PLUGIN Override absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset","title":"Environment Variables"},{"location":"download/","text":"At the time of this writing, Ragdoll is still in early access. Reach out for access. Download Ragdoll 2021.04.23 awaits. Click here to get started. Previous versions Install Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. However you can also do what Linux users do, and unzip the plug-in straight into your home directory. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS Sorry, MacOS is currently not supported . Let us know this is important to you, and priorities can be shifted. contact@ragdolldynamics.com The plug-in is now available via the Plug-in Manager. See Release History Everything ok? No menu You've booted up Maya, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' Fair enough, let's go deeper. from os.path import join modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = join ( modules_path , \"Ragdoll-Maya-2021_06_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here . FAQ What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2022 What are my licensing options? Trial - 30 days of non-commercial use, no strings attached NodeLocked - Any number of users, one machine per licence Floating - Any number of machines, one user per licence Headless - A cost-effective alternative for distributed simulations What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? Best not to, you'll see this warning message in your Script Editor. Warning: Ragdoll evaluation skipped, frame change too large Letting you know to rewind and not trust the results until you do. How do I disable the ground? A static collider is automatically added on the Maya grid per default, it can be disabled on the rdScene node via the .useGround attribute. Why not use nHair for overlapping animation? Yes, and while your at it, why not stick razor blades in your eyes? Seriously though, Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance. Limitations As of Ragdoll 2021.04.23 these are the current known limitations of Ragdoll. Must visit start frame on scene open No support for rotateAxis other than 0 Attributes jointOrient , rotatePivot and rotatePivotTranslate will be zeroed out When weight painting rigid joints, cannot right-click \"Select influence\" (see workaround )","title":"Download"},{"location":"download/#install","text":"Ragdoll ships as a Maya Module for Windows and Linux. Installation for Windows On the Windows platform, there's an executable you can run. However you can also do what Linux users do, and unzip the plug-in straight into your home directory. Run the .msi installer Restart Maya Alternatively, unzip Ragdoll into your ~/maya directory. You should end up with something like this. c: \\U sers \\m arcus \\D ocuments \\m aya \\m odules \\R agdoll.mod Installation for Linux On Linux, installation and upgrades are done in the same fashion. Unzip the .zip into your ~/maya directory Restart Maya You should end up with something like this. /home/marcus/maya/modules/Ragdoll.mod Installation for MacOS Sorry, MacOS is currently not supported . Let us know this is important to you, and priorities can be shifted. contact@ragdolldynamics.com The plug-in is now available via the Plug-in Manager. See Release History Everything ok? No menu You've booted up Maya, but there is no menu, what gives? Maya Modules work in mysterious ways. Try installing it the old fashioned way. from ragdoll import interactive interactive . install () No module named 'ragdoll' Fair enough, let's go deeper. from os.path import join modules_path = r \"c:\\Users\\marcus\\Documents\\maya\\modules\" ragdoll_path = join ( modules_path , \"Ragdoll-Maya-2021_06_06\\scripts\" ) import sys sys . path . insert ( 0 , ragdoll_path ) from ragdoll import interactive interactive . install () Make sure you replace the version number (date) with the version you are using. At this point, I expect you've uncovered why your module wasn't working in the first place and should probably revisit that as this process would require you to manually update the version number in that path each time you upgrade. No fun. Something else happened Oh no! I'd like to know about what happened, please let me know here .","title":"Install"},{"location":"download/#faq","text":"What are my workstation requirements? Anything capable of running Maya can run Ragdoll. Windows 10+ or CentOS 7+ 64-bit Intel\u00ae or AMD\u00ae processor 4 GB of RAM Maya 2018-2022 What are my licensing options? Trial - 30 days of non-commercial use, no strings attached NodeLocked - Any number of users, one machine per licence Floating - Any number of machines, one user per licence Headless - A cost-effective alternative for distributed simulations What happens when my licence runs out? Your scenes will still open, but the solver will be disabled. Contact licence@ragdolldynamics.com for renewal of your licence. What happens when I skip frames? Best not to, you'll see this warning message in your Script Editor. Warning: Ragdoll evaluation skipped, frame change too large Letting you know to rewind and not trust the results until you do. How do I disable the ground? A static collider is automatically added on the Maya grid per default, it can be disabled on the rdScene node via the .useGround attribute. Why not use nHair for overlapping animation? Yes, and while your at it, why not stick razor blades in your eyes? Seriously though, Ragdoll simulates your translate and rotate channels, whereas nHair simulates point geometry. You can convert those points into translation and rotation, but given the choice why would you? Besides, Ragdoll has far more robust collisions, control and constraints than nHair or nCloth could ever hope to achieve, at much greater performance.","title":"FAQ"},{"location":"download/#limitations","text":"As of Ragdoll 2021.04.23 these are the current known limitations of Ragdoll. Must visit start frame on scene open No support for rotateAxis other than 0 Attributes jointOrient , rotatePivot and rotatePivotTranslate will be zeroed out When weight painting rigid joints, cannot right-click \"Select influence\" (see workaround )","title":"Limitations"},{"location":"examples/","text":"Examples Download and have a go! 6.78 mb Example 1 | Just a Girl An example of hair simulation with Ragdoll. Download 2.93 mb Example 2 | mGirl An example of cloth simulation with Ragdoll. Download 2.77 mb Example 3 | Muscle An example of muscle simulation with Ragdoll. Download 1.18 mb Example 4 | Overview Some basic object types to fool around with. Download 0.16 mb Example 5 | Parkour An animated Ragdoll \"parkour\" character. Download 4.15 mb Example 6 | mHair Basic character setup with basic hair controls. Download 0.44 mb Example 7 | Mechanical An accurate mechanical contraption. Download 0.40 mb Example 8 | Driving A late night drive on a busy country road. Download 0.05 mb Example 9 | Dynamic Control A regular animation control. With dynamics! Download 2.91 mb Example 10 | Dance, Baby Fool around with guide strength to affect this dance performance! Download 0.24 mb Example 11 | Slowmo Manipulate time with the timeMultiplier attribute. Download","title":"Examples"},{"location":"examples/#examples","text":"Download and have a go! 6.78 mb","title":"Examples"},{"location":"licencing/","text":"Each instance of Ragdoll requires an individual licence. Activation requires a Product Key which you get by either purchasing a licence or by being really awesome. FAQ Let's dive into specifics. How does it work? On first launch, Ragdoll will try and connect to the Ragdoll Licence Server and register your trial version. This version is node-locked to the particular machine you are on. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Enter your product key Click Activate Or if you prefer: from ragdoll import licence licence . activate ( key ) If internet is unavailable, Ragdoll enters \"offline mode\" and expires at a fixed date. Each new release is given an updated expiry date. What happens when my trial expires? Any rdScene.enabled attribute will be set to False . Scenes will still load just fine and nothing else in your scene is affected. Once activated, the .enabled attribute will return to normal. Can I renew my trial licence? Possibly. Reach out to us if this is relevant to you. We're contemplating a permanently active \"Personal Learning Edition\" with limitations on what you can do commercially, similar to SideFX Houdini. Can I open scenes made with the trial version in the commercial version? No. Files made with the trial version will appear scrambled with a commercial version. The trial version is however able to use files saved with a commercial version. Can I use my licence on more than one machine? Yes. You can activate and use each Ragdoll licence on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence. Can I move a licence between two machines? Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've activated) and the activation will be released. Do I need an internet connection to use Ragdoll? No. Activation can happen either offline or online, online happening from within Maya at the click of a button and offline being a 4-step process, see below . What if someone steals my licence key? That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one. Can I have a floating licence? Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All we need is you. Can I activate offline? Yes. See Offline Activation below. When exactly is internet required? A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain. Can I manage my licence via Python? Sure can, see below. Licence API As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Activation for those without access to Internet licence . activation_request_to_file ( key , fname ) licence . activate_from_file ( fname ) # Deactivate whatever key is currently activated licence . deactivate () # Deactivate offline, to e.g. move a licence from one machine to another licence . deactivation_request_to_file ( fname ) # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" : \"Your-Key\" , # Is the current licence activated? \"isActivated\" : True , # Is the current licence a trial licence? \"isTrial\" : False , # Has the licence not been tampered with? \"isGenuine\" : True , # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" : True , # How many days until this trial expires? \"trialDays\" : 23 } Offline Activation Haven't got no internet? No problem, here's what you need to do. Generate an \"activation request\", a file Send us this file, via email Receive a \"activation response\", another file Activate using this file It requires pasting some Python commands into the Maya Script Editor . Generate Request from ragdoll import licence key = \"YOUR-VERY-LONG-KEY-HERE\" fname = r \"c:\\ragdoll_activation_request.xml\" licence . activation_request_to_file ( key , fname ) Email Us Send this file to licencing@ragdolldynamics.com . We'll abrakadabra this file before you can say Taumatawhakatangi\u00adhangakoauauotamatea\u00adturipukakapikimaunga\u00adhoronukupokaiwhen\u00aduakitanatahu . Activate Once you've got a response, activate your licence like this. from ragdoll import licence fname = r \"c:\\ragdoll_activation_response.xml\" licence . activate_from_file ( fname ) Offline Deactivation Licences are node-locked (floating licences coming soon), which means that if you need to move a licence from one machine to another you can do so by deactivating an activated licence, and then activating it elsewhere. The process is similar to activation. Generate Request from ragdoll import licence fname = r \"c:\\ragdoll_deactivation_request.xml\" licence . deactivation_request_to_file ( fname ) Email Us Send this file to licencing@ragdolldynamics.com . Once we have confirmed receipt of this file, you will be able to re-activate Ragdoll on another machine. Offline Licence Roadmap Apologies for the tedious nature of offline licence management at the moment! Not long from now, you will be able to manage your licences online without sending any emails.","title":"Licencing"},{"location":"licencing/#faq","text":"Let's dive into specifics.","title":"FAQ"},{"location":"licencing/#how-does-it-work","text":"On first launch, Ragdoll will try and connect to the Ragdoll Licence Server and register your trial version. This version is node-locked to the particular machine you are on. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Enter your product key Click Activate Or if you prefer: from ragdoll import licence licence . activate ( key ) If internet is unavailable, Ragdoll enters \"offline mode\" and expires at a fixed date. Each new release is given an updated expiry date.","title":"How does it work?"},{"location":"licencing/#what-happens-when-my-trial-expires","text":"Any rdScene.enabled attribute will be set to False . Scenes will still load just fine and nothing else in your scene is affected. Once activated, the .enabled attribute will return to normal.","title":"What happens when my trial expires?"},{"location":"licencing/#can-i-renew-my-trial-licence","text":"Possibly. Reach out to us if this is relevant to you. We're contemplating a permanently active \"Personal Learning Edition\" with limitations on what you can do commercially, similar to SideFX Houdini.","title":"Can I renew my trial licence?"},{"location":"licencing/#can-i-open-scenes-made-with-the-trial-version-in-the-commercial-version","text":"No. Files made with the trial version will appear scrambled with a commercial version. The trial version is however able to use files saved with a commercial version.","title":"Can I open scenes made with the trial version in the commercial version?"},{"location":"licencing/#can-i-use-my-licence-on-more-than-one-machine","text":"Yes. You can activate and use each Ragdoll licence on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence.","title":"Can I use my licence on more than one machine?"},{"location":"licencing/#can-i-move-a-licence-between-two-machines","text":"Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've activated) and the activation will be released.","title":"Can I move a licence between two machines?"},{"location":"licencing/#do-i-need-an-internet-connection-to-use-ragdoll","text":"No. Activation can happen either offline or online, online happening from within Maya at the click of a button and offline being a 4-step process, see below .","title":"Do I need an internet connection to use Ragdoll?"},{"location":"licencing/#what-if-someone-steals-my-licence-key","text":"That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one.","title":"What if someone steals my licence key?"},{"location":"licencing/#can-i-have-a-floating-licence","text":"Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All we need is you.","title":"Can I have a floating licence?"},{"location":"licencing/#can-i-activate-offline","text":"Yes. See Offline Activation below.","title":"Can I activate offline?"},{"location":"licencing/#when-exactly-is-internet-required","text":"A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain.","title":"When exactly is internet required?"},{"location":"licencing/#can-i-manage-my-licence-via-python","text":"Sure can, see below.","title":"Can I manage my licence via Python?"},{"location":"licencing/#licence-api","text":"As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Activation for those without access to Internet licence . activation_request_to_file ( key , fname ) licence . activate_from_file ( fname ) # Deactivate whatever key is currently activated licence . deactivate () # Deactivate offline, to e.g. move a licence from one machine to another licence . deactivation_request_to_file ( fname ) # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" : \"Your-Key\" , # Is the current licence activated? \"isActivated\" : True , # Is the current licence a trial licence? \"isTrial\" : False , # Has the licence not been tampered with? \"isGenuine\" : True , # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" : True , # How many days until this trial expires? \"trialDays\" : 23 }","title":"Licence API"},{"location":"licencing/#offline-activation","text":"Haven't got no internet? No problem, here's what you need to do. Generate an \"activation request\", a file Send us this file, via email Receive a \"activation response\", another file Activate using this file It requires pasting some Python commands into the Maya Script Editor . Generate Request from ragdoll import licence key = \"YOUR-VERY-LONG-KEY-HERE\" fname = r \"c:\\ragdoll_activation_request.xml\" licence . activation_request_to_file ( key , fname ) Email Us Send this file to licencing@ragdolldynamics.com . We'll abrakadabra this file before you can say Taumatawhakatangi\u00adhangakoauauotamatea\u00adturipukakapikimaunga\u00adhoronukupokaiwhen\u00aduakitanatahu . Activate Once you've got a response, activate your licence like this. from ragdoll import licence fname = r \"c:\\ragdoll_activation_response.xml\" licence . activate_from_file ( fname )","title":"Offline Activation"},{"location":"licencing/#offline-deactivation","text":"Licences are node-locked (floating licences coming soon), which means that if you need to move a licence from one machine to another you can do so by deactivating an activated licence, and then activating it elsewhere. The process is similar to activation. Generate Request from ragdoll import licence fname = r \"c:\\ragdoll_deactivation_request.xml\" licence . deactivation_request_to_file ( fname ) Email Us Send this file to licencing@ragdolldynamics.com . Once we have confirmed receipt of this file, you will be able to re-activate Ragdoll on another machine.","title":"Offline Deactivation"},{"location":"licencing/#offline-licence-roadmap","text":"Apologies for the tedious nature of offline licence management at the moment! Not long from now, you will be able to manage your licences online without sending any emails.","title":"Offline Licence Roadmap"},{"location":"menu/","text":"All items found in the Ragdoll menu at the top of Maya's main window. Add menu items to your shelf with Ctrl + Shift + Click Overview Item Description Show Messages Display warnings and errors in the Message Board Active Rigid Customise the creation of a new rigid body. Active Chain Create a series of connected rigid bodies. Passive Rigid Customise the creation of a new passive rigid body. Muscle Make a muscle from the selected anchor points. Constraint Constrain one rigid to another. Point Constrain the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. Parent Constrain both the position and orientation of two rigid bodies. Hinge A special kind of Socket Constraint Socket Constrain the position and limit the orientation between two rigid bodies. Animation Constraint Convert translate/rotate channels into a target guide. Hard Pin Pin a rigid body in worldspace. Soft Pin Pin a rigid body in worldspace, with a spring-like softness. Push Push rigids away from a point in space. Pull Pull rigids towards a point in space. Directional Like gravity, except in any arbitrary direction. Wind Create a force similar to wind, with editable turbulence. Visualiser Visualise 3D forces with a 2D slice, much like an MRI. Assign Force to Selected Rigid(s) Assign force to the selected rigids. Character Generate a character from the selected joint hierarchy. Create Dynamic Control Create a new dynamic control from the currently selected regular control(s). Multiply Selected Rigids Multiply keyable attributes on multiple rigid at once. Multiply Selected Constraints Multiply keyable attributes on multiple constraints at once. Export Physics Save physics to disk. Import Physics Load physics from disk. Edit Constraint Pivots Edit the parent and child pivots using native Maya transforms Edit Shape Edit the shape offset and shape rotation attributes with a native Maya transform. Duplicate Selected Create a new rigid, using the selected rigid as a template for position, orientation and shape. Transfer Attributes Copy attributes from one rigid body to another. Convert to Polygons Convert selected rigids and controls into polygons. Normalise Shapes Resize shapes within a hierarchy to avoid some being too different. Set Initial State Re-establish the starting position and orientation of selected rigids. Delete Physics Clear the Maya scene of anything related to Ragdoll. Ragdoll Explorer Explore the internals of the solver. Ragdoll Preferences Edit global Ragdoll preferences, like the scale at which Ragdoll draws things. Save Preferences Save Ragdoll preferences to disk. Reset Preferences Restore Ragdoll preferences to their default values. Select Rigids Select all rigids, or filter rigids from selection. Select Constraints Select all constraints, or filter constraints from selection. Select Scenes Select all scenes, or filter scenes from selection. Select Controls Select all controls, or filter controls from selection. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though. More Print all messages you can think of. Default Print only messages that may be interesting, but probably aren't. Less Don't print anything unless it's something I need to pay attention to. Off Stay quiet. Create The top part of the menu contain commands to create new rigids. Active Rigid The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box. Rigids either output or input a transform. The active rigid outputs a transform, passing information from solver into your Maya scene. Basics Basics Turn any native Maya polygon or NURBS object into a rigid by selecting it and clicking 'Active Rigid'. Multiple Selection Multiple Selection When two or more objects are selected - whether it be polygons, NURBS or joints - they'll all be turned into rigids. Blend Existing Animation Blend Existing Animation If the selected node(s) are animated, the animation can be used as a target for the subsequent simulation using the 'Blend' option. Blend and Edit Blend and Edit Once turned into rigids, your original animation remains intact and can be edited just like before. You can also blend between the original input and final simulation via the blendSimulation node. Passive Rigid The passive rigid body feeds data from your animation control to Ragdoll, rather than the other way around like the Active Rigid. It's used to pass animation straight into the solver, without modifying it with forces or contacts. That also means passive rigids can travel straight through other rigids if not careful. You can think of a Passive Rigid as a physical object of infinite mass; nothing gets in its way. Basics Basics Turn any polygonal, NURBS surface or joint into a rigid which can be animated but isn't affected by the simulation. Muscle The muscle is a regular Active Rigid with two additional Point Constraints added to either end. The benefit is simply less clicks required. Option Description Default Aim Axis Which axis to treat as aim for the resulting muscle. X Up Axis Which axis to treat as the up-axis for the resulting muscle. Y Flex How much to allow the muscle to contract, from not-at-all to all-the-way. 0.75 Radius Capsule radius, how thick of a muscle to make. 1.0 Constraint Like normal Maya constraints, these limit the motion of one rigid relative another. For example, the Parent Constraint will make one rigid move as though it was a child of the other, whereas the Point Constraint will only limit position whilst letting orientation roam free. Option Description Default Constraint Type The type of constraint created. Point Maintain Offset Keep rigids where they are, or snap them together. Offsets can be manipulated with the Edit Constraint Frames menu item. True Auto Orient Orient constraint automatically by aiming towards the immediate child. Otherwise use the local orientation of the node. True Use Rotate Pivot Use rotate pivot of child as offset for the constraint frames. True Guide Strength Include some guide strength with this constraint. 1.0 Point Constrain the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship. Parent Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid. Socket Constrain the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints. Hinge A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well suited for hinge-like appendages, like elbows and knees. Control High-level control, either direct (kinematic, passive) or indirect (driven, guided). Kinematic Control Pin the selected rigid body at its current worldspace position. The pin may be animated and disabled/enabled at run-time. Option Description Default No Options Guide Control Guide the selected rigid body towards its current worldspace position. The guide may be animated and disabled/enabled at run-time. Option Description Default No Options Forces Apply an external force to rigids. Kind of like constraints, except rigids are effected independently instead of relative another rigid. Push Force This forces applies a force facing away from a point in space. It can be used for things like explosions. Option Description Default No Options Pull Force This is technically the same as 'Push', except the opposite. Instead of pushing rigids away from a point in space, rigids are pull towards it. This can be used for effects like black holes, or to simply nudge a rigid in some specific direction. Option Description Default No Options Directional Force Gravity is computed deep within the solver and isn't technically applied as an external force, but apart form that this force replicates gravity in addition to letting you control the direction. Option Description Default No Options Wind Force Wind is a complex phenomena. This force applies an iterative, 3D Perlin noise field to rigid bodies and is a great representation of how wind looks and acts in the real world. Use 'Visualiser' to get a sense of how it looks. Option Description Default No Options Visualiser This creates a 2-dimensonal representation of either all or selected 3-dimensional forces. The slice can be moved and scaled just like any normal Maya transform, and the amount and length of samples can be manipulated (and even animated) interactively to get a fine-grained understanding of what your forces do to each rigid. Hint: Create multiple slices at various strategic locations in your scene to get an even greater understanding at specific areas. Option Description Default No Options Assign To Selected Forces are typically assigned to all existing rigids when created, or to the currently selected rigids. This command lets you add forces to rigids manually. Forces can be removed by breaking their connection to each other. Option Description Default No Options Utilities High-level tools for animators and riggers that build upon the lower-level concepts above. Everything here can be created manually using a combination of the above commands or by making the connections yourself. Character An auto-rigger, designed to automatically generate an animatable character from a skeletal hierarchy. Option Description Default Copy Turn a copy of the selected hierarchy into a character, rather than the hierarchy itself. True Control Create an additional control hierarchy from generated character. True Normalise Shapes Make sure shapes are relatively evenly sized. This can help prevent 'stick-figures' which are tougher to control. Stop Behaviour Whether to include the joint with a 'Stop' label in the generated character or not. Inclusive Dynamic Control Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between. Basics Basics Turn any FK hierarchy into a dynamic chain. Every other control Every other control Skip some FK controls, for a simplified dynamic hierarchy. Global Preferences Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend. Option Description Default Gizmo Scale Scale at which to draw viewport widgets, like constraints. 1.0 Cache Media Cache clips in the timeline, for immediate feedback when scroll. - Off Fast, interactive but no scrubbing. - On Slow scrubbing support. - All Interactive scrubbing at the expense of RAM.< Off Auto Initial State (Requires scene reopen) Whether or not to use the pose of a rigid at the start time as the active initial state. This feature records the pose from frame 1 at frame 2, by inserting itself in between finished evaluation of frame 1 and yet-to-begin evaluation of frame 2. True Auto Return To Start Automatically return to the start frame whenever creating new rigid bodies. True Cycle Protection Protect against accidental cycles. True DG Viewport Fix Improve viewport robustness when simulating in DG Evaluation mode, by calling ogs -reset on the start frame. Bear in mind this action is global to Maya and may negatively (or positively) affect other nodes in your scene. Validate Evaluation Mode Check whether Maya is evaluating in Parallel or Serial whenever creating a new scene, as DG is slow and error-prone. True Validate Caching Mode Check whether Maya is caching dynamics, which is required in order for Cached Playback to work with Ragdoll. True Validate Legacy Open Gl Check whether Viewport 2.0 is set to render using Legacy OpenGL. That isn't supported. True Validate Scale Pivot Check whether the selected transform has a non-zero scalePivot; they are unsupported and will be zeroed out. Validate Rotate Axis Let the user know of a Ragdoll limitation, that a custom rotate axis are unsupported. Validate Playback Speed Make sure Maya's playback speed is set to 'Play every frame'. True Help The Ragdoll user interfaces double as a place for help. The information is generated from the same source as this website, so as to be available wherever you are; without breaking your flow . Help Page The page can also be accessed by clicking on the top description. You can find hints about each option by hovering over it. Timeline Available videos regarding any menu item is visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about.","title":"Menu Reference"},{"location":"menu/#overview","text":"Item Description Show Messages Display warnings and errors in the Message Board Active Rigid Customise the creation of a new rigid body. Active Chain Create a series of connected rigid bodies. Passive Rigid Customise the creation of a new passive rigid body. Muscle Make a muscle from the selected anchor points. Constraint Constrain one rigid to another. Point Constrain the position of two rigid bodies. Orient Constrain the orientation of two rigid bodies. Parent Constrain both the position and orientation of two rigid bodies. Hinge A special kind of Socket Constraint Socket Constrain the position and limit the orientation between two rigid bodies. Animation Constraint Convert translate/rotate channels into a target guide. Hard Pin Pin a rigid body in worldspace. Soft Pin Pin a rigid body in worldspace, with a spring-like softness. Push Push rigids away from a point in space. Pull Pull rigids towards a point in space. Directional Like gravity, except in any arbitrary direction. Wind Create a force similar to wind, with editable turbulence. Visualiser Visualise 3D forces with a 2D slice, much like an MRI. Assign Force to Selected Rigid(s) Assign force to the selected rigids. Character Generate a character from the selected joint hierarchy. Create Dynamic Control Create a new dynamic control from the currently selected regular control(s). Multiply Selected Rigids Multiply keyable attributes on multiple rigid at once. Multiply Selected Constraints Multiply keyable attributes on multiple constraints at once. Export Physics Save physics to disk. Import Physics Load physics from disk. Edit Constraint Pivots Edit the parent and child pivots using native Maya transforms Edit Shape Edit the shape offset and shape rotation attributes with a native Maya transform. Duplicate Selected Create a new rigid, using the selected rigid as a template for position, orientation and shape. Transfer Attributes Copy attributes from one rigid body to another. Convert to Polygons Convert selected rigids and controls into polygons. Normalise Shapes Resize shapes within a hierarchy to avoid some being too different. Set Initial State Re-establish the starting position and orientation of selected rigids. Delete Physics Clear the Maya scene of anything related to Ragdoll. Ragdoll Explorer Explore the internals of the solver. Ragdoll Preferences Edit global Ragdoll preferences, like the scale at which Ragdoll draws things. Save Preferences Save Ragdoll preferences to disk. Reset Preferences Restore Ragdoll preferences to their default values. Select Rigids Select all rigids, or filter rigids from selection. Select Constraints Select all constraints, or filter constraints from selection. Select Scenes Select all scenes, or filter scenes from selection. Select Controls Select all controls, or filter controls from selection. Ragdoll View your version, and eventually look for updates and tutorials. Not yet though. More Print all messages you can think of. Default Print only messages that may be interesting, but probably aren't. Less Don't print anything unless it's something I need to pay attention to. Off Stay quiet.","title":"Overview"},{"location":"menu/#create","text":"The top part of the menu contain commands to create new rigids.","title":"Create"},{"location":"menu/#active-rigid","text":"The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box. Rigids either output or input a transform. The active rigid outputs a transform, passing information from solver into your Maya scene. Basics","title":"Active Rigid"},{"location":"menu/#passive-rigid","text":"The passive rigid body feeds data from your animation control to Ragdoll, rather than the other way around like the Active Rigid. It's used to pass animation straight into the solver, without modifying it with forces or contacts. That also means passive rigids can travel straight through other rigids if not careful. You can think of a Passive Rigid as a physical object of infinite mass; nothing gets in its way. Basics","title":"Passive Rigid"},{"location":"menu/#muscle","text":"The muscle is a regular Active Rigid with two additional Point Constraints added to either end. The benefit is simply less clicks required. Option Description Default Aim Axis Which axis to treat as aim for the resulting muscle. X Up Axis Which axis to treat as the up-axis for the resulting muscle. Y Flex How much to allow the muscle to contract, from not-at-all to all-the-way. 0.75 Radius Capsule radius, how thick of a muscle to make. 1.0","title":"Muscle"},{"location":"menu/#constraint","text":"Like normal Maya constraints, these limit the motion of one rigid relative another. For example, the Parent Constraint will make one rigid move as though it was a child of the other, whereas the Point Constraint will only limit position whilst letting orientation roam free. Option Description Default Constraint Type The type of constraint created. Point Maintain Offset Keep rigids where they are, or snap them together. Offsets can be manipulated with the Edit Constraint Frames menu item. True Auto Orient Orient constraint automatically by aiming towards the immediate child. Otherwise use the local orientation of the node. True Use Rotate Pivot Use rotate pivot of child as offset for the constraint frames. True Guide Strength Include some guide strength with this constraint. 1.0","title":"Constraint"},{"location":"menu/#point","text":"Constrain the position of two rigid bodies.","title":"Point"},{"location":"menu/#orient","text":"Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship.","title":"Orient"},{"location":"menu/#parent","text":"Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid.","title":"Parent"},{"location":"menu/#socket","text":"Constrain the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints.","title":"Socket"},{"location":"menu/#hinge","text":"A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well suited for hinge-like appendages, like elbows and knees.","title":"Hinge"},{"location":"menu/#control","text":"High-level control, either direct (kinematic, passive) or indirect (driven, guided).","title":"Control"},{"location":"menu/#kinematic-control","text":"Pin the selected rigid body at its current worldspace position. The pin may be animated and disabled/enabled at run-time. Option Description Default No Options","title":"Kinematic Control"},{"location":"menu/#guide-control","text":"Guide the selected rigid body towards its current worldspace position. The guide may be animated and disabled/enabled at run-time. Option Description Default No Options","title":"Guide Control"},{"location":"menu/#forces","text":"Apply an external force to rigids. Kind of like constraints, except rigids are effected independently instead of relative another rigid.","title":"Forces"},{"location":"menu/#push-force","text":"This forces applies a force facing away from a point in space. It can be used for things like explosions. Option Description Default No Options","title":"Push Force"},{"location":"menu/#pull-force","text":"This is technically the same as 'Push', except the opposite. Instead of pushing rigids away from a point in space, rigids are pull towards it. This can be used for effects like black holes, or to simply nudge a rigid in some specific direction. Option Description Default No Options","title":"Pull Force"},{"location":"menu/#directional-force","text":"Gravity is computed deep within the solver and isn't technically applied as an external force, but apart form that this force replicates gravity in addition to letting you control the direction. Option Description Default No Options","title":"Directional Force"},{"location":"menu/#wind-force","text":"Wind is a complex phenomena. This force applies an iterative, 3D Perlin noise field to rigid bodies and is a great representation of how wind looks and acts in the real world. Use 'Visualiser' to get a sense of how it looks. Option Description Default No Options","title":"Wind Force"},{"location":"menu/#visualiser","text":"This creates a 2-dimensonal representation of either all or selected 3-dimensional forces. The slice can be moved and scaled just like any normal Maya transform, and the amount and length of samples can be manipulated (and even animated) interactively to get a fine-grained understanding of what your forces do to each rigid. Hint: Create multiple slices at various strategic locations in your scene to get an even greater understanding at specific areas. Option Description Default No Options","title":"Visualiser"},{"location":"menu/#assign-to-selected","text":"Forces are typically assigned to all existing rigids when created, or to the currently selected rigids. This command lets you add forces to rigids manually. Forces can be removed by breaking their connection to each other. Option Description Default No Options","title":"Assign To Selected"},{"location":"menu/#utilities","text":"High-level tools for animators and riggers that build upon the lower-level concepts above. Everything here can be created manually using a combination of the above commands or by making the connections yourself.","title":"Utilities"},{"location":"menu/#character","text":"An auto-rigger, designed to automatically generate an animatable character from a skeletal hierarchy. Option Description Default Copy Turn a copy of the selected hierarchy into a character, rather than the hierarchy itself. True Control Create an additional control hierarchy from generated character. True Normalise Shapes Make sure shapes are relatively evenly sized. This can help prevent 'stick-figures' which are tougher to control. Stop Behaviour Whether to include the joint with a 'Stop' label in the generated character or not. Inclusive","title":"Character"},{"location":"menu/#dynamic-control","text":"Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between. Basics","title":"Dynamic Control"},{"location":"menu/#global-preferences","text":"Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend. Option Description Default Gizmo Scale Scale at which to draw viewport widgets, like constraints. 1.0 Cache Media Cache clips in the timeline, for immediate feedback when scroll. - Off Fast, interactive but no scrubbing. - On Slow scrubbing support. - All Interactive scrubbing at the expense of RAM.< Off Auto Initial State (Requires scene reopen) Whether or not to use the pose of a rigid at the start time as the active initial state. This feature records the pose from frame 1 at frame 2, by inserting itself in between finished evaluation of frame 1 and yet-to-begin evaluation of frame 2. True Auto Return To Start Automatically return to the start frame whenever creating new rigid bodies. True Cycle Protection Protect against accidental cycles. True DG Viewport Fix Improve viewport robustness when simulating in DG Evaluation mode, by calling ogs -reset on the start frame. Bear in mind this action is global to Maya and may negatively (or positively) affect other nodes in your scene. Validate Evaluation Mode Check whether Maya is evaluating in Parallel or Serial whenever creating a new scene, as DG is slow and error-prone. True Validate Caching Mode Check whether Maya is caching dynamics, which is required in order for Cached Playback to work with Ragdoll. True Validate Legacy Open Gl Check whether Viewport 2.0 is set to render using Legacy OpenGL. That isn't supported. True Validate Scale Pivot Check whether the selected transform has a non-zero scalePivot; they are unsupported and will be zeroed out. Validate Rotate Axis Let the user know of a Ragdoll limitation, that a custom rotate axis are unsupported. Validate Playback Speed Make sure Maya's playback speed is set to 'Play every frame'. True","title":"Global Preferences"},{"location":"menu/#help","text":"The Ragdoll user interfaces double as a place for help. The information is generated from the same source as this website, so as to be available wherever you are; without breaking your flow .","title":"Help"},{"location":"menu/#help-page","text":"The page can also be accessed by clicking on the top description. You can find hints about each option by hovering over it.","title":"Help Page"},{"location":"menu/#timeline","text":"Available videos regarding any menu item is visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about.","title":"Timeline"},{"location":"no-javascript/","text":"Got'cha! You've just been redirected from a JavaScript-heavy landing page, but your browser won't permit JavaScript. Continue Try again","title":"No javascript"},{"location":"nodes/","text":"Detailed information about all of Ragdoll's custom nodes along with the most commonly used attributes. For full attribute reference, see the link at the bottom of each node type, such as rdRigid . Each Ragdoll node starts with rd , e.g. rdRigid Scene Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Parallelism Ragdoll scenes support both scene-level parallelism and node-level parallelism. Scene-level parallelism happens when there are more than one Ragdoll scene present, each scene is then run in parallel for improved performance. For that reason, prefer using as many scenes as possible, especially if they are unlikely to interact. Node-level Parallelism happens internally, whereby a single simulation is distributed over multiple threads. The behavior can be tuned via the rdScene.threadCount attribute. Keep this at 0 when your scenes are small, i.e. < 100 rigids. The overhead of splitting up a simulation outweighs the benefit unless there is a lot to split. You should notice a performance difference in either direction as you manipulate this attribute. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .groundRestitution Bounciness of the ground plane. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference Rigid A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Active Rigid pass data from Ragdoll to Maya Passive Rigid pass data from Maya to Ragdoll Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference Constraint A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference Control A placeholder for drawing a rigid under a different transform. This node is cosmetic only. It helps you spot the rigid and rigid orientation in the viewport for a standalone controller, like a Guide . It also draws the node with a special icon in the outliner. But that's about it! Full Reference Constraint Multiplier Multiply one or more attributes of one or more constraints . This node enables you to animate one attribute that affect many attributes, like Translate Guide Stiffness across an entire character or limb. Attribute Description Type .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping float .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness float .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping float .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness float .driveStrength Multiplier for rdConstraint.driveStrength float .limitStrength Multiplier for rdConstraint.limitStrength float .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping float .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness float .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping float .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness float Full Reference Rigid Multiplier Multiply one or more attributes of one or more rigids . This node enables you to animate one attribute that affect many attributes, like Air Density across an entire character or limb. Attribute Description Type .airDensity Multiplier for rdRigid.airDensity float .angularDamping Multiplier for rdRigid.angularDamping float .linearDamping Multiplier for rdRigid.linearDamping float Full Reference Other Notes on general concepts used in Ragdoll. Backwards Compatibility Default values never change, those written into the node type itself Initial values may change, those set during node-creation This means previously authored scenes will always behave the same, whilst still enabling new default values for future versions and future authored physics. Exclusive Nodes Ragdoll consists of a few new native types, like rdRigid and rdConstraint . During creation, Ragdoll may generate Maya-native types too, like multMatrix and composeMatrix . Those nodes are exclusive to Ragdoll and should be removed alongside them. This is managed via the so-called .exclusiveNodes attribute on each Ragdoll node type. User Attributes Whenever Ragdoll attributes appear on your original animation controls, they are referred to as \"user attributes\" by Ragdoll and tracked via the .userAttributes attribute on each Ragdoll node. These attributes are exclusive to Ragdoll and are removed alongside the Ragdoll node types they interact with.","title":"Node Reference"},{"location":"nodes/#scene","text":"Container of all rigids, constraints and forces that interact. The scene represents the knowledge each simulation has, including rigids and their properties, constraints, forces. The works. There can be more than one Ragdoll scene in your Maya scene, but much like Maya scenes they cannot interact. The order in which scenes are simulated is also undefined, so you cannot expect e.g. fingers in one solver to run after the body in another solver. Parallelism Ragdoll scenes support both scene-level parallelism and node-level parallelism. Scene-level parallelism happens when there are more than one Ragdoll scene present, each scene is then run in parallel for improved performance. For that reason, prefer using as many scenes as possible, especially if they are unlikely to interact. Node-level Parallelism happens internally, whereby a single simulation is distributed over multiple threads. The behavior can be tuned via the rdScene.threadCount attribute. Keep this at 0 when your scenes are small, i.e. < 100 rigids. The overhead of splitting up a simulation outweighs the benefit unless there is a lot to split. You should notice a performance difference in either direction as you manipulate this attribute. Attribute Description Type .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. time .enabled State of the solver. An enabled solver will update whenever time changes. bool .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 .groundFriction Friction of the ground. float .groundRestitution Bounciness of the ground plane. float .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool Full Reference","title":"Scene"},{"location":"nodes/#rigid","text":"A single transform in or out of Ragdoll. The rigid is the physical equivalent of native Maya geometry. It can either feed into the simulation (passive) or come out of the simulation (active). Active Rigid pass data from Ragdoll to Maya Passive Rigid pass data from Maya to Ragdoll Attribute Description Type .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. float .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. float .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float .inputMatrix Passive position and orientation, this may be animated. matrix .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. matrix .kinematic Whether this rigid should be affected by contacts, constraints and forces. bool .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. float .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float .shapeExtents The dimensions of the 'Box' shapeType . float3 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float Full Reference","title":"Rigid"},{"location":"nodes/#constraint","text":"A relationship between two rigids. Typically this relationship is something to limit one or more axes - e.g. translateXYZ and rotateZ - of one rigid relative another rigid, like a door \"constrained\" to a wall. In that case, the wall would be considered a \"parent\" and the door a \"child\". However it is important to keep in mind that in the real world, there is no such thing. The door is as constrained to the wall as the wall is constrained to the door. This is especially apparent when the two constrained rigids are both active and have a similar mass, such as your upper and lower leg. As you bend your knee, both the thigh and lower leg are affected equally. Attribute Description Type .angularDriveDamping Angular damping of the drive. float .angularDriveStiffness Angular stiffness of the drive. float .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. float .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. float .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. bool .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . matrix .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. float .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. bool .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. float .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. float .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. float .linearLimitDamping Damping factor for contacts with the limit. float .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. float Full Reference","title":"Constraint"},{"location":"nodes/#control","text":"A placeholder for drawing a rigid under a different transform. This node is cosmetic only. It helps you spot the rigid and rigid orientation in the viewport for a standalone controller, like a Guide . It also draws the node with a special icon in the outliner. But that's about it! Full Reference","title":"Control"},{"location":"nodes/#constraint-multiplier","text":"Multiply one or more attributes of one or more constraints . This node enables you to animate one attribute that affect many attributes, like Translate Guide Stiffness across an entire character or limb. Attribute Description Type .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping float .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness float .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping float .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness float .driveStrength Multiplier for rdConstraint.driveStrength float .limitStrength Multiplier for rdConstraint.limitStrength float .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping float .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness float .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping float .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness float Full Reference","title":"Constraint Multiplier"},{"location":"nodes/#rigid-multiplier","text":"Multiply one or more attributes of one or more rigids . This node enables you to animate one attribute that affect many attributes, like Air Density across an entire character or limb. Attribute Description Type .airDensity Multiplier for rdRigid.airDensity float .angularDamping Multiplier for rdRigid.angularDamping float .linearDamping Multiplier for rdRigid.linearDamping float Full Reference","title":"Rigid Multiplier"},{"location":"nodes/#other","text":"Notes on general concepts used in Ragdoll.","title":"Other"},{"location":"nodes/#backwards-compatibility","text":"Default values never change, those written into the node type itself Initial values may change, those set during node-creation This means previously authored scenes will always behave the same, whilst still enabling new default values for future versions and future authored physics.","title":"Backwards Compatibility"},{"location":"nodes/#exclusive-nodes","text":"Ragdoll consists of a few new native types, like rdRigid and rdConstraint . During creation, Ragdoll may generate Maya-native types too, like multMatrix and composeMatrix . Those nodes are exclusive to Ragdoll and should be removed alongside them. This is managed via the so-called .exclusiveNodes attribute on each Ragdoll node type.","title":"Exclusive Nodes"},{"location":"nodes/#user-attributes","text":"Whenever Ragdoll attributes appear on your original animation controls, they are referred to as \"user attributes\" by Ragdoll and tracked via the .userAttributes attribute on each Ragdoll node. These attributes are exclusive to Ragdoll and are removed alongside the Ragdoll node types they interact with.","title":"User Attributes"},{"location":"overview/","text":"Ragdoll is a real-time physics solver for Maya, similar the native nCloth and nHair solvers except it works on transforms rather than points. That makes it better equipt to integrate with your existing animation controls and doesn't require translating from points like people did in the 90's. This domain contains Ragdoll learning resources, for a more general overview see the Product Page . Where to Find Help? Depending on where you are and what you are looking for, one of these should fit the bill. Source Description Release Notes Every new release comes with examples of every new feature and squashed bug. Search Top-right on this website there's a field to search for any word or phrase on this domain, including node attribute reference. UI Help Find help without leaving Maya YouTube Videos Long-form walkthroughs and examples. Tutorials (Coming soon) Long-form, written tutorials are about to appear on this website, watch this space. Examples Download and play around with some example scenes. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . Community Inspire and be inspired via the Ragdoll forums Support Get us involved and let's make some waves What's Next? Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch Me I've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"Overview"},{"location":"overview/#where-to-find-help","text":"Depending on where you are and what you are looking for, one of these should fit the bill. Source Description Release Notes Every new release comes with examples of every new feature and squashed bug. Search Top-right on this website there's a field to search for any word or phrase on this domain, including node attribute reference. UI Help Find help without leaving Maya YouTube Videos Long-form walkthroughs and examples. Tutorials (Coming soon) Long-form, written tutorials are about to appear on this website, watch this space. Examples Download and play around with some example scenes. Reference The Reference page lists all menu items, item options and node attributes of Ragdoll along with descriptions and examples. Node Reference Every node is detailed in the \"Nodes\" section to the right, such as rdRigid . Community Inspire and be inspired via the Ragdoll forums Support Get us involved and let's make some waves","title":"Where to Find Help?"},{"location":"overview/#whats-next","text":"Here are some options for getting into Ragdoll. Route Description Install & Explore Tried and true, who reads documentation anyway? Watch Me I've made a number of videos demonstrating how to use Ragdoll. Read All About It Keep clicking that next button at the bottom of every page.","title":"What's Next?"},{"location":"physics/","text":"Constraint Every object in the real world can move along 6 different axes, or 6 \"degrees of freedom\". Translate X Translate Y Translate Z Rotate X Rotate Y Rotate Z A constraint limits one or more of these axes. In Maya, the most typical form of constraint is locking a channel. This prevents this axis from changing. A value < 0 means LOCKED , meaning it may not move along this axis A value = 0 means FREE , meaning it may freely move along this axis A value > 0 means LIMITED , meaning it may move within the limited range of this axis Soft Constraints Limits above 0 are referred to as \"soft\", because their amount of influence can be tuned using the Stiffness and Damping attributes. These can safely flex and can approach that of a hard constraint given enough stiffness and damping, but would struggle to reach a given target 100%. Hard Constraints Limits below 0, typically -1, are referred to as \"hard\", because their influence is infinite. These should never flex, as even the slightest amount of flex means the constraint has broken . Leaving the solver in a poor state, struggling to keep up.","title":"Physics"},{"location":"physics/#constraint","text":"Every object in the real world can move along 6 different axes, or 6 \"degrees of freedom\". Translate X Translate Y Translate Z Rotate X Rotate Y Rotate Z A constraint limits one or more of these axes. In Maya, the most typical form of constraint is locking a channel. This prevents this axis from changing. A value < 0 means LOCKED , meaning it may not move along this axis A value = 0 means FREE , meaning it may freely move along this axis A value > 0 means LIMITED , meaning it may move within the limited range of this axis","title":"Constraint"},{"location":"physics/#soft-constraints","text":"Limits above 0 are referred to as \"soft\", because their amount of influence can be tuned using the Stiffness and Damping attributes. These can safely flex and can approach that of a hard constraint given enough stiffness and damping, but would struggle to reach a given target 100%.","title":"Soft Constraints"},{"location":"physics/#hard-constraints","text":"Limits below 0, typically -1, are referred to as \"hard\", because their influence is infinite. These should never flex, as even the slightest amount of flex means the constraint has broken . Leaving the solver in a poor state, struggling to keep up.","title":"Hard Constraints"},{"location":"quick-tail-setup/","text":"In this tutorial you'll learn how to setup a tail with physics and how to steer the look and feel of the simulation using normal keyframing techniques. We'll use one of the excellent rigs by Truong CG Artist . Optional example files falloff_example.zip Walkcycle Let's start with a walkcycle, and move towards interacting with the environment. Apply Simulation Select the hip followed by each tail control along the tail in order, and click Create Dynamic Control . Reduce Gravity This particular rig is very small, about 1.6 cm tall, so we need to reduce the default Gravity to reflect this. Global Strength The first selected Dynamic Control contains a Guide Multiplier to influence the strength on all of the tail controls at the same time. Local Strength You can also adjust the strength values individually for each joints, to taper their stiffness along the length of the tail. Strength Falloff Let's taper the strength along the length of the tail. Result Let's see how it looks. Sitting Down Now let's see how to steer our simulation with regular keyframes. Switch to Animation The simulation will try to follow your keyframe animation. Just switch off the Simulated attribute on the root control while you're animating, then switch it back on to see how it looks. Animation vs Simulation You can see the animation input on the left and the resulting simulation on the right. With just 3 keyframed poses we end up with this result. Note that I had to overcompensate my animation poses to fight gravity when the tail swings around. Advanced Control Gain even more fine-grained control with these advanced topics. Flex and Relax Muscles By keyframing the root strength multiplier you can flex or relax the muscles in the tail. The higher the value the stiffer it gets and the lower the value the more relaxed it becomes, allowing gravity to drop it to the ground. Damping Damping controls how fleshy and sluggish your simulation behaves. Low or zero damping preserves more energy in the system, making a simulation more elastic or rubbery. Creatures and humans tend to look best with moderate to high damping values.","title":"Quick Tail Setup"},{"location":"quick-tail-setup/#walkcycle","text":"Let's start with a walkcycle, and move towards interacting with the environment.","title":"Walkcycle"},{"location":"quick-tail-setup/#apply-simulation","text":"Select the hip followed by each tail control along the tail in order, and click Create Dynamic Control .","title":"Apply Simulation"},{"location":"quick-tail-setup/#reduce-gravity","text":"This particular rig is very small, about 1.6 cm tall, so we need to reduce the default Gravity to reflect this.","title":"Reduce Gravity"},{"location":"quick-tail-setup/#global-strength","text":"The first selected Dynamic Control contains a Guide Multiplier to influence the strength on all of the tail controls at the same time.","title":"Global Strength"},{"location":"quick-tail-setup/#local-strength","text":"You can also adjust the strength values individually for each joints, to taper their stiffness along the length of the tail.","title":"Local Strength"},{"location":"quick-tail-setup/#strength-falloff","text":"Let's taper the strength along the length of the tail.","title":"Strength Falloff"},{"location":"quick-tail-setup/#result","text":"Let's see how it looks.","title":"Result"},{"location":"quick-tail-setup/#sitting-down","text":"Now let's see how to steer our simulation with regular keyframes.","title":"Sitting Down"},{"location":"quick-tail-setup/#switch-to-animation","text":"The simulation will try to follow your keyframe animation. Just switch off the Simulated attribute on the root control while you're animating, then switch it back on to see how it looks.","title":"Switch to Animation"},{"location":"quick-tail-setup/#animation-vs-simulation","text":"You can see the animation input on the left and the resulting simulation on the right. With just 3 keyframed poses we end up with this result. Note that I had to overcompensate my animation poses to fight gravity when the tail swings around.","title":"Animation vs Simulation"},{"location":"quick-tail-setup/#advanced-control","text":"Gain even more fine-grained control with these advanced topics.","title":"Advanced Control"},{"location":"quick-tail-setup/#flex-and-relax-muscles","text":"By keyframing the root strength multiplier you can flex or relax the muscles in the tail. The higher the value the stiffer it gets and the lower the value the more relaxed it becomes, allowing gravity to drop it to the ground.","title":"Flex and Relax Muscles"},{"location":"quick-tail-setup/#damping","text":"Damping controls how fleshy and sluggish your simulation behaves. Low or zero damping preserves more energy in the system, making a simulation more elastic or rubbery. Creatures and humans tend to look best with moderate to high damping values.","title":"Damping"},{"location":"releases/","text":"Stay up to date with the latest improvements and fixes to Ragdoll. 2021.04.23 - No Limits 2021.04.11 - JSON Import 2021.03.25 - Maya 2022 2021.03.23 - JSON Export 2021.03.11 - Localspace Simulation 2021.03.04 - Passive to Active Transitions 2021.03.01 - Auto Initial State 2021.02.07 - Scale 2021.01.27 - Message Board 2021.01.17 - Hotfix 2021.01.15 - Dynamic Control 3.0 2021.01.14 - Multiplier Nodes 2021.01.04 - Licencing 2020.12.18 - Documentation 2020.12.07 - Dynamic Control Improvements 2020.12.01 - Character 2.0 2020.11.24 - Hotfix 2020.11.23 - Dynamic Control 2.0 2020.11.22 - Bugfixes 2020.11.17 - Splash Screen 2020.11.16 - Cached Playback 2020.11.10 - Multi-threading","title":"Releases"},{"location":"serialisation/","text":"Serialise all rigid bodies to JSON, for import into external software such as Unreal, Unity, Godot, CryEngine or any other engine able to read and parse JSON, including your own custom game engine. Units All linear units are in centimeters All angular units are in radians All quaternions are ordered XYZW Overview On playback, Ragdoll generates a physical representation of your Maya scene, suitable for simulation. You can gain access to that representation, independent of Maya, for use in your own software and for your own purposes. This enables you to use Maya as an authoring environment for general-purpose physics scenes, including full or partial ragdolls, for characters or props and even full environments. Target Audience Game programmers working on a custom engine Technical Directors working with e.g. Unreal Engine, Unity or CryEngine Roboticists exploring algorithms on humanoids with rigid bodies Scientists in Machine Learning in need of bespoke ragdolls for their work Usecases Once a ragdoll has been authored in Maya, it can be exported for later import into external software for a variety of purposes. Game Development where main or secondary characters need a physics representation Virtual Production where you need Motion Builder or Unreal Engine to reproduce physics happening in Maya for real-time feedback Robotics where you want interactive control over parameters that are also applied to a physical real-world equivalent, like Boston Dynamics's Atlas Reinforcement Learning where algorithm and articulation depend on each other and are iterated upon in parallel, like OpenAI's gym environments and algorithms Debugging in cases where odd things happen and you just require deep insight into what the solver sees Concepts Ragdoll internally stores data as \"entities\" and \"components\". Entity is a unique identifier for any \"thing\" in the solver, like a rigid body, a constraint or force. Component is a set of data, like the transformation or rigid body properties, associated to an entity The exported format reflects this relationship and looks something like this. { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } } Rigid Body A single translation/rotation pair. Components Component Description NameComponent Name and path in Maya ColorComponent Used in Maya viewport SceneComponent Reference to the scene entity this rigid belongs to RestComponent Initial transformation RigidComponent Physics attributes GeometryDescriptionComponent Shape attributes \"RigidComponent\" : { \"type\" : \"RigidComponent\" , \"members\" : { \"enabled\" : true , \"mass\" : 1.0 , \"friction\" : 0.80 , \"restitution\" : 0.10 , \"thickness\" : 0.0 , \"disableGravity\" : false , \"collide\" : true , \"kinematic\" : false , \"dynamic\" : true , \"sleeping\" : false , \"linearDamping\" : 0.5 , \"angularDamping\" : 1.0 , \"positionIterations\" : 8 , \"velocityIterations\" : 1 , \"maxContactImpulse\" : - 1.0 , \"maxDepenetrationVelocity\" : - 1.0 , \"sleepThreshold\" : 0.00 , \"enableCCD\" : false , # A value of -1 means \"automatically computed\" \"angularMass\" : { \"type\" : \"Vector3\" , \"values\" : [ - 1.0 , - 1.0 , - 1.0 ] }, # A value of 0 means \"automatically computed\" \"centerOfMass\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.0 , 0.0 , 0.0 ] } } } Shape Every rigid has exactly one collision shape. The transformation of this shape can be optionally offset, and that offset happens in the frame of the rigid. ________ ^ |\\ \\ | | \\_______\\ | | | | o--\\-|-> | \\ \\|______| \\ v In this example, the center of the box is offset from the center of the rigid along the X axis. Notice how the geometry is relative the axis of the rigid, so rotating the rigid along the Z axis would naturally take the geometry with it. \"GeometryDescriptionComponent\" : { \"type\" : \"GeometryDescriptionComponent\" , \"members\" : { \"type\" : \"Capsule\" , # Used by Capsule \"length\" : 0.123 , # Used by Sphere \"radius\" : 0.012 , # Used by Box \"extents\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.123 , 0.024 , 0.0247 ] }, # Translation relative the associated rigid \"offset\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.033 , - 0.05 , 0.00 ] }, # Rotation relative the associated rigid # Ordered as XYZW \"rotation\" : { \"type\" : \"Quaternion\" , \"values\" : [ 0.87 , - 0.47 , 0.00 , 0.00 ] } } } Constraint A relationship between two rigid bodies is referred to as a \"constraint\". A constraint constrains the way two rigid bodies move relative each other. For example, the position of the lower arm is typically associated with the tip of the upper arm. Wherever the upper arm goes, the lower arm must follow. It may also be further limited in how it is oriented, to e.g. prevent a lower arm from bending past the natural elbow limit; i.e. to rotate between 20-180 degrees along the Z axis, and 0-10 degrees around the X and Y axis (as that rotation would normally come from twisting the upper arm). All constraints are bi-directional Rigid A attaches to B, as B attaches to A The point on A where B attaches is referred to as the parentFrame The point on B where A attaches is referred to as the childFrame Despite the name, there is no notion of hierarchy or \"parent\" in Ragdoll; the naming reflects the hierarchy as represented in Maya, where constraints are parented to the rigid representing the childFrame . Components Component Description JointComponent References to associated rigids and frame matrices LimitComponent Optional limits on translation and/or rotation DriveComponent Optional target transformation, i.e. the animation \"JointComponent\" : { \"type\" : \"JointComponent\" , \"members\" : { # Reference to the associated rigid body entities \"parent\" : 1048586 , \"child\" : 1048584 , # The translate/rotate of the parent # rigid in the frame of child rigid \"parentFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.760 , - 0.594 , - 0.259 , 0.0 , - 0.648 , - 0.680 , - 0.340 , 0.0 , 0.0262 , 0.4274 , - 0.903 , 0.0 , 10.51 , - 0.646 , 0.0 , 1.0 ] }, # The translate/rotate of the child # rigid in the frame of parent rigid \"childFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.606 , - 0.751 , - 0.259 , 0.0 , - 0.785 , - 0.515 , - 0.340 , 0.0 , 0.122 , 0.4103 , - 0.903 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] }, # Allow intersections between connected rigids \"disableCollision\" : true } } Limit Constraints may optionally have a \"limit\", which means it can keep a rigid within a given angle (\"angular limit\") or position (\"linear limit\"). Min & Max Values represent a upper end of a range . With x=5 the minimum value of the linear X axis is -5 . \"LimitComponent\" : { \"type\" : \"LimitComponent\" , \"members\" : { \"enabled\" : true , \"x\" : - 1.0 , # Linear limit along the X-axis \"y\" : - 1.0 , \"z\" : - 1.0 , \"twist\" : 0.78 , # Angular limit along the X-axis \"swing1\" : 0.78 , # ..Y \"swing2\" : 0.78 , # ..Z \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } } Locked, Free or Limited A value of -1 means the axis is \"Locked\", i.e. the value along this axis cannot change. A Point Constraint is typically locked on all linear axes, but free on the angular axes. A value of 0 means the axis if \"Free\", meaning it has no effect. It is \"limitless\". A value above 0 indicates the range of a given limit. <0 means Locked =0 means Free >0 means Limited Drive A constraint may optionally have a \"drive\", which means having one rigid reach a target position and/or angle relative another rigid. The typical use case is having simulation match your input animation, where the animation provides the positions and angles. \"DriveComponent\" : { \"type\" : \"DriveComponent\" , \"members\" : { \"enabled\" : true , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"acceleration\" : true , \"target\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.973 , 0.2267 , 0.0 , 0.0 , - 0.226 , 0.973 , 0.0 , 0.0 , 0.0 , 0.0 , 0.999 , 0.0 , 0.1051 , - 0.006 , 0.0 , 1.0 ] } } } Data Types In addition to the plain-old-data types int , double and bool , these are all possible data types found in the exported JSON. { \"type\" : \"Color4\" , \"values\" : [ 0.4429999887943268 , # red 0.7049999833106995 , # green 0.9520000219345093 # blue 1.0 # alpha ] } { \"type\" : \"Vector3\" , \"values\" : [ 100.00001788139201 , # x 100.00001788139201 , # y 100.00000000000003 # z ] } { \"type\" : \"Quaternion\" , \"values\" : [ 0.8791841887437938 , # x - 0.47648206919348187 , # y - 2.7953360940182678e-8 , # z 1.191501461145112e-7 # w ] } { # Unscaled, unsheared matrix \"type\" : \"Matrix44\" , \"values\" : [ 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , 0.0 , # translateX 0.0 , # translateY 0.0 , # translateZ 1.0 ] } Reference Components These are all possible types of components found in the exported JSON. SolverComponent SceneComponent NameComponent ColorComponent RestComponent ScaleComponent RigidComponent GeometryDescriptionComponent JointComponent DriveComponent LimitComponent Output Example Here's an example of what a complete dump looks like. Ragdoll Dump Output Example Code Example Test your dump, by re-building the scene in Maya. from maya import cmds from ragdoll.vendor import cmdx class Component ( dict ): \"\"\"Simplified access to component members\"\"\" def __getattr__ ( self , key ): value = self [ \"members\" ][ key ] if not isinstance ( value , dict ): return value if value [ \"type\" ] == \"Vector3\" : return cmdx . Vector ( value [ \"values\" ]) elif value [ \"type\" ] == \"Color4\" : return cmdx . Color ( value [ \"values\" ]) elif value [ \"type\" ] == \"Matrix44\" : return cmdx . Matrix4 ( value [ \"values\" ]) elif value [ \"type\" ] == \"Quaternion\" : return cmdx . Quaternion ( * value [ \"values\" ]) else : raise TypeError ( \"Unsupported type: %s \" % value ) def dedump ( dump ): with cmdx . DagModifier () as mod : root = mod . createNode ( \"transform\" , name = \"dump\" ) for entity , data in dump [ \"entities\" ] . items (): comps = data [ \"components\" ] if \"RigidComponent\" not in comps : continue name = Component ( comps [ \"NameComponent\" ]) if not name . path : # Bad export continue joint = name . path . rsplit ( \"|\" , 3 )[ - 2 ] scale = Component ( comps [ \"ScaleComponent\" ]) rest = Component ( comps [ \"RestComponent\" ]) desc = Component ( comps [ \"GeometryDescriptionComponent\" ]) # Establish rigid transformation tm = cmdx . TransformationMatrix ( rest . matrix ) # Establish shape if desc . type in ( \"Cylinder\" , \"Capsule\" ): radius = desc . radius * scale . absolute . x length = desc . length * scale . absolute . y geo , _ = cmds . polyCylinder ( axis = ( 1 , 0 , 0 ), radius = radius , height = length , roundCap = True , subdivisionsCaps = 5 ) elif desc . type == \"Box\" : extents = desc . extents extents . x *= scale . absolute . x extents . y *= scale . absolute . y extents . z *= scale . absolute . z geo , _ = cmds . polyCube ( width = extents . x , height = extents . y , depth = extents . z ) elif desc . type == \"Sphere\" : radius = desc . radius * scale . absolute . x geo , _ = cmds . polySphere ( radius = radius ) else : print ( \"Unsupported shape type: %s .type= %s \" % ( name . path , desc . type )) continue with cmdx . DagModifier () as mod : transform = mod . createNode ( \"transform\" , name = joint , parent = root ) transform [ \"translate\" ] = tm . translation () transform [ \"rotate\" ] = tm . rotation () # Establish shape transformation offset = desc . offset offset . x *= scale . absolute . x offset . y *= scale . absolute . y offset . z *= scale . absolute . z geo = cmdx . encode ( geo ) geo [ \"translate\" ] = offset geo [ \"rotate\" ] = desc . rotation transform . addChild ( geo ) # Usage Example import json dump = cmds . ragdollDump () dump = json . loads ( dump ) dedump ( dump )","title":"Serialisation"},{"location":"serialisation/#overview","text":"On playback, Ragdoll generates a physical representation of your Maya scene, suitable for simulation. You can gain access to that representation, independent of Maya, for use in your own software and for your own purposes. This enables you to use Maya as an authoring environment for general-purpose physics scenes, including full or partial ragdolls, for characters or props and even full environments.","title":"Overview"},{"location":"serialisation/#target-audience","text":"Game programmers working on a custom engine Technical Directors working with e.g. Unreal Engine, Unity or CryEngine Roboticists exploring algorithms on humanoids with rigid bodies Scientists in Machine Learning in need of bespoke ragdolls for their work","title":"Target Audience"},{"location":"serialisation/#usecases","text":"Once a ragdoll has been authored in Maya, it can be exported for later import into external software for a variety of purposes. Game Development where main or secondary characters need a physics representation Virtual Production where you need Motion Builder or Unreal Engine to reproduce physics happening in Maya for real-time feedback Robotics where you want interactive control over parameters that are also applied to a physical real-world equivalent, like Boston Dynamics's Atlas Reinforcement Learning where algorithm and articulation depend on each other and are iterated upon in parallel, like OpenAI's gym environments and algorithms Debugging in cases where odd things happen and you just require deep insight into what the solver sees","title":"Usecases"},{"location":"serialisation/#concepts","text":"Ragdoll internally stores data as \"entities\" and \"components\". Entity is a unique identifier for any \"thing\" in the solver, like a rigid body, a constraint or force. Component is a set of data, like the transformation or rigid body properties, associated to an entity The exported format reflects this relationship and looks something like this. { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } }","title":"Concepts"},{"location":"serialisation/#rigid-body","text":"A single translation/rotation pair. Components Component Description NameComponent Name and path in Maya ColorComponent Used in Maya viewport SceneComponent Reference to the scene entity this rigid belongs to RestComponent Initial transformation RigidComponent Physics attributes GeometryDescriptionComponent Shape attributes \"RigidComponent\" : { \"type\" : \"RigidComponent\" , \"members\" : { \"enabled\" : true , \"mass\" : 1.0 , \"friction\" : 0.80 , \"restitution\" : 0.10 , \"thickness\" : 0.0 , \"disableGravity\" : false , \"collide\" : true , \"kinematic\" : false , \"dynamic\" : true , \"sleeping\" : false , \"linearDamping\" : 0.5 , \"angularDamping\" : 1.0 , \"positionIterations\" : 8 , \"velocityIterations\" : 1 , \"maxContactImpulse\" : - 1.0 , \"maxDepenetrationVelocity\" : - 1.0 , \"sleepThreshold\" : 0.00 , \"enableCCD\" : false , # A value of -1 means \"automatically computed\" \"angularMass\" : { \"type\" : \"Vector3\" , \"values\" : [ - 1.0 , - 1.0 , - 1.0 ] }, # A value of 0 means \"automatically computed\" \"centerOfMass\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.0 , 0.0 , 0.0 ] } } }","title":"Rigid Body"},{"location":"serialisation/#shape","text":"Every rigid has exactly one collision shape. The transformation of this shape can be optionally offset, and that offset happens in the frame of the rigid. ________ ^ |\\ \\ | | \\_______\\ | | | | o--\\-|-> | \\ \\|______| \\ v In this example, the center of the box is offset from the center of the rigid along the X axis. Notice how the geometry is relative the axis of the rigid, so rotating the rigid along the Z axis would naturally take the geometry with it. \"GeometryDescriptionComponent\" : { \"type\" : \"GeometryDescriptionComponent\" , \"members\" : { \"type\" : \"Capsule\" , # Used by Capsule \"length\" : 0.123 , # Used by Sphere \"radius\" : 0.012 , # Used by Box \"extents\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.123 , 0.024 , 0.0247 ] }, # Translation relative the associated rigid \"offset\" : { \"type\" : \"Vector3\" , \"values\" : [ 0.033 , - 0.05 , 0.00 ] }, # Rotation relative the associated rigid # Ordered as XYZW \"rotation\" : { \"type\" : \"Quaternion\" , \"values\" : [ 0.87 , - 0.47 , 0.00 , 0.00 ] } } }","title":"Shape"},{"location":"serialisation/#constraint","text":"A relationship between two rigid bodies is referred to as a \"constraint\". A constraint constrains the way two rigid bodies move relative each other. For example, the position of the lower arm is typically associated with the tip of the upper arm. Wherever the upper arm goes, the lower arm must follow. It may also be further limited in how it is oriented, to e.g. prevent a lower arm from bending past the natural elbow limit; i.e. to rotate between 20-180 degrees along the Z axis, and 0-10 degrees around the X and Y axis (as that rotation would normally come from twisting the upper arm). All constraints are bi-directional Rigid A attaches to B, as B attaches to A The point on A where B attaches is referred to as the parentFrame The point on B where A attaches is referred to as the childFrame Despite the name, there is no notion of hierarchy or \"parent\" in Ragdoll; the naming reflects the hierarchy as represented in Maya, where constraints are parented to the rigid representing the childFrame . Components Component Description JointComponent References to associated rigids and frame matrices LimitComponent Optional limits on translation and/or rotation DriveComponent Optional target transformation, i.e. the animation \"JointComponent\" : { \"type\" : \"JointComponent\" , \"members\" : { # Reference to the associated rigid body entities \"parent\" : 1048586 , \"child\" : 1048584 , # The translate/rotate of the parent # rigid in the frame of child rigid \"parentFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.760 , - 0.594 , - 0.259 , 0.0 , - 0.648 , - 0.680 , - 0.340 , 0.0 , 0.0262 , 0.4274 , - 0.903 , 0.0 , 10.51 , - 0.646 , 0.0 , 1.0 ] }, # The translate/rotate of the child # rigid in the frame of parent rigid \"childFrame\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.606 , - 0.751 , - 0.259 , 0.0 , - 0.785 , - 0.515 , - 0.340 , 0.0 , 0.122 , 0.4103 , - 0.903 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] }, # Allow intersections between connected rigids \"disableCollision\" : true } }","title":"Constraint"},{"location":"serialisation/#limit","text":"Constraints may optionally have a \"limit\", which means it can keep a rigid within a given angle (\"angular limit\") or position (\"linear limit\"). Min & Max Values represent a upper end of a range . With x=5 the minimum value of the linear X axis is -5 . \"LimitComponent\" : { \"type\" : \"LimitComponent\" , \"members\" : { \"enabled\" : true , \"x\" : - 1.0 , # Linear limit along the X-axis \"y\" : - 1.0 , \"z\" : - 1.0 , \"twist\" : 0.78 , # Angular limit along the X-axis \"swing1\" : 0.78 , # ..Y \"swing2\" : 0.78 , # ..Z \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } } Locked, Free or Limited A value of -1 means the axis is \"Locked\", i.e. the value along this axis cannot change. A Point Constraint is typically locked on all linear axes, but free on the angular axes. A value of 0 means the axis if \"Free\", meaning it has no effect. It is \"limitless\". A value above 0 indicates the range of a given limit. <0 means Locked =0 means Free >0 means Limited","title":"Limit"},{"location":"serialisation/#drive","text":"A constraint may optionally have a \"drive\", which means having one rigid reach a target position and/or angle relative another rigid. The typical use case is having simulation match your input animation, where the animation provides the positions and angles. \"DriveComponent\" : { \"type\" : \"DriveComponent\" , \"members\" : { \"enabled\" : true , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"acceleration\" : true , \"target\" : { \"type\" : \"Matrix44\" , \"values\" : [ 0.973 , 0.2267 , 0.0 , 0.0 , - 0.226 , 0.973 , 0.0 , 0.0 , 0.0 , 0.0 , 0.999 , 0.0 , 0.1051 , - 0.006 , 0.0 , 1.0 ] } } }","title":"Drive"},{"location":"serialisation/#data-types","text":"In addition to the plain-old-data types int , double and bool , these are all possible data types found in the exported JSON. { \"type\" : \"Color4\" , \"values\" : [ 0.4429999887943268 , # red 0.7049999833106995 , # green 0.9520000219345093 # blue 1.0 # alpha ] } { \"type\" : \"Vector3\" , \"values\" : [ 100.00001788139201 , # x 100.00001788139201 , # y 100.00000000000003 # z ] } { \"type\" : \"Quaternion\" , \"values\" : [ 0.8791841887437938 , # x - 0.47648206919348187 , # y - 2.7953360940182678e-8 , # z 1.191501461145112e-7 # w ] } { # Unscaled, unsheared matrix \"type\" : \"Matrix44\" , \"values\" : [ 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , # rotation matrix 0.0 , 0.0 , # rotation matrix 0.0 , # rotation matrix 1.0 , # rotation matrix 0.0 , 0.0 , # translateX 0.0 , # translateY 0.0 , # translateZ 1.0 ] }","title":"Data Types"},{"location":"serialisation/#reference","text":"","title":"Reference"},{"location":"serialisation/#components","text":"These are all possible types of components found in the exported JSON. SolverComponent SceneComponent NameComponent ColorComponent RestComponent ScaleComponent RigidComponent GeometryDescriptionComponent JointComponent DriveComponent LimitComponent","title":"Components"},{"location":"serialisation/#output-example","text":"Here's an example of what a complete dump looks like. Ragdoll Dump Output Example","title":"Output Example"},{"location":"serialisation/#code-example","text":"Test your dump, by re-building the scene in Maya. from maya import cmds from ragdoll.vendor import cmdx class Component ( dict ): \"\"\"Simplified access to component members\"\"\" def __getattr__ ( self , key ): value = self [ \"members\" ][ key ] if not isinstance ( value , dict ): return value if value [ \"type\" ] == \"Vector3\" : return cmdx . Vector ( value [ \"values\" ]) elif value [ \"type\" ] == \"Color4\" : return cmdx . Color ( value [ \"values\" ]) elif value [ \"type\" ] == \"Matrix44\" : return cmdx . Matrix4 ( value [ \"values\" ]) elif value [ \"type\" ] == \"Quaternion\" : return cmdx . Quaternion ( * value [ \"values\" ]) else : raise TypeError ( \"Unsupported type: %s \" % value ) def dedump ( dump ): with cmdx . DagModifier () as mod : root = mod . createNode ( \"transform\" , name = \"dump\" ) for entity , data in dump [ \"entities\" ] . items (): comps = data [ \"components\" ] if \"RigidComponent\" not in comps : continue name = Component ( comps [ \"NameComponent\" ]) if not name . path : # Bad export continue joint = name . path . rsplit ( \"|\" , 3 )[ - 2 ] scale = Component ( comps [ \"ScaleComponent\" ]) rest = Component ( comps [ \"RestComponent\" ]) desc = Component ( comps [ \"GeometryDescriptionComponent\" ]) # Establish rigid transformation tm = cmdx . TransformationMatrix ( rest . matrix ) # Establish shape if desc . type in ( \"Cylinder\" , \"Capsule\" ): radius = desc . radius * scale . absolute . x length = desc . length * scale . absolute . y geo , _ = cmds . polyCylinder ( axis = ( 1 , 0 , 0 ), radius = radius , height = length , roundCap = True , subdivisionsCaps = 5 ) elif desc . type == \"Box\" : extents = desc . extents extents . x *= scale . absolute . x extents . y *= scale . absolute . y extents . z *= scale . absolute . z geo , _ = cmds . polyCube ( width = extents . x , height = extents . y , depth = extents . z ) elif desc . type == \"Sphere\" : radius = desc . radius * scale . absolute . x geo , _ = cmds . polySphere ( radius = radius ) else : print ( \"Unsupported shape type: %s .type= %s \" % ( name . path , desc . type )) continue with cmdx . DagModifier () as mod : transform = mod . createNode ( \"transform\" , name = joint , parent = root ) transform [ \"translate\" ] = tm . translation () transform [ \"rotate\" ] = tm . rotation () # Establish shape transformation offset = desc . offset offset . x *= scale . absolute . x offset . y *= scale . absolute . y offset . z *= scale . absolute . z geo = cmdx . encode ( geo ) geo [ \"translate\" ] = offset geo [ \"rotate\" ] = desc . rotation transform . addChild ( geo ) # Usage Example import json dump = cmds . ragdollDump () dump = json . loads ( dump ) dedump ( dump )","title":"Code Example"},{"location":"blog/20201215_cmdx/","text":"Talk about cmdx and why it's necessary.","title":"20201215 cmdx"},{"location":"blog/20201216_high_dpi_and_px/","text":"UI and Resolution Scaling Read about how Ragdoll implements resolution scaling, to support scalable UIs on modern high-resolution displays. TL;DR Here's a standalone version of the function I'll be walking you through, requires Maya 2017 (Qt 5) and above (due to QScreen ). def px ( value ): if not hasattr ( px , \"dpi\" ): any_widget = QtWidgets . QWidget () any_widget . setWindowFlags ( QtCore . Qt . ToolTip ) any_widget . show () window = any_widget . windowHandle () scale = window . screen () . logicalDotsPerInch () / 96.0 px . dpi = scale return value * px . dpi What is Resolution Scaling? Most displays have resolutions beyond the traditional 1080p, which makes text and graphics overly small. To account for this, operating systems have implemented \"resolution scaling\"; which is some factor to scale text and graphics by when drawing it on screen. Maya added (early and crude) support for resolution scaling in Maya 2016 with a usable and mostly transparent version landing in 2018 and beyond. Building UIs with Maya's native MEL-based UI tools account for scaling automatically, so you generally don't have to think about it. Unfortunately, for any non-trivial Qt project however you'll need to actively implement and maintain support for it. Ragdoll does this, and here's how. Implementation In short, any mention pixels run through a conversion function like this. # setFixedWidth(50) # Before setFixedWidth ( px ( 50 )) # After Where px() looks something like this. def px ( value ): return value * 1.5 That goes for stylesheets as well. style = \"\"\" QPushButton { width: 50px; } \"\"\" style = convert_px ( style ) setStyleSheet ( style ) Where convert_px() looks something like.. def convert_px ( style ): lines = [] for line in style . splitlines (); if \"px\" in line : # Find them and destroy them return \" \\n \" . join ( lines ) But where does this magical 1.5 value come from? The value depends on your display scale factor, or more precisely whichever scale factor Maya is currently working with. On Windows, the scale factor is set under your Display settings and Linux's various display managers have something like it. You can read this straight from the operating system, but the more cross-platform method would be to lean on Qt. Unfortunately, the Qt documentation for resolution scaling is a good representation of how confusing resolution scaling is amongst UI developers at large. https://doc.qt.io/qt-5/highdpi.html Because you have (1) an application scale, (2) an operating system scale and (3) a physical monitor scale; each of which combine in non-obvious ways to produce the final pixel coordinate on screen. What is the difference between \"Physical DPI\" and \"Logical DPI\"? Where does \"Device Pixel Ratio\" come into the picture? Here's what you need to know. scale = logicalDpi / 96.0 The value you'll end up with is 1.0 for a non-scaled display, such as your everyday 1080p monitor, and 1.5 or 2.0 for greater resolutions. If your OS allows, you could get values inbetween or greater, and although text scales somewhat well to any value, graphics shipped with Ragdoll is scaled at 2.0 which means it'll look best at 1.0 , 1.5 and 2.0 . Anything else will likely introduce blur. But wait, where does logicalDpi come from, and what's this magical 96.0 ? Qt can provide that for you, but not without a fight. window .","title":"20201216 high dpi and px"},{"location":"blog/20201216_high_dpi_and_px/#ui-and-resolution-scaling","text":"Read about how Ragdoll implements resolution scaling, to support scalable UIs on modern high-resolution displays.","title":"UI and Resolution Scaling"},{"location":"blog/20201216_high_dpi_and_px/#tldr","text":"Here's a standalone version of the function I'll be walking you through, requires Maya 2017 (Qt 5) and above (due to QScreen ). def px ( value ): if not hasattr ( px , \"dpi\" ): any_widget = QtWidgets . QWidget () any_widget . setWindowFlags ( QtCore . Qt . ToolTip ) any_widget . show () window = any_widget . windowHandle () scale = window . screen () . logicalDotsPerInch () / 96.0 px . dpi = scale return value * px . dpi","title":"TL;DR"},{"location":"blog/20201216_high_dpi_and_px/#what-is-resolution-scaling","text":"Most displays have resolutions beyond the traditional 1080p, which makes text and graphics overly small. To account for this, operating systems have implemented \"resolution scaling\"; which is some factor to scale text and graphics by when drawing it on screen. Maya added (early and crude) support for resolution scaling in Maya 2016 with a usable and mostly transparent version landing in 2018 and beyond. Building UIs with Maya's native MEL-based UI tools account for scaling automatically, so you generally don't have to think about it. Unfortunately, for any non-trivial Qt project however you'll need to actively implement and maintain support for it. Ragdoll does this, and here's how.","title":"What is Resolution Scaling?"},{"location":"blog/20201216_high_dpi_and_px/#implementation","text":"In short, any mention pixels run through a conversion function like this. # setFixedWidth(50) # Before setFixedWidth ( px ( 50 )) # After Where px() looks something like this. def px ( value ): return value * 1.5 That goes for stylesheets as well. style = \"\"\" QPushButton { width: 50px; } \"\"\" style = convert_px ( style ) setStyleSheet ( style ) Where convert_px() looks something like.. def convert_px ( style ): lines = [] for line in style . splitlines (); if \"px\" in line : # Find them and destroy them return \" \\n \" . join ( lines ) But where does this magical 1.5 value come from? The value depends on your display scale factor, or more precisely whichever scale factor Maya is currently working with. On Windows, the scale factor is set under your Display settings and Linux's various display managers have something like it. You can read this straight from the operating system, but the more cross-platform method would be to lean on Qt. Unfortunately, the Qt documentation for resolution scaling is a good representation of how confusing resolution scaling is amongst UI developers at large. https://doc.qt.io/qt-5/highdpi.html Because you have (1) an application scale, (2) an operating system scale and (3) a physical monitor scale; each of which combine in non-obvious ways to produce the final pixel coordinate on screen. What is the difference between \"Physical DPI\" and \"Logical DPI\"? Where does \"Device Pixel Ratio\" come into the picture? Here's what you need to know. scale = logicalDpi / 96.0 The value you'll end up with is 1.0 for a non-scaled display, such as your everyday 1080p monitor, and 1.5 or 2.0 for greater resolutions. If your OS allows, you could get values inbetween or greater, and although text scales somewhat well to any value, graphics shipped with Ragdoll is scaled at 2.0 which means it'll look best at 1.0 , 1.5 and 2.0 . Anything else will likely introduce blur. But wait, where does logicalDpi come from, and what's this magical 96.0 ? Qt can provide that for you, but not without a fight. window .","title":"Implementation"},{"location":"blog/20201217_option_dialogs/","text":"Talk about qargparse and why it's necessary.","title":"20201217 option dialogs"},{"location":"blog/20201218_optionvar/","text":"Maya's native persistent preferences, with support for access from C++.","title":"20201218 optionvar"},{"location":"blog/20201219_pythonreload/","text":"Talk about how you iterate in Maya, reloading all modules by namespace and what to look out for. Especially undo. And always having an uninstall.","title":"20201219 pythonreload"},{"location":"blog/20210325_view_to_pixmap/","text":"Write about this. def view_to_pixmap ( size = None ): \"\"\"Render currently active 3D viewport as a QPixmap\"\"\" # Python 2 backwards compatibility try : long except NameError : long = int image = om . MImage () view = omui . M3dView . active3dView () view . readColorBuffer ( image , True ) # Translate from Maya -> Qt jargon image . verticalFlip () osize = size or QtCore . QSize ( 512 , 256 ) isize = image . getSize () buf = ctypes . c_ubyte * isize [ 0 ] * isize [ 1 ] buf = buf . from_address ( long ( image . pixels ())) qimage = QtGui . QImage ( buf , isize [ 0 ], isize [ 1 ], QtGui . QImage . Format_RGB32 ) . rgbSwapped () return QtGui . QPixmap . fromImage ( qimage ) . scaled ( osize . width (), osize . height (), QtCore . Qt . KeepAspectRatio , QtCore . Qt . SmoothTransformation ) def pixmap_to_base64 ( pixmap ): array = QtCore . QByteArray () buffer = QtCore . QBuffer ( array ) buffer . open ( QtCore . QIODevice . WriteOnly ) pixmap . save ( buffer , \"png\" ) return bytes ( array . toBase64 ()) def base64_to_pixmap ( base64 ): data = QtCore . QByteArray . fromBase64 ( base64 ) pixmap = QtGui . QPixmap () pixmap . loadFromData ( data ) return pixmap","title":"20210325 view to pixmap"},{"location":"blog/20210409_littlebits_locatorshotkey/","text":"Write about the script for toggling locators in the viewport, alongside curves and meshes. A workflow tip. A short one. A \"Little Bits\". :D","title":"20210409 littlebits locatorshotkey"},{"location":"blog/20210420_bugfree/","text":"The bug-free software guarantee. Find a bug, get a free licence If you already have a licence, get the next one free (incentive to find bugs in the 2-4 week trial period) What if everyone finds a bug, and everyone gets a free licence? That's OK. If nobody is able to use Ragdoll without finding a bug, Ragdoll does not deserve payment. Requirements: Bug must be reproducible in the latest version Bug must not already have been reported, first-come first-served (tracked via GitHub issues) But must not already be known (tracked via GitHub)","title":"20210420 bugfree"},{"location":"blog/20210422_escapehatch/","text":"Always give users a way to circumvent protections and to workaround issues without waiting for a new update (which could be days or weeks).","title":"20210422 escapehatch"},{"location":"nodes/rdConstraint/","text":"Reference sheet for the rdConstraint node type. from maya import cmds cmds . createNode ( \"rdConstraint\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdConstraint"},{"location":"nodes/rdConstraint/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Angular damping of the drive. \u2714\ufe0f float 1000.0 .angularDriveStiffness Angular stiffness of the drive. \u2714\ufe0f float 10000.0 .angularLimit Amount of rotational offset before the limit kicks in. angle3 0.0 0.0 0.0 .angularLimitDamping Damping of contacts with the limit. It is an opposing force to whatever direction a contact is applied. A low value produces a springy appearance, whereas a high value resists any and all motion. \u2714\ufe0f float 10000.0 .angularLimitStiffness Stiffness of contacts with the angular limit. A low value makes limits appear soft. Values are relative the mass of your rigid and the amount of force being applied by contacts and other constraints. But with a mass of 1.0 and under normal gravity, the default value should produce a somewhat hard response. \u2714\ufe0f float 1000000.0 .childFrame Transform relative the child that a parent is attached. The inverse of the parentFrame , this attribute establishes a point and orientation within the child that the parent rigid attaches to. matrix identity .childRigid One of two constrained rigids, the 'child'. int -1 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a constraint keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .disableCollision Disable collision between constrained rigids. This is generally desirable, as connected rigids are typically limbs or a character, e.g. upper and lower arm, and you generally want some overlap between these rigids. However unless you disable collisions, the overlap would cause a conflict in the solver, where it wouldn't know whether to keep them connected or split them apart due to their contact. For objects without overlap, this attribute is better left off. bool True .drawChildFrame Visualise the childFrame attribute. bool True .drawConnection Visualise the connection between the parentRigid and childRigid . bool True .drawDrive Visualise the drive. bool True .drawLimit Visualise the limit of this constraint. bool True .drawParentFrame Visualise the parentFrame attribute. bool True .drawScale The scale at which to visualise things. double 1.0 .driveEnabled Whether or not to try and follow the driveMatrix attribute. Drives (a.k.a. Guides) are used to follow an input animation by applying forces relative the delta between your animation and the simulation. The further your animation is from the current state of the simulation, the stronger the force. It's a spring-like force. \u2714\ufe0f bool False .driveMatrix A target position and orientation for the childRigid , relative the parentFrame . The constraint can apply a spring-like force to both parent and child to try and match this matrix as though the childRigid was an actual child of the parentRigid . \u2714\ufe0f matrix identity .driveSpringType Whether to use force or acceleration to compute the drive. Acceleration takes masses of connected rigids into account and is generally easier to tune. enum 1 .driveStrength Multipler to linearDriveStiffness , linearDriveDamping , angularDriveStiffness and angularDriveDamping . This is a convenience attribute to simplify manipulation (and animation) of the overall drive behaviour. The same result can be achieved by manually multiplying these values. The equation is strength * strength * stiffness and the same for damping. \u2714\ufe0f float 1.0 .limitEnabled Whether any of the specified limits are enabled or not. Think of this as a convenience override for linear (position) and angular (rotation) limits. You can achieve the same effect by setting each limit to a value of 0. \u2714\ufe0f bool False .limitStrength Multiplier for the linearLimitStiffness , linearLimitDamping , angularLimitStiffness and angularLimitDamping attributes. \u2714\ufe0f float 1.0 .linearDriveDamping Linear damping of the drive. A high value produces a slimy, slow-moving motion. \u2714\ufe0f float 100.0 .linearDriveStiffness Linear stiffness of the drive. If you think of the drive as a spring, then the stiffness determines the thickness of the coil of that spring. A thick coil yields a fast, springy motion. \u2714\ufe0f float 1000.0 .linearLimit Amount of positional offset before the limit kicks in. distance3 0.0 0.0 0.0 .linearLimitDamping Damping factor for contacts with the limit. \u2714\ufe0f float 10000.0 .linearLimitStiffness Stiffness of contacts with linear limit. Whenever the linear limit is hit, this attribute determines how soft/hard to response should be. A low value (e.g. 10) yields a soft appearance, whereas a high (e.g. 1'000'000) yields a metal-versus-marble contact. \u2714\ufe0f float 1000000.0 .nextState This attribute is pulled whenever the constraint needs to fetch information from the constraint. int 0 .parentFrame Transform relative the parent that a child is attached. If the child rigid was a child of the parent, then this transform represents a point under the parent where the child is connected. The driveMatrix attribute is relative this frame. If they are equal, the rigid is driven towards the restMatrix . matrix identity .parentRigid One of two constrained rigids, the 'parent'. int -1 .ragdollId Internal identifier for this node in the solver. int 0 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the constraint, including its parent and child frames and drive attributes. int 0 .type Internal attribute used to record which type this constraint was originally intended as. Because all 'types' are really just an rdConstraint with various values set, there is no specific type. This is merely intended as a hint for scripts and tools to use. enum 0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdConstraintMultiplier/","text":"Reference sheet for the rdConstraintMultiplier node type. from maya import cmds cmds . createNode ( \"rdConstraintMultiplier\" ) Attributes Attribute Description Keyable Type Default .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping \u2714\ufe0f float 1.0 .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness \u2714\ufe0f float 1.0 .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping \u2714\ufe0f float 1.0 .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness \u2714\ufe0f float 1.0 .driveStrength Multiplier for rdConstraint.driveStrength \u2714\ufe0f float 1.0 .limitStrength Multiplier for rdConstraint.limitStrength \u2714\ufe0f float 1.0 .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping \u2714\ufe0f float 1.0 .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness \u2714\ufe0f float 1.0 .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping \u2714\ufe0f float 1.0 .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdConstraintMultiplier"},{"location":"nodes/rdConstraintMultiplier/#attributes","text":"Attribute Description Keyable Type Default .angularDriveDamping Multiplier for rdConstraint.angularDriveDamping \u2714\ufe0f float 1.0 .angularDriveStiffness Multiplier for rdConstraint.angularDriveStiffness \u2714\ufe0f float 1.0 .angularLimitDamping Multiplier for rdConstraint.angularLimitDamping \u2714\ufe0f float 1.0 .angularLimitStiffness Multiplier for rdConstraint.angularLimitStiffness \u2714\ufe0f float 1.0 .driveStrength Multiplier for rdConstraint.driveStrength \u2714\ufe0f float 1.0 .limitStrength Multiplier for rdConstraint.limitStrength \u2714\ufe0f float 1.0 .linearDriveDamping Multiplier for rdConstraint.linearDriveDamping \u2714\ufe0f float 1.0 .linearDriveStiffness Multiplier for rdConstraint.linearDriveStiffness \u2714\ufe0f float 1.0 .linearLimitDamping Multiplier for rdConstraint.linearLimitDamping \u2714\ufe0f float 1.0 .linearLimitStiffness Multiplier for rdConstraint.linearLimitStiffness \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdControl/","text":"Reference sheet for the rdControl node type. from maya import cmds cmds . createNode ( \"rdControl\" ) Attributes Attribute Description Keyable Type Default .color Color of the surface and wireframe. float3 0.443 0.705 0.952 .drawShaded Whether or not to draw wireframe or shaded. bool False .outputMesh Polygonal output, for rendering, shadows and export. mesh .rigid Reference to rigid this control represents. int -1 .version Version of Ragdoll used to create this node. int 0","title":"rdControl"},{"location":"nodes/rdControl/#attributes","text":"Attribute Description Keyable Type Default .color Color of the surface and wireframe. float3 0.443 0.705 0.952 .drawShaded Whether or not to draw wireframe or shaded. bool False .outputMesh Polygonal output, for rendering, shadows and export. mesh .rigid Reference to rigid this control represents. int -1 .version Version of Ragdoll used to create this node. int 0","title":"Attributes"},{"location":"nodes/rdRigid/","text":"Reference sheet for the rdRigid node type. from maya import cmds cmds . createNode ( \"rdRigid\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float 1.0 .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced. Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .exclusiveNodes Nodes created for this and only this rigid. Exclusive nodes are deleted alongside this rigid. If you want to keep a node initially created as an exclusive node, disconnect it from this array. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .inputSurface NURBS input to the Mesh shape type. nurbsSurface .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float 0.5 .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum 1 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .userAttributes References to attributes created for this rigid but on another node. Such as proxy attributes created on an original animation control, used to drive the attribute on this rigid. bool True .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdRigid"},{"location":"nodes/rdRigid/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier of both linearDamping and angularDamping . The two damping attributes are typically used together, but can also be used separately in which case this attribute could be left at 1.0 and forgotten. \u2714\ufe0f float 1.0 .angularDamping Resistance along the opposite direction of rotation for a rigid. Like linearDamping but along the rotation axes. \u2714\ufe0f float 1.0 .angularMass Like mass, but for changes in orientation. float3 -1.0 -1.0 -1.0 .centerOfMass The point at which a rigid may be balanced. Or put another way, the point whereby the weight of a rigid is equal in all directions. float3 0.0 0.0 0.0 .collide Whether this rigid should collide with other rigids. This can be useful in areas of many overlapping rigids that aren't necessarily constrained, such as a shoulder or hip. bool True .color Color of the rigid when drawn in the viewport, used for vertex color when used as polygons. float3 .currentState The scene pulls this attribute on every frame to update itself on attributes that can be animated, such as the linear and angular damping. int 0 .currentTime This attribute is meant to be dirtied whenever time changes; it's how a rigid keeps an eye on what Maya is up to. The actual value isn't used. time 0.0 .drawShaded Whether to draw this rigid shaded or wireframe-only. bool True .enabled Whether or not to include this node in the simulation. A value of False is the same as the node not existing in the first place. bool True .exclusiveNodes Nodes created for this and only this rigid. Exclusive nodes are deleted alongside this rigid. If you want to keep a node initially created as an exclusive node, disconnect it from this array. bool True .friction The resistance at which two rigids rub against each other. A value of 0 creates an appearance of ice, whereas a value of 1.0 represents 100% friction, no sliding allowed. The value may exceed 1.0, but it is unclear what happens. Use at your own risk. float 0.8 .inputCurve NURBS input to the Mesh shape type. nurbsCurve .inputForce An array attribute with references to all forces that act upon this rigid. int 0 .inputMatrix Passive position and orientation, this may be animated. \u2714\ufe0f matrix identity .inputMesh Polygonal input to the Mesh shape type. mesh .inputParentInverseMatrix Used to cancel out any Maya parent prior to outputting the outputMatrix. \u2714\ufe0f matrix identity .inputSurface NURBS input to the Mesh shape type. nurbsSurface .jointOrient Input attribute for the formatting of outputMatrix. angle3 0.0 0.0 0.0 .kinematic Whether this rigid should be affected by contacts, constraints and forces. \u2714\ufe0f bool False .linearDamping Resistance in the opposite direction of travel for a rigid. This creates an underwater look, or at high-enough values resembles honey or eventually cement. \u2714\ufe0f float 0.5 .mass The 'weight' of a rigid. Except 'weight' is technically the result of mass and gravity, and a rigid still has mass even when there isn't any gravity. This attribute is mostly relevant when two active rigids interact, think of a pool table where one of the balls is heavier than another. On the other hand, dropping a feather from high on up onto a static ground yields an identical result to dropping much heavier bowling ball. The ground being static will not move regardless and the speed at which your rigid falls to the ground is independent of its mass given there is no actual air in the simulation to apply counterforce like in the real world. float 1.0 .maxContactImpulse How strong contact forces are allowed to be. A value of -1 means 'infinite' and anything less can help produce soft collisions. float -1.0 .maxDepenetrationVelocity How quickly two intersecting rigids are allowed to de-intersect. This can help avoid explosions and maintain a soft appearance. float -1.0 .nextState This attribute is pulled whenever the rigid needs to know its position and orientation from the solver. int 0 .outputMatrix The primary output from each Rigid, and from Ragdoll overall. The final position and orientation following the simulation at the current time step. matrix identity .outputMesh Polygonal version of the rigid, for rendering and export. mesh .outputRotate The rotation part in Euler format of the outputMatrix . angle3 .outputTranslate The translation part of the outputMatrix , that's all it is. double3 0.0 0.0 0.0 .positionIterations Accuracy of non-intersecting constraints and contacts. If the drive (guide) strength isn't strong enough, increase this value. int 8 .ragdollId Internal identifier for this node in the solver. int 0 .restMatrix Starting position and orientation of a rigid in the simulation. This attribute is typically initialised with wherever the chosen Maya transform is located at the time of creating the rigid. It is also the attribute manipulated when setting the initial state. matrix identity .restitution The 'bounciness' of a rigid body. Bounce is an opposite force applied whenever two rigids come into contact. The bounce is however also dependent on the rdScene.bounceThresholdVelocity which determines how strong a contact must be in order for an opposing force to be added. Without a threshold, a rigid would bounce at increasingly small intervals into infinity. However, for high-frequency bounces, like a billiard ball bouncing on a marble floor, don't forget to increase your substeps so as to capture the very small and fast motion happening towards the end of its bounce lifetime. float 0.1 .rotateOrder Input attribute such that the output matrix and rotation respects the chosen rotate order of the target transform. enum 0 .rotatePivot Input attribute to properly format the outputMatrix and friends. double3 0.0 0.0 0.0 .rotatePivotTranslate Input attribute for the formatting of outputMatrix. double3 0.0 0.0 0.0 .shapeExtents The dimensions of the 'Box' shapeType . float3 1.0 1.0 1.0 .shapeLength Length of the 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeOffset Position of a shape relative the rigid. Think of the shape as being a child of the rigid, and this is its child position. It'll be in the orientation of the parent, as you would expect. double3 0.0 0.0 0.0 .shapeRadius Radius of the 'Sphere', 'Capsule' and 'Cylinder' shapeType . float 1.0 .shapeRotation Rotation of the shape relative the rigid. angle3 .shapeType Shape used for collision detection and automatic computation of centerOfMass and angularMass . The 'Mesh' option converts any input to inputMesh or inputCurve to a suitable physical representation called 'Convex Hull'. As the name implies, the hull cannot be concave. To model concave shapes, like a torus, use multiple rigids and parent them together to form a compound shape. enum 1 .startState The scene pulls on this attribute at the start frame to set-up the initial state of the rigid, including its rest position and shape properties. int 0 .thickness Additional offset from the surface of a shape. Think of this as the shape being extruded by this amount along the surface normals. It's meant to create some padding between two rigids that collide and can help stabilise complex or strong contacts. float 0.0 .userAttributes References to attributes created for this rigid but on another node. Such as proxy attributes created on an original animation control, used to drive the attribute on this rigid. bool True .velocityIterations Accuracy of intersecting constraints and contacts. If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution. int 1 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdRigidMultiplier/","text":"Reference sheet for the rdRigidMultiplier node type. from maya import cmds cmds . createNode ( \"rdRigidMultiplier\" ) Attributes Attribute Description Keyable Type Default .airDensity Multiplier for rdRigid.airDensity \u2714\ufe0f float 1.0 .angularDamping Multiplier for rdRigid.angularDamping \u2714\ufe0f float 1.0 .linearDamping Multiplier for rdRigid.linearDamping \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdRigidMultiplier"},{"location":"nodes/rdRigidMultiplier/#attributes","text":"Attribute Description Keyable Type Default .airDensity Multiplier for rdRigid.airDensity \u2714\ufe0f float 1.0 .angularDamping Multiplier for rdRigid.angularDamping \u2714\ufe0f float 1.0 .linearDamping Multiplier for rdRigid.linearDamping \u2714\ufe0f float 1.0 .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"nodes/rdScene/","text":"Reference sheet for the rdScene node type. from maya import cmds cmds . createNode ( \"rdScene\" ) Attributes Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .positionIterations Spend this many iterations on each rigid. Amount of iterations given to solve all constraints. This attribute is a multiplier of the rdRigid.positionIterations attribute, to affect the overall behavior of the scene. int 4 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"rdScene"},{"location":"nodes/rdScene/#attributes","text":"Attribute Description Keyable Type Default .airDensity Global multiplier to the linearDamping and angularDamping of every rigid part of this scene. This is a convenience attribute to the same attribute found in the rdRigid node for global effects, like the whole scene turning into honey. float 1.0 .bounceThresholdVelocity How strong must a collision be in order to be considered for bounce? To achieve a typical bouncing ball animation, lower this value significantly and increase the number of substeps by a lot. A lower value generally leads to rigids being unable to ever come to rest, but values too large can result in rigids unrealistically coming to rest prematurely. float 1.0 .currentTime Ragdoll's knowledge of time. This is typically connected automatically and needn't be touched, but it is technically possible to animate this and achieve complex slow-motion or time-related effects. \u2714\ufe0f time 0.0 .drawConstraints Draw all constraints in this scene. bool False .drawForces Draw all forces in this scene. bool False .drawLimitScale Scale limits by this amount. float 1.0 .drawLineWidth Scale lines by this amount. float 1.0 .drawShapes Draw all shapes in this scene. Debugging attribute for visualising shapes external to their corresponding rigid. bool False .drawTrajectories Draw a line over time from the center of mass for each rigid in the scene. bool False .drawVelocities Draw an arrow representing velocity for each rigids in this scene. bool False .drawVelocityScale Scale velocity arrows by this amount. float 1.0 .enableCCD Continuous collision detection is used to detect collisions that happen between frames. For example, a bullet being fired from the scene at frame 1 and ends up behind a character on frame 2 would normally not be picked up by normal collision detection. CCD fixes that, at slight cost to performance. bool False .enabled State of the solver. An enabled solver will update whenever time changes. \u2714\ufe0f bool True .gravity Default gravity, in Maya's current distance unit (typically centimeters). Because native Maya shapes are generally quite small - e.g. 1 centimeter for a polyCube - the default gravity is less than the realistic 986.0 cm/s2. If your characters are real-world scaled - e.g. 2 meters tall - then gravity should be closer to 986.0 instead. distance3 0.0 -98.6 0.0 .groundFriction Friction of the ground. float 0.5 .groundRestitution Bounciness of the ground plane. float 0.5 .inputActive An input connection to every rigid part of this scene. This attribute tracks which rigid to account for during simulation. It is dirtied whenever time changes which in turn causes connected rigids to pull on it for latest updated position and orientation. int 0 .inputActiveStart An input connection to every rigid part of this scene. Like inputActive except this attribute is only dirtied on the start frame, to cause rigids to provide their initial state. int 0 .inputConstraint An input connection to every constraint in the scene. int 0 .inputConstraintStart An input connection to every constraint in the scene. int 0 .inputMatrix An offset for all rigid bodies in the scene. (Not yet implemented) This can be used to move a simulation away from the origin and account for animation happening very far away. It can also be used to cancel out animation, by parenting the scene to an animated node. matrix identity .inputSlice An input connection to every slice in the scene. int 0 .inputSliceStart An input connection to every slice in the scene. int 0 .numThreads Number of threads to use internally whilst simulating. Ragdoll automatically divides a scene into 'islands' each frame based on the proximity to rigid bodies in your simulation. Rigids that are far away from each other and unlikely to come into contact are put into separate islands, each island being suitable for simulation in a separate thread. For single-character simulations or simulations where characters interact it is generally faster to leave this at -1 (meaning 'no threads'). int -1 .outputChanged An auxiliary output connection to any object interested in updates from this scene. int 0 .outputObjects An output connection to every rigid updated by this scene. int 0 .positionIterations Spend this many iterations on each rigid. Amount of iterations given to solve all constraints. This attribute is a multiplier of the rdRigid.positionIterations attribute, to affect the overall behavior of the scene. int 4 .ragdollId Internal identifier for this node in the solver. int 0 .solverType The type of solver used for simulation. Projected Gauss-Seidel (PGS) or Temporal Gauss-Seidel (TGS), TGS is generally does a better job at guided simulation such as full-body dynamics, whereas PGS does a better job at many unconstrained objects like brick wall destruction. enum 1 .startTime Time at which to start simulating. Ragdoll will keep rigids at their restMatrix until simulation starts. time 0.0 .substeps Divide changes in time by this many. Ragdoll simulates once per frame (or generally once per change in time, including sub-frame changes), but multiples the number of steps taken by this amount for greater accuracy at a (possible) cost to performance. int 4 .timeMultiplier Speed up or slow down the passage of time with this attribute. This value is multiplied with the normal passing of time, for slow-motion use a value less than 1.0 such as 0.5 for a 50% reduction in speed. float 1.0 .useGround Automatically add a static ground shape to this scene. This has a very similar effect to making your own plane and turning that into a Passive Rigid. The ground responds to changes in translation of the scene, but cannot be animated. bool True .version Version of Ragdoll used to create this node. Saved with scene to keep track of what version of Ragdoll the node was created with. int 0","title":"Attributes"},{"location":"releases/2020.11.10/","text":"Performance! NEW Multi-threading Ragdoll now supports multiple solvers in the same Maya scene, each of which run in parallel offering a 2-3x increase in FPS NEW UI Menu items now have additional customisation with a new UI interface. NEW Animation Influence Dynamic Controls can now respond to animation input, either kinematically or as a guided influence to your simulation. This means you can turn your controllers dynamic, and add additional animation to steer the simulation! NEW Exploratory Menu The menu is now fully unlocked, with user-friendly messages letting you know how to use it if you are unfamiliar. The goal is facilitating exploration and curiosity in a safe environment with reliable undo. FIXED Hinge Constraint A constraint being converted to/from a hinge constraint no longer breaks the constraint. FIXED Set Initial State Modify the position and orientation of your rigid bodies after creation with this feature. Multi-Threading Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead. Option Dialogs Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches. Animation Influence The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"2020.11.10"},{"location":"releases/2020.11.10/#multi-threading","text":"Ragdoll is now multi-threaded! There are two mechanisms for managing performance. Scene-level parallelism Solver-level parallelism With 2 or more Ragdoll solvers in the same Maya scene, Maya will run these in parallel. Which means they will both run independently, on separate hardware cores on your CPU. Currently, you can expect a 2-3x performance increase through use of multiple solvers, with more optimisation to come. A single Ragdoll solver can be automatically broken up into simulation \"islands\" that run in parallel. Islands are created when two or more groups of rigid bodies are unlikely or unable to interact. For example, two characters in the same solver far away from each other. To leverage solver-level parallelism, adjust the rdScene.threadCount attribute (under Advanced in the Attribute Editor). A value of 0 (default) means it will run on a single thread, on the same thread as the rest of Ragdoll and Maya. For small scenes, with less than 100 rigid bodies, you should expect improved performance from a single thread. Each thread comes with some amount of overhead.","title":"Multi-Threading"},{"location":"releases/2020.11.10/#option-dialogs","text":"Some menu items now have option dialog boxes for further customisation. Settings are stored with Maya's preferences and persists across scenes and between application launches.","title":"Option Dialogs"},{"location":"releases/2020.11.10/#animation-influence","text":"The \"Dynamic Control\" feature now enables control of the simulation using the animation used for blending. See Tutorial for details.","title":"Animation Influence"},{"location":"releases/2020.11.16/","text":"The highlight for this release is Cached Playback! NEW Cached Playback You can now leverage Maya 2020's native cached playback for your simulations, speeding up playback performance and lowering iteration times. NEW Help Videos Ragdoll commands now come with how-to videos built directly into the UI. NEW Shape orientation and joints Shapes relied on the jointOrient being proper for joints, gone are the days. FIXED Wireframe Bug The wireframe for the Box shape does now draw correctly with a custom rdRigid.shapeRotation FIXED Outliner Icon Support on Linux Linux now benefits from the same pretty icons as Windows FIXED Logging Warnings These now emit a yellow color in your Command Line FIXED Boxes and Joints Joints converted to Rigids can now be set to Box shape with proper orientation Cached Playback Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor Known Limitations with Cached Playback There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! rdRigid.ouputGeometry Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why. Help Videos Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll. Shape Orientation Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"2020.11.16"},{"location":"releases/2020.11.16/#cached-playback","text":"Maya 2019 introduced support for Cached Playback, and Maya 2020 added support for Cached Simulation , which is now supported by Ragdoll! Create new rigids Edit existing rigids Trajectories can be enabled with the rdScene.drawTrajectories attribute, under Visualisation of the Attribute Editor","title":"Cached Playback"},{"location":"releases/2020.11.16/#known-limitations-with-cached-playback","text":"There is still work to be done. Currently, animated visualisations aren't updating in cached mode. However the simulation still runs correctly and your driven character animation will behave identically to non-cached mode. The animation of the slice visualisation doesn't represent the current, animated state The connection visualisation is not up-to-date, you can disable the drawing with rdConstraint.drawConnection The guide delta drawn to represent the difference between simulation and your animation only draws the latest result, rather than the result on the current frame. Note that these are only visual and does not affect the simulation. These will all be addressed in a future release! rdRigid.ouputGeometry Remove any geometries when working with cached playback, these cause instant death to Maya and it's still unclear why.","title":"Known Limitations with Cached Playback"},{"location":"releases/2020.11.16/#help-videos","text":"Find out more about a command, by seeing an example of how to use it. There's only one video at the moment, with more to come. Including videos for different ways of using the same command. The goal is to never have to leave Maya to learn about Ragdoll.","title":"Help Videos"},{"location":"releases/2020.11.16/#shape-orientation","text":"Shapes typically align with the Maya node, but in the case of joints that isn't always what you want. Maya separates between joint orientation and drawing; it'll always draw joints facing its child. When the orientation and visual orientation of a joint differs, you would end up with correct but unexpected results. This release fixes that by properly updating.. rdRigid.shapeOffset rdRigid.shapeRotation ..to mimic how joints appear in the Maya viewport.","title":"Shape Orientation"},{"location":"releases/2020.11.17/","text":"Minor release. NEW Installation confirmation Ragdoll now lets you know whether the install went successful or not. This appears on first launch, and can be revisited via the Ragdoll menu. This is also where updates will be found, along with future new-user material like links to docs and tutorials. FIXED The Ragdoll | Character menu item has been fixed and is operating at 100% Install Confirmation It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"2020.11.17"},{"location":"releases/2020.11.17/#install-confirmation","text":"It isn't obvious to new users that Ragdoll installed successfully, so here's what the splash screen looks like that you'll see on first launch.","title":"Install Confirmation"},{"location":"releases/2020.11.22/","text":"Minor release, no breaking changes. FIXED Capsule orientation used to face the wrong direction with some joints FIXED Creating a new collider is now undoable like you would expect FIXED Message printed when converting a rigid is now accurate FIXED Kinematic/Dynamic option from Convert Options does no longer bleeds into the Create Rigid Options ADDED Auto option to Convert Rigid , to toggle a rigid between dynamic and kinematic CHANGED The rdRigid.kinematic attribute is now up-top, better indicating its importance CHANGED The Ragdoll | Convert menu item is now split into Convert Rigid and Convert Constraint CHANGED Renamed Convex Hull -> Mesh , should make more sense now Capsule Orientation Fixed a bug where the capsule of a joint would face the wrong way. What is Rigid Body Dynamics? Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body Performance Tips Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"2020.11.22"},{"location":"releases/2020.11.22/#capsule-orientation","text":"Fixed a bug where the capsule of a joint would face the wrong way.","title":"Capsule Orientation"},{"location":"releases/2020.11.22/#what-is-rigid-body-dynamics","text":"Loose thoughts that will eventually transform into a quick 10 second video. Rigid Body Dynamics is a branch of computer science which \"studies the movement of systems of interconnected bodies under the action of external forces\" . It differs from your typical simulation - such as nHair and nCloth - in that it simulates the translate and rotate channels of a given transform node rather than points of the geometry. The main advantage is that it is well suited for animation and rigging, since animation and rigging is all about translate and rotate. Ragdoll Jargon Rigid a.k.a. Dynamic Rigid Body is a transform affected by forces. Forces like Wind, but also contacts and constraints which are both considered forces, in that they happen instantaneously rather than continuously. Collider a.k.a. Kinematic Rigid Body is a transform affected by animation . It does not respect forces, but enables you to animate Shape Every rigid body has a shape, either Box , Sphere , Capsule or Mesh . Shape attributes are prefixed Shape * e.g. Shape Length affects the length of the Capsule , whereas Shape Extents affects the dimensions of the Box Constraint two rigids interact by either colliding and/or being constrained. Constraints work similarly to Maya Constraints, in that there is a parent and a child that lock either translate or rotate or both channels to each other. Force is an external force, like Wind or Push you can use to affect a Dynamic Rigid Body","title":"What is Rigid Body Dynamics?"},{"location":"releases/2020.11.22/#performance-tips","text":"Many things are currently unoptimised and these are the lowest hanging fruit you can reap for greater performance. Hide Rigids Drawing is currently unoptimised and somewhat heavy. You'll find a 5-10% increase in performance by simply hiding the rdRigid shape once you're done tweaking Hide Constraints These are even heavier, since they update dynamically to show you the deltas between animation and simulation poses. Hiding these can yield a 20-30% performance increase. Other things come down to scene-by-scene basis. Try PGS There are two separate solvers you can use, \"TGS\" and \"PGS\". TGS (the default) is better suited for full-body dynamics, whereas PGS is better suited for lots of independent rigid bodies, like a brick wall. Decrease Position Iterations The rdRigid.positionIterations is how many iterations are given to each related constraint. Greater numbers means you can use higher values for Guide Strength and Limit Strength , at the expense of performance Decrease Substeps These generally don't need to exceed 8, try 4 and 2 as well to see whether that makes a difference to behaviour/performance.","title":"Performance Tips"},{"location":"releases/2020.11.23/","text":"The headline of this release is Dynamic Control 2.0 CHANGED Dynamic Control Removed fuss and simplified the interface. CHANGED \"Delete All Physics\" Now deletes all physics, regardless of the current selection CHANGED Rigid versus Collider Learn about what these mean and how to convert between the two. ADDED Center of mass (Advanced) Now you can change the point at which a rigid body is balanced ADDED Angular mass (Advanced) Typically computed automatically from the shape and size of your rigid, now you can manually define this. ADDED Auto Connect More clarity, and also usable with things other than joints Dynamic Control 2.0 Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos Limitations Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment. Center of Mass If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it Angular Mass In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\" or \"moment of inertia\". It's like mass, but in terms of rotation rather than position. The broom has a low angular mass around its length axis, and a high angular mass in the other two axes. That makes it \"heavier\" around some axes but not others. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, then the angular mass will also be lighter around its length then its width. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it Auto Connect The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"2020.11.23"},{"location":"releases/2020.11.23/#dynamic-control-20","text":"Ragdoll is currently very technical. It is exposing features of an underlying mathematical framework for solving \"Rigid-Body Dynamics\" ( wiki ) and tries to be as friendly about it as possible, but there is always a tradeoff in usability and flexibility. Dynamic Control was made to bridge that gap. It combines a user-selection with a series of commands to automatically try and figure out your intentions when those intentions are \"add some dynamics to my animation control\". Dynamic Control has been with Ragdoll for a few weeks now, and have undergone a series of changes to try and increase its intuitiveness whilst reducing complexity. It's hard! But in this release I'd like to present what I'm dubbing the \"2.0\" of Dynamic Control. The main differences are: Preserves existing animation rather than replacing it Simulation follows animation with additional \"stiffness\" and \"damping\" attributes stiffness is the \"springiness\" whereas damping is the \"plasticity\". A control can have 0 damping and be very springy and active. It can also have 0 stiffness, but that would basically disable it. On a technical note, the attributes exposed on your animation control are \"proxy\" attributes. Which means they can be animated either from your control, or from the source node, such as the rSocketConstraint shape node under your control. Here are some more videos to get you familiar with the tool. More videos","title":"Dynamic Control 2.0"},{"location":"releases/2020.11.23/#limitations","text":"Some limitations in this current version, yell if these affect you. Negative scale not allowed , the tool will refuse your request Rotate and scale pivots are zeroed out The same goes for all things Ragdoll at the moment.","title":"Limitations"},{"location":"releases/2020.11.23/#center-of-mass","text":"If you try and balance something on your finger, but the \"center of mass\" is off center, it would fall over. It is the point at which the weight of an object is equal in all directions. Ragdoll automatically computes this point based on what the shape looks like. For meshes, it will voxelise your geometry to figure out the physically accurate volumetric center of mass, assuming the density of the object is uniform throughout (rather than hollow or variadic, like swiss cheese). You can now override this point using rdRigid.centerOfMass . Guidelines For realistic results, leave it at 0 to compute the point automatically based on the shape For full control, override it","title":"Center of Mass"},{"location":"releases/2020.11.23/#angular-mass","text":"In real life, if you spin a broom 180 degrees along its length; that's easy. But if you spin it 180 degrees along any other axis, like a ninja, it's considerably heavier. The reason is something called \"angular mass\" or \"moment of inertia\". It's like mass, but in terms of rotation rather than position. The broom has a low angular mass around its length axis, and a high angular mass in the other two axes. That makes it \"heavier\" around some axes but not others. This effect happens in Ragdoll too and is typically automatically computed for you based on the shape you use. If it looks like the broom, then the angular mass will also be lighter around its length then its width. With this release, you can now customise this for greater control of your rotations. When would you want to do that? Your shape looks like a broom, but you want it to act like a box Your shape doesn't look like a broom, but you would like it to Or any combination in between. :) Generally, a broom or any thin shape is more easily spun along its length, so you may find stability in setting your angular mass to (1.0, 1.0, 1.0) , at the expense of realism. Guidelines For realistic results, leave it at -1 to automatically compute the angular mass For full control, override it","title":"Angular Mass"},{"location":"releases/2020.11.23/#auto-connect","text":"The \"Auto Connect\" option now enables you to specify whether to connect joints, or any selected object.","title":"Auto Connect"},{"location":"releases/2020.11.24/","text":"Hotfix, the last release broke a few things. FIXED You can now save the Maya scene. Imagine that! FIXED You can now enable the Ragdoll solver after having disabled it That's all, have mercy.","title":"2020.11.24"},{"location":"releases/2020.12.01/","text":"Lots of good stuff! CHANGED Active & Passive Rigid More intuitive jargon for these suckers CHANGED Character 2.0 New and improved, now with cup-holders! ADDED Dynamic Control Capsules For those flat controls ADDED Time Multiplier Speed up or slow down your simulation, can be animated! ADDED Normalise Shapes Evenly distribute shapes across a hierarchy ADDED Auto Orient Don't bother orienting your joints with this nifty automation, now the X-axis always means \"length\" CHANGED Delete all Physics now also deletes Ragdoll's attributes on your animation controls, for that squeaky clean feeling ADDED Support for custom Rotate Order means more character controls now work out-of-the-box. FIXED Undo bug and rdRigid The rigids should now clean up after themselves better FIXED Simulation start time now uses the start range rather than start time, which is what you would expect NOTES Stick figures Learn about how thickness affects your simulation NOTES Animation in 1995 Witness how little our industry has changed since then, let's fix that! Active & Passive Rigid Body The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\"). Character 2.0 - \"Auto-Ragger\" This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page Dynamic Control Capsules Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page Normalise Shapes An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up Time Multiplier Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene Rotate Order Now rigids plya well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one! Auto Orient Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons. Undo Bug There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed! Stick Figures In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head? Animation in 1995 Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"2020.12.01"},{"location":"releases/2020.12.01/#active-passive-rigid-body","text":"The terminology for \"Rigid\" and \"Collider\" wasn't clear. Surely, a \"Rigid\" collides too? With this release, I've updated the jargon to make a little more sense. Active Rigid A rigid that moves is active Passive Rigid A rigid that doesn't move is passive This also goes for the kinematic attribute which has been renamed passive , highlighting that an active rigid can made passive by flicking this switch. Backwards compatibility is preserved by keeping the underlying attribute name, and only changing it in the Channel Box and Attribute Editor (i.e. the \"nice name\").","title":"Active &amp; Passive Rigid Body"},{"location":"releases/2020.12.01/#character-20-auto-ragger","text":"This release expands on the \"Character\" tool with some nifty new features. But since I haven't mentioned what 1.0 was capable of, here's an overall round down of what it is and when to use it. Character is a one-click character creation tool - and auto-rigger (or auto-ragger, if you will). It's designed to give you the essential tools for turning any native Maya skeleton into an animatable rigid body hierarchy. Read more about it on this new dedicated page I've made for it. Character Page","title":"Character 2.0 - \"Auto-Ragger\""},{"location":"releases/2020.12.01/#dynamic-control-capsules","text":"Now Dynamic Control can be configured to generate capsules between selected controls, instead of assuming that the NURBS CVs neatly wrap around the model. Current and Default behaviour The tool uses the Mesh shape per default like before. Alternative Capsules But if your controls do not have volume, or do not nicely wrap the underlying model, you can now use Capsules instead. The caveat with capsules is that the tool cannot know how long to make your capsules. Therefore, there is an option to use the last-selected node as a hint for how long to make it. In this example, 5 nodes selected, 1 passive and 3 active rigids comes out. If you don't use a last selection for length, the last selected capsule will have a length of 0 (it'll be a sphere). That can work in some cases, but is generally discouraged. The center of mass would be wrong and you should expect unrealistic results until you tweak it to fit your model. Gathering information about Dynamic Control on the.. Dynamic Control Page","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.01/#normalise-shapes","text":"An early version of the \"Normalise Sizes\" tool, meant to more evenly distribute sizes of shapes across a hierarchy. Per default, shapes are sized based on the geometry of the Maya node. If it's a box, it'll get the dimensions of the box. If it's a joint, it'll get the length and radius of that joint. But because this mechanism can't see past the one node it's looking at, it's an uphill battle making shapes evenly distributed in a greater network. The \"Normalise Sizes\" tool is meant to address that. It's still early, and a few things are missing. Resolve Self-intersections These are more likely to happen the larger shapes get. Handle spine It tends to become too thin and desperately needs to be thickened up","title":"Normalise Shapes"},{"location":"releases/2020.12.01/#time-multiplier","text":"Now you can speed up or slow down your simulation with a multiplier attribute found on the rdScene node! If you need something happening really-really fast , don't forget to also up your Substeps . If you need something even faster, like a bullet moving across the room in 2 frames, activate Continuous Collision Detection to prevent it from flying through stuff without noticing. For anything slower than real-time, remember contacts and constraints are solved each frame, so more frames means more accurate simulation. If you don't like that, you can either (1) half the substeps alongside halving time or (2) bake out the simulation and scale the bake instead. Example Scene","title":"Time Multiplier"},{"location":"releases/2020.12.01/#rotate-order","text":"Now rigids plya well with non-standard rotation orders, very common your everyday character animation rigs to ensure axes don't go gimbal. Thanks to Peter Jemstedt for help on this one!","title":"Rotate Order"},{"location":"releases/2020.12.01/#auto-orient","text":"Shapes and constraints can now be automatically oriented based on the parent and child of each joint (soon coming to controls). This should help sort out those pesky joint orientations any manner of skeletons.","title":"Auto Orient"},{"location":"releases/2020.12.01/#undo-bug","text":"There was this nasty bug that caused rdRigid nodes to remain behind after creating and then undoing. But what got left behind wasn't your normal nodes. They only appeared in the Node Editor and could not be selected or even deleted. They would show themselves out when re-opening the Maya scene which is great. This visibility isn't a problem in itself, if it wasn't for them also being visible from Python. If any command needed to know \"hey, animation control, are you connected to a rigid?\" then it would happily reply \"yes! for sure!\". And that's bad. But not anymore, because it's fixed!","title":"Undo Bug"},{"location":"releases/2020.12.01/#stick-figures","text":"In a previous release I touched on \"angular mass\" and what it meant for your simulations. Let's look at this in practice. Here's one character with identical settings, the only difference is the radius of her capsules, and yet the move differently. Why is that? Remember that angular mass is 3-dimensional. Just like normal mass, when mass is high, more force is required to introduce motion. In the case of angular mass, the force required is divided into three axes. In this illustration, the angular mass along the X axis is much larger than Y and Z, so in to rotate around this axis you need much more force than the other two axes. There is however only 1 value for \"guide strength\". You can think of this force as being distributed across each axis, relative its mass. For example, if your Guide Strength is 10.0, then the distribution might look something like this. X Strength = 10 Y Strength = 2 Z Strength = 1 Whereas if angularMassX was equal like a square cube.. X Strength = 10 Y Strength = 10 Z Strength = 10 In light of this, what are your options? Fit your geometry The most realistic behaviour is what you get when model your shapes to the geometry you are animating. Adjust to taste If there is no geometry, or if the geometry is of an actual stick figure that you would like to act like a person, thicknen up your shapes. To separate between behaviour and collisions, add a second rigid and disable collisions on the first. Edit angularMass The least intrusive but perhaps most complex option is to manually specify a preferred angular mass. Here's the scene and one more gif to keep you warm at night. https://files.ragdolldynamics.com/share/rKN1sryQ Some things to experiment with: What if she has a really heavy head? ..really heavy hand ? What if the Guide Strength was halved? ..or 10x?! What if you remove Guide Strength on her hip? What if you add an extra Guide to her head?","title":"Stick Figures"},{"location":"releases/2020.12.01/#animation-in-1995","text":"Stumbled upon this (thanks Jarl!) which I think is a great example of what I think we're ready to move away from as an industry. :) https://twitter.com/jeandenishaas/status/1330671654477860864 Here's a prediction for you - about a year from now, you won't be keyframing anymore. You'll be recording .","title":"Animation in 1995"},{"location":"releases/2020.12.07/","text":"Small release with important changes if you use Dynamic Controls on complex rigs with pre-existing animation. ADDED Blend Rigid Now rigids can do some of what Dynamic Controls can do. :) FIXED Dynamic Control switch Shape You can now switch to capsules after having created them as meshes. FIXED Dynamic Control and Undo If your controls have pre-existing animation, undo will now work properly FIXED Dynamic Control and Auto Orient If you controls have intermediate groups between themselves, auto axis will now work properly Blend Rigid Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box. Dynamic Control Capsules Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around. Dynamic Control and Undo You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo. Dynamic Control and Orient Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"2020.12.07"},{"location":"releases/2020.12.07/#blend-rigid","text":"Non-destructive guidance from your original animation when making active rigid bodies. This works much like Dynamic Control , except the guidance is in worldspace. :) Look at this example of driving an IK handle with physics. You can blend between simulation and animation using the blendSimulation node in the Channel Box.","title":"Blend Rigid"},{"location":"releases/2020.12.07/#dynamic-control-capsules","text":"Change shape type, after creation. No matter the starting type. In the previous release, I added an option for generating dynamic controls as capsules instead of using the actual NURBS geometry. The usecase is for controls that don't have enough geometry to sufficiently wrap around the underlying geometry. This release enables the user to switch between capsules and mesh after having made the dynamic control. Previously, it was only possible to switch from Capsule to Mesh, not the other way around.","title":"Dynamic Control Capsules"},{"location":"releases/2020.12.07/#dynamic-control-and-undo","text":"You couldn't undo, now you can. I found and patched a nasty bug that affected any Dynamic Control - and in fact any Rigid - created with anyhting that had pre-existing animation or connections of any kind, breaking undo.","title":"Dynamic Control and Undo"},{"location":"releases/2020.12.07/#dynamic-control-and-orient","text":"Orientations were whack, now they're back. Previously, the orientation of dynamic controls were determined by the physical hierarchy of the control. If the immediate parent was the expected parent control, all was well. But in real-world rigs, there are typically several intermediate groups - some empty, some constrained, some offsets. In such cases, the immediate parent can't be assumed to be the visible parent control the animator sees on screen. This releases solves this by treating the user-selection as the hierarchy, regardless of what the actual hierarchy looks like. This means you the animator get to control how things are oriented, just like you control what is to be simulated.","title":"Dynamic Control and Orient"},{"location":"releases/2020.12.18/","text":"Documentation documentation documentation! ADDED Documentation You heard it here first! ADDED Help Page All menu items now offer a dedicated help page for details about how it works. ADDED Timeline More videos more easily accessible via the new Timeline feature of UIs CHANGED API \ud83d\udc96 cmds The API now integrates with maya.cmds ADDED Shelf Support Menu items can now be added to your own custom shelf with Ctrl + Shift + Click ADDED Helper warnings Ragdoll now warns when doing something unsupported This version expires January 10 2021 Documentation Since the last release I've added a boatload of documentation to Ragdoll, including the very website you are visiting now! https://learn.ragdolldynamics.com This is where I'll aggregate anything there is to know about Ragdoll, including links to the upcoming forums and chat rooms, YouTube series and more. More more more! Documentation is generated dynamically from the same source used to generate the in-Maya menu and graphical dialogs, so whenever you want quick help from within Maya without breaking your flow, you can! And when you're on the train without access to Maya wanting to know more about a particular button or feature, you can! Overview Help Page Every menu item now comes with the Help sub-menu active. The page can also be accessed by clicking on the top description. I also added hints to the labels of attributes, rather than just the widgets themselves. All of the information is generated from the same source as the website, so they'll tell you the same thing except closer to where you are. For example, the Active Rigid menu item: https://learn.ragdolldynamics.com/menu/#active-rigid Timeline Multiple videos are now visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about. Real-time scrubbing I've added real-time scrubbing too! The caveat however is that it consumes a lot of RAM, this dialog of about 1,000 frames takes 1.5 GB of RAM, and a hefty delay to showing the option dialog. API and cmds The API used to take and return instances of cmdx , the high-performance alternative to PyMEL. The API now integrates seamlessly with maya.cmds , both taking and returning node paths (i.e. strings) rather than instances, which means you can now do this! from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) The performance advantage of cmdx is still intact, and can be accessed via commands.py which contains identical members and argument signatures, except returning instanced of cmdx instead. This is what's used internally for both performance and readability. In addition, there is now support for interactive.py for quick-and-dirty one-off scripts. This module contains all of what is provided by the Ragdoll menu and work similarly to api.py except they take (1) user selection and (2) user preferences into account. API Reference Add to Shelf Menu items can now be added to the shelf by holding Ctrl + Shift + Click. Menu items also reveal the equivalent Python command to use for your scripts! Helper Warnings If nodes have custom pivots or if your Maya scene is set to DG evaluation mode, Ragdoll will tell you about why that's a bad idea.","title":"2020.12.18"},{"location":"releases/2020.12.18/#documentation","text":"Since the last release I've added a boatload of documentation to Ragdoll, including the very website you are visiting now! https://learn.ragdolldynamics.com This is where I'll aggregate anything there is to know about Ragdoll, including links to the upcoming forums and chat rooms, YouTube series and more. More more more! Documentation is generated dynamically from the same source used to generate the in-Maya menu and graphical dialogs, so whenever you want quick help from within Maya without breaking your flow, you can! And when you're on the train without access to Maya wanting to know more about a particular button or feature, you can! Overview","title":"Documentation"},{"location":"releases/2020.12.18/#help-page","text":"Every menu item now comes with the Help sub-menu active. The page can also be accessed by clicking on the top description. I also added hints to the labels of attributes, rather than just the widgets themselves. All of the information is generated from the same source as the website, so they'll tell you the same thing except closer to where you are. For example, the Active Rigid menu item: https://learn.ragdolldynamics.com/menu/#active-rigid","title":"Help Page"},{"location":"releases/2020.12.18/#timeline","text":"Multiple videos are now visible in the UI, to shed more light onto how things work. Hints Hovering over the currently playing video displays a description of what it is about. Real-time scrubbing I've added real-time scrubbing too! The caveat however is that it consumes a lot of RAM, this dialog of about 1,000 frames takes 1.5 GB of RAM, and a hefty delay to showing the option dialog.","title":"Timeline"},{"location":"releases/2020.12.18/#api-and-cmds","text":"The API used to take and return instances of cmdx , the high-performance alternative to PyMEL. The API now integrates seamlessly with maya.cmds , both taking and returning node paths (i.e. strings) rather than instances, which means you can now do this! from maya import cmds from ragdoll import api as rd cube , _ = cmds . polyCube () cmds . move ( 0 , 10 , 0 ) cmds . rotate ( 35 , 50 , 30 ) scene = rd . createScene () rigid = rd . createRigid ( cube , scene ) cmds . evalDeferred ( cmds . play ) The performance advantage of cmdx is still intact, and can be accessed via commands.py which contains identical members and argument signatures, except returning instanced of cmdx instead. This is what's used internally for both performance and readability. In addition, there is now support for interactive.py for quick-and-dirty one-off scripts. This module contains all of what is provided by the Ragdoll menu and work similarly to api.py except they take (1) user selection and (2) user preferences into account. API Reference","title":"API and cmds"},{"location":"releases/2020.12.18/#add-to-shelf","text":"Menu items can now be added to the shelf by holding Ctrl + Shift + Click. Menu items also reveal the equivalent Python command to use for your scripts!","title":"Add to Shelf"},{"location":"releases/2020.12.18/#helper-warnings","text":"If nodes have custom pivots or if your Maya scene is set to DG evaluation mode, Ragdoll will tell you about why that's a bad idea.","title":"Helper Warnings"},{"location":"releases/2021.01.04/","text":"This release introduces proper licencing to Ragdoll. ADDED Official Website Tell your friends! ADDED Licencing Read all about it! FIXED Locked rotatePivot Minor bug patched up and ready to go FIXED Centered Option Window - On Linux, the option window would sometimes appear in the top-left corner of the screen. No more! Website Happy New Year, the year of Ragdoll. :) I've launched the next generation of Ragdoll's website. Something a little more flashy and intended to wet people's appetite for what lies ahead. Feel free to tell people about it, I've added a note about when it'll become a reality. https://ragdolldynamics.com Also see this news coverage happening in Japan! :D https://3dnchu.com/archives/ragdoll-dynamics-maya/ The old website can still be accessed, although it is a little crippled. https://alanjfs.github.io/ragdoll-web/ If any link fails, just make sure it's prefixed with ragdoll-web/ as the landing page, e.g. https://alanjfs.github.io/ragdoll-web/howto Licencing Ragdoll is growing up and now understands the \"product key\" which means users can now purchase a copy and register it to themselves. Here's the short version, with a longer version below. Can I use it on more than one machine? Yes Can I move a licence between two machines? Yes Do I need an internet connection to use Ragdoll? Yes and no What if someone steals my licence key? Bummer Can I have a floating licence? Soon Can I activate offline? Soon When exactly is internet required? See long answer Can I manage my licence via Python? Yes Now let's cover the nitty gritty details, at the time of this writing. See licencing for current up-to-date information if you are reading this from the future. What's changed? You won't notice a change, other than a new UI. Rather than Ragdoll expiring on a fixed date, it'll now expire 30 days after first launch, unless you activate. Activation requires a product key which you get by either purchasing a licence or being really awesome. How does it work? On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Click Activate Enter your product key Or if you prefer: from ragdoll import licence licence . activate ( key ) Can I use it on more than one machine? Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence. Can I move a licence between two machines? Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released. Do I need an internet connection to use Ragdoll? Yes and no. Yes: To activate either the trial of purchased version of Ragdoll, the machine needs a connection to the internet. No: Once activated, you won't need internet for 90 days No: For special cases, get in touch. What if someone steals my licence key? That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one. Can I have a floating licence? Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All I need is you. Can I activate offline? Yes. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch. When exactly is internet required? A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain. Can I manage my licence via Python? Sure can, see below. Licence API As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" # Is the current licence activated? \"isActivated\" # Is the current licence a trial licence? \"isTrial\" # Has the licence not been tampered with? \"isGenuine\" # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" # How many days until this trial expires? \"trialDays\" } Locked Rotate Pivot Ragdoll doesn't support a custom rotatePivot attribute and would zero this out whenever a transform is turned dynamic. It'll provide a warning to the end user that this would happen. But, it wasn't taking into account the rotatePivot being connected or locked. If that happened, Ragdoll would flat out refuse and print something cryptic in the Script Editor. This has now been fixed. If the attribute is zero, nothing changes If the attribute is modified, it'll be zeroed out If the attribute is locked or connected, a warning is printed, but nothing changes. Ragdoll still doesn't actually support a custom rotate pivot. So this fixes only the situation where.. The rotatePivot is zero (default), and.. The rotatePivot is locked","title":"2021.01.04"},{"location":"releases/2021.01.04/#website","text":"Happy New Year, the year of Ragdoll. :) I've launched the next generation of Ragdoll's website. Something a little more flashy and intended to wet people's appetite for what lies ahead. Feel free to tell people about it, I've added a note about when it'll become a reality. https://ragdolldynamics.com Also see this news coverage happening in Japan! :D https://3dnchu.com/archives/ragdoll-dynamics-maya/ The old website can still be accessed, although it is a little crippled. https://alanjfs.github.io/ragdoll-web/ If any link fails, just make sure it's prefixed with ragdoll-web/ as the landing page, e.g. https://alanjfs.github.io/ragdoll-web/howto","title":"Website"},{"location":"releases/2021.01.04/#licencing","text":"Ragdoll is growing up and now understands the \"product key\" which means users can now purchase a copy and register it to themselves. Here's the short version, with a longer version below. Can I use it on more than one machine? Yes Can I move a licence between two machines? Yes Do I need an internet connection to use Ragdoll? Yes and no What if someone steals my licence key? Bummer Can I have a floating licence? Soon Can I activate offline? Soon When exactly is internet required? See long answer Can I manage my licence via Python? Yes Now let's cover the nitty gritty details, at the time of this writing. See licencing for current up-to-date information if you are reading this from the future.","title":"Licencing"},{"location":"releases/2021.01.04/#whats-changed","text":"You won't notice a change, other than a new UI. Rather than Ragdoll expiring on a fixed date, it'll now expire 30 days after first launch, unless you activate. Activation requires a product key which you get by either purchasing a licence or being really awesome.","title":"What's changed?"},{"location":"releases/2021.01.04/#how-does-it-work","text":"On first launch, Ragdoll will try and connect to the Ragdoll Licence Server (internet connection required, offline activation coming soon) and register your trial version. This version is node-locked to the particular machine you are on. It'll stick with the machine even across re-installs of your operating system. Once you've acquired a product key, you can either: Click the Ragdoll menu item (bottom) Click Activate Enter your product key Or if you prefer: from ragdoll import licence licence . activate ( key )","title":"How does it work?"},{"location":"releases/2021.01.04/#can-i-use-it-on-more-than-one-machine","text":"Yes. You can activate and use Ragdoll on up to 3 machines. You just can't run a simulation on more than 1 at a time, that could lead to suspension of the licence.","title":"Can I use it on more than one machine?"},{"location":"releases/2021.01.04/#can-i-move-a-licence-between-two-machines","text":"Yes. If you've activated 3 licences, you can hit the Deactivate button (which is same as the Activate button once you've actiavted) and the activation will be released.","title":"Can I move a licence between two machines?"},{"location":"releases/2021.01.04/#do-i-need-an-internet-connection-to-use-ragdoll","text":"Yes and no. Yes: To activate either the trial of purchased version of Ragdoll, the machine needs a connection to the internet. No: Once activated, you won't need internet for 90 days No: For special cases, get in touch.","title":"Do I need an internet connection to use Ragdoll?"},{"location":"releases/2021.01.04/#what-if-someone-steals-my-licence-key","text":"That key is all that is required to run Ragdoll on any machine. If someone takes your key and activates 3 of their own machines, you won't be able to activate it yourself. If this happens, email us with proof of ownership (e.g. via the email used when purchasing) and you'll get a new one.","title":"What if someone steals my licence key?"},{"location":"releases/2021.01.04/#can-i-have-a-floating-licence","text":"Yep, get in touch with licencing@ragdolldynamics.com . Later on, these will be as trivial as node-locked licences. All I need is you.","title":"Can I have a floating licence?"},{"location":"releases/2021.01.04/#can-i-activate-offline","text":"Yes. As soon as someone needs it, I'll add it. Get in touch with licencing@ragdolldynamics.com Offline will be a 4-step process. Running e.g. activation_request_to_file() from you local machine Emailing generated file Receiving a licence file back Running e.g. activate_from_file(fname) on the same local machine. Floating offline is also be possible, again get in touch.","title":"Can I activate offline?"},{"location":"releases/2021.01.04/#when-exactly-is-internet-required","text":"A connection is made in one of two separate occasions. Calling ragdoll.licence.install() On simulating any frame install() is typically called on Maya startup when the plug-in is loaded and menu is installed. You can disable this. That is, Maya can open a scene with Ragdoll in it without making a connection to the internet if neither of these things happen. This means you can simulate on one machine, bake or otherwise disable the solver and send it off to a farm (e.g. local or cloud) without worrying about licences. The alternative would be having to erase any trace of Ragdoll from a scene which would be such a pain.","title":"When exactly is internet required?"},{"location":"releases/2021.01.04/#can-i-manage-my-licence-via-python","text":"Sure can, see below.","title":"Can I manage my licence via Python?"},{"location":"releases/2021.01.04/#licence-api","text":"As a user, you'll generally use the UI. But the UI is ultimately making calls to Python (which is making calls to C++) and you can bypass the UI using these same calls. from ragdoll import licence # Called once before calling any other licencing function # This is automatically called on Ragdoll Python initialisation # and simulation start, but needs calling manually if simulation # hasn't yet started. licence . install () # Retrieve the currently activated product key licence . current_key () # Activate using your product ket licence . activate ( key ) # Deactivate whatever key is currently activated licence . deactivate () # Dictionary of useful information data = licence . data () { # Same as current_key \"key\" # Is the current licence activated? \"isActivated\" # Is the current licence a trial licence? \"isTrial\" # Has the licence not been tampered with? \"isGenuine\" # Has the licence been verified with the server # (requires a connection to the internet)? \"isVerified\" # How many days until this trial expires? \"trialDays\" }","title":"Licence API"},{"location":"releases/2021.01.04/#locked-rotate-pivot","text":"Ragdoll doesn't support a custom rotatePivot attribute and would zero this out whenever a transform is turned dynamic. It'll provide a warning to the end user that this would happen. But, it wasn't taking into account the rotatePivot being connected or locked. If that happened, Ragdoll would flat out refuse and print something cryptic in the Script Editor. This has now been fixed. If the attribute is zero, nothing changes If the attribute is modified, it'll be zeroed out If the attribute is locked or connected, a warning is printed, but nothing changes. Ragdoll still doesn't actually support a custom rotate pivot. So this fixes only the situation where.. The rotatePivot is zero (default), and.. The rotatePivot is locked","title":"Locked Rotate Pivot"},{"location":"releases/2021.01.14/","text":"Highlight for this release are the new Multiplier Nodes ! ADDED Multiplier Nodes Animate in bulk with this nifty utility node! ADDED Environment variables Gain more control over the integration of Ragdoll into your pipeline ADDED Dynamic Shape Type Attributes Cleaner channel box means happier animators FIXED NaN and Dynamic Control Got bogus values on the Rotate Limit of Dynamic Controls? No longer! FIXED Cycle warnings on create In rare occasions, Maya would complain that there's a cycle just as you turn a control dynamic. No more. FIXED Zero limit strength Used to be interpreted as \"inifinitely strong\", but now is \"off\" as one would expect. PUBLICITY EnTT We got mentioned in this great project :) OPTIMISATION Bounding Box Minor performance and stability improvements with native bounding box support Multiplier Nodes Work procedurally, with this centralised place to edit any number of rigids or constraints simultaneously. The idea is to facilitate a top-level node which govern the overall look of your simulation; withouth having to find and select each control individually. Workflow Select any number of rigids or constraints Click Multiply Selected Constraints (or Rigids ) The order in which you select matters, the first selection gets the node. The recommended workflow is to start with the root and work your way out. But your selection can span multiple hierarchies or even the whole character. A quick \"Select Hierarchy\" across an entire character is possible also. A constraint and rigid can only have 1 multiplier connected at any one time. Demo The most common attributes are made available currently, let me know if you find something missing! YouTube Wolf Rig Example Multiply Constraint Attributes Multiply Rigid Attributes Environment Variables Added these suckers for you to play around with. Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset For up to date information, see here. https://learn.ragdolldynamics.com/api/#environment-variables EnTT Getting some more recognition on the interwebs from EnTT, the library used to keep Ragdoll fast and clean! https://github.com/skypjack/entt Dynamic Shape Type Attributes Now only relevant attributes are visible in the Channel Box, dynamically based on the current type. I've added an option to disable this in the Global Preferences. Bounding Box Maya uses bounding box information to avoid drawing things that aren't visible in camera. The previous version of Ragdoll didn't provide Maya with any bounding box, which left Maya with no choice but to draw these always; even when behind the camera. Now this isn't so. You shouldn't notice much for smaller scenes, but drawing typically consumes 20-30% of the total CPU impact Ragdoll has on your character rigs. So for larger scenes this should reap a significant performance boost. Pro tip: You can also disable drawing of all Ragdoll primitives by disabling Locators in your viewport; that's how Maya classifies any and all Ragdoll nodes. Cycle Warnings TLDR; you should now experience fewer cycle warnings. https://forums.ragdolldynamics.com/t/how-to-cause-a-cycle-warning/33 Whenever you create a rigid from any Maya node, like an animation control, Ragdoll makes a note of the position and orientation of that control. It takes into account that you may not be on the start frame when you create the control, which is what you most likely intended to do. When that happens, Maya will silently roll back time in the background to query an attribute at the start frame. This silent roll-back has a tendency to trigger evaluation of unrelated nodes, like IK handles, which in turn trigger other nodes, ultimately leading back to where it came from, and thus cause a cycle. These were somewhat harmless, but could mask a real cycle from happening. In this release, this silent roll back only happens when you actually aren't on the start frame. So you should see less of it. There's still room for improvement however, so if you still find warnings or any odd behaviors being due to cycles, do reach out! NaN If you've ever gotten these, you can now rest easy. They are gone. They could happen on occasion, especially after repeated undo. It had to do with memory access violation by Maya being naughty, something it really shouldn't be able to do in the first place. We now guard against this , so all is well.","title":"2021.01.14"},{"location":"releases/2021.01.14/#multiplier-nodes","text":"Work procedurally, with this centralised place to edit any number of rigids or constraints simultaneously. The idea is to facilitate a top-level node which govern the overall look of your simulation; withouth having to find and select each control individually. Workflow Select any number of rigids or constraints Click Multiply Selected Constraints (or Rigids ) The order in which you select matters, the first selection gets the node. The recommended workflow is to start with the root and work your way out. But your selection can span multiple hierarchies or even the whole character. A quick \"Select Hierarchy\" across an entire character is possible also. A constraint and rigid can only have 1 multiplier connected at any one time. Demo The most common attributes are made available currently, let me know if you find something missing! YouTube Wolf Rig Example Multiply Constraint Attributes Multiply Rigid Attributes","title":"Multiplier Nodes"},{"location":"releases/2021.01.14/#environment-variables","text":"Added these suckers for you to play around with. Variable Description Default RAGDOLL_PLUGIN Absolute path to binary plugin, .mll on Windows .so on Linux. This overrides whatever is on MAYA_PLUG_IN_PATH \"ragdoll\" RAGDOLL_NO_AUTOLOAD Do not automatically load the plug-in and add the menu on startup of Maya. False RAGDOLL_NO_STARTUP_DIALOG Do not display the startup-dialog on first launch. False RAGDOLL_AUTO_SERIAL Automatically activate Ragdoll on install using this serial number. Unset For up to date information, see here. https://learn.ragdolldynamics.com/api/#environment-variables","title":"Environment Variables"},{"location":"releases/2021.01.14/#entt","text":"Getting some more recognition on the interwebs from EnTT, the library used to keep Ragdoll fast and clean! https://github.com/skypjack/entt","title":"EnTT"},{"location":"releases/2021.01.14/#dynamic-shape-type-attributes","text":"Now only relevant attributes are visible in the Channel Box, dynamically based on the current type. I've added an option to disable this in the Global Preferences.","title":"Dynamic Shape Type Attributes"},{"location":"releases/2021.01.14/#bounding-box","text":"Maya uses bounding box information to avoid drawing things that aren't visible in camera. The previous version of Ragdoll didn't provide Maya with any bounding box, which left Maya with no choice but to draw these always; even when behind the camera. Now this isn't so. You shouldn't notice much for smaller scenes, but drawing typically consumes 20-30% of the total CPU impact Ragdoll has on your character rigs. So for larger scenes this should reap a significant performance boost. Pro tip: You can also disable drawing of all Ragdoll primitives by disabling Locators in your viewport; that's how Maya classifies any and all Ragdoll nodes.","title":"Bounding Box"},{"location":"releases/2021.01.14/#cycle-warnings","text":"TLDR; you should now experience fewer cycle warnings. https://forums.ragdolldynamics.com/t/how-to-cause-a-cycle-warning/33 Whenever you create a rigid from any Maya node, like an animation control, Ragdoll makes a note of the position and orientation of that control. It takes into account that you may not be on the start frame when you create the control, which is what you most likely intended to do. When that happens, Maya will silently roll back time in the background to query an attribute at the start frame. This silent roll-back has a tendency to trigger evaluation of unrelated nodes, like IK handles, which in turn trigger other nodes, ultimately leading back to where it came from, and thus cause a cycle. These were somewhat harmless, but could mask a real cycle from happening. In this release, this silent roll back only happens when you actually aren't on the start frame. So you should see less of it. There's still room for improvement however, so if you still find warnings or any odd behaviors being due to cycles, do reach out!","title":"Cycle Warnings"},{"location":"releases/2021.01.14/#nan","text":"If you've ever gotten these, you can now rest easy. They are gone. They could happen on occasion, especially after repeated undo. It had to do with memory access violation by Maya being naughty, something it really shouldn't be able to do in the first place. We now guard against this , so all is well.","title":"NaN"},{"location":"releases/2021.01.15/","text":"The gift that keeps on giving, the highlight for this release is Dynamic Control 3.0 ! UX Dynamic Control 3.0 More intuitive, more smart UX Convert & Restore Slimmer and more intuitive UI Passive Grayscale Passive rigids are now distinguished by grayscale colors ADDED Select All Quickly select all rigids and constraints with this handy menu or shelf item. Dynamic Control 3.0 Another step forward for Dynamic Controls. Default Capsule Ragdoll now defaults to the newer Capsule shape type for dynamic controls. It's faster and applies more generally to most rigs; even those that do have NURBS curves wrapping around the underlying character geometry. Before After Automatic Multiplier The previous release introduced Multiplier Nodes . This release add a multiplier to each new dynamic control chain per default, on the root control, which means you can now do stuff like this! Centralised Blend Simulation Previously, to blend between animation and simulation you needed to select the controls to blend and edit each individually. But it's rather uncommon (and probably not very useful) to want independent control over each blend. In this release, there is 1 central Blend Simulation attribute on the root dynamic control. This can be changed in the Options, but will probably disappear unless someone says they like it and wants to keep it! Smart Tip Length Previously, Ragdoll wasn't able to figure out how long to make the last control. Now it borrows length, radius and orientation from the parent capsule, which should be what you expect for the majority of cases. Meaning you can now expect this. Before After You can change the shape type after creation, and modify the default value in the options dialog. Transparent Root The first selection of a dynamic control chain is passive, and it used to also collide with the first child. But, most of the time, that root isn't useful as a collider. It would be a global hip control or some particular shoulder/clavicle gizmo. So the root is now set to Collide = False , meaning this is now ok. You can still enable it afterwards if you'd like. Convert and Restore I've merge the Convert Rigid and Convert Constraint buttons into the rigid and constraint creation buttons. Convert Rigid Turn a passive into an active rigid, or vice versa. Select active rigid in viewport Click Passive to convert it into a passive rigid If it's already passive, nothing happens. If you wanted to make a passive rigid active, you know what to do. Convert Constraint Turn a Socket Constraint into a Hinge Constraint, or any other type, on-the-fly. Select any constraint Click Socket to turn it into a socket constraint, regardless of what it was Restore Constraint Sometimes you just want to start from scratch. And using the same convert feature you can also restore a constraint to its original settings. Select any constraint Click any constraint type Passive Grayscale Spot passive rigids by their colors, now all passive rigids are gray. That means.. Active rigids are multi-colored Passive rigids are gray Controls are blue Select All Sometimes you want to make bulk changes to all rigids or all constraints at once. You could select each of them, or you could turn to Python and say.. cmds . select ( cmds . ls ( type = \"rdRigid\" )) Now there's a menu item for it too! With nothing selected, it'll select all rigids or constraints With something selected, it'll filter that selection for just rigids or constraints That means you can either find everything all at once and make great big changes, or you can zone in on a particular hierarchy or character and affect all rigids or constraints in just that hierarchy! Fire Wolf rig courtesy of Truong CG Artist","title":"2021.01.15"},{"location":"releases/2021.01.15/#dynamic-control-30","text":"Another step forward for Dynamic Controls.","title":"Dynamic Control 3.0"},{"location":"releases/2021.01.15/#default-capsule","text":"Ragdoll now defaults to the newer Capsule shape type for dynamic controls. It's faster and applies more generally to most rigs; even those that do have NURBS curves wrapping around the underlying character geometry. Before After","title":"Default Capsule"},{"location":"releases/2021.01.15/#automatic-multiplier","text":"The previous release introduced Multiplier Nodes . This release add a multiplier to each new dynamic control chain per default, on the root control, which means you can now do stuff like this!","title":"Automatic Multiplier"},{"location":"releases/2021.01.15/#centralised-blend-simulation","text":"Previously, to blend between animation and simulation you needed to select the controls to blend and edit each individually. But it's rather uncommon (and probably not very useful) to want independent control over each blend. In this release, there is 1 central Blend Simulation attribute on the root dynamic control. This can be changed in the Options, but will probably disappear unless someone says they like it and wants to keep it!","title":"Centralised Blend Simulation"},{"location":"releases/2021.01.15/#smart-tip-length","text":"Previously, Ragdoll wasn't able to figure out how long to make the last control. Now it borrows length, radius and orientation from the parent capsule, which should be what you expect for the majority of cases. Meaning you can now expect this. Before After You can change the shape type after creation, and modify the default value in the options dialog.","title":"Smart Tip Length"},{"location":"releases/2021.01.15/#transparent-root","text":"The first selection of a dynamic control chain is passive, and it used to also collide with the first child. But, most of the time, that root isn't useful as a collider. It would be a global hip control or some particular shoulder/clavicle gizmo. So the root is now set to Collide = False , meaning this is now ok. You can still enable it afterwards if you'd like.","title":"Transparent Root"},{"location":"releases/2021.01.15/#convert-and-restore","text":"I've merge the Convert Rigid and Convert Constraint buttons into the rigid and constraint creation buttons.","title":"Convert and Restore"},{"location":"releases/2021.01.15/#convert-rigid","text":"Turn a passive into an active rigid, or vice versa. Select active rigid in viewport Click Passive to convert it into a passive rigid If it's already passive, nothing happens. If you wanted to make a passive rigid active, you know what to do.","title":"Convert Rigid"},{"location":"releases/2021.01.15/#convert-constraint","text":"Turn a Socket Constraint into a Hinge Constraint, or any other type, on-the-fly. Select any constraint Click Socket to turn it into a socket constraint, regardless of what it was","title":"Convert Constraint"},{"location":"releases/2021.01.15/#restore-constraint","text":"Sometimes you just want to start from scratch. And using the same convert feature you can also restore a constraint to its original settings. Select any constraint Click any constraint type","title":"Restore Constraint"},{"location":"releases/2021.01.15/#passive-grayscale","text":"Spot passive rigids by their colors, now all passive rigids are gray. That means.. Active rigids are multi-colored Passive rigids are gray Controls are blue","title":"Passive Grayscale"},{"location":"releases/2021.01.15/#select-all","text":"Sometimes you want to make bulk changes to all rigids or all constraints at once. You could select each of them, or you could turn to Python and say.. cmds . select ( cmds . ls ( type = \"rdRigid\" )) Now there's a menu item for it too! With nothing selected, it'll select all rigids or constraints With something selected, it'll filter that selection for just rigids or constraints That means you can either find everything all at once and make great big changes, or you can zone in on a particular hierarchy or character and affect all rigids or constraints in just that hierarchy! Fire Wolf rig courtesy of Truong CG Artist","title":"Select All"},{"location":"releases/2021.01.17/","text":"Minor maintenance release. FIXED userSetup.py More robust integration with some pipelines FIXED Two-chain Dynamic Control More able to deal with edge-cases userSetup The startup code for Ragdoll since 2021.01.14 didn't play well with other userSetup.py files, like the ones you might have in a major production pipeline. If you were having any issues with the os module, then this is the fix for you. Two-chain Dynamic Control The previous release made it possible for the last selected Dynamic Control to inherit its size and orientation from the previously selected control. This only worked if you have 3 controls selected. This release makes it work on just 2 controls!","title":"2021.01.17"},{"location":"releases/2021.01.17/#usersetup","text":"The startup code for Ragdoll since 2021.01.14 didn't play well with other userSetup.py files, like the ones you might have in a major production pipeline. If you were having any issues with the os module, then this is the fix for you.","title":"userSetup"},{"location":"releases/2021.01.17/#two-chain-dynamic-control","text":"The previous release made it possible for the last selected Dynamic Control to inherit its size and orientation from the previously selected control. This only worked if you have 3 controls selected. This release makes it work on just 2 controls!","title":"Two-chain Dynamic Control"},{"location":"releases/2021.01.27/","text":"Focus of this release is Solver Iterations , and some UI additions too! ADDED Message Board Greater visibility of warnings and errors ADDED Solver Iterations Trade performance for precision ADDED Help Line The Help Line now displays a summary of what menu items do ADDED Delete from Selection Trim your setup more accurately with this new addition FIXED Locked Channels Now able to simulate even the most locked channel! FIXED Multiple cmdx You're now able to have Ragdoll running in conjunction with cmdx and vendors of cmdx. ADDED Animated Initial State A more adaptive initial state ADDED Worldspace Dynamic Control Dynamic Controls.. now in wordspace! Message Board Ever opened the Script Editor to find Ragdoll screaming for help? I've added a new Message Board to help Ragdoll stand out from the overall messy or hidden messages from rigs and Maya and all else. Your goal then is to never have any messages appear in the Message Board. A silent Message Board means a happy simulation. :) Solver Iterations Anything called strength in Ragdoll is a multipler for stiffness and damping . And currently there's a ceiling to how high stiffness and damping values can go, after which point they just stop having an effect. The values are limited by how many \"iterations\" you let the solver perform. Per default, they are set to 8 and can be found at rdRigid.positionIterations . This release sheds some more light on this somewhat obscure attribute by exposing it directly on the solver, right next to Substeps . This value multiplies each rdRigid.positionIterations attribute, meaning a value of 2 yields a total iteration count for every rigid in the solver of 16 (i.e. 2 * 8 ). Which means you can now do this! You can further customise iteration counts per rigid, under the Advanced tab. There's no limit to how many iterations you can allow; more iterations means greater accuracy. However, I have found that values beyond 128 tend to get funky. Iteration Count Strength Range Description 8 (default) 0-5 Default, sensible for most uses 16 0-10 High 32 0-500 Really, really high 64 0-1000 Ultra Nightmare For completeness, here's how Iterations differ from Substeps . Substep Divide each frame into smaller time steps Iterations Number of times a constraint is \"resolved\" They both provide accuracy in slightly different ways. With a greater amount of substeps, the solver is effectively working in slow-motion. Everything is easier in slow-motion. Resolving constraints is independent of time and a little more technical to describe, so you can instead kind of think of it a little bit like rubbing dirt of a silver platter. The first rub, you'll get most of it off. But the more you rub, the shinier it gets. There's no limit to how much you can rub, but eventually rubbing will stop having a visible effect. Help Line Hovering over any menu item now reveals a short description of what it does in the native Maya Help Line (typically at the bottom of the Maya window). This is the same information as can be found in the Menu Reference . Delete From Selection The Delete All Physics menu-item has gotten an option box, now it can be used to limit deletion to currently selected nodes! Locked Channels The previous release would bark at you whenever trying to turn any transform dynamic if it had any of its translate or rotate channels locked. This was a problem when you didn't necessarily care for some of them. For example, with a dynamic control, you really only cared for the rotate channels but would be prevented from simulating them if the sibling translate channels were locked. No longer! That said, the simulation does still produce both translate and rotate values. There's no way around it. And locked channels cannot be connected or edited. Even though you might want to. If the transform is referenced, then there's nothing you can do. Warnings will be emitted (and made visible in the new Message Board!) if this happens, so it's still true that if your Message Board is silent, all is well. Multiple cmdx This should only really affect users of WeightShift, which also uses cmdx . The previous release was adamant on being the one and only physics solver for Maya. But it has now become more lenient and accepting of other lifestyle choices. :D Animated Initial State Heads up! This got removed. Stay tuned for a re-appearance in a later release In the previous release, you could animate your dynamic controls, but you couldn't change the initial pose unless you explicitly called Set Initial Pose from the Ragdoll | Rigging menu. With this release, you can! Limitations This currently only works reliably with strict FK control hierarchies. The animation is translated into an initial state, but in doing so we are effectively recreating the parent/child relationship between controls. And sometimes - perhaps a lot of times - this isn't a direct FK hierarchy. Here you can see how the physics and animation controls disagree on what the pose should be. The animation controls aren't in a hierarchy, they are constrained in a complex manner. It isn't accurately reproduced in the initial state. So if you notice your the simulated initial state to differ from the first pose of your animation, it's the best you can get at the moment. Worldspace Dynamic Control Heads up! This got removed. Stay tuned for a re-appearance in a later release Guide forces in dynamic controls are all local . Which means it'll maintain a pose, even if that pose is upside down or sideways. And since many versions ago, you've been able to append these \"Guide\" controls, that are in worldspace (per default). These look at the worldspace position and rotation of the control, and use that to line up the simulation. Much like IK! Now these are built-in to each Dynamic Control (toggle in the option dialog). These can help keep a character closer to an animated pose. But they are \"cheats\". Forces that appear out of nowhere, as opposed to the local forces which behave like muscles. Muscles can tense and relax whilst still appearing natural, but these are not natural. You can however use them to fake natural. One more thing; world spaces have strength in either translation or rotation, or both. A worldspace rotation could for example keep a head facing a certain direction, not unlike how IK works. Except physical! Limitations This feature uses the same \"virtual hierarchy\" as the animated initial state and suffers from the same limitations.","title":"2021.01.27"},{"location":"releases/2021.01.27/#message-board","text":"Ever opened the Script Editor to find Ragdoll screaming for help? I've added a new Message Board to help Ragdoll stand out from the overall messy or hidden messages from rigs and Maya and all else. Your goal then is to never have any messages appear in the Message Board. A silent Message Board means a happy simulation. :)","title":"Message Board"},{"location":"releases/2021.01.27/#solver-iterations","text":"Anything called strength in Ragdoll is a multipler for stiffness and damping . And currently there's a ceiling to how high stiffness and damping values can go, after which point they just stop having an effect. The values are limited by how many \"iterations\" you let the solver perform. Per default, they are set to 8 and can be found at rdRigid.positionIterations . This release sheds some more light on this somewhat obscure attribute by exposing it directly on the solver, right next to Substeps . This value multiplies each rdRigid.positionIterations attribute, meaning a value of 2 yields a total iteration count for every rigid in the solver of 16 (i.e. 2 * 8 ). Which means you can now do this! You can further customise iteration counts per rigid, under the Advanced tab. There's no limit to how many iterations you can allow; more iterations means greater accuracy. However, I have found that values beyond 128 tend to get funky. Iteration Count Strength Range Description 8 (default) 0-5 Default, sensible for most uses 16 0-10 High 32 0-500 Really, really high 64 0-1000 Ultra Nightmare For completeness, here's how Iterations differ from Substeps . Substep Divide each frame into smaller time steps Iterations Number of times a constraint is \"resolved\" They both provide accuracy in slightly different ways. With a greater amount of substeps, the solver is effectively working in slow-motion. Everything is easier in slow-motion. Resolving constraints is independent of time and a little more technical to describe, so you can instead kind of think of it a little bit like rubbing dirt of a silver platter. The first rub, you'll get most of it off. But the more you rub, the shinier it gets. There's no limit to how much you can rub, but eventually rubbing will stop having a visible effect.","title":"Solver Iterations"},{"location":"releases/2021.01.27/#help-line","text":"Hovering over any menu item now reveals a short description of what it does in the native Maya Help Line (typically at the bottom of the Maya window). This is the same information as can be found in the Menu Reference .","title":"Help Line"},{"location":"releases/2021.01.27/#delete-from-selection","text":"The Delete All Physics menu-item has gotten an option box, now it can be used to limit deletion to currently selected nodes!","title":"Delete From Selection"},{"location":"releases/2021.01.27/#locked-channels","text":"The previous release would bark at you whenever trying to turn any transform dynamic if it had any of its translate or rotate channels locked. This was a problem when you didn't necessarily care for some of them. For example, with a dynamic control, you really only cared for the rotate channels but would be prevented from simulating them if the sibling translate channels were locked. No longer! That said, the simulation does still produce both translate and rotate values. There's no way around it. And locked channels cannot be connected or edited. Even though you might want to. If the transform is referenced, then there's nothing you can do. Warnings will be emitted (and made visible in the new Message Board!) if this happens, so it's still true that if your Message Board is silent, all is well.","title":"Locked Channels"},{"location":"releases/2021.01.27/#multiple-cmdx","text":"This should only really affect users of WeightShift, which also uses cmdx . The previous release was adamant on being the one and only physics solver for Maya. But it has now become more lenient and accepting of other lifestyle choices. :D","title":"Multiple cmdx"},{"location":"releases/2021.01.27/#animated-initial-state","text":"Heads up! This got removed. Stay tuned for a re-appearance in a later release In the previous release, you could animate your dynamic controls, but you couldn't change the initial pose unless you explicitly called Set Initial Pose from the Ragdoll | Rigging menu. With this release, you can! Limitations This currently only works reliably with strict FK control hierarchies. The animation is translated into an initial state, but in doing so we are effectively recreating the parent/child relationship between controls. And sometimes - perhaps a lot of times - this isn't a direct FK hierarchy. Here you can see how the physics and animation controls disagree on what the pose should be. The animation controls aren't in a hierarchy, they are constrained in a complex manner. It isn't accurately reproduced in the initial state. So if you notice your the simulated initial state to differ from the first pose of your animation, it's the best you can get at the moment.","title":"Animated Initial State"},{"location":"releases/2021.01.27/#worldspace-dynamic-control","text":"Heads up! This got removed. Stay tuned for a re-appearance in a later release Guide forces in dynamic controls are all local . Which means it'll maintain a pose, even if that pose is upside down or sideways. And since many versions ago, you've been able to append these \"Guide\" controls, that are in worldspace (per default). These look at the worldspace position and rotation of the control, and use that to line up the simulation. Much like IK! Now these are built-in to each Dynamic Control (toggle in the option dialog). These can help keep a character closer to an animated pose. But they are \"cheats\". Forces that appear out of nowhere, as opposed to the local forces which behave like muscles. Muscles can tense and relax whilst still appearing natural, but these are not natural. You can however use them to fake natural. One more thing; world spaces have strength in either translation or rotation, or both. A worldspace rotation could for example keep a head facing a certain direction, not unlike how IK works. Except physical! Limitations This feature uses the same \"virtual hierarchy\" as the animated initial state and suffers from the same limitations.","title":"Worldspace Dynamic Control"},{"location":"releases/2021.02.07/","text":"Highlight of this release is Support for Scale ! ADDED Support for Scale Ragdoll now works on scaled geometry and controls ADDED Support for NURBS Surfaces This hip new thing popularised in the 90s is now yours to reap! ADDED Visualise Output Attributes Gain insight into what comes out of the solver FIXED Zombie Attributes Delete All Physics didn't quite catch'em all Scale This has been an epic challenge , but it finally happened! Up till now, any scale other than (1, 1, 1) at any level of a hierarchy would have either broken a simulation or refused to work outright. Not anymore! Now you can simulate scaled transforms , including scaled rigs and all of what it entails. Here's a brief on what works and what doesn't. Feature Example \u2714\ufe0f Uniform Scale 1.5, 1.5, 1.5 \u2714\ufe0f Non-uniform Scale 0.5, 0.6, 0.12 \u2714\ufe0f Scaled parent(s) Scaled root control \u2714\ufe0f Mixed Scale & Constraints Scaled box to differently-scaled capsule \u2796 Zero Scale 0.0, 0.0, 0.0 \u2796 Mixed Zero Scale 1.0, 0.0, 1.0 \u2796 Negative Scale -1.5, -1.5, -1.5 \u2796 Mixed Positive/Negative Scale 0.9, -1.5, -1.1 \u2796 Non-uniform Negative Scale -1.0, 1.0, -2.0 \u274c Non Object-Space Scale Scale in World mode There are a few caveats. Avoid negative scale if possible, it works but can surprise you Negative non-uniform scale is more common, e.g. to mirror something across the X-axis, and may work but may surprise you Non object-space scale flat-out doesn't work, not even Maya can do that; it's here for completeness. Scale cannot be animated Scale is set on the start frame, and is part of the Initial State. It is also updated alongside the translate/rotate initial state. Negative Scale Commonly found in parent hierarchies that attempt to mirror the behavior of a control or hierarchy of controls. I'd like to better support this, but it is currently limited by math. More specifically, in that a transformation matrix simply cannot distinguish between negative and positive scale. So this one is semi-supported . The problem is for Ragdoll to distinguish between scale and rotation. It's a bit mathy, but you know how you can achieve the same pose by either scaling something negatively or rotate it 180 degrees along one or more axes? Ragdoll currently cannot know which of the possible outcomes you wanted. Here's a visual to help illustrate this point. ( Reference ) Here's what can happen in practice. Notice how both the scale and rotation values changed, even though the object in the viewport remains in the same orientation. That's because these values are both correct scale and orientation for this particular transform. You might think.. Well, whatever. So long as it's oriented right, why should I care? Well, what if you had animated a realistically looking horse locomotion, rotating around the X-axis ? Did you spot it? Both X and Z got their scale neutralised and X got 180 degrees steeper, compensating for the neutralised scale values. Also Z got flipped too! You can work around it, by accepting the new Z and offsetting your animation by 180 degrees. There's also the issue with it flying off for the first few frames. It's unclear why this happens, this may be a bug in the solver itself, trying to reconcile an orientation that is 180 degrees wrong. So, negative scale works, but it's painful. Avoid if possible. Zero Scale This is \"supported\" in that it doesn't fatal crash your Maya session. Ragdoll is a 3D solver, it cannot operate on anything without volume and mass. Here's an example of what to expect should you find the need for zero scale. Scaled Rotation TLDR; if you animate something from 0-45 degrees, it will rotate 45 degrees, regardless of scale. This should be what you expect and won't need remembering, but for completeness here's what happening under the hood. Ragdoll strips scale from most internal computations. It's kept mostly so that it can be outputted again, as well as for rendering. See, custom Maya nodes render in the space of the transform. So rendering a point at coordinate (0, 0, 0) ends up in the middle of the transform node. Even as you move that transform around with the translate tool. That's problematic if you need to draw something uniformly, like the limits and drive visualisations. Even more so when you attempt to draw a line from one transform to another.. at different scales! But stripping it early is beneficial for both readability of code, but also usability for you. Uniform scale normally doesn't affect rotation, but non-uniform scale could. Consider this. Here, we've got a single angle of 45 degrees. If you were to scale this horizontally, you can see how the angle now changes! At a scale of 0, the angle has gone from 45 degrees to 90 degrees. This complicates things a lot, and Ragdoll saves you from that by not taking non-uniform scale into consideration for its rotations. A 45 degree angle will remain 45 degree regardless of scale; with the exception of negative scales which still flip the angle as you'd expect. Non Object-Space Scale You probably don't do this, but for completeness here's what doesn't work. NURBS Surfaces Ragdoll could translate polygon meshes and NURBS curves into collision meshes, and today I'm happy to announce that it now also supports the latest trend in computer graphics, heavily used in the 90s at Dreamworks for critically acclaimed feature animation films Antz and Shark Tale. Join the future! Output Attributes The Attribute Editor now displays the output translate, rotate and scale attributes from each rigid body. In both local and world space coordinates. These are the values that feed into your animation control, or any transform you're simulating. Zombie Attributes Minor bug fix. The Delete All Physics menu item didn't catch the last remaining Local Strength attribute created by Create Dynamic Control . This is all patched up!","title":"2021.02.07"},{"location":"releases/2021.02.07/#scale","text":"This has been an epic challenge , but it finally happened! Up till now, any scale other than (1, 1, 1) at any level of a hierarchy would have either broken a simulation or refused to work outright. Not anymore! Now you can simulate scaled transforms , including scaled rigs and all of what it entails. Here's a brief on what works and what doesn't. Feature Example \u2714\ufe0f Uniform Scale 1.5, 1.5, 1.5 \u2714\ufe0f Non-uniform Scale 0.5, 0.6, 0.12 \u2714\ufe0f Scaled parent(s) Scaled root control \u2714\ufe0f Mixed Scale & Constraints Scaled box to differently-scaled capsule \u2796 Zero Scale 0.0, 0.0, 0.0 \u2796 Mixed Zero Scale 1.0, 0.0, 1.0 \u2796 Negative Scale -1.5, -1.5, -1.5 \u2796 Mixed Positive/Negative Scale 0.9, -1.5, -1.1 \u2796 Non-uniform Negative Scale -1.0, 1.0, -2.0 \u274c Non Object-Space Scale Scale in World mode There are a few caveats. Avoid negative scale if possible, it works but can surprise you Negative non-uniform scale is more common, e.g. to mirror something across the X-axis, and may work but may surprise you Non object-space scale flat-out doesn't work, not even Maya can do that; it's here for completeness. Scale cannot be animated Scale is set on the start frame, and is part of the Initial State. It is also updated alongside the translate/rotate initial state.","title":"Scale"},{"location":"releases/2021.02.07/#negative-scale","text":"Commonly found in parent hierarchies that attempt to mirror the behavior of a control or hierarchy of controls. I'd like to better support this, but it is currently limited by math. More specifically, in that a transformation matrix simply cannot distinguish between negative and positive scale. So this one is semi-supported . The problem is for Ragdoll to distinguish between scale and rotation. It's a bit mathy, but you know how you can achieve the same pose by either scaling something negatively or rotate it 180 degrees along one or more axes? Ragdoll currently cannot know which of the possible outcomes you wanted. Here's a visual to help illustrate this point. ( Reference ) Here's what can happen in practice. Notice how both the scale and rotation values changed, even though the object in the viewport remains in the same orientation. That's because these values are both correct scale and orientation for this particular transform. You might think.. Well, whatever. So long as it's oriented right, why should I care? Well, what if you had animated a realistically looking horse locomotion, rotating around the X-axis ? Did you spot it? Both X and Z got their scale neutralised and X got 180 degrees steeper, compensating for the neutralised scale values. Also Z got flipped too! You can work around it, by accepting the new Z and offsetting your animation by 180 degrees. There's also the issue with it flying off for the first few frames. It's unclear why this happens, this may be a bug in the solver itself, trying to reconcile an orientation that is 180 degrees wrong. So, negative scale works, but it's painful. Avoid if possible.","title":"Negative Scale"},{"location":"releases/2021.02.07/#zero-scale","text":"This is \"supported\" in that it doesn't fatal crash your Maya session. Ragdoll is a 3D solver, it cannot operate on anything without volume and mass. Here's an example of what to expect should you find the need for zero scale.","title":"Zero Scale"},{"location":"releases/2021.02.07/#scaled-rotation","text":"TLDR; if you animate something from 0-45 degrees, it will rotate 45 degrees, regardless of scale. This should be what you expect and won't need remembering, but for completeness here's what happening under the hood. Ragdoll strips scale from most internal computations. It's kept mostly so that it can be outputted again, as well as for rendering. See, custom Maya nodes render in the space of the transform. So rendering a point at coordinate (0, 0, 0) ends up in the middle of the transform node. Even as you move that transform around with the translate tool. That's problematic if you need to draw something uniformly, like the limits and drive visualisations. Even more so when you attempt to draw a line from one transform to another.. at different scales! But stripping it early is beneficial for both readability of code, but also usability for you. Uniform scale normally doesn't affect rotation, but non-uniform scale could. Consider this. Here, we've got a single angle of 45 degrees. If you were to scale this horizontally, you can see how the angle now changes! At a scale of 0, the angle has gone from 45 degrees to 90 degrees. This complicates things a lot, and Ragdoll saves you from that by not taking non-uniform scale into consideration for its rotations. A 45 degree angle will remain 45 degree regardless of scale; with the exception of negative scales which still flip the angle as you'd expect.","title":"Scaled Rotation"},{"location":"releases/2021.02.07/#non-object-space-scale","text":"You probably don't do this, but for completeness here's what doesn't work.","title":"Non Object-Space Scale"},{"location":"releases/2021.02.07/#nurbs-surfaces","text":"Ragdoll could translate polygon meshes and NURBS curves into collision meshes, and today I'm happy to announce that it now also supports the latest trend in computer graphics, heavily used in the 90s at Dreamworks for critically acclaimed feature animation films Antz and Shark Tale. Join the future!","title":"NURBS Surfaces"},{"location":"releases/2021.02.07/#output-attributes","text":"The Attribute Editor now displays the output translate, rotate and scale attributes from each rigid body. In both local and world space coordinates. These are the values that feed into your animation control, or any transform you're simulating.","title":"Output Attributes"},{"location":"releases/2021.02.07/#zombie-attributes","text":"Minor bug fix. The Delete All Physics menu item didn't catch the last remaining Local Strength attribute created by Create Dynamic Control . This is all patched up!","title":"Zombie Attributes"},{"location":"releases/2021.03.01/","text":"It's been an epic month of problem-solving, but it finally happened. :D Highlight for this release is.. drumroll.. Automatic Initial State ! ADDED Auto Initial State Start simulating in whatever pose your character is in ADDED Hierarchy Preservation Moving parents around now correctly moves children ADDED Worldspace Constraints Animate in both local- and world-space FIXED DG Viewport Bug Fix for rare cases of viewport going out of sync FIXED Unload plug-in The Ragdoll plug-in can now be loaded and unloaded using the native Maya plug-in manager ADDED New Commands Developer candy, return a JSON of physics for export and import into another application, like Unreal, Motion Builder or Blender! Tiger Rig courtesy of www.cgspectrum.com Auto Initial State Have you ever used the Set Initial State button? It's useful, isn't it? It's what enables you to turn something dynamic but then change your mind about where it should start simulating. With this release, that process is automatic! It's more or less what you expected would happen anyway. I mean, obviously the box should drop from where you left it, rather than where it was originally turned dynamic? Disable Feature If you would rather have none of it, or if it gives you trouble, you can switch it off like this. NOTE: Changes take effect on next scene open and newly created rigids. Parallel Only That's right, automatic initial state will only work in Maya's Parallel Evaluation mode. It may end up getting support for DG later on, the trouble lies in the callback we use to read an edited initial state is not reliable in DG. It's possible we'll find another means of achieving the same goal in the future, although DG really is part of the past. Ragdoll works best under Parallel for other reasons too; primarily performance but also stability and robustness. Constraints Stay Behind Constraints currently show you the true position of rigid bodies. They stay behind because hierarchy preservation is \"artificial\". It's just for you and Maya. In a later release, I'll make rigids also stay behind, and only have your controls move with hierarchy, so that you get to visualise where rigid bodies really are (even when your controls have locked channels, like translate) whilst at the same time letting you move and see your controls and how they reflect that true position. Caveat There's one known \"gotcha\" with the automated initial state. Namely, the initial state is \"recorded\" whenever you transition from the start time to the next frame. Evaluation on the next frame will automatically read whatever was evaluated previously, and store that as the initial state. However! It is possible to trigger evaluation without actually changing time. Maya loves doing that. You can do it by either scrubbing the timeline, or holding K and dragging (effectively scrubbing) the viewport. As you scrub, even if time isn't actually changing, Maya will go ahead and re-evaluated the time. When that happens, it won't actually record a new initial state, but instead restore the original value. Something to be aware of. Journey For the technically inclined, here you can witness last month's struggle first hand and all the kinks uncovered in Maya's API and evaluation graph. Hierarchy Preservation Like in the real world, physics happens in worldspace. There are no \"children\" and no \"parents\". As a result, as soon as you turn any of your controls dynamic, they start acting that way. But we don't want that. With this release, you'll now get realism along with that familiar feeling of having children and being a parent! Before After Caveat There is one known case to be aware of when it comes to children. Passive Rigids Hierarchy is currently preserved only if a rigid is active . The reason being.. well, I'll just show you. In this case, the passive rigid bodies are driven by an external transform, those blue \"controls\". Hierarchy is coming from the blue rigids, so we wouldn't want the passive rigids to mess with that. But now when we move the rigids themselves (gray, in this example) we aren't getting our hierarchy preservation.. :( At the other extreme, if we do account for hierarchy then the problem pops up at the other end instead. I trust experience and feedback will light the way here for a more intuitive experience working with external controls. Worldspace Constraints If you thought automatic initial state was enough, think again! If your controls have animation already applied, Ragdoll will now translate it into physics in world- and local-space. Default Behavior Local animation, like a rotated arm, are imbued with a \"local constraint\" to preserve the relative angle between it and its parent. World animation, like in this case where there is no parent, get imbued with a \"world constraint\". World Only Here's what you get when constraining the child to its worldspace pose. Notice how it assumes the angle you give it regardless of whatever the parent is doing. Local Only Conversely, with just the local constraint, it'll assume the relative angle and respects its parent. World + Local Things get interesting when you combine the two! World + World + Local ..or combine the three! Here's the lower arm trying to adhere to both its worldspace and local orientation. Notice the constraint coming out of alignment at the root; the constraints are of equal strength per default so it'll end up averaging the desired poses. There's one more thing happening here that I'll touch on in an upcoming release, which is the concept of world space forces. Notice how the joint chain follows animation DG Viewport Bug If you've ever had the viewport \"remember\" old frames as you scrub the timeline, this fix is for you. Unload Plug-in In the previous release, licencing was implemented as a Python binding. The trouble with compiled Python bindings in Maya is that they cannot be unloaded. As a result, Ragdoll could not be unloaded. Licencing is now implemented as a native Maya command, accessible as ragdollLicence from MEL and cmds.ragdollLicence() from Python. See ragdollLicence below New Commands Three new commands was added in this release, they are primarily intended for TDs and technically minded folk. cmds.ragdollLicence() cmds.ragdollPeek() cmds.ragdollDump() cmds.ragdollLicence Synopsis : ragdollLicence [ flags ] Flags : - q - query - a - activate String - d - deactivate - h - help - i - init - ia - isActivated - ig - isGenuine - it - isTrial - iv - isVerified - md - magicDays - r - reverify - s - serial - td - trialDays You still typically interact with ragdoll.licence , as documented here . But under the hood, this is now the native Maya command being called. from maya import cmds cmds . ragdollLicence ( serial = True , query = True ) # Your-Serial-Number-Here cmds.ragdollPeek Synopsis : ragdollPeek [ flags ] Flags : - e - entity UnsignedInt - h - help - ps - physicsStatistics - ss - sceneStatistics Gain insight into what Maya sees in Ragdoll. cmds . ragdollPeek ( sceneStatistics = True ) # Ragdoll Peek Scene ____________ ___________________________ _______________ | Id | Scene | Name | |------------|---------------------------|---------------| | 71 | rSceneShape | rSceneShape | | 70 | rSceneShape | rRigid18 | | 69 | rSceneShape | rRigid17 | | 67 | rSceneShape | rRigid | | 65 | rSceneShape | rRigid7 | | 63 | rSceneShape | rRigid8 | | 61 | rSceneShape | rRigid14 | | 59 | rSceneShape | rRigid15 | | 57 | rSceneShape | rRigid16 | | 55 | rSceneShape | rRigid11 | | 53 | rSceneShape | rRigid12 | | 51 | rSceneShape | rRigid13 | | 49 | rSceneShape | rRigid9 | | 46 | rSceneShape | rRigid10 | | 44 | rSceneShape | rRigid4 | | 42 | rSceneShape | rRigid5 | | 40 | rSceneShape | rRigid6 | | 38 | rSceneShape | rRigid1 | | 36 | rSceneShape | rRigid2 | | 34 | rSceneShape | rRigid3 | | 15 | rSceneShape | rRigid27 | | 14 | rSceneShape | rRigid28 | | 13 | rSceneShape | rRigid29 | | 12 | rSceneShape | rRigid30 | | 11 | rSceneShape | rRigid31 | | 10 | rSceneShape | rRigid32 | | 9 | rSceneShape | rRigid33 | | 8 | rSceneShape | rRigid34 | | 7 | rSceneShape | rRigid19 | | 6 | rSceneShape | rRigid20 | | 5 | rSceneShape | rRigid21 | | 4 | rSceneShape | rRigid22 | | 3 | rSceneShape | rRigid23 | | 1048576 | rSceneShape | rRigid24 | | 1048578 | rSceneShape | rRigid25 | | 1048577 | rSceneShape | rRigid26 | | ____________ | ___________________________ | _______________ | cmds . ragdollPeek ( physicsStatistics = True ) # Ragdoll Peek Solver - Number of scenes : 1 - Number of shapes : 36 - Number of materials : 36 - Number of convex meshes : 0 - scene [ 71 ] - Number of dynamic actors : 35 - Number of static actors : 1 - Number of constraints : 18 # cmds.ragdollDump Synopsis : ragdollDump - h - help This is more of a teaser of what's to come, but let me tell you about it for completeness of these release notes. ragdollDumps is the start of an integration effort of Ragdoll into any and all external software, like Unreal and Blender. Anything able to parse JSON. Including web-applications. What if you could rig and/or animate in Maya, but then export the physics setup into e.g. Unreal? I'm not talking about baking your animation and playing it back somewhere else. But of exporting the internal physics objects from Ragdoll, translating them to whatever the third-party software uses for physics, and re-using it there! With that, you could bypass all of the horrible authoring tools of those applications and transfer a physics scene or setup across applications. Later, you'll be able to load these into a standalone Ragdoll desktop and web-based application. Useful for sharing your creations and animations with others, and for debugging too! import json from maya import cmds cmds . ragdollDump () # { # \"scenes\": { # \"0\": { # \"id\": 0, # \"name\": \"rSceneShape\", # \"entities\": { # \"0\": { # \"id\": 0, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rSceneShape\" # } # } # } # }, # \"1\": { # \"id\": 1, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rRigid\" # } # } # } # }, # \"2\": { # \"id\": 2, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rGuideConstraint\" # } # } # } # } # } # } # } # } Turn this string into json, with the native Python json module. import json from maya import cmds dump = cmds . ragdollDump () dump = json . loads ( dump ) # From string to dictionary # The format is internal and yet to be documented, stay tuned scene = dump [ \"scenes\" ][ \"0\" ] rigid = scene [ \"entities\" ][ \"1\" ] name = rigid [ \"components\" ][ \"NameComponent\" ][ \"members\" ][ \"value\" ] print ( name ) # rRigid Expect the output to grow throughout later releases as more internals get serialised to JSON.","title":"2021.03.01"},{"location":"releases/2021.03.01/#auto-initial-state","text":"Have you ever used the Set Initial State button? It's useful, isn't it? It's what enables you to turn something dynamic but then change your mind about where it should start simulating. With this release, that process is automatic! It's more or less what you expected would happen anyway. I mean, obviously the box should drop from where you left it, rather than where it was originally turned dynamic?","title":"Auto Initial State"},{"location":"releases/2021.03.01/#disable-feature","text":"If you would rather have none of it, or if it gives you trouble, you can switch it off like this. NOTE: Changes take effect on next scene open and newly created rigids.","title":"Disable Feature"},{"location":"releases/2021.03.01/#parallel-only","text":"That's right, automatic initial state will only work in Maya's Parallel Evaluation mode. It may end up getting support for DG later on, the trouble lies in the callback we use to read an edited initial state is not reliable in DG. It's possible we'll find another means of achieving the same goal in the future, although DG really is part of the past. Ragdoll works best under Parallel for other reasons too; primarily performance but also stability and robustness.","title":"Parallel Only"},{"location":"releases/2021.03.01/#constraints-stay-behind","text":"Constraints currently show you the true position of rigid bodies. They stay behind because hierarchy preservation is \"artificial\". It's just for you and Maya. In a later release, I'll make rigids also stay behind, and only have your controls move with hierarchy, so that you get to visualise where rigid bodies really are (even when your controls have locked channels, like translate) whilst at the same time letting you move and see your controls and how they reflect that true position.","title":"Constraints Stay Behind"},{"location":"releases/2021.03.01/#caveat","text":"There's one known \"gotcha\" with the automated initial state. Namely, the initial state is \"recorded\" whenever you transition from the start time to the next frame. Evaluation on the next frame will automatically read whatever was evaluated previously, and store that as the initial state. However! It is possible to trigger evaluation without actually changing time. Maya loves doing that. You can do it by either scrubbing the timeline, or holding K and dragging (effectively scrubbing) the viewport. As you scrub, even if time isn't actually changing, Maya will go ahead and re-evaluated the time. When that happens, it won't actually record a new initial state, but instead restore the original value. Something to be aware of.","title":"Caveat"},{"location":"releases/2021.03.01/#journey","text":"For the technically inclined, here you can witness last month's struggle first hand and all the kinks uncovered in Maya's API and evaluation graph.","title":"Journey"},{"location":"releases/2021.03.01/#hierarchy-preservation","text":"Like in the real world, physics happens in worldspace. There are no \"children\" and no \"parents\". As a result, as soon as you turn any of your controls dynamic, they start acting that way. But we don't want that. With this release, you'll now get realism along with that familiar feeling of having children and being a parent! Before After","title":"Hierarchy Preservation"},{"location":"releases/2021.03.01/#caveat_1","text":"There is one known case to be aware of when it comes to children. Passive Rigids Hierarchy is currently preserved only if a rigid is active . The reason being.. well, I'll just show you. In this case, the passive rigid bodies are driven by an external transform, those blue \"controls\". Hierarchy is coming from the blue rigids, so we wouldn't want the passive rigids to mess with that. But now when we move the rigids themselves (gray, in this example) we aren't getting our hierarchy preservation.. :( At the other extreme, if we do account for hierarchy then the problem pops up at the other end instead. I trust experience and feedback will light the way here for a more intuitive experience working with external controls.","title":"Caveat"},{"location":"releases/2021.03.01/#worldspace-constraints","text":"If you thought automatic initial state was enough, think again! If your controls have animation already applied, Ragdoll will now translate it into physics in world- and local-space.","title":"Worldspace Constraints"},{"location":"releases/2021.03.01/#default-behavior","text":"Local animation, like a rotated arm, are imbued with a \"local constraint\" to preserve the relative angle between it and its parent. World animation, like in this case where there is no parent, get imbued with a \"world constraint\".","title":"Default Behavior"},{"location":"releases/2021.03.01/#world-only","text":"Here's what you get when constraining the child to its worldspace pose. Notice how it assumes the angle you give it regardless of whatever the parent is doing.","title":"World Only"},{"location":"releases/2021.03.01/#local-only","text":"Conversely, with just the local constraint, it'll assume the relative angle and respects its parent.","title":"Local Only"},{"location":"releases/2021.03.01/#world-local","text":"Things get interesting when you combine the two!","title":"World + Local"},{"location":"releases/2021.03.01/#world-world-local","text":"..or combine the three! Here's the lower arm trying to adhere to both its worldspace and local orientation. Notice the constraint coming out of alignment at the root; the constraints are of equal strength per default so it'll end up averaging the desired poses. There's one more thing happening here that I'll touch on in an upcoming release, which is the concept of world space forces. Notice how the joint chain follows animation","title":"World + World + Local"},{"location":"releases/2021.03.01/#dg-viewport-bug","text":"If you've ever had the viewport \"remember\" old frames as you scrub the timeline, this fix is for you.","title":"DG Viewport Bug"},{"location":"releases/2021.03.01/#unload-plug-in","text":"In the previous release, licencing was implemented as a Python binding. The trouble with compiled Python bindings in Maya is that they cannot be unloaded. As a result, Ragdoll could not be unloaded. Licencing is now implemented as a native Maya command, accessible as ragdollLicence from MEL and cmds.ragdollLicence() from Python. See ragdollLicence below","title":"Unload Plug-in"},{"location":"releases/2021.03.01/#new-commands","text":"Three new commands was added in this release, they are primarily intended for TDs and technically minded folk. cmds.ragdollLicence() cmds.ragdollPeek() cmds.ragdollDump()","title":"New Commands"},{"location":"releases/2021.03.01/#cmdsragdolllicence","text":"Synopsis : ragdollLicence [ flags ] Flags : - q - query - a - activate String - d - deactivate - h - help - i - init - ia - isActivated - ig - isGenuine - it - isTrial - iv - isVerified - md - magicDays - r - reverify - s - serial - td - trialDays You still typically interact with ragdoll.licence , as documented here . But under the hood, this is now the native Maya command being called. from maya import cmds cmds . ragdollLicence ( serial = True , query = True ) # Your-Serial-Number-Here","title":"cmds.ragdollLicence"},{"location":"releases/2021.03.01/#cmdsragdollpeek","text":"Synopsis : ragdollPeek [ flags ] Flags : - e - entity UnsignedInt - h - help - ps - physicsStatistics - ss - sceneStatistics Gain insight into what Maya sees in Ragdoll. cmds . ragdollPeek ( sceneStatistics = True ) # Ragdoll Peek Scene ____________ ___________________________ _______________ | Id | Scene | Name | |------------|---------------------------|---------------| | 71 | rSceneShape | rSceneShape | | 70 | rSceneShape | rRigid18 | | 69 | rSceneShape | rRigid17 | | 67 | rSceneShape | rRigid | | 65 | rSceneShape | rRigid7 | | 63 | rSceneShape | rRigid8 | | 61 | rSceneShape | rRigid14 | | 59 | rSceneShape | rRigid15 | | 57 | rSceneShape | rRigid16 | | 55 | rSceneShape | rRigid11 | | 53 | rSceneShape | rRigid12 | | 51 | rSceneShape | rRigid13 | | 49 | rSceneShape | rRigid9 | | 46 | rSceneShape | rRigid10 | | 44 | rSceneShape | rRigid4 | | 42 | rSceneShape | rRigid5 | | 40 | rSceneShape | rRigid6 | | 38 | rSceneShape | rRigid1 | | 36 | rSceneShape | rRigid2 | | 34 | rSceneShape | rRigid3 | | 15 | rSceneShape | rRigid27 | | 14 | rSceneShape | rRigid28 | | 13 | rSceneShape | rRigid29 | | 12 | rSceneShape | rRigid30 | | 11 | rSceneShape | rRigid31 | | 10 | rSceneShape | rRigid32 | | 9 | rSceneShape | rRigid33 | | 8 | rSceneShape | rRigid34 | | 7 | rSceneShape | rRigid19 | | 6 | rSceneShape | rRigid20 | | 5 | rSceneShape | rRigid21 | | 4 | rSceneShape | rRigid22 | | 3 | rSceneShape | rRigid23 | | 1048576 | rSceneShape | rRigid24 | | 1048578 | rSceneShape | rRigid25 | | 1048577 | rSceneShape | rRigid26 | | ____________ | ___________________________ | _______________ | cmds . ragdollPeek ( physicsStatistics = True ) # Ragdoll Peek Solver - Number of scenes : 1 - Number of shapes : 36 - Number of materials : 36 - Number of convex meshes : 0 - scene [ 71 ] - Number of dynamic actors : 35 - Number of static actors : 1 - Number of constraints : 18 #","title":"cmds.ragdollPeek"},{"location":"releases/2021.03.01/#cmdsragdolldump","text":"Synopsis : ragdollDump - h - help This is more of a teaser of what's to come, but let me tell you about it for completeness of these release notes. ragdollDumps is the start of an integration effort of Ragdoll into any and all external software, like Unreal and Blender. Anything able to parse JSON. Including web-applications. What if you could rig and/or animate in Maya, but then export the physics setup into e.g. Unreal? I'm not talking about baking your animation and playing it back somewhere else. But of exporting the internal physics objects from Ragdoll, translating them to whatever the third-party software uses for physics, and re-using it there! With that, you could bypass all of the horrible authoring tools of those applications and transfer a physics scene or setup across applications. Later, you'll be able to load these into a standalone Ragdoll desktop and web-based application. Useful for sharing your creations and animations with others, and for debugging too! import json from maya import cmds cmds . ragdollDump () # { # \"scenes\": { # \"0\": { # \"id\": 0, # \"name\": \"rSceneShape\", # \"entities\": { # \"0\": { # \"id\": 0, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rSceneShape\" # } # } # } # }, # \"1\": { # \"id\": 1, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rRigid\" # } # } # } # }, # \"2\": { # \"id\": 2, # \"components\": { # \"NameComponent\": { # \"type\": \"NameComponent\", # \"members\": { # \"value\": \"rGuideConstraint\" # } # } # } # } # } # } # } # } Turn this string into json, with the native Python json module. import json from maya import cmds dump = cmds . ragdollDump () dump = json . loads ( dump ) # From string to dictionary # The format is internal and yet to be documented, stay tuned scene = dump [ \"scenes\" ][ \"0\" ] rigid = scene [ \"entities\" ][ \"1\" ] name = rigid [ \"components\" ][ \"NameComponent\" ][ \"members\" ][ \"value\" ] print ( name ) # rRigid Expect the output to grow throughout later releases as more internals get serialised to JSON.","title":"cmds.ragdollDump"},{"location":"releases/2021.03.04/","text":"Small fixes and tweaks, with one pretty cool new feature - the ability to animate the transition between active and passive mode for any rigid! ADDED Animated Transition Between Passive and Active It's now possible! ADDED More Scene Visualisation You can now visualise the internal rigid bodies at the scene level FIXED More Robust Passive Rigids The start frame now does a better job representing passive rigids FIXED Better Scaled Shape Rendering Shading on scaled shapes now render correctly FIXED Consistent X-axis for Sphere Radius Rather than the average of X and Y Transition Between Passive and Active Active rigid bodies can now be made passive interactively, and continue to be animated as passive, and then - here's the cool part! - once they transition from passive to active, they inherit the animated velocity you gave it! Pay special attention to the fact that we can key the simulated values, such that we can continue animating from exactly where they left off. Making for a clean transition both to and from physics! More Scene Visualisation The rdScene node has been able to draw velocities, trajectories and constraints to help you track down problems or gain better insight into the inner workings of the solver. Now it can also draw the current position and orientation of rigids, regardless of where your animation controls are. This can be especially helpful if your controls have locked channels, such as translate, as they would be unable to show you the translation of the physical version of the control. Here's how it works. See how the box as-seen from the scene falls down, whereas the original box doesn't? Because the translate channels were locked, they weren't able to fully represent the simulation. Here's a more practical example of a tail. Notice that because the translate channels of the tail are locked, they remain positioned according to the rig. And the rig has some clever mechanics going on to keep the tail attached to the body even when the hip control moves away. Here's a close-up of that mechanic. The solver shows you what is actually going on physically and can help track down controls that misbehave. Better Scaled Shape Rendering Small, but important. When you scale things, rendering needs to keep up and descale the normals of the geometry.","title":"2021.03.04"},{"location":"releases/2021.03.04/#transition-between-passive-and-active","text":"Active rigid bodies can now be made passive interactively, and continue to be animated as passive, and then - here's the cool part! - once they transition from passive to active, they inherit the animated velocity you gave it! Pay special attention to the fact that we can key the simulated values, such that we can continue animating from exactly where they left off. Making for a clean transition both to and from physics!","title":"Transition Between Passive and Active"},{"location":"releases/2021.03.04/#more-scene-visualisation","text":"The rdScene node has been able to draw velocities, trajectories and constraints to help you track down problems or gain better insight into the inner workings of the solver. Now it can also draw the current position and orientation of rigids, regardless of where your animation controls are. This can be especially helpful if your controls have locked channels, such as translate, as they would be unable to show you the translation of the physical version of the control. Here's how it works. See how the box as-seen from the scene falls down, whereas the original box doesn't? Because the translate channels were locked, they weren't able to fully represent the simulation. Here's a more practical example of a tail. Notice that because the translate channels of the tail are locked, they remain positioned according to the rig. And the rig has some clever mechanics going on to keep the tail attached to the body even when the hip control moves away. Here's a close-up of that mechanic. The solver shows you what is actually going on physically and can help track down controls that misbehave.","title":"More Scene Visualisation"},{"location":"releases/2021.03.04/#better-scaled-shape-rendering","text":"Small, but important. When you scale things, rendering needs to keep up and descale the normals of the geometry.","title":"Better Scaled Shape Rendering"},{"location":"releases/2021.03.11/","text":"Highlight for this release is Local Space Simulation ! ADDED Ragdog Tutorial Learn how to setup a \"ragdog\" from scratch ADDED Big Fish Showcase of the benefit of automated overlapping animation for a fish ADDED Local Space Simulation Robust simulated hierarchy whilst animating FIXED Rotate Order Warning More safeguards against unsupported aspects of Ragdoll FIXED Animated Rigid Attributes Minor bugfix FIXED Pre-Start Frame Pose is now reset prior to hitting the solver start frame FIXED Explosion on Initial State More robust detection of when to actually update the initial state Sunny Side Up Just a wolf, for breakfast. Waterproof Fire Fox If you squint, it almost looks like he's underwater! Collision Volumes The automatically-generated colliders you get when turning animation NURBS controls dynamic. Ragdog Tutorial That's no typo, this is a Ragdoll-dog! :D Learn about how to achieve the above simulation in this 2-part series on using Dynamic Control. Fire Wolf Rig Big Fish Spotted an animation on LinkedIn the other day by Radovan Zivkovic, and wanted to see whether it would work with Ragdoll. Here's about 15 minutes of work from launch of Maya to final playblast. Reference Sea Beast Maya Rig Local Space Simulation TLDR; This will keep simulation of children intact whilst manipulating parents. Up until this release, simulation has taken place in worldspace. The last few releases has tried translating worldspace into localspace to try and mimic that familiar feeling of moving the parent and having children follow. This release moves simulation altogether into local space which means a seamless integration with he parent/child hierarchy that your animation controls are normally in! Before Pay special attention to how you can edit the master control mid-way through a simulation, but then have that change completely ignored as you return to frame 1. After Now, with simulation resting in the local space, it behaves as you would expect. Rotate Order Warning A while back , support was implemented for a custom rotateOrder , such as ZYX or YXZ . As it turns out, this support was rather incomplete. Solving for a custom rotate order is much more involved than I'd hoped it would be, so for the time being you are advised not to use them. If you do, you may run into issues such as this. Animated Rigid Attributes The previous release broke your ability to animate anything on a rigid, e.g. rdRigid.linearDamping . That's been all patched up! Pre-Start Frame A bug in a prior version caused frames ahead of the start frame to not reset correctly, unless you explicitly visited the start frame. E.g. skipping from frame 100 directly to 1 rather than from 2 to 1 wouldn't look right. Coupled with the next auto-initial-state feature, this could break a pose. This has now been patched up! Explosion on Initial State Ragdoll could mistakenly treat a broken simulated first frame as the new and correct initial state. Detecting that stuff is hard! Now it's doing a better job, but keep an eye out for when your start pose breaks, that should never happen. Also don't forget that this fancy new shiny feature can be disabled under Ragdoll -> System -> Ragdoll Preferences. Shear The enemy of any animation, shear is scale's ugly brother. Ragdoll now accounts for shear, even though you are strongly advised never to introduce it willingly.","title":"2021.03.11"},{"location":"releases/2021.03.11/#ragdog-tutorial","text":"That's no typo, this is a Ragdoll-dog! :D Learn about how to achieve the above simulation in this 2-part series on using Dynamic Control. Fire Wolf Rig","title":"Ragdog Tutorial"},{"location":"releases/2021.03.11/#big-fish","text":"Spotted an animation on LinkedIn the other day by Radovan Zivkovic, and wanted to see whether it would work with Ragdoll. Here's about 15 minutes of work from launch of Maya to final playblast. Reference Sea Beast Maya Rig","title":"Big Fish"},{"location":"releases/2021.03.11/#local-space-simulation","text":"TLDR; This will keep simulation of children intact whilst manipulating parents. Up until this release, simulation has taken place in worldspace. The last few releases has tried translating worldspace into localspace to try and mimic that familiar feeling of moving the parent and having children follow. This release moves simulation altogether into local space which means a seamless integration with he parent/child hierarchy that your animation controls are normally in!","title":"Local Space Simulation"},{"location":"releases/2021.03.11/#before","text":"Pay special attention to how you can edit the master control mid-way through a simulation, but then have that change completely ignored as you return to frame 1.","title":"Before"},{"location":"releases/2021.03.11/#after","text":"Now, with simulation resting in the local space, it behaves as you would expect.","title":"After"},{"location":"releases/2021.03.11/#rotate-order-warning","text":"A while back , support was implemented for a custom rotateOrder , such as ZYX or YXZ . As it turns out, this support was rather incomplete. Solving for a custom rotate order is much more involved than I'd hoped it would be, so for the time being you are advised not to use them. If you do, you may run into issues such as this.","title":"Rotate Order Warning"},{"location":"releases/2021.03.11/#animated-rigid-attributes","text":"The previous release broke your ability to animate anything on a rigid, e.g. rdRigid.linearDamping . That's been all patched up!","title":"Animated Rigid Attributes"},{"location":"releases/2021.03.11/#pre-start-frame","text":"A bug in a prior version caused frames ahead of the start frame to not reset correctly, unless you explicitly visited the start frame. E.g. skipping from frame 100 directly to 1 rather than from 2 to 1 wouldn't look right. Coupled with the next auto-initial-state feature, this could break a pose. This has now been patched up!","title":"Pre-Start Frame"},{"location":"releases/2021.03.11/#explosion-on-initial-state","text":"Ragdoll could mistakenly treat a broken simulated first frame as the new and correct initial state. Detecting that stuff is hard! Now it's doing a better job, but keep an eye out for when your start pose breaks, that should never happen. Also don't forget that this fancy new shiny feature can be disabled under Ragdoll -> System -> Ragdoll Preferences.","title":"Explosion on Initial State"},{"location":"releases/2021.03.11/#shear","text":"The enemy of any animation, shear is scale's ugly brother. Ragdoll now accounts for shear, even though you are strongly advised never to introduce it willingly.","title":"Shear"},{"location":"releases/2021.03.23/","text":"Highlight for this release is JSON Export, this one's for you game developers out there! ADDED JSON Export Run your ragdolls in Unreal, Unity or your own custom game engine ADDED Active Chain Next generation \"Dynamic Control\" with \"chain\" ADDED Dynamic Constraint Attributes Stay focused on attributes that matter ADDED What'Z-Up? Is your up axis-Z? Ragdoll is now down with that. CHANGED Simplified Menu Less noisy, more focused menu CHANGED Dynamic Install Tighter integration into Maya's native Plug-in Manager CHANGED Greater Guide Strength Have simulation follow animation even closelier FIXED Less Crashes Kids, say no to crashes FIXED Custom Rotate Order Now works as expected FIXED Bad Initial State on Load Loading saved physics now works as expected Important! This version won't self-install like the past releases, see Dynamic Install on how you need to load the plug-in via Maya's Plug-in Manager from now on. Ragcar It's a ragcar allright. You can tell by how bouncy it is! Knocking things around No obstacle is too tall for ragcar. A look underneath The parts are all there, it's how it would work in real life if you put an engine in it. :D Vehicle model from Mecabricks . JSON Export In 2021.03.01 we introduced cmds.ragdollDump to get a copy of all rigids in the form of a JSON dictionary. This release includes all initial state for the simulation, such that you can reproduce the results you see in Maya in a game engine, like Unreal, Unity, CryEngine or your own custom game engine. Or why not Houdini, Blender or 3dsMax? This enables you to use Maya as an authoring platform for physics anywhere. from maya import cmds dump = cmds . ragdollDump () # Convert big string to structured dictionary import json dump = json . loads ( dump ) for entity , data in dump . items (): components = data [ \"components\" ] name = components [ \"NameComponents\" ][ \"members\" ][ \"path\" ] print ( name ) # |root|pelvis|rRigid1 # |root|pelvis|spine|rRigid2 # |root|pelvis|spine2|rRigid3 # ... Here's an example of what to expect from the output. output_example.json { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } } See the new Serialisation documentation for an overview, examples and data reference. https://learn.ragdolldynamics.com/serialisation Dynamic Install Previous releases shipped with a userSetup.py that triggered on launch of Maya. This made it easy to get setup, but made it challenging to uninstall without physically removing files off of the file system (hint: ~/Documents/maya/modules/Ragdoll.mod ). This release associates install with plug-in load. Install Uninstall Active Chain Dynamic Control has been renamed Active Chain . Turns out, what Dynamic Control was really all about was a generic chain that can also be turned into hierarchies of chains - or \"branches\" - to form a tree. Even a literal one! Dynamic Constraint Attributes Now whatever attributes are relevant show up in the Channel Box, and stay relevant as you make changes. Similar to how the rdRigid.shapeType attribute updates the shapeExtents and shapeOffset attributes! What'Z-up? Ragdoll now understands when the up-axis is Z rather than the default Y. Simplified Menu Items have been re-arranged and grouped together to be easier to find and less cluttered. Greater Guide Strength The solver Iterations determines how high your Guide Strength attribute can go. Per default, Iterations was set to 1 which enabled strengths between 0-5 or so until their effect dimished. This release increases this default value to 4 for ranges between 0-100 , which means \"incredibly high!\". The change comes at a minor performance impact - estimated between 1-5% - so if you find the need to optimise, lower this value back to 2 or 1. Hint Bear in mind that the number of iterations are spread across all rigid in your scene. Meaning twice the number of rigids would half the amount of iterations dedicated to each one. Before After Crash on Cleanup In rare cases, Ragdoll could crash Maya due to accessing memory it had no business accessing. Those have now been patched up and refactored for a more stable, crash-free experience! Bad Initial State on Load In rare cases, opening a scene could lead to some controls being badly positioned. This could happen if the control you made dynamic was parented to a group with no values. That made the parent and local matrices cancel out, producing an identity matrix. Maya doesn't normally save attributes that are equal to their default values, and this includes matrices whose defaults are the identity matrix. This has now been fixed. Rotate Order Improvement In previous releases, any rotation order other than XYZ (the default) would make your rotations all whack. Ragdoll didn't know how to translate physics into any order other than XYZ, so it would put them in the wrong place. In the last release, I added a warning for that and in this release I've lifted that warning somewhat. Most rotation orders works well, but I have spotted rare instances of one axis flipping. Here's the problem. See how arms and torso flips? It tends to happen around the 90 and 180 degree values, values below that normally look fine. This will be fixed in a future release, one way or another!","title":"2021.03.23"},{"location":"releases/2021.03.23/#json-export","text":"In 2021.03.01 we introduced cmds.ragdollDump to get a copy of all rigids in the form of a JSON dictionary. This release includes all initial state for the simulation, such that you can reproduce the results you see in Maya in a game engine, like Unreal, Unity, CryEngine or your own custom game engine. Or why not Houdini, Blender or 3dsMax? This enables you to use Maya as an authoring platform for physics anywhere. from maya import cmds dump = cmds . ragdollDump () # Convert big string to structured dictionary import json dump = json . loads ( dump ) for entity , data in dump . items (): components = data [ \"components\" ] name = components [ \"NameComponents\" ][ \"members\" ][ \"path\" ] print ( name ) # |root|pelvis|rRigid1 # |root|pelvis|spine|rRigid2 # |root|pelvis|spine2|rRigid3 # ... Here's an example of what to expect from the output. output_example.json { \"entities\" : { \"10\" : { \"components\" : { \"NameComponent\" : \"upperArm\" , \"ColorComponent\" : [ 1.0 , 0.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Capsule\" , ... } }, \"15\" : { \"components\" : { \"NameComponent\" : \"lowerArm\" , \"ColorComponent\" : [ 0.0 , 1.0 , 0.0 ], \"GeometryDescriptionComponent\" : \"Box\" , ... } } } See the new Serialisation documentation for an overview, examples and data reference. https://learn.ragdolldynamics.com/serialisation","title":"JSON Export"},{"location":"releases/2021.03.23/#dynamic-install","text":"Previous releases shipped with a userSetup.py that triggered on launch of Maya. This made it easy to get setup, but made it challenging to uninstall without physically removing files off of the file system (hint: ~/Documents/maya/modules/Ragdoll.mod ). This release associates install with plug-in load. Install Uninstall","title":"Dynamic Install"},{"location":"releases/2021.03.23/#active-chain","text":"Dynamic Control has been renamed Active Chain . Turns out, what Dynamic Control was really all about was a generic chain that can also be turned into hierarchies of chains - or \"branches\" - to form a tree. Even a literal one!","title":"Active Chain"},{"location":"releases/2021.03.23/#dynamic-constraint-attributes","text":"Now whatever attributes are relevant show up in the Channel Box, and stay relevant as you make changes. Similar to how the rdRigid.shapeType attribute updates the shapeExtents and shapeOffset attributes!","title":"Dynamic Constraint Attributes"},{"location":"releases/2021.03.23/#whatz-up","text":"Ragdoll now understands when the up-axis is Z rather than the default Y.","title":"What'Z-up?"},{"location":"releases/2021.03.23/#simplified-menu","text":"Items have been re-arranged and grouped together to be easier to find and less cluttered.","title":"Simplified Menu"},{"location":"releases/2021.03.23/#greater-guide-strength","text":"The solver Iterations determines how high your Guide Strength attribute can go. Per default, Iterations was set to 1 which enabled strengths between 0-5 or so until their effect dimished. This release increases this default value to 4 for ranges between 0-100 , which means \"incredibly high!\". The change comes at a minor performance impact - estimated between 1-5% - so if you find the need to optimise, lower this value back to 2 or 1. Hint Bear in mind that the number of iterations are spread across all rigid in your scene. Meaning twice the number of rigids would half the amount of iterations dedicated to each one.","title":"Greater Guide Strength"},{"location":"releases/2021.03.23/#before","text":"","title":"Before"},{"location":"releases/2021.03.23/#after","text":"","title":"After"},{"location":"releases/2021.03.23/#crash-on-cleanup","text":"In rare cases, Ragdoll could crash Maya due to accessing memory it had no business accessing. Those have now been patched up and refactored for a more stable, crash-free experience!","title":"Crash on Cleanup"},{"location":"releases/2021.03.23/#bad-initial-state-on-load","text":"In rare cases, opening a scene could lead to some controls being badly positioned. This could happen if the control you made dynamic was parented to a group with no values. That made the parent and local matrices cancel out, producing an identity matrix. Maya doesn't normally save attributes that are equal to their default values, and this includes matrices whose defaults are the identity matrix. This has now been fixed.","title":"Bad Initial State on Load"},{"location":"releases/2021.03.23/#rotate-order-improvement","text":"In previous releases, any rotation order other than XYZ (the default) would make your rotations all whack. Ragdoll didn't know how to translate physics into any order other than XYZ, so it would put them in the wrong place. In the last release, I added a warning for that and in this release I've lifted that warning somewhat. Most rotation orders works well, but I have spotted rare instances of one axis flipping. Here's the problem. See how arms and torso flips? It tends to happen around the 90 and 180 degree values, values below that normally look fine. This will be fixed in a future release, one way or another!","title":"Rotate Order Improvement"},{"location":"releases/2021.03.25/","text":"Highlight for this release is support for Maya 2022 ! ADDED Support for Maya 2022 It's out, and Ragdoll is game ADDED Ragdoll on GitHub Browse the source, contribute your own feaures and fixes FIXED Backwards Compatibility Last release broke our precious example scenes! FIXED Accurate Gravity The gravity indicator on the scene is now always truthful FIXED Ragdoll Explorer Visually browse the output of cmds.ragdollDump() Support for Maya 2022 Ready when you are, Python 3 and all! Ragdoll on GitHub Ragdoll is a high-performance C++ plug-in with a flexible Python API. The API is what powers all user interfaces and all menu items, including the tools themselves. It's what generates Ragdoll nodes and hooks them up to other nodes, translating your selection into physics. This API is now available on GitHub and will soon open for contributions too! https://github.com/mottosso/ragdoll Backwards Compatibility What does breaking backwards compatibility of a dynamics solver look like? Original Last Release He's the same person! Only the circumstances have changed. :D This has now been fixed, and all previous examples now open and run as expected! Still pretty cool though I thought, that even though it's broken it still gives you an interesting result. Look at how he initially falls over, it looks like he's attempting to hold onto the seat for balance, and also takes a step back before landing on his butt. :D Accurate Gravity The indicator used to face in the Y-axis of wherever the node was facing. That wasn't true. It's now accurate no matter how you spin it around, including a potential Z-up axis! Before After Ragdoll Explorer Added an early version of a visual interface for the cmds.ragdollDump() command, something to inspect the internals of the solver. Mostly intended for game developers but also advanced users and techincal directors. Expect an Outliner-like appearance and use for this explorer, more to come!","title":"2021.03.25"},{"location":"releases/2021.03.25/#support-for-maya-2022","text":"Ready when you are, Python 3 and all!","title":"Support for Maya 2022"},{"location":"releases/2021.03.25/#ragdoll-on-github","text":"Ragdoll is a high-performance C++ plug-in with a flexible Python API. The API is what powers all user interfaces and all menu items, including the tools themselves. It's what generates Ragdoll nodes and hooks them up to other nodes, translating your selection into physics. This API is now available on GitHub and will soon open for contributions too! https://github.com/mottosso/ragdoll","title":"Ragdoll on GitHub"},{"location":"releases/2021.03.25/#backwards-compatibility","text":"What does breaking backwards compatibility of a dynamics solver look like? Original Last Release He's the same person! Only the circumstances have changed. :D This has now been fixed, and all previous examples now open and run as expected! Still pretty cool though I thought, that even though it's broken it still gives you an interesting result. Look at how he initially falls over, it looks like he's attempting to hold onto the seat for balance, and also takes a step back before landing on his butt. :D","title":"Backwards Compatibility"},{"location":"releases/2021.03.25/#accurate-gravity","text":"The indicator used to face in the Y-axis of wherever the node was facing. That wasn't true. It's now accurate no matter how you spin it around, including a potential Z-up axis! Before After","title":"Accurate Gravity"},{"location":"releases/2021.03.25/#ragdoll-explorer","text":"Added an early version of a visual interface for the cmds.ragdollDump() command, something to inspect the internals of the solver. Mostly intended for game developers but also advanced users and techincal directors. Expect an Outliner-like appearance and use for this explorer, more to come!","title":"Ragdoll Explorer"},{"location":"releases/2021.04.11/","text":"Highlight for this release is import of physics from one character to another! ADDED Import Animator-friendly export/import workflow for physics ADDED Edit Shape Edit shapes using normal Maya manipulators ADDED Logging Level Tune how chatty Ragdoll is IMPROVED Ragdoll Stability Rock-solid undo support, go nuts! IMPROVED Maya 2022 Stability Steer clear IMPROVED Explorer Next iteration of the Ragdoll Explorer CHANGED Proxy Attributes A small sacrifice for stability CHANGED Python API Consistency More to come Head's up Game Developers NameComponent was changed, and entity values are now a fully-fledged type. See Backwards Incompatibility for details. Import onto Selected Character Import onto the Ragcar Import limbs of Tiger Import Animators can now setup physics one character, export it, and then import onto another. The usecase is having spent time setting up a perfect ragdoll and then wanting to reuse this setup across multiple scenes, on multiple instances of the same referenced character, or on characters with similar naming scheme and anatomy. It can also be used to import parts of a character or individual objects. Demo Here's an 18 second run-down of the complete workflow, from authoring to import. Features Anything you can apply physics to can be exported. The nodes onto which physics is imported .. \u2714\ufe0f Can have a different namespace \u2714\ufe0f Can have a different naming convention \u2714\ufe0f Can have a different pose \u2714\ufe0f Can have a different scale \u2714\ufe0f Can be animated \u2714\ufe0f Can be referenced \u2714\ufe0f Can be imported in pieces, based on what is currently selected It will remember.. \u2714\ufe0f All edited attributes, like Guide Strength \u2714\ufe0f All edited constraints, like their limits and frames It will not remember.. \u274c The convex hulls \u274c The original root of your chains About those 'Convex Hulls'.. Convex hulls, those triangulated versions of your Maya shapes - the Mesh shape type - are re-generated onto whatever character you import onto. This is probably what you want, and enables you to apply physics onto characters with different geometry from when you originally authored the physics. Although sometimes it's not, which is why this we be augmented in a future release. About the 'Original Root'.. The root in any chain is the first in your selection when creating the chain. If you build a network of chains - a \"tree\" - which is common for any character of more than 1 limb, the exported file will not remember which the original root was. It will figure out new roots procedurally based on their parent/child relationship which may or may not be the same as your original. For importing a full character, this makes no difference. Only for the advanced case of exporting a full character but then wanting to apply only the arm or leg of that character onto another character makes this problematic. This will be addressed in a future release. And that's about it! It doesn't even have to be a \"character\", any combination of Maya nodes you can apply physics to can have their physics exported. Like a (rag)car, or just a (rag)box. User Interface In addition to import everything found in an exported file, there's a UI for more control. The UI resembles native Maya and Ragdoll option dialogs, with two interesting bits. 1. File Browser The top part displays other Ragdoll scene ( .rag ) files in the same directory as the selected file, along with the thumbnail stored during the time of export. The thumbnail currently isn't visible during export, it is captured from the currently active viewport. An Export UI with thumbnail preview (and more!) will be added in a future release. 2. Content Preview This sections shows you the contents of the physics scene, ahead of actually importing it. It will visualise a number of things. Which Maya nodes will be \"physicalised\"? Which nodes present during export are not present in the currently opened scene? What was the original path of a node during export? What is the destination path of the node being imported? Is there a destination node? Is the destination already physicalised? What was the original node icon , e.g. nurbsCurve or mesh ? What is the Shape Type of the exported rigid, e.g Capsule ? Introduction Did you see Snyder's Justice League? In it, they introduce and explain the \"mother box\" and how it is capable of turning the dust of a burnt house back into a house. This Import feature is the Mother Box of Ragdoll. The export format is identical to what game developers use to author physics in Maya and import it into their game engine. It contains all data managed by Ragdoll in full detail. Enough detail to reverse-engineer it back into a Maya scene, which is exactly what's going on here. Example Files mytiger.rag mycharacter.rag ragcar.rag Thumbnail Each export captures the currently active 3d viewport for use as a thumbnail. So, whenever you export, remember to smile and wave! :D Context Sensitive The visualisations will update as you select different nodes and edit the various options in the UI. To illustrate this, let's import onto the same scene we exported. Export Only one character is physicalised and exported. Import Notice that importing is not possible, since the character is already physicalised. Unless we replace the namespace, by selecting another character. Use Selection Import onto selected nodes with Use Selection toggled (it's the default). Search and Replace Every node is stored along with its full path, such as.. |root_grp|spine_grp|spine_ctrl And in most cases can get quite long, with one or more namespaces and tens to hundreds of levels deep in hierarchy. |_:Group|_:Main|_:DeformationSystem|_:Root_M|_:RootPart1_M|_:RootPart2_M|_:Spine1_M|_:Spine1Part1_M|_:Spine1Part2_M|_:Chest_M|_:Scapula_L|_:Shoulder_L|_:ShoulderPart1_L|_:ShoulderPart2_L|_:Elbow_L|_:ElbowPart1_L|_:ElbowPart2_L|_:Wrist_L|_:IndexFinger1_L Here, the namespace is simply _: The Search and Replace boxes of the UI can be used to replace parts of each path, to try and map the original path to whatever path is currently available in the scene. Auto Namespace One challenge with export/import it remapping names from the original scene onto your new scene. Ragdoll solves the typical case of only the namespace being different with \"Auto Namespace\". \"Auto Namespace\" will replace any namespace in the original file with whatever namespace is currently selected. Neat! If there are multiple namespaces, it'll use the last namespace. Let me know how you find that, there's room left to explore here. Most often, you only ever have a single namespace, but Maya does allow you to tie yourself into a knot if you really wanted to. Auto Scene Locate and use the original physics scene from the original file, so as to preserve your multi-scene setups. For example, if your one character has 3 physics scenes - one for the right arm, one for the left and a single one for both legs - then \"Auto Scene\" will preserve these scenes for you. Performance Tip Using more than one scene can improve performance significantly, as Ragdoll will parallelise each invidual scene. The caveat is that rigids in different scenes cannot interact with each other. Ragdoll Clean Here's a quick way you can use this feature to \"clean\" a physics scene. Export Delete All Import The resulting scene will be \"clean\" in that it will have been broken down into its componens and reassembled again, not taking into account anything Ragdoll doesn't know about. (I may just add a menu item for this, called Clean to do this in one go :) Roadmap A few things became apparent as I rounded off this feature Export UI - You'll want control over what that thumbnail looks like, currently it'll take a snapshot but not show you what that snapshot looks like until you look at it from the importer Remember \"root\" of each chain - The importer will recognise what is a Rigid and what is a Chain, but it's having trouble distinguishing the root of each chain. For example, if you made the spine into a chain, followed by the two arms, odds are it'll think the hip leading out to the hand is one chain, and torso to head being another chain, and so on. This isn't an issue when importing a full character, but it'll keep you from being able to import only one of those chains. E.g. just the arm. Import Python API Anything the UI can do can be done via Python, using the new dump.Loader object. from ragdoll import dump loader = dump . Loader () loader . read ( r \"c:\\path\\to\\myRagdoll.rag\" ) # Search and replace these terms from the full node path # E.g. |root_grp|arm_left -> |root_grp|arm_right loader . set_replace (( ( \"_left\" , \"_right\" ), ( \"_ik\" , \"_fk\" ), )) # An automatic method of search-and-replace, that replaces # any namespaces found in the file with this. # E.g. |char1:root_grp -> |char2:root_grp loader . set_namespace ( \"char2:\" ) # Limit imported nodes to those with an absolute path # starting with *any* of these loader . set_roots (( \"|char1:root_grp\" , \"|char2:root_grp\" )) # Deconstruct the provided `.rag` file # (This is what is visualised in the UI) # (The exact layout of this data may change) analysis = loader . analyse () assert isinstance ( analysis , dict ) # Print a brief human-readable summary of the current analysis loader . report () Heads up Consider this a version 0.1 of the API, it will likely change in the future. Ragdoll Stability Implementing import put a lot of strain on Ragdoll. Whereas before, authoring physics was a matter of calling one command at a time, playing around with the result, calling another. Maybe undoing every so often. Import on the other hand calls tens to hundreds of commands at once, undoing them en masse, redoing them en masse. It exposed a ton of flaws in the system that had gone unnoticed in all but the rarest of occasions. Crashes, a ton of them. The worst kind, the kind that doesn't tell you anyhing about why it crashes. The above an example of: Authoring lots of physics in different ways Undoing all of it Redoing all of it With no problem! I'm happy to say these have all been resolved, and the automated test-suite has grown 10x since the last release. Every command is tested, and tested again with undo, and again with redoing an undone redo. It is rock solid, and fast. You can now undo any command as-one, any number of times, redo it any number of times, undo your redo any number of times. Ragdoll will not be the cause of any crashes. Maya 2022 Stability Maya 2022 in its current state has proven incapable of reliably supporting Ragdoll. https://forums.autodesk.com/t5/maya-programming/maya-2022-dagitem-was-nullptr/td-p/10217589 Maya 2022 may crash with Ragdoll That's right. Maya 2022 isn't quite baked yet, and needs a Service Pack. Until then, Ragdoll will run reliably so long as you don't delete anything, or try and open a new scene. In addition to that, the multiplier nodes didn't quite work with Maya 2022, or more specifically with Python 3. from ragdoll import interactive as ri ri.multiply_rigids () # Error: 'filter' object is not subscriptable # Traceback (most recent call last): # File \"<maya console>\", line 2, in <module> # File \"C:\\Users\\marcus\\Documents\\maya\\modules\\Ragdoll\\python\\ragdoll\\interactive.py\", line 2112, in multiply_rigids # root = rigids[0].parent() # TypeError: 'filter' object is not subscriptable # There were also crashes happening on deleting rigid bodies from your scene, these got swept away alongside a number of other fixes to the handling of nodes. So one step forward, one step back. :) Edit Shape A new menu item got added for manipulating shapes with a native Maya transform, as an alternative to fiddling with numbers in the Channel Box. Proxy Attributes In Maya 2018 and 2020, the attributes added to your original animation controls that mirror those of Ragdoll were \"proxy attributes\". That is, they could be edited from either their original attribute, or the one connected to by your control. That's really convenient. Turns out, it is also really unstable. Most of the crashes happening so far, especially on deleting physics or starting a new scene, has come from proxy attributes messing everything up. It should't be surprising, even Maya struggles with them. node = cmds . createNode ( \"transform\" ) shape = cmds . createNode ( \"nurbsCurve\" , parent = node ) cmds . addAttr ( node , ln = \"proxyVisibility\" , proxy = shape + \".visibility\" ) assert cmds . objExists ( node + \".proxyVisibility\" ) assert cmds . getAttr ( node + \".proxyVisibility\" ) == 1 # What should happen to the proxy attribute? :O cmds . delete ( shape ) cmds . getAttr ( node + \".proxyVisibility\" ) # RuntimeError: The value for the attribute could not be retrieved. # The same thing applies with access from the API. It just doesn't know what's going on. If we're lucky - which we have been so far - it'll just fail and tell you about it. Other times it'll fail and take Maya down with it. That's just bad. In Maya 2019, the problem was so severe that proxy attributes were simply not used. With this release, no proxy attributes are used. I hope to reintroduce them at a later date, once I discover is a safe method (read: workaround) to using them. Python API Consistency The good news is, the Python API is maturing. The bad news is, this release introduces backwards incompatible changes. from maya import cmds from ragdoll import api cube , _ = cmds . polyCube () cmds . move ( 0 , 5 , 0 ) cmds . rotate ( 0 , 45 , 45 ) scene = api . createScene () rigid = api . createRigid ( cube ) So far so good. # Before api . socketConstraint ( parent , child , maintain_offset = False ) # After api . socketConstraint ( parent , child , opts = { \"maintainOffset\" : False }) Here's the change. These behavior-like arguments have been moved into an opts={} argument, and is now consistent across any commands that take \"options\". It's to faciliate a large number of options, both from the UI and scripting and enhance compatibility over time; with a dictionary, you can test for availability of arguments at run-time, as opposed to suffer the consequences of not being able to call an update function. I'm still exploring ways of getting more options into commands, without polluting the argument signature, without changing their order when an argument is deprecated, or changing an argument name when jargon inevitably changes. Using a dictionary for options-like arguments enables us to pass arbitrary sized options to functions, they can also be passed to functions that don't necessarily need all contained options, meaning you can establish a single options dictionary up-front and pass that to all relevant functions. It's too soon to tell whether the cons of this approach outweighs the pros. This is one reason for the API still going through changes. The non-optional arguments are those that are never intended to change, like the createRigid(node) argument. Every rigid needs something to make rigid. (Or so you'd think, as you can now also create a rigid from a new empty transform). So, the API has changed and will continue changing for a while longer. Node/Attribute format The Ragdoll scene format is stable and has been for months. It will remain compatible with future versions of Ragdoll, which means anything you build today (or months ago) will continue to work identically. The Python API on the other hand is not yet refined and is still changing. So when you build tools ontop of Ragdoll, keep in mind that nodes, their attributes and their connections are stable , but the means of creating those connections are not. So if you need stability today , look at what nodes and connections are made by the API, and do it yourself. Ragdoll Explorer For developers Explorer has gotten an update, inching its way towards Outliner-like behavior and feel. Eventually maybe even an integration with the Outliner, similar to how USD slots into Maya 2022. That's quite neat! Logging Level You can now tune the way Ragdoll communicates with you. Off means it won't tell you anything, not even warnings Default is what you've gotten used to so far Less only shows you important messages that require you to take action More is the full monty, performance metrics, detailed messages, you name it Programmer Jargon These are animator-friendly jargon for the native logging.INFO and logging.WARNING levels. \"Off\" means logging.CRITICAL since Ragdoll does not emit any critical messages. Developer Updates A few things has been improved for those using Ragdoll as an authoring platform for other software like Unreal and general game engines. New Components The export format has been graced with new components to accommodate for the import feature. As the name suggests, these are stricly related to UI and aren't required for reproducing the physics in another application or engine. They are meant to cover user elements in Maya such that they can be accurately reproduced on re-import back into Maya. New Components RigidUIComponent ConstraintUIComponent LimitUIComponent DriveUIComponent RigidMultiplierUIComponent ConstraintMultiplierUIComponent Here's what the new components may look like in your exported file. { \"type\" : \"RigidUIComponent\" , \"members\" : { \"shaded\" : false , \"airDensity\" : 1.0 , \"shapeIcon\" : \"transform\" , \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 } } }, { \"type\" : \"ConstraintUIComponent\" , \"members\" : { \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 }, \"childIndex\" : 2 } }, \"type\" : \"LimitUIComponent\" , \"members\" : { \"strength\" : 1.0 , \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } }, \"type\" : \"DriveUIComponent\" , \"members\" : { \"strength\" : 0.5 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 } } There's also an added section for \"ui\" related data, most interestingly a base64-encoded QPixmap of a thumbnail . \"ui\" : { \"description\" : \"\" , \"filename\" : \"C:/scenes/demo/advancedskeleton5.rag\" , \"thumbnail\" : \"iVBORw0KGgoAAAAN ... lots more characters ...\" } That can be converted like this. from ragdoll import ui qpixmap = ui . base64_to_pixmap ( data [ \"ui\" ][ \"thumbnail\" ]) Backwards Incompatibility The export format has changed slightly, here's what you need to know. NameComponent.path was changed from the full path + Ragdoll node to just full path. Entity values are now types instead of plain integers Example # Before | root_grp | spine1_ctrl | upperArm_ctrl | rRigid3 # After | root_grp | spine1_ctrl | upperArm_ctrl Some values were entities themselves, but there wasn't any way of knowing unless you explicitly new that JointComponent.parent is in fact an entity. This has now been addressed, and all entities now carry a [\"type\"] signature. # Before { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : true , \"parent\" : 16 \"child\" : 15 } } # After { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : True , \"parent\" : { \"type\" : \"Entity\" , \"value\" : 16 }, \"child\" : { \"type\" : \"Entity\" , \"value\" : 15 } } }","title":"2021.04.11"},{"location":"releases/2021.04.11/#import","text":"Animators can now setup physics one character, export it, and then import onto another. The usecase is having spent time setting up a perfect ragdoll and then wanting to reuse this setup across multiple scenes, on multiple instances of the same referenced character, or on characters with similar naming scheme and anatomy. It can also be used to import parts of a character or individual objects. Demo Here's an 18 second run-down of the complete workflow, from authoring to import.","title":"Import"},{"location":"releases/2021.04.11/#features","text":"Anything you can apply physics to can be exported. The nodes onto which physics is imported .. \u2714\ufe0f Can have a different namespace \u2714\ufe0f Can have a different naming convention \u2714\ufe0f Can have a different pose \u2714\ufe0f Can have a different scale \u2714\ufe0f Can be animated \u2714\ufe0f Can be referenced \u2714\ufe0f Can be imported in pieces, based on what is currently selected It will remember.. \u2714\ufe0f All edited attributes, like Guide Strength \u2714\ufe0f All edited constraints, like their limits and frames It will not remember.. \u274c The convex hulls \u274c The original root of your chains About those 'Convex Hulls'.. Convex hulls, those triangulated versions of your Maya shapes - the Mesh shape type - are re-generated onto whatever character you import onto. This is probably what you want, and enables you to apply physics onto characters with different geometry from when you originally authored the physics. Although sometimes it's not, which is why this we be augmented in a future release. About the 'Original Root'.. The root in any chain is the first in your selection when creating the chain. If you build a network of chains - a \"tree\" - which is common for any character of more than 1 limb, the exported file will not remember which the original root was. It will figure out new roots procedurally based on their parent/child relationship which may or may not be the same as your original. For importing a full character, this makes no difference. Only for the advanced case of exporting a full character but then wanting to apply only the arm or leg of that character onto another character makes this problematic. This will be addressed in a future release. And that's about it! It doesn't even have to be a \"character\", any combination of Maya nodes you can apply physics to can have their physics exported. Like a (rag)car, or just a (rag)box.","title":"Features"},{"location":"releases/2021.04.11/#user-interface","text":"In addition to import everything found in an exported file, there's a UI for more control. The UI resembles native Maya and Ragdoll option dialogs, with two interesting bits.","title":"User Interface"},{"location":"releases/2021.04.11/#1-file-browser","text":"The top part displays other Ragdoll scene ( .rag ) files in the same directory as the selected file, along with the thumbnail stored during the time of export. The thumbnail currently isn't visible during export, it is captured from the currently active viewport. An Export UI with thumbnail preview (and more!) will be added in a future release.","title":"1. File Browser"},{"location":"releases/2021.04.11/#2-content-preview","text":"This sections shows you the contents of the physics scene, ahead of actually importing it. It will visualise a number of things. Which Maya nodes will be \"physicalised\"? Which nodes present during export are not present in the currently opened scene? What was the original path of a node during export? What is the destination path of the node being imported? Is there a destination node? Is the destination already physicalised? What was the original node icon , e.g. nurbsCurve or mesh ? What is the Shape Type of the exported rigid, e.g Capsule ?","title":"2. Content Preview"},{"location":"releases/2021.04.11/#introduction","text":"Did you see Snyder's Justice League? In it, they introduce and explain the \"mother box\" and how it is capable of turning the dust of a burnt house back into a house. This Import feature is the Mother Box of Ragdoll. The export format is identical to what game developers use to author physics in Maya and import it into their game engine. It contains all data managed by Ragdoll in full detail. Enough detail to reverse-engineer it back into a Maya scene, which is exactly what's going on here. Example Files mytiger.rag mycharacter.rag ragcar.rag","title":"Introduction"},{"location":"releases/2021.04.11/#thumbnail","text":"Each export captures the currently active 3d viewport for use as a thumbnail. So, whenever you export, remember to smile and wave! :D","title":"Thumbnail"},{"location":"releases/2021.04.11/#context-sensitive","text":"The visualisations will update as you select different nodes and edit the various options in the UI. To illustrate this, let's import onto the same scene we exported. Export Only one character is physicalised and exported. Import Notice that importing is not possible, since the character is already physicalised. Unless we replace the namespace, by selecting another character.","title":"Context Sensitive"},{"location":"releases/2021.04.11/#use-selection","text":"Import onto selected nodes with Use Selection toggled (it's the default).","title":"Use Selection"},{"location":"releases/2021.04.11/#search-and-replace","text":"Every node is stored along with its full path, such as.. |root_grp|spine_grp|spine_ctrl And in most cases can get quite long, with one or more namespaces and tens to hundreds of levels deep in hierarchy. |_:Group|_:Main|_:DeformationSystem|_:Root_M|_:RootPart1_M|_:RootPart2_M|_:Spine1_M|_:Spine1Part1_M|_:Spine1Part2_M|_:Chest_M|_:Scapula_L|_:Shoulder_L|_:ShoulderPart1_L|_:ShoulderPart2_L|_:Elbow_L|_:ElbowPart1_L|_:ElbowPart2_L|_:Wrist_L|_:IndexFinger1_L Here, the namespace is simply _: The Search and Replace boxes of the UI can be used to replace parts of each path, to try and map the original path to whatever path is currently available in the scene.","title":"Search and Replace"},{"location":"releases/2021.04.11/#auto-namespace","text":"One challenge with export/import it remapping names from the original scene onto your new scene. Ragdoll solves the typical case of only the namespace being different with \"Auto Namespace\". \"Auto Namespace\" will replace any namespace in the original file with whatever namespace is currently selected. Neat! If there are multiple namespaces, it'll use the last namespace. Let me know how you find that, there's room left to explore here. Most often, you only ever have a single namespace, but Maya does allow you to tie yourself into a knot if you really wanted to.","title":"Auto Namespace"},{"location":"releases/2021.04.11/#auto-scene","text":"Locate and use the original physics scene from the original file, so as to preserve your multi-scene setups. For example, if your one character has 3 physics scenes - one for the right arm, one for the left and a single one for both legs - then \"Auto Scene\" will preserve these scenes for you. Performance Tip Using more than one scene can improve performance significantly, as Ragdoll will parallelise each invidual scene. The caveat is that rigids in different scenes cannot interact with each other.","title":"Auto Scene"},{"location":"releases/2021.04.11/#ragdoll-clean","text":"Here's a quick way you can use this feature to \"clean\" a physics scene. Export Delete All Import The resulting scene will be \"clean\" in that it will have been broken down into its componens and reassembled again, not taking into account anything Ragdoll doesn't know about. (I may just add a menu item for this, called Clean to do this in one go :)","title":"Ragdoll Clean"},{"location":"releases/2021.04.11/#roadmap","text":"A few things became apparent as I rounded off this feature Export UI - You'll want control over what that thumbnail looks like, currently it'll take a snapshot but not show you what that snapshot looks like until you look at it from the importer Remember \"root\" of each chain - The importer will recognise what is a Rigid and what is a Chain, but it's having trouble distinguishing the root of each chain. For example, if you made the spine into a chain, followed by the two arms, odds are it'll think the hip leading out to the hand is one chain, and torso to head being another chain, and so on. This isn't an issue when importing a full character, but it'll keep you from being able to import only one of those chains. E.g. just the arm.","title":"Roadmap"},{"location":"releases/2021.04.11/#import-python-api","text":"Anything the UI can do can be done via Python, using the new dump.Loader object. from ragdoll import dump loader = dump . Loader () loader . read ( r \"c:\\path\\to\\myRagdoll.rag\" ) # Search and replace these terms from the full node path # E.g. |root_grp|arm_left -> |root_grp|arm_right loader . set_replace (( ( \"_left\" , \"_right\" ), ( \"_ik\" , \"_fk\" ), )) # An automatic method of search-and-replace, that replaces # any namespaces found in the file with this. # E.g. |char1:root_grp -> |char2:root_grp loader . set_namespace ( \"char2:\" ) # Limit imported nodes to those with an absolute path # starting with *any* of these loader . set_roots (( \"|char1:root_grp\" , \"|char2:root_grp\" )) # Deconstruct the provided `.rag` file # (This is what is visualised in the UI) # (The exact layout of this data may change) analysis = loader . analyse () assert isinstance ( analysis , dict ) # Print a brief human-readable summary of the current analysis loader . report () Heads up Consider this a version 0.1 of the API, it will likely change in the future.","title":"Import Python API"},{"location":"releases/2021.04.11/#ragdoll-stability","text":"Implementing import put a lot of strain on Ragdoll. Whereas before, authoring physics was a matter of calling one command at a time, playing around with the result, calling another. Maybe undoing every so often. Import on the other hand calls tens to hundreds of commands at once, undoing them en masse, redoing them en masse. It exposed a ton of flaws in the system that had gone unnoticed in all but the rarest of occasions. Crashes, a ton of them. The worst kind, the kind that doesn't tell you anyhing about why it crashes. The above an example of: Authoring lots of physics in different ways Undoing all of it Redoing all of it With no problem! I'm happy to say these have all been resolved, and the automated test-suite has grown 10x since the last release. Every command is tested, and tested again with undo, and again with redoing an undone redo. It is rock solid, and fast. You can now undo any command as-one, any number of times, redo it any number of times, undo your redo any number of times. Ragdoll will not be the cause of any crashes.","title":"Ragdoll Stability"},{"location":"releases/2021.04.11/#maya-2022-stability","text":"Maya 2022 in its current state has proven incapable of reliably supporting Ragdoll. https://forums.autodesk.com/t5/maya-programming/maya-2022-dagitem-was-nullptr/td-p/10217589 Maya 2022 may crash with Ragdoll That's right. Maya 2022 isn't quite baked yet, and needs a Service Pack. Until then, Ragdoll will run reliably so long as you don't delete anything, or try and open a new scene. In addition to that, the multiplier nodes didn't quite work with Maya 2022, or more specifically with Python 3. from ragdoll import interactive as ri ri.multiply_rigids () # Error: 'filter' object is not subscriptable # Traceback (most recent call last): # File \"<maya console>\", line 2, in <module> # File \"C:\\Users\\marcus\\Documents\\maya\\modules\\Ragdoll\\python\\ragdoll\\interactive.py\", line 2112, in multiply_rigids # root = rigids[0].parent() # TypeError: 'filter' object is not subscriptable # There were also crashes happening on deleting rigid bodies from your scene, these got swept away alongside a number of other fixes to the handling of nodes. So one step forward, one step back. :)","title":"Maya 2022 Stability"},{"location":"releases/2021.04.11/#edit-shape","text":"A new menu item got added for manipulating shapes with a native Maya transform, as an alternative to fiddling with numbers in the Channel Box.","title":"Edit Shape"},{"location":"releases/2021.04.11/#proxy-attributes","text":"In Maya 2018 and 2020, the attributes added to your original animation controls that mirror those of Ragdoll were \"proxy attributes\". That is, they could be edited from either their original attribute, or the one connected to by your control. That's really convenient. Turns out, it is also really unstable. Most of the crashes happening so far, especially on deleting physics or starting a new scene, has come from proxy attributes messing everything up. It should't be surprising, even Maya struggles with them. node = cmds . createNode ( \"transform\" ) shape = cmds . createNode ( \"nurbsCurve\" , parent = node ) cmds . addAttr ( node , ln = \"proxyVisibility\" , proxy = shape + \".visibility\" ) assert cmds . objExists ( node + \".proxyVisibility\" ) assert cmds . getAttr ( node + \".proxyVisibility\" ) == 1 # What should happen to the proxy attribute? :O cmds . delete ( shape ) cmds . getAttr ( node + \".proxyVisibility\" ) # RuntimeError: The value for the attribute could not be retrieved. # The same thing applies with access from the API. It just doesn't know what's going on. If we're lucky - which we have been so far - it'll just fail and tell you about it. Other times it'll fail and take Maya down with it. That's just bad. In Maya 2019, the problem was so severe that proxy attributes were simply not used. With this release, no proxy attributes are used. I hope to reintroduce them at a later date, once I discover is a safe method (read: workaround) to using them.","title":"Proxy Attributes"},{"location":"releases/2021.04.11/#python-api-consistency","text":"The good news is, the Python API is maturing. The bad news is, this release introduces backwards incompatible changes. from maya import cmds from ragdoll import api cube , _ = cmds . polyCube () cmds . move ( 0 , 5 , 0 ) cmds . rotate ( 0 , 45 , 45 ) scene = api . createScene () rigid = api . createRigid ( cube ) So far so good. # Before api . socketConstraint ( parent , child , maintain_offset = False ) # After api . socketConstraint ( parent , child , opts = { \"maintainOffset\" : False }) Here's the change. These behavior-like arguments have been moved into an opts={} argument, and is now consistent across any commands that take \"options\". It's to faciliate a large number of options, both from the UI and scripting and enhance compatibility over time; with a dictionary, you can test for availability of arguments at run-time, as opposed to suffer the consequences of not being able to call an update function. I'm still exploring ways of getting more options into commands, without polluting the argument signature, without changing their order when an argument is deprecated, or changing an argument name when jargon inevitably changes. Using a dictionary for options-like arguments enables us to pass arbitrary sized options to functions, they can also be passed to functions that don't necessarily need all contained options, meaning you can establish a single options dictionary up-front and pass that to all relevant functions. It's too soon to tell whether the cons of this approach outweighs the pros. This is one reason for the API still going through changes. The non-optional arguments are those that are never intended to change, like the createRigid(node) argument. Every rigid needs something to make rigid. (Or so you'd think, as you can now also create a rigid from a new empty transform). So, the API has changed and will continue changing for a while longer. Node/Attribute format The Ragdoll scene format is stable and has been for months. It will remain compatible with future versions of Ragdoll, which means anything you build today (or months ago) will continue to work identically. The Python API on the other hand is not yet refined and is still changing. So when you build tools ontop of Ragdoll, keep in mind that nodes, their attributes and their connections are stable , but the means of creating those connections are not. So if you need stability today , look at what nodes and connections are made by the API, and do it yourself.","title":"Python API Consistency"},{"location":"releases/2021.04.11/#ragdoll-explorer","text":"For developers Explorer has gotten an update, inching its way towards Outliner-like behavior and feel. Eventually maybe even an integration with the Outliner, similar to how USD slots into Maya 2022. That's quite neat!","title":"Ragdoll Explorer"},{"location":"releases/2021.04.11/#logging-level","text":"You can now tune the way Ragdoll communicates with you. Off means it won't tell you anything, not even warnings Default is what you've gotten used to so far Less only shows you important messages that require you to take action More is the full monty, performance metrics, detailed messages, you name it Programmer Jargon These are animator-friendly jargon for the native logging.INFO and logging.WARNING levels. \"Off\" means logging.CRITICAL since Ragdoll does not emit any critical messages.","title":"Logging Level"},{"location":"releases/2021.04.11/#developer-updates","text":"A few things has been improved for those using Ragdoll as an authoring platform for other software like Unreal and general game engines.","title":"Developer Updates"},{"location":"releases/2021.04.11/#new-components","text":"The export format has been graced with new components to accommodate for the import feature. As the name suggests, these are stricly related to UI and aren't required for reproducing the physics in another application or engine. They are meant to cover user elements in Maya such that they can be accurately reproduced on re-import back into Maya. New Components RigidUIComponent ConstraintUIComponent LimitUIComponent DriveUIComponent RigidMultiplierUIComponent ConstraintMultiplierUIComponent Here's what the new components may look like in your exported file. { \"type\" : \"RigidUIComponent\" , \"members\" : { \"shaded\" : false , \"airDensity\" : 1.0 , \"shapeIcon\" : \"transform\" , \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 } } }, { \"type\" : \"ConstraintUIComponent\" , \"members\" : { \"multiplierEntity\" : { \"type\" : \"Entity\" , \"value\" : 0 }, \"childIndex\" : 2 } }, \"type\" : \"LimitUIComponent\" , \"members\" : { \"strength\" : 1.0 , \"angularStiffness\" : 1000000.0 , \"angularDamping\" : 10000.0 , \"linearStiffness\" : 1000000.0 , \"linearDamping\" : 10000.0 } }, \"type\" : \"DriveUIComponent\" , \"members\" : { \"strength\" : 0.5 , \"angularStiffness\" : 10000.0 , \"angularDamping\" : 1000.0 , \"linearStiffness\" : 0.0 , \"linearDamping\" : 0.0 } } There's also an added section for \"ui\" related data, most interestingly a base64-encoded QPixmap of a thumbnail . \"ui\" : { \"description\" : \"\" , \"filename\" : \"C:/scenes/demo/advancedskeleton5.rag\" , \"thumbnail\" : \"iVBORw0KGgoAAAAN ... lots more characters ...\" } That can be converted like this. from ragdoll import ui qpixmap = ui . base64_to_pixmap ( data [ \"ui\" ][ \"thumbnail\" ])","title":"New Components"},{"location":"releases/2021.04.11/#backwards-incompatibility","text":"The export format has changed slightly, here's what you need to know. NameComponent.path was changed from the full path + Ragdoll node to just full path. Entity values are now types instead of plain integers Example # Before | root_grp | spine1_ctrl | upperArm_ctrl | rRigid3 # After | root_grp | spine1_ctrl | upperArm_ctrl Some values were entities themselves, but there wasn't any way of knowing unless you explicitly new that JointComponent.parent is in fact an entity. This has now been addressed, and all entities now carry a [\"type\"] signature. # Before { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : true , \"parent\" : 16 \"child\" : 15 } } # After { \"type\" : \"JointComponent\" , \"members\" : { \"disableCollision\" : True , \"parent\" : { \"type\" : \"Entity\" , \"value\" : 16 }, \"child\" : { \"type\" : \"Entity\" , \"value\" : 15 } } }","title":"Backwards Incompatibility"},{"location":"releases/2021.04.23/","text":"Highlight for this release is No Limits and Greater Performance ! ADDED No Limits No rig is now too complex for Ragdoll! ADDED 30% Greater Performance You're welcome! ADDED Offline Activation For the poor souls without an internet connection ADDED Auto-cleanup Shape and Constraint editors now vanish alongside the rest of physics ADDED Return To Start More intuitive creation of new rigid bodies ADDED Cycle Protection Avoid running into cycle warnings with this early-warning mechanism ADDED Hard Pin Tell a rigid body exactly where to be in worldspace, no exceptions ADDED Soft Pin Guide a rigid body towards a worldspace position and orientation ADDED Animation Constraint Convert translate/rotate to a guide constraint ADDED Character Multiplier Characters now get a default multiplier IMPROVED Simulated Attribute Active Chains and Trees are now more animator-friendly FIXED Import Bugs Ironed out a few quirks with the new import feature FIXED User Attributes Names and default values of user attributes wasn't quite up to the task FIXED Looped Playback Bug This could under rare circumstances look off FIXED Qt Bug In rare cases this could pollute your Script Editor whenever selection changed FIXED Low-DPI Cosmetics More eye-candy for those still using a low resolution display FIXED Z-up Worldspace Guides Worldspace guides now play nice with a re-oriented world FIXED Tree Multipliers Complex active chains weren't multiplied correctly 10 Second Ragdoll Here's the absolute quickest way to turn a fresh mesh into a full ragdoll. And here's a more practical example of using this feature to clean up a bad mocap clip. It'll endure changes to the environment too, with little to no modification of the physics settings or the original animation. No Limits! That's right! It used to be the case that if your character had a non-default Rotate Order , or a tweaked Rotate Pivot or maybe made use of the handy Rotate Axis or the joints you were using had a non-zero Joint Orient , then you were out of luck ! Ragdoll just couldn't handle those. It would aggressively reset those to their defaults, or flat-out refuse to work. This release adds support for these missing members, which just so happens to be the very last major limitations of Ragdoll when used with your everyday character rigs! \u2714\ufe0f Rotate Pivot \u2714\ufe0f Rotate Axis \u2714\ufe0f Rotate Order \u2714\ufe0f Joint Orient From now on, if it doesn't work with your rig, that's a bug (let me know!). Rotate Pivot This release introduces support for both the .rotatePivot and rotatePivotTranslate attributes, letting you do things like.. I've also added an option to actually use the rotate pivot (for greater good?) such that you can do this. Rotate Axis The advanced rigger will know of his lesser-known feature of Maya transform nodes, with the ability to modify the axis around which the Rotate XYZ channels operate. Rotate Order Finally cracked this one, it has been far too long and is a far-too used feature of Maya transform nodes to not support. But it's done! You should now be able to pick any rotate order and experience no flipping or issue of any kind. Don't even bother getting in touch if you do, because I will not believe you. xD This tiger (courtesy of www.cgspectrum.com ) has a different rotate order on nearly every control. Before After Hold on a second! That final flip of the spine is coming from the rig itself, the joints driven by the controllers we're simulating. Ragdoll isn't the only one having issues with flipping. :) Joint Orient When simulating joints, it can be important to retain the original jointOrient values. Especially if those joints are later used for IK or if you want or need to zero out those rotate values. But it is perhaps most important for an already-animated skeleton, like what you get out of motion capture. Some motion capture libraries, like Rokoku, do a good job not having any jointOrient in which case they would already work well with Ragdoll. But for animated skeletons with a non-default jointOrient you would have been out of luck.. Until now! 30% Greater Performance Ragdoll used to be really really fast, and is now really really really fast! Rendering is one of two areas where Ragdoll spends time computing (the other being simulating), and rendering performance has been improved by 400%, making Ragdoll 30% faster overall! Here you can see the improvement up-close, notice how much time was spent simulating versus rendering each frame in the previous version; almost half the time was spent just rendering! And if you're wondering... Ok, but what features did you remove ? On the contrary! Rendering now includes .. \u2714\ufe0f Specular \u2714\ufe0f Shadows \u2714\ufe0f Ambient Occlusion \u2714\ufe0f Depth of Field \u2714\ufe0f With more to come! Even More Performance? You'll notice that the rendering square isn't entirely gone. If 4 ms just to render is too much to ask, you'll get even more of a performance jolt by simply hiding anything Ragdoll related, in particular the rdRigid and rdConstraint nodes. The simulated result is independent of whether or not it is visible in the viewport. If you are a rigger , this can be handy for your animators once you've finished setting things up, as they may not benefit from seeing these things anyway and could use all of the performance you can give. Simulated Attribute Whenever you make a new chain, an attribute is created on the root of that chain to control whether or not the chain should be Simulated or animated. With this release, Simulated = Off means: \u2714\ufe0f Disabled Solver - meaning no more warnings on skipping frames! \u2714\ufe0f Hidden Drawing of Physics - For a less distracting animation experience Return To Start Additions to the physics solver can only happen on the start frame, and if you in previous version created anything on any other frame Ragdoll would yell at you. This release aids in this process, in that rather then telling you you are wrong, it helps you make it right by automatically returning to the start frame when necessary. Cycle Protection Cycle warnings are generally bad but especially bad for Ragdoll. Understanding when they happen and where they come from can be difficult, especially in complex setups. Ragdoll now includes Cycle Protection to help you spot potential cycles before they happen ! Notice how making a passive rigid here would have resulted in it becoming a child of an otherwise active hierarchy. That would have been bad! Protected Commands These commands will try and protect your from cycles. \u2714\ufe0f Active Rigid \u2714\ufe0f Active Chain \u2714\ufe0f Convert Rigid All other commands is already safe to use and shouldn't cause any cycles. FAQ These are some of the things you might want to learn more about. How does it work? Whenever a new Passive Rigid or Active Chain (with passive root) is being created, Ragdoll is asked to evaluate the world transformation of the node you are attempting to make dynamic. The solver should not be bothered to simulate anything during this encounter, because if it did then that would mean a cycle is about to happen. Why? Because passive rigids pass data into the solver. Namely, the position and orientation of the node you are attempting to turn into a passive rigid. It cannot both pass and receive data. If it is to receive translate/rotate from the solver, then that's an active rigid. Is it accurate? Very. Character rigs can get very complex; how can Ragdoll distinguish between an actual parent being active, and a node acting like a parent via something like Maya's Parent Constraints (i.e. a \"broken rig\")? The answer is that the feature builds on Maya's own evaluation mechanism to figure out whether a node is dependent on the solver or not. The mechanism is surprisingly simple. def is_dynamic ( transform , scene ): \"\"\"Does `transform` in any way affect `scene`?\"\"\" scene [ \"clean\" ] = True # Pull, but do not bother actually serialising it transform [ \"worldMatrix\" ] . pull () return not scene [ \"clean\" ] . read () By pulling on worldMatrix we ensure all hierarchy and constraints is taken into account, and by not actually retrieving value we limit the computational cost to dirty propagation only - as opposed to actually reading and serialising the 16 values that make up the matrix. Can it be disabled? Yes. The protection is only happening when interacting with Ragdoll via the UI menu items. The API remains unaffected and there is an option in the Preferences to disable it in the UI as well. New Constraints Have more fun with more control. \ud83d\ude18 These were previously available under a different names and less intuitive usage Hard Pin When you want a rigid to be at an exact place at an exact time, use Hard Pin . Limitations A rigid can currently have 1 Hard Pin each. This will be addressed in a future release. These cannot currently be exported, they are primarily intended for use interactively by the animator Previously called Passive Control . Soft Pin When you want a rigid to be at an approximate place at an approximate time, whilst still respecting the laws of physics including contacts and gravity, use Soft Pin . Soft pins are nothing more than a constraint with a guide position towards the newly created transform. Limitations These cannot currently be exported, see Hard Pin for rationale Previously called Guide Control . Animation Constraint In the the previous releases I've been experimenting with the idea of turning the Maya translate/rotate channels directly into a guide constraint. There are three possible scenarios with subtle differences. \u2714\ufe0f Non-dynamic Parent E.g. the first rigid in a new scene with an animated character \u2714\ufe0f Passive Parent E.g. a prop attached to a passive body \u2714\ufe0f Active Parent E.g. what you normally get out of chains \u2796 Dynamic Grandparent A less-supported special case, see below In the above, the parent of the newly created rigid with an animation constraint is non-dynamic, it's got nothing to do with Ragdoll. Just your everyday (boring) Maya transform. In this case, the channel is successfully converted to a worldspace position and orientation from your translate/rotate channels. Here on the other hand, the immediate parent is a Passive Rigid which is a little more flexible, and gives you an option to actually collide with the parent. Finally, the parent is active. This is also OK and quite fun. Now the new rigid will affect the parent, since it adds weight onto it. Like a backback. Dynamic Grandparent Here's where things get less predictable. If the parent of the control you want physics to follow along with your translate/rotate channels is non-dynamic, but one or more of its parent are active rigids, then the channel box values no longer align. This will be addressed in a future release. Character Multiplier Making a new character now includes a default multiplier for all constraints (just like chains do!), meaning you can more easily create effects like this! Import Bugs Two issues were found with the importer introduced in the last version. It wasn't able to distinguish between a passive and active rigid It wasn't able to correctly identify a chain with only 2 links Passive versus Rigid When importing a passive rigid, odds are it got imported as a active rigid instead. This could get very messy, as it could end up creating passive rigids as children of active ones, which could reak all kinds of havoc, including cycle warnings. 2-link chains Any \"chain\" with more than one child (head) is a special case of each chain only having 1 rigid each, as opposed to longer chains like arms and legs. Now these can be imported too! Export is Unchanged This and the above import fix were only related to importing of physics, both your existing Maya scenes and exported .rag files are unchanged and were already in good condition. Yay! User Attributes Whenever you make a rigid or chain, some attributes are forwarded onto your animation controls. These attributes are called \"User Attributes\" and the previous release changed these from Maya proxy-attributes to plain-attributes. In doing so, they lost their nice names and default values. :( This has now been fixed! Looped Playback Bug If you've ever had both passive and active rigids and let playback run on a loop, you might have encountered something like this. Whereas if you rewound and playback without looping, everything would be allright. This bug got squashed in this release, letting you witness loop things to your hearts content! Auto-cleanup Whenever you Delete All Physics anything created by Ragdoll disappears, including User Attributes. What wasn't included however was the handles that appears when you Edit Constraint Pivot and Edit Shape . These now also vanish with delete-all, making your life just a little bit better! Thanks to Remi Comtois for pointing this out! Offline Activation Activation is streamlined by happening inside of Maya at the paste of a serial and press of a button. Unless you are one of those without access to the internet, in which case we'll need to do a little dance. :) Step 1 - Generate Request from ragdoll import licence key = \"YOUR-VERY-LONG-KEY-HERE\" fname = r \"c:\\ragdoll_activation_request.xml\" licence . activation_request_to_file ( key , fname ) Step 2 - Email Request Send this file to licencing@ragdolldynamics.com . We'll abrakadabra this file before you can say Taumatawhakatangi\u00adhangakoauauotamatea\u00adturipukakapikimaunga\u00adhoronukupokaiwhen\u00aduakitanatahu . Step 3 - Activate Once you've got a response, activate your licence like this. from ragdoll import licence fname = r \"c:\\ragdoll_activation_response.xml\" licence . activate_from_file ( fname ) Linux users, you'll know what to do about that Windows-like path. Full documentation https://learn.ragdolldynamics.com/licencing/#offline-activation Qt Bug The last release included a callback for synchronising the Import Options UI with the Maya selection. As a result, a bug slipped in which could - in rare cases - produce the following error messages in your Script Editor whenever you changed selection. ../ragdoll/vendor/qargparse.py line 654: Internal C++ object (WidgetHoverFactory) already deleted. // This has now been patched up, but do shout out if this or anything like it happens to you! Thanks to Rafael Villar for finding this bug! Low-DPI Cosmetics The Import Options UI didn't quite live up to the hype at 720p and 1080p, now it does! Preview properly resizes to fit content Thumbnail properly fits the square Thumbnail and file listing lines up nicely Spacing between widgets are consistent across high and low DPI settings Before After Z-up Worldspace Guides Whenever you make a Guide control (now called Soft Pin ) you are technically creating a constraint between a rigid and the world . That's what makes it worldspace. Until now, constraints assumed the world didn't move. But you z-up folks out there know that, sometimes, it does! Ragdoll is now OK with that. Before After Thanks to Jason Snyman for finding this bug! Tree Multipliers There was a minor bug with multipliers for any chain branching off of another chain (e.g. an arm from a spine) which caused the default multiplier to not correctly affect every link in those chains. This has now been fixed! Known Issues At the time of this release, these are the known issues that will be addressed in a future release. Evaluation Graph Controllers If you use \"controllers\" in your rig, there is a possibility Ragdoll will be drawing things incorrectly. This can be addressed by either not (1) using controllers, (2) disabling controllers in the evaluation or (3) awaiting a future update. The problem appears visual-only and should have no effect on the simulation itself. Scale Pivot When you hold the D key and move the pivot, there are 4 attributes being edited. Rotate Pivot Rotate Pivot Translate Scale Pivot Scale Pivot Translate If scalePivot and scalePivotTranslate result in zero change to a nodes position (the default) then all is well. But, if you edit these independently then that will in turn affect the final position of the node, in which case Ragdoll will struggle to simulate it. Auto Key I've narrowed down a particularly annoying behavior (likely a bug) in Maya that can affect users of auto-key and Ragdoll. https://forums.autodesk.com/t5/maya-animation-and-rigging/bug-with-pairblend-and-auto-key/td-p/10258735 This will be fixed in a future release, and if anyone knows of any workaround please let me know! Joint Orient & Non-linear Hierarchy When joints do not immediately follow each other, the rotate channel isn't entirely accurate. Notice how there is a joint inbetween the two rigids? Avoid this edge case for now, or zero out the jointOrient . Soft Passive Guides Guiding the translation of an Active Rigid with a Passive Rigid is currently problematic and creates an unrealistic increase of acceleration. The current workaround is to swap solvers under the Advanced tab of the scene.","title":"2021.04.23"},{"location":"releases/2021.04.23/#no-limits","text":"That's right! It used to be the case that if your character had a non-default Rotate Order , or a tweaked Rotate Pivot or maybe made use of the handy Rotate Axis or the joints you were using had a non-zero Joint Orient , then you were out of luck ! Ragdoll just couldn't handle those. It would aggressively reset those to their defaults, or flat-out refuse to work. This release adds support for these missing members, which just so happens to be the very last major limitations of Ragdoll when used with your everyday character rigs! \u2714\ufe0f Rotate Pivot \u2714\ufe0f Rotate Axis \u2714\ufe0f Rotate Order \u2714\ufe0f Joint Orient From now on, if it doesn't work with your rig, that's a bug (let me know!).","title":"No Limits!"},{"location":"releases/2021.04.23/#rotate-pivot","text":"This release introduces support for both the .rotatePivot and rotatePivotTranslate attributes, letting you do things like.. I've also added an option to actually use the rotate pivot (for greater good?) such that you can do this.","title":"Rotate Pivot"},{"location":"releases/2021.04.23/#rotate-axis","text":"The advanced rigger will know of his lesser-known feature of Maya transform nodes, with the ability to modify the axis around which the Rotate XYZ channels operate.","title":"Rotate Axis"},{"location":"releases/2021.04.23/#rotate-order","text":"Finally cracked this one, it has been far too long and is a far-too used feature of Maya transform nodes to not support. But it's done! You should now be able to pick any rotate order and experience no flipping or issue of any kind. Don't even bother getting in touch if you do, because I will not believe you. xD This tiger (courtesy of www.cgspectrum.com ) has a different rotate order on nearly every control. Before After Hold on a second! That final flip of the spine is coming from the rig itself, the joints driven by the controllers we're simulating. Ragdoll isn't the only one having issues with flipping. :)","title":"Rotate Order"},{"location":"releases/2021.04.23/#joint-orient","text":"When simulating joints, it can be important to retain the original jointOrient values. Especially if those joints are later used for IK or if you want or need to zero out those rotate values. But it is perhaps most important for an already-animated skeleton, like what you get out of motion capture. Some motion capture libraries, like Rokoku, do a good job not having any jointOrient in which case they would already work well with Ragdoll. But for animated skeletons with a non-default jointOrient you would have been out of luck.. Until now!","title":"Joint Orient"},{"location":"releases/2021.04.23/#30-greater-performance","text":"Ragdoll used to be really really fast, and is now really really really fast! Rendering is one of two areas where Ragdoll spends time computing (the other being simulating), and rendering performance has been improved by 400%, making Ragdoll 30% faster overall! Here you can see the improvement up-close, notice how much time was spent simulating versus rendering each frame in the previous version; almost half the time was spent just rendering! And if you're wondering... Ok, but what features did you remove ? On the contrary! Rendering now includes .. \u2714\ufe0f Specular \u2714\ufe0f Shadows \u2714\ufe0f Ambient Occlusion \u2714\ufe0f Depth of Field \u2714\ufe0f With more to come! Even More Performance? You'll notice that the rendering square isn't entirely gone. If 4 ms just to render is too much to ask, you'll get even more of a performance jolt by simply hiding anything Ragdoll related, in particular the rdRigid and rdConstraint nodes. The simulated result is independent of whether or not it is visible in the viewport. If you are a rigger , this can be handy for your animators once you've finished setting things up, as they may not benefit from seeing these things anyway and could use all of the performance you can give.","title":"30% Greater Performance"},{"location":"releases/2021.04.23/#simulated-attribute","text":"Whenever you make a new chain, an attribute is created on the root of that chain to control whether or not the chain should be Simulated or animated. With this release, Simulated = Off means: \u2714\ufe0f Disabled Solver - meaning no more warnings on skipping frames! \u2714\ufe0f Hidden Drawing of Physics - For a less distracting animation experience","title":"Simulated Attribute"},{"location":"releases/2021.04.23/#return-to-start","text":"Additions to the physics solver can only happen on the start frame, and if you in previous version created anything on any other frame Ragdoll would yell at you. This release aids in this process, in that rather then telling you you are wrong, it helps you make it right by automatically returning to the start frame when necessary.","title":"Return To Start"},{"location":"releases/2021.04.23/#cycle-protection","text":"Cycle warnings are generally bad but especially bad for Ragdoll. Understanding when they happen and where they come from can be difficult, especially in complex setups. Ragdoll now includes Cycle Protection to help you spot potential cycles before they happen ! Notice how making a passive rigid here would have resulted in it becoming a child of an otherwise active hierarchy. That would have been bad!","title":"Cycle Protection"},{"location":"releases/2021.04.23/#protected-commands","text":"These commands will try and protect your from cycles. \u2714\ufe0f Active Rigid \u2714\ufe0f Active Chain \u2714\ufe0f Convert Rigid All other commands is already safe to use and shouldn't cause any cycles.","title":"Protected Commands"},{"location":"releases/2021.04.23/#faq","text":"These are some of the things you might want to learn more about. How does it work? Whenever a new Passive Rigid or Active Chain (with passive root) is being created, Ragdoll is asked to evaluate the world transformation of the node you are attempting to make dynamic. The solver should not be bothered to simulate anything during this encounter, because if it did then that would mean a cycle is about to happen. Why? Because passive rigids pass data into the solver. Namely, the position and orientation of the node you are attempting to turn into a passive rigid. It cannot both pass and receive data. If it is to receive translate/rotate from the solver, then that's an active rigid. Is it accurate? Very. Character rigs can get very complex; how can Ragdoll distinguish between an actual parent being active, and a node acting like a parent via something like Maya's Parent Constraints (i.e. a \"broken rig\")? The answer is that the feature builds on Maya's own evaluation mechanism to figure out whether a node is dependent on the solver or not. The mechanism is surprisingly simple. def is_dynamic ( transform , scene ): \"\"\"Does `transform` in any way affect `scene`?\"\"\" scene [ \"clean\" ] = True # Pull, but do not bother actually serialising it transform [ \"worldMatrix\" ] . pull () return not scene [ \"clean\" ] . read () By pulling on worldMatrix we ensure all hierarchy and constraints is taken into account, and by not actually retrieving value we limit the computational cost to dirty propagation only - as opposed to actually reading and serialising the 16 values that make up the matrix. Can it be disabled? Yes. The protection is only happening when interacting with Ragdoll via the UI menu items. The API remains unaffected and there is an option in the Preferences to disable it in the UI as well.","title":"FAQ"},{"location":"releases/2021.04.23/#new-constraints","text":"Have more fun with more control. \ud83d\ude18 These were previously available under a different names and less intuitive usage","title":"New Constraints"},{"location":"releases/2021.04.23/#hard-pin","text":"When you want a rigid to be at an exact place at an exact time, use Hard Pin . Limitations A rigid can currently have 1 Hard Pin each. This will be addressed in a future release. These cannot currently be exported, they are primarily intended for use interactively by the animator Previously called Passive Control .","title":"Hard Pin"},{"location":"releases/2021.04.23/#soft-pin","text":"When you want a rigid to be at an approximate place at an approximate time, whilst still respecting the laws of physics including contacts and gravity, use Soft Pin . Soft pins are nothing more than a constraint with a guide position towards the newly created transform. Limitations These cannot currently be exported, see Hard Pin for rationale Previously called Guide Control .","title":"Soft Pin"},{"location":"releases/2021.04.23/#animation-constraint","text":"In the the previous releases I've been experimenting with the idea of turning the Maya translate/rotate channels directly into a guide constraint. There are three possible scenarios with subtle differences. \u2714\ufe0f Non-dynamic Parent E.g. the first rigid in a new scene with an animated character \u2714\ufe0f Passive Parent E.g. a prop attached to a passive body \u2714\ufe0f Active Parent E.g. what you normally get out of chains \u2796 Dynamic Grandparent A less-supported special case, see below In the above, the parent of the newly created rigid with an animation constraint is non-dynamic, it's got nothing to do with Ragdoll. Just your everyday (boring) Maya transform. In this case, the channel is successfully converted to a worldspace position and orientation from your translate/rotate channels. Here on the other hand, the immediate parent is a Passive Rigid which is a little more flexible, and gives you an option to actually collide with the parent. Finally, the parent is active. This is also OK and quite fun. Now the new rigid will affect the parent, since it adds weight onto it. Like a backback. Dynamic Grandparent Here's where things get less predictable. If the parent of the control you want physics to follow along with your translate/rotate channels is non-dynamic, but one or more of its parent are active rigids, then the channel box values no longer align. This will be addressed in a future release.","title":"Animation Constraint"},{"location":"releases/2021.04.23/#character-multiplier","text":"Making a new character now includes a default multiplier for all constraints (just like chains do!), meaning you can more easily create effects like this!","title":"Character Multiplier"},{"location":"releases/2021.04.23/#import-bugs","text":"Two issues were found with the importer introduced in the last version. It wasn't able to distinguish between a passive and active rigid It wasn't able to correctly identify a chain with only 2 links Passive versus Rigid When importing a passive rigid, odds are it got imported as a active rigid instead. This could get very messy, as it could end up creating passive rigids as children of active ones, which could reak all kinds of havoc, including cycle warnings. 2-link chains Any \"chain\" with more than one child (head) is a special case of each chain only having 1 rigid each, as opposed to longer chains like arms and legs. Now these can be imported too! Export is Unchanged This and the above import fix were only related to importing of physics, both your existing Maya scenes and exported .rag files are unchanged and were already in good condition. Yay!","title":"Import Bugs"},{"location":"releases/2021.04.23/#user-attributes","text":"Whenever you make a rigid or chain, some attributes are forwarded onto your animation controls. These attributes are called \"User Attributes\" and the previous release changed these from Maya proxy-attributes to plain-attributes. In doing so, they lost their nice names and default values. :( This has now been fixed!","title":"User Attributes"},{"location":"releases/2021.04.23/#looped-playback-bug","text":"If you've ever had both passive and active rigids and let playback run on a loop, you might have encountered something like this. Whereas if you rewound and playback without looping, everything would be allright. This bug got squashed in this release, letting you witness loop things to your hearts content!","title":"Looped Playback Bug"},{"location":"releases/2021.04.23/#auto-cleanup","text":"Whenever you Delete All Physics anything created by Ragdoll disappears, including User Attributes. What wasn't included however was the handles that appears when you Edit Constraint Pivot and Edit Shape . These now also vanish with delete-all, making your life just a little bit better! Thanks to Remi Comtois for pointing this out!","title":"Auto-cleanup"},{"location":"releases/2021.04.23/#offline-activation","text":"Activation is streamlined by happening inside of Maya at the paste of a serial and press of a button. Unless you are one of those without access to the internet, in which case we'll need to do a little dance. :) Step 1 - Generate Request from ragdoll import licence key = \"YOUR-VERY-LONG-KEY-HERE\" fname = r \"c:\\ragdoll_activation_request.xml\" licence . activation_request_to_file ( key , fname ) Step 2 - Email Request Send this file to licencing@ragdolldynamics.com . We'll abrakadabra this file before you can say Taumatawhakatangi\u00adhangakoauauotamatea\u00adturipukakapikimaunga\u00adhoronukupokaiwhen\u00aduakitanatahu . Step 3 - Activate Once you've got a response, activate your licence like this. from ragdoll import licence fname = r \"c:\\ragdoll_activation_response.xml\" licence . activate_from_file ( fname ) Linux users, you'll know what to do about that Windows-like path. Full documentation https://learn.ragdolldynamics.com/licencing/#offline-activation","title":"Offline Activation"},{"location":"releases/2021.04.23/#qt-bug","text":"The last release included a callback for synchronising the Import Options UI with the Maya selection. As a result, a bug slipped in which could - in rare cases - produce the following error messages in your Script Editor whenever you changed selection. ../ragdoll/vendor/qargparse.py line 654: Internal C++ object (WidgetHoverFactory) already deleted. // This has now been patched up, but do shout out if this or anything like it happens to you! Thanks to Rafael Villar for finding this bug!","title":"Qt Bug"},{"location":"releases/2021.04.23/#low-dpi-cosmetics","text":"The Import Options UI didn't quite live up to the hype at 720p and 1080p, now it does! Preview properly resizes to fit content Thumbnail properly fits the square Thumbnail and file listing lines up nicely Spacing between widgets are consistent across high and low DPI settings Before After","title":"Low-DPI Cosmetics"},{"location":"releases/2021.04.23/#z-up-worldspace-guides","text":"Whenever you make a Guide control (now called Soft Pin ) you are technically creating a constraint between a rigid and the world . That's what makes it worldspace. Until now, constraints assumed the world didn't move. But you z-up folks out there know that, sometimes, it does! Ragdoll is now OK with that. Before After Thanks to Jason Snyman for finding this bug!","title":"Z-up Worldspace Guides"},{"location":"releases/2021.04.23/#tree-multipliers","text":"There was a minor bug with multipliers for any chain branching off of another chain (e.g. an arm from a spine) which caused the default multiplier to not correctly affect every link in those chains. This has now been fixed!","title":"Tree Multipliers"},{"location":"releases/2021.04.23/#known-issues","text":"At the time of this release, these are the known issues that will be addressed in a future release.","title":"Known Issues"},{"location":"releases/2021.04.23/#evaluation-graph-controllers","text":"If you use \"controllers\" in your rig, there is a possibility Ragdoll will be drawing things incorrectly. This can be addressed by either not (1) using controllers, (2) disabling controllers in the evaluation or (3) awaiting a future update. The problem appears visual-only and should have no effect on the simulation itself.","title":"Evaluation Graph Controllers"},{"location":"releases/2021.04.23/#scale-pivot","text":"When you hold the D key and move the pivot, there are 4 attributes being edited. Rotate Pivot Rotate Pivot Translate Scale Pivot Scale Pivot Translate If scalePivot and scalePivotTranslate result in zero change to a nodes position (the default) then all is well. But, if you edit these independently then that will in turn affect the final position of the node, in which case Ragdoll will struggle to simulate it.","title":"Scale Pivot"},{"location":"releases/2021.04.23/#auto-key","text":"I've narrowed down a particularly annoying behavior (likely a bug) in Maya that can affect users of auto-key and Ragdoll. https://forums.autodesk.com/t5/maya-animation-and-rigging/bug-with-pairblend-and-auto-key/td-p/10258735 This will be fixed in a future release, and if anyone knows of any workaround please let me know!","title":"Auto Key"},{"location":"releases/2021.04.23/#joint-orient-non-linear-hierarchy","text":"When joints do not immediately follow each other, the rotate channel isn't entirely accurate. Notice how there is a joint inbetween the two rigids? Avoid this edge case for now, or zero out the jointOrient .","title":"Joint Orient &amp; Non-linear Hierarchy"},{"location":"releases/2021.04.23/#soft-passive-guides","text":"Guiding the translation of an Active Rigid with a Passive Rigid is currently problematic and creates an unrealistic increase of acceleration. The current workaround is to swap solvers under the Advanced tab of the scene.","title":"Soft Passive Guides"}]}